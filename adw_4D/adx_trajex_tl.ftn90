!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

#include "constants.h"

!/**
subroutine adx_trajex2_tl (F_xto   ,F_yto   ,F_xcto  , F_ycto  , &
                           F_zcto  ,F_xctm  ,F_yctm  , F_zctm  , &
                           F_xto_m ,F_yto_m ,F_xcto_m, F_ycto_m, &
                           F_zcto_m,F_xctm_m,F_yctm_m, F_zctm_m, &
                           i0,in,j0,jn,k0)

   implicit none
!
   !@objective TLM of adx_trajex 
!
   !@arguments
   real, dimension(*) :: &
        F_xto, F_yto, &          !O, upstream positions at origin
        F_xcto, F_ycto, F_zcto,& !O, upstream cartesian positions at origin
        F_xctm, F_yctm, F_zctm   !I, upstream cartesian positions at mid-traj
   real, dimension(*) :: &
        F_xto_m, F_yto_m, &            !O, upstream positions at origin TRAJ
        F_xcto_m, F_ycto_m, F_zcto_m,& !O, upstream cartesian positions at origin TRAJ
        F_xctm_m, F_yctm_m, F_zctm_m   !I, upstream cartesian positions at mid-traj TRAJ
   integer :: i0,in,j0,jn,k0     !I, scope of operator
!
   !@author Monique Tanguay
!
   !@revisions
   ! v4_13 - Tanguay M.        - Adjustments GEM413
   ! v4_40 - Tanguay M.        - Revision TL/AD
!
!**/
#include "adx_dims.cdk"
#include "adx_grid.cdk"
!
   integer :: i,j,k, n, vnij
   real*8 :: prx, pry, prz, prdot2
   real*8 :: prdot2_m
   real   :: minmax, minmax_m, nodiv0_m
   real*8,dimension(i0:in,j0:jn) :: xasin_m, yasin_m, xatan_m, yatan_m, zatan_m
   real*8,dimension(i0:in,j0:jn) :: xy_m, smin_m, rsmin_m, rxy_m 

   !---------------------------------------------------------------------

   vnij = (in-i0+1)*(jn-j0+1)

!$omp parallel do private(prx    , pry     , prz    , prdot2, &
!$omp prdot2_m, minmax , minmax_m, nodiv0_m,                  &
!$omp xasin_m , yasin_m, xatan_m , yatan_m , zatan_m,         &
!$omp xy_m    , smin_m , rsmin_m , rxy_m)
   do k=k0,adx_lnkm
      do j=j0,jn
         do i=i0,in

            n = (k-1)*adx_mlnij+((j-1)*adx_mlni) + i

            pry = dble(adx_cy_8(j))
            prx = dble(adx_cx_8(adx_trj_i_off+i)) * pry
            pry = dble(adx_sx_8(adx_trj_i_off+i)) * pry
            prz = dble(adx_sy_8(j))

            !TRAJECTORY
            !----------
            prdot2_m= 2.D0 * ( prx * dble(F_xctm_m(n)) + &
                               pry * dble(F_yctm_m(n)) + &
                               prz * dble(F_zctm_m(n)) )

            F_xcto_m(n) = prdot2_m * dble(F_xctm_m(n)) - prx
            F_ycto_m(n) = prdot2_m * dble(F_yctm_m(n)) - pry
            F_zcto_m(n) = prdot2_m * dble(F_zctm_m(n)) - prz

            xy_m(i,j) = F_xcto_m(n)*F_xcto_m(n) + F_ycto_m(n)*F_ycto_m(n)

            xatan_m(i,j)= F_xcto_m(n)
            yatan_m(i,j)= F_ycto_m(n)
            xasin_m(i,j)= max(-1.,min(1.,F_zcto_m(n)))

            !TLM
            !---
            prdot2= 2.D0 * ( prx * dble(F_xctm(n)) + &
                             pry * dble(F_yctm(n)) + &
                             prz * dble(F_zctm(n)) )

            F_xcto(n) = prdot2_m * dble(F_xctm(n)) + prdot2 * dble(F_xctm_m(n))
            F_ycto(n) = prdot2_m * dble(F_yctm(n)) + prdot2 * dble(F_yctm_m(n))
            F_zcto(n) = prdot2_m * dble(F_zctm(n)) + prdot2 * dble(F_zctm_m(n))


            !NOTE: nodiv0_m is used to allow valid 1/smin_8
            !----------------------------------------------
            minmax_m = F_zcto_m(n)
            nodiv0_m = minmax_m
            if (F_zcto_m(n).ge.1.) then
                minmax_m = 1.
                nodiv0_m = 0.
            elseif (F_zcto_m(n).le.-1.) then
                minmax_m =-1.
                nodiv0_m = 0.
            endif

            smin_m(i,j) = sqrt( 1.0-nodiv0_m*nodiv0_m )

         enddo
      enddo

!TODO: merge this part with the same done in trajsp?

         !Pre-calculations
         !----------------
         call vatan2(zatan_m, yatan_m, xatan_m, vnij)
         call vasin (yasin_m, xasin_m, vnij)
         call vrec  (rxy_m  , xy_m   , vnij)
         call vrec  (rsmin_m, smin_m , vnij)

!TODO: merge this part with the same done in trajsp?

      do j=j0,jn
         do i=i0,in

            n = (k-1)*adx_mlnij+((j-1)*adx_mlni) + i

            F_xto_m(n) = zatan_m(i,j)
            F_yto_m(n) = yasin_m(i,j)

            F_xto(n) = (F_ycto(n)*F_xcto_m(n) - F_ycto_m(n)*F_xcto(n)) * rxy_m(i,j)

            if ( F_xto_m(n) .lt. 0.0 ) F_xto_m(n) = F_xto_m(n) + CONST_2PI_8  

            !The following min statement is expanded as two IF blocks:
            !minmax_m = max(-1.,min(1.,F_zcto_m(n)))
            !--------------------------------------------------------
            minmax = F_zcto(n)
            if (F_zcto_m(n).ge.1.) then
                minmax   = 0.
                F_yto(n) = 0.
            elseif (F_zcto_m(n).le.-1.) then
                minmax   = 0.
                F_yto(n) = 0.
            else
                F_yto(n) = minmax * rsmin_m(i,j)
            endif
 
         enddo
      enddo

   enddo
!$omp end parallel do

   !---------------------------------------------------------------------
   return
end subroutine adx_trajex2_tl
