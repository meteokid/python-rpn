!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

#include "constants.h"

!/**
subroutine adx_trajsp2_ad (F_lon  , F_lat  , F_x  , F_y  , F_z  , F_u  , F_v  , &
                                    F_lat_m, F_x_m, F_y_m, F_z_m, F_u_m, F_v_m, & 
                           F_cx_8,F_cy_8,F_sx_8,F_sy_8, &
                           F_dt,i0,in,j0,jn,k0,F_ni,F_nj )
!
   implicit none
!
   !@objective ADJ of adx_trajsp 
!
   !@arguments
   real, dimension(*) :: &
        F_lon,         &     !O, upwind longitudes at central time
        F_lat,         &     !I/O, upwind lat at central time
        F_x, F_y, F_z, &     !O, upwind cartesian positions at central time
        F_u, F_v,      &     !I, real wind components at upwind pos
        F_lat_m,             & ! I/O, upwind lat at central time TRAJ
        F_x_m, F_y_m, F_z_m, & ! O, upwind cartesian positions at central time TRAJ
        F_u_m, F_v_m           ! I, real wind components at upwind pos TRAJ
   real    :: F_dt           !I, timestep lenght
   integer :: i0,in,j0,jn,k0 !I, scope of operator
   integer :: F_ni,F_nj
   real*8, dimension(F_ni) :: F_cx_8,F_sx_8
   real*8, dimension(F_nj) :: F_cy_8,F_sy_8
!
   !@author Monique Tanguay
!
   !@revisions
   ! v4_13 - Tanguay M.        - Adjustments GEM413
   ! v4_40 - Tanguay M.        - Revision TL/AD
!
!**/

#include "adx_dims.cdk"

   integer :: vnij, i,j,k, n
   real*8 :: pdsa, pdca, pdcai, pdso, pdco, pdx, pdy, pdz
   real*8 :: pdux, pduy, pduz, pdsinal, pdcosal
   real*8,dimension(i0:in,j0:jn) :: xcos, ycos, xsin, ysin, yrec

   real, dimension((in-i0+1)*(jn-j0+1)*(adx_lnkm-k0+1)) :: F_x_m1, F_y_m1, F_z_m1 

   real*8 :: pdsa_m, pdca_m, pdcai_m, pdso_m, pdco_m
   real*8 :: pdux_m, pduy_m, pduz_m, pdsinal_m1, pdcosal_m, pduz_m1, pdux_m1, pduy_m1, pdsinal_m2
   real*8 :: rxyz_m
   real*8,dimension(i0:in,j0:jn) :: xcos_m, ycos_m, xsin_m, ysin_m, yrec_m
   real*8,dimension(i0:in,j0:jn) :: cos2_m, rcos2_m, sz2_m, xy2_m, rxy2_m, suv2_m, slat_m, rsxyz_m
   real                          :: z_m3
    
   real*8, parameter :: ZERO_8 = 0.0
    
   !---------------------------------------------------------------------

   vnij = (in-i0+1)*(jn-j0+1)

   !Zero adjoint work space
   !-----------------------
   pdsa   = ZERO_8
   pdca   = ZERO_8
   pdcai  = ZERO_8
   pdso   = ZERO_8
   pdco   = ZERO_8
   pdux   = ZERO_8
   pduy   = ZERO_8
   pduz   = ZERO_8
   pdsinal= ZERO_8
   pdcosal= ZERO_8

!$omp parallel do private(pdsa   ,pdca   ,pdcai  ,pdso      ,pdco     , &
!$omp                     n      ,pdx    ,pdy    ,pdz       ,           &    
!$omp                     pdux   ,pduy   ,pduz   ,pdsinal   ,pdcosal  , &
!$omp                     pdsa_m ,pdca_m ,pdcai_m,pdso_m    ,pdco_m   , &
!$omp                     pdux_m ,pduy_m ,pduz_m ,pdsinal_m1,pdcosal_m, &
!$omp                     pduz_m1,pdux_m1,pduy_m1,pdsinal_m2,rxyz_m   , &   
!$omp                     xcos_m ,ycos_m ,xsin_m ,ysin_m    ,yrec_m   , &  
!$omp                     cos2_m ,rcos2_m,sz2_m  ,xy2_m     ,rxy2_m   , &
!$omp                     suv2_m ,slat_m ,rsxyz_m,z_m3)
   do k=adx_lnkm,k0,-1

      !------------------------
      !START REBUILD TRAJECTORY
      !------------------------

      !Pre-calculations (START)
      !------------------------
      do j=j0,jn
         do i=i0,in

            n = (k-1)*adx_mlnij + ((j-1)*adx_mlni) + i

            xcos_m(i,j) = F_lat_m(n)
            suv2_m(i,j) = sqrt( F_u_m(n) ** 2 + F_v_m(n) ** 2 )
            xsin_m(i,j) = suv2_m(i,j) * F_dt

         end do
      end do

      call vcos(ycos_m,  xcos_m, vnij)
      call vsin(ysin_m,  xsin_m, vnij)
      call vrec(yrec_m,  ycos_m, vnij)

      !Pre-calculations (END)
      !------------------------

      do j=j0,jn
         do i=i0,in

            n = (k-1)*adx_mlnij + ((j-1)*adx_mlni) + i

            !- cartesian coordinates of grid points

            pdx = F_cx_8(adx_trj_i_off+i)
            pdy = F_sx_8(adx_trj_i_off+i)
            pdz = F_sy_8(j)

            !- if very small wind set upwind point to grid point

            if (abs(F_u_m(n))+abs(F_v_m(n)) >= 1.e-10) then

            pdx = pdx * F_cy_8(j)
            pdy = pdy * F_cy_8(j)

            ! sin and cosin of first guess of upwind positions

            pdsa_m  = F_z_m(n)
            pdca_m  = ycos_m(i,j)
            pdcai_m = yrec_m(i,j)
            pdso_m  = F_y_m(n) * pdcai_m
            pdco_m  = F_x_m(n) * pdcai_m

            !- wind components in cartesian coordinate at upwind positions

            pdux_m1 = ( - F_u_m(n) * pdso_m - F_v_m(n) * pdco_m * pdsa_m )
            pduy_m1 = (   F_u_m(n) * pdco_m - F_v_m(n) * pdso_m * pdsa_m )
            pduz_m1 =     F_v_m(n) * pdca_m

            pdsinal_m1 = pdx * pdux_m1 + pdy * pduy_m1 + pdz * pduz_m1
            pdux_m = pdux_m1 - pdx * pdsinal_m1
            pduy_m = pduy_m1 - pdy * pdsinal_m1
            pduz_m = pduz_m1 - pdz * pdsinal_m1

            rsxyz_m(i,j)= 1./sqrt( pdux_m * pdux_m + pduy_m * pduy_m + pduz_m * pduz_m )

            pdcosal_m  = sqrt( ( 1.0 + ysin_m(i,j) ) * ( 1.0 - ysin_m(i,j) ) )
            pdsinal_m2 = ysin_m(i,j) * rsxyz_m(i,j)

            F_x_m1(n) = F_x_m(n)
            F_y_m1(n) = F_y_m(n)
            F_z_m1(n) = F_z_m(n)

            F_x_m(n) = pdcosal_m * pdx - pdsinal_m2 * pdux_m
            F_y_m(n) = pdcosal_m * pdy - pdsinal_m2 * pduy_m
            F_z_m(n) = pdcosal_m * pdz - pdsinal_m2 * pduz_m

            endif

         end do
      end do

      !Pre-calculations (START)
      !------------------------

      do j=j0,jn
         do i=i0,in

            n = (k-1)*adx_mlnij + (j-1)*adx_mlni + i

            z_m3 = F_z_m(n)

            if ( F_z_m(n) .lt. -1.D0 ) then
                 z_m3 = -1.D0
            elseif ( F_z_m(n) .gt.  1.D0 ) then
                 z_m3 =  1.D0
            endif

            sz2_m (i,j) = sqrt(1.0 - z_m3*z_m3)
            xy2_m (i,j) = F_x_m(n)*F_x_m(n) + F_y_m(n)*F_y_m(n)
            cos2_m(i,j) = ycos_m(i,j) **2

         end do
      end do

      call vrec(rxy2_m , xy2_m , vnij)
      call vsin(slat_m , xcos_m, vnij)
      call vrec(rcos2_m, cos2_m, vnij)

      !Pre-calculations (END)
      !------------------------

      !----------------------
      !END REBUILD TRAJECTORY
      !----------------------

      do j=j0,jn
         do i=i0,in

            n = (k-1)*adx_mlnij + (j-1)*adx_mlni + i

            !- cartesian coordinates of grid points

            pdx = F_cx_8(adx_trj_i_off+i)
            pdy = F_sx_8(adx_trj_i_off+i)
            pdz = F_sy_8(j)

            z_m3 = F_z_m(n)

            if ( F_z_m(n) .lt. -1.D0 ) then
               z_m3 = -1.D0
            elseif ( F_z_m(n) .gt.  1.D0 ) then
               z_m3 =  1.D0
            endif

            F_y  (n) =  F_x_m(n)*F_lon(n)*rxy2_m(i,j) + F_y(n)
            F_x  (n) = -F_y_m(n)*F_lon(n)*rxy2_m(i,j) + F_x(n)
            F_lon(n) = ZERO_8

            if ( abs(z_m3) .ne. 1.D0 ) then
              F_z  (n) = F_lat(n) / sz2_m(i,j) + F_z(n)
              F_lat(n) = ZERO_8
            else
              F_lat(n) = 0.0D0
            endif

            if ( F_z_m(n) .lt. -1.D0 ) then
              F_z (n) =  0.D0
            elseif ( F_z_m(n) .gt.  1.D0 ) then
              F_z (n) =  0.D0
            endif

            !- if very small wind set upwind point to grid point

            if (abs(F_u_m(n))+abs(F_v_m(n)) >= 1.e-10) then

            pdx = pdx * F_cy_8(j)
            pdy = pdy * F_cy_8(j)

            !TRAJECTORY
            !----------

            ! sin and cosin of first guess of upwind positions

            pdsa_m  = F_z_m1(n)
            pdca_m  = ycos_m(i,j)
            pdcai_m = yrec_m(i,j)
            pdso_m  = F_y_m1(n) * pdcai_m
            pdco_m  = F_x_m1(n) * pdcai_m

            !TRAJECTORY
            !----------

            !- wind components in cartesian coordinate at upwind positions

            pdux_m1 = ( - F_u_m(n) * pdso_m - F_v_m(n) * pdco_m * pdsa_m )
            pduy_m1 = (   F_u_m(n) * pdco_m - F_v_m(n) * pdso_m * pdsa_m )
            pduz_m1 = F_v_m(n) * pdca_m

            pdsinal_m1 = pdx * pdux_m1 + pdy * pduy_m1 + pdz * pduz_m1
            pdux_m     = pdux_m1 - pdx * pdsinal_m1
            pduy_m     = pduy_m1 - pdy * pdsinal_m1
            pduz_m     = pduz_m1 - pdz * pdsinal_m1

            pdcosal_m  = sqrt( ( 1.0 + ysin_m(i,j) ) * ( 1.0 - ysin_m(i,j) ) )
            pdsinal_m2 = ysin_m(i,j) * rsxyz_m(i,j)

            rxyz_m     = 1./( pdux_m * pdux_m + pduy_m * pduy_m + pduz_m * pduz_m )


            !ADJ
            !---
            pdcosal =   F_x(n) * pdx &
                      + F_y(n) * pdy &
                      + F_z(n) * pdz
            pdsinal = - F_x(n) * pdux_m &
                      - F_y(n) * pduy_m &
                      - F_z(n) * pduz_m

            pdux    = -pdsinal_m2 * pdux_m * pdsinal * rxyz_m &
                      -pdsinal_m2 * F_x(n)

            pduy    = -pdsinal_m2 * pduy_m * pdsinal * rxyz_m &
                      -pdsinal_m2 * F_y(n)

            pduz    = -pdsinal_m2 * pduz_m * pdsinal * rxyz_m &
                      -pdsinal_m2 * F_z(n)

            pdsinal = pdsinal * rsxyz_m(i,j)

            F_u(n)  = -F_dt* ysin_m(i,j)* F_u_m(n)*pdcosal/ suv2_m(i,j) + F_u(n)
            F_v(n)  = -F_dt* ysin_m(i,j)* F_v_m(n)*pdcosal/ suv2_m(i,j) + F_v(n)
            F_u(n)  =  F_dt* pdcosal_m  * F_u_m(n)*pdsinal/ suv2_m(i,j) + F_u(n)
            F_v(n)  =  F_dt* pdcosal_m  * F_v_m(n)*pdsinal/ suv2_m(i,j) + F_v(n)

            pdsinal = - pdx * pdux - pdy * pduy - pdz * pduz

            pdux    = pdx * pdsinal + pdux
            pduy    = pdy * pdsinal + pduy
            pduz    = pdz * pdsinal + pduz


            !- ADJ of
            !- wind components in cartesian coordinate at upwind positions

            F_u(n)  =  - pdux * pdso_m &
                       + pduy * pdco_m + F_u(n)
            F_v(n)  =  - pdux * pdco_m * pdsa_m &
                       - pduy * pdso_m * pdsa_m & 
                       + pduz * pdca_m + F_v(n)

            pdco    = - F_v_m(n) *( pdux * pdsa_m ) &
                      + F_u_m(n) *  pduy
            F_x(n)  = pdco * pdcai_m

            pdso   = - F_u_m(n) *  pdux &
                     - F_v_m(n) *( pduy * pdsa_m )
            F_y(n) = pdso * pdcai_m

            !- ADJ of
            ! sin and cosin of first guess of upwind positions

            pdcai    = F_y_m1(n) * pdso   + &
                       F_x_m1(n) * pdco
            F_lat(n) = -slat_m(i,j) * (-pdcai  * rcos2_m(i,j)  + F_v_m(n) * pduz)

            F_z(n) = - F_v_m(n) *( pdco_m * pdux ) &
                     - F_v_m(n) *( pdso_m * pduy )

            endif

         end do
      end do

   enddo
!$omp end parallel do

   !---------------------------------------------------------------------
   return
end subroutine adx_trajsp2_ad
