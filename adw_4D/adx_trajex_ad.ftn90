!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

#include "constants.h"

!/**
subroutine adx_trajex2_ad (F_xto   ,F_yto   ,F_xcto  , F_ycto  , &
                           F_zcto  ,F_xctm  ,F_yctm  , F_zctm  , &
                                    F_xctm_m,F_yctm_m, F_zctm_m, &
                           i0,in,j0,jn,k0)
!
   implicit none
#include <arch_specific.hf>
!
   !@objective ADJ of adx_trajex 
!
   !@arguments
   real, dimension(*) :: &
        F_xto, F_yto, &          !O, upstream positions at origin
        F_xcto, F_ycto, F_zcto,& !O, upstream cartesian positions at origin
        F_xctm, F_yctm, F_zctm   !I, upstream cartesian positions at mid-traj
   real, dimension(*) :: &
        F_xctm_m, F_yctm_m, F_zctm_m !I, upstream cartesian positions at mid-traj TRAJ
   integer :: i0,in,j0,jn,k0     !I, scope of operator
!
   !@author Monique Tanguay
   !@revisions
   ! v4_13 - Tanguay M.        - Adjustments GEM413
   ! v4_40 - Tanguay M.        - Revision TL/AD
!
!**/
#include "adx_dims.cdk"
#include "adx_grid.cdk"
!
   integer :: i,j,k, n, vnij
   real*8 :: prx, pry, prz, prdot2
   real*8 :: prdot2_m
   real   :: prxcto_m, prycto_m, przcto_m, minmax, minmax_m
   real*8, parameter :: ZERO_8 = 0.0
   !---------------------------------------------------------------------

   vnij = (in-i0+1)*(jn-j0+1)

   !Zero adjoint variables
   !----------------------
   minmax = ZERO_8
   prdot2 = ZERO_8

!$omp parallel do private(prx,pry,prz,prdot2,prdot2_m, &
!$omp                     prxcto_m,prycto_m,przcto_m,  &
!$omp                     minmax,minmax_m)
   do k=adx_lnkm,k0,-1
      do j=j0,jn
         do i=i0,in

            !START REBUILD TRAJECTORY
            !------------------------

            n = (k-1)*adx_mlnij+((j-1)*adx_mlni) + i

            pry = dble(adx_cy_8(j))
            prx = dble(adx_cx_8(adx_trj_i_off+i)) * pry
            pry = dble(adx_sx_8(adx_trj_i_off+i)) * pry
            prz = dble(adx_sy_8(j))

            prdot2_m= 2.D0 * (prx * dble(F_xctm_m(n)) + &
                              pry * dble(F_yctm_m(n)) + &
                              prz * dble(F_zctm_m(n)) )

            prxcto_m = prdot2_m * dble(F_xctm_m(n)) - prx
            prycto_m = prdot2_m * dble(F_yctm_m(n)) - pry
            przcto_m = prdot2_m * dble(F_zctm_m(n)) - prz
 
            !The following min statement is expanded as two IF blocks:
            !minmax_m = max(-1.,min(1.,przcto_m))
            !---------------------------------------------------------
            minmax_m = przcto_m
            !
            !END REBUILD TRAJECTORY
            !----------------------

            !ADJ
            !---
            if (przcto_m.ge.1.) then
                F_yto(n) = 0.
                minmax   = 0.
            elseif (przcto_m.le.-1.) then
                F_yto(n) = 0.
                minmax   = 0.
            else
!!!             minmax   = F_yto(n)/sqrt( 1.0-minmax_m**2 ) + minmax
                minmax   = F_yto(n)/sqrt( 1.0-minmax_m**2 )
                F_yto(n) = ZERO_8
            endif
            F_zcto(n) = minmax + F_zcto(n)
!!!         minmax    = ZERO_8

            F_ycto(n) = ( F_xto(n)*prxcto_m  ) &
                        /(prxcto_m*prxcto_m + prycto_m*prycto_m) &
                        + F_ycto(n)
            F_xcto(n) = ( - prycto_m*F_xto(n)) &
                        /(prxcto_m*prxcto_m + prycto_m*prycto_m) &
                        + F_xcto(n)
            F_xto(n)  = ZERO_8

            F_zctm(n) = prdot2_m * dble(F_zcto(n)) + F_zctm(n)

            F_yctm(n) = prdot2_m * dble(F_ycto(n)) + F_yctm(n)
 
            F_xctm(n) = prdot2_m * dble(F_xcto(n)) + F_xctm(n)
 
            prdot2 = dble(F_xcto(n)) * dble(F_xctm_m(n)) + &
                     dble(F_ycto(n)) * dble(F_yctm_m(n)) + &
                     dble(F_zcto(n)) * dble(F_zctm_m(n))
 
            F_zcto(n) = ZERO_8
            F_ycto(n) = ZERO_8
            F_xcto(n) = ZERO_8

            F_xctm(n) = 2.0 * ( prx * prdot2 ) + F_xctm(n)
            F_yctm(n) = 2.0 * ( pry * prdot2 ) + F_yctm(n)
            F_zctm(n) = 2.0 * ( prz * prdot2 ) + F_zctm(n)

         enddo
      enddo

   enddo
!$omp end parallel do

   !---------------------------------------------------------------------
   return
end subroutine adx_trajex2_ad
