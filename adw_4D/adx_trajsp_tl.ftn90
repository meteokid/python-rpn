!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

#include "constants.h"

!/**
subroutine adx_trajsp2_tl (F_lon  , F_lat  , F_x  , F_y  , F_z  , F_u  , F_v  , &
                           F_lon_m, F_lat_m, F_x_m, F_y_m, F_z_m, F_u_m, F_v_m, &
                           F_cx_8,F_cy_8,F_sx_8,F_sy_8, &
                           F_dt,i0,in,j0,jn,k0,F_ni,F_nj )
!
   implicit none
#include <arch_specific.hf>
!
   !@objective TLM of adx_trajsp 
!
   !@arguments
   real, dimension(*) :: &
        F_lon,         &     !O, upwind longitudes at central time
        F_lat,         &     !I/O, upwind lat at central time
        F_x, F_y, F_z, &     !O, upwind cartesian positions at central time
        F_u, F_v,      &     !I, real wind components at upwind pos
        F_lon_m,             & ! O, upwind longitudes at central time TRAJ
        F_lat_m,             & ! I/O, upwind lat at central time TRAJ
        F_x_m, F_y_m, F_z_m, & ! O, upwind cartesian positions at central time TRAJ
        F_u_m, F_v_m           ! I, real wind components at upwind pos TRAJ
   real    :: F_dt           !I, timestep lenght
   integer :: i0,in,j0,jn,k0 !I, scope of operator
   integer :: F_ni,F_nj
   real*8, dimension(F_ni) :: F_cx_8,F_sx_8
   real*8, dimension(F_nj) :: F_cy_8,F_sy_8
!
   !@author Monique Tanguay
!
   !@revisions
   ! v4_13 - Tanguay M.        - Adjustments GEM413
   ! v4_40 - Tanguay M.        - Revision TL/AD
!
!**/
#include "adx_dims.cdk"

   integer :: vnij, i,j,k, n
   real*8 :: pdsa  , pdca  , pdcai  , pdso  , pdco  , pdx, pdy, pdz
   real*8 :: pdsa_m, pdca_m, pdcai_m, pdso_m, pdco_m
   real*8 :: pdux  , pduy  , pduz  , pdsinal   , pdcosal
   real*8 :: pdux_m, pduy_m, pduz_m, pdsinal_m1, pdcosal_m, pduz_m1, pdux_m1, pduy_m1, pdsinal_m2
   real*8 :: rsxyz_m, rxyz_m 
   real*8,dimension(i0:in,j0:jn) :: xcos  , ycos  , xsin  , ysin  , yrec
   real*8,dimension(i0:in,j0:jn) :: xcos_m, ycos_m, xsin_m, ysin_m, yrec_m
   real*8,dimension(i0:in,j0:jn) :: xasin_m, yasin_m, xatan_m, yatan_m, zatan_m
   real*8,dimension(i0:in,j0:jn) :: cos2_m, rcos2_m, sz2_m, xy2_m, rxy2_m, suv2_m, slat_m   
   real                          :: F_z_m_2 

   !---------------------------------------------------------------------

   vnij = (in-i0+1)*(jn-j0+1)

!$omp parallel do private(xcos , ycos     ,  xsin     , ysin    , yrec  , &
!$omp xcos_m , ycos_m , xsin_m , ysin_m   ,  yrec_m   ,                   &
!$omp xasin_m, yasin_m, xatan_m, yatan_m  ,  zatan_m  ,                   &
!$omp cos2_m , rcos2_m, sz2_m  , xy2_m    ,  rxy2_m   , suv2_m  , slat_m, &
!$omp F_z_m_2, rsxyz_m, rxyz_m ,                                          &
!$omp pdsa   , pdca   , pdcai  , pdso     ,  pdco     , pdx, pdy, pdz ,   &
!$omp pdsa_m , pdca_m , pdcai_m, pdso_m   ,  pdco_m   ,                   &
!$omp pdux   , pduy   , pduz   , pdsinal  ,  pdcosal  ,                   &
!$omp pdux_m , pduy_m , pduz_m , pdsinal_m1, pdcosal_m,                   &
!$omp pduz_m1, pdux_m1, pduy_m1, pdsinal_m2)
   do k=k0,adx_lnkm

      do j=j0,jn
         do i=i0,in

            n = (k-1)*adx_mlnij + ((j-1)*adx_mlni) + i

            !TRAJECTORY
            !---------- 
            xcos_m(i,j) = F_lat_m(n)
            suv2_m(i,j) = sqrt(F_u_m(n)**2 + F_v_m(n)**2) 
            xsin_m(i,j) = sqrt(F_u_m(n)**2 + F_v_m(n)**2) * F_dt
!!!         xsin_m(i,j) = suv2_m(i,j) * F_dt

            !TLM
            !--- 
            xcos(i,j) = F_lat(n)
            xsin(i,j) = ( (F_u(n) + F_v(n)) / suv2_m(i,j) ) * F_dt 

         end do
      end do

      do j=j0,jn
         do i=i0,in

!!!         n = (k-1)*adx_mlnij + ((j-1)*adx_mlni) + i

            !TRAJECTORY
            !----------
!!!         ysin_m(i,j) = sin(sqrt(F_u_m(i,j,k)**2 + F_v_m(i,j,k)**2) * F_dt)
!!!         ycos_m(i,j) = cos(F_lat_m(i,j,k))
!!!         yrec_m(i,j) = 1./cos(F_lat_m(i,j,k))
            !TLM
            !----
!!!         ysin(i,j) =  cos(sqrt(F_u_m(i,j,k)**2 + F_v_m(i,j,k)**2) * F_dt) * xsin(i,j)
!!!         ycos(i,j) = -sin(F_lat_m(i,j,k))* F_lat(i,j,k)
!!!         yrec(i,j) =( sin(F_lat_m(i,j,k))* F_lat(i,j,k) ) /cos(F_lat_m(i,j,k))**2

         end do
      end do
      !
      call vsin(ysin_m, xsin_m, vnij)
      call vcos(ycos_m, xcos_m, vnij)
      call vsin(slat_m, xcos_m, vnij)
      call vrec(yrec_m, ycos_m, vnij)
      !
      do j=j0,jn
         do i=i0,in

!!!         n = (k-1)*adx_mlnij + ((j-1)*adx_mlni) + i

!!!         cos2_m(i,j) = cos(F_lat_m(n))**2
            cos2_m(i,j) = ycos_m(i,j) **2
         end do
      end do
      !
      call vrec(rcos2_m, cos2_m, vnij)
      !
      do j=j0,jn
         do i=i0,in

            n = (k-1)*adx_mlnij + (j-1)*adx_mlni + i

            !- cartesian coordinates of grid points

            pdx = F_cx_8(adx_trj_i_off+i)
            pdy = F_sx_8(adx_trj_i_off+i)
            pdz = F_sy_8(j)

            !- if very small wind set upwind point to grid point

            if (abs(F_u_m(n))+abs(F_v_m(n)) >= 1.e-10) then

            pdx = pdx * F_cy_8(j)
            pdy = pdy * F_cy_8(j)

            ! sin and cosin of first guess of upwind positions

            !TRAJECTORY
            !----------
            pdsa_m  = F_z_m(n)
            pdca_m  = ycos_m(i,j)
            pdcai_m = yrec_m(i,j)
            pdso_m  = F_y_m(n) * pdcai_m
            pdco_m  = F_x_m(n) * pdcai_m

            !TLM
            !---
            pdsa  = F_z(n)
            pdca  = -slat_m(i,j) * F_lat(n)
            pdcai = -pdca * rcos2_m(i,j)
            pdso  = F_y_m(n) * pdcai + F_y(n) * pdcai_m
            pdco  = F_x_m(n) * pdcai + F_x(n) * pdcai_m

            !- wind components in cartesian coordinate at upwind positions

            !TRAJECTORY
            !----------
            pdux_m1 = ( - F_u_m(n) * pdso_m - F_v_m(n) * pdco_m * pdsa_m )
            pduy_m1 = (   F_u_m(n) * pdco_m - F_v_m(n) * pdso_m * pdsa_m )
            pduz_m1 =     F_v_m(n) * pdca_m

            !TLM
            !---
            pdux =  - F_u_m(n) * pdso   - F_v_m(n) * ( pdco_m * pdsa + pdco * pdsa_m) &
                    - F_u  (n) * pdso_m - F_v  (n) *   pdco_m * pdsa_m
            pduy =    F_u_m(n) * pdco   - F_v_m(n) * ( pdso_m * pdsa + pdso * pdsa_m) &
                    + F_u  (n) * pdco_m - F_v  (n) *   pdso_m * pdsa_m
            pduz =  F_v_m(n) * pdca + F_v(n) * pdca_m


            !TRAJECTORY
            !----------
            pdsinal_m1 = pdx * pdux_m1 + pdy * pduy_m1 + pdz * pduz_m1
            pdux_m = pdux_m1 - pdx * pdsinal_m1
            pduy_m = pduy_m1 - pdy * pdsinal_m1
            pduz_m = pduz_m1 - pdz * pdsinal_m1

            rsxyz_m  = 1./sqrt( pdux_m * pdux_m + pduy_m * pduy_m + pduz_m * pduz_m )

            pdcosal_m  = sqrt( ( 1.0 + ysin_m(i,j) ) * ( 1.0 - ysin_m(i,j) ) )
!!!         pdsinal_m2 = ysin_m(i,j) * rsxyz_m
            pdsinal_m2 = ysin_m(i,j) / sqrt(pdux_m*pdux_m + pduy_m*pduy_m + pduz_m*pduz_m) 

            rxyz_m     = 1./( pdux_m * pdux_m + pduy_m * pduy_m + pduz_m * pduz_m )

            !TLM
            !---
            pdsinal = pdx * pdux + pdy * pduy + pdz * pduz
            pdux = pdux - pdx * pdsinal
            pduy = pduy - pdy * pdsinal
            pduz = pduz - pdz * pdsinal

            pdsinal =  F_dt*pdcosal_m  *(F_u_m(n)*F_u(n)+F_v_m(n)*F_v(n))/suv2_m(i,j)
            pdcosal = -F_dt*ysin_m(i,j)*(F_u_m(n)*F_u(n)+F_v_m(n)*F_v(n))/suv2_m(i,j)
            pdsinal =   pdsinal    *   rsxyz_m & 
                      - pdsinal_m2 * ( pdux_m * pdux  + pduy_m * pduy  + pduz_m * pduz ) * rxyz_m

            !TRAJECTORY
            !----------
            F_x_m(n) = pdcosal_m * pdx - pdsinal_m2 * pdux_m
            F_y_m(n) = pdcosal_m * pdy - pdsinal_m2 * pduy_m
            F_z_m(n) = pdcosal_m * pdz - pdsinal_m2 * pduz_m

            !TLM
            !---
            F_x(n) = pdcosal * pdx - pdsinal * pdux_m - pdsinal_m2 * pdux
            F_y(n) = pdcosal * pdy - pdsinal * pduy_m - pdsinal_m2 * pduy
            F_z(n) = pdcosal * pdz - pdsinal * pduz_m - pdsinal_m2 * pduz

            endif

            !TRAJECTORY + TLM
            !Replace the following line by two IF blocks:
            !--------------------------------------------
            !F_z_m(n) = min(1.D0,max(1.D0*F_z_m(n),-1.D0))

            F_z_m_2 = min(1.D0,max(1.D0*F_z_m(n),-1.D0))

            if ( F_z_m(n) .lt. -1.D0 ) then
!!!            F_z_m(n) = -1.D0
               F_z  (n) =  0.D0
            elseif ( F_z_m(n) .gt.  1.0D0 ) then
!!!            F_z_m(n) =  1.D0
               F_z  (n) =  0.D0
            endif

            F_z_m(n) = F_z_m_2

            xasin_m(i,j) = F_z_m(n)
            xatan_m(i,j) = F_x_m(n)
            yatan_m(i,j) = F_y_m(n)
            sz2_m  (i,j) = sqrt(1.0 - F_z_m(n)*F_z_m(n))
            xy2_m  (i,j) = F_x_m(n)*F_x_m(n) + F_y_m(n)*F_y_m(n)

         enddo
      enddo

      !TRAJECTORY
      !----------
      call vasin  ( yasin_m, xasin_m,          vnij )
      call vatan2 ( zatan_m, yatan_m, xatan_m, vnij )
      call vrec   ( rxy2_m,  xy2_m  ,          vnij )

      do j=j0,jn
         do i=i0,in

            n = (k-1)*adx_mlnij + (j-1)*adx_mlni + i

            !TRAJECTORY
            !----------
            F_lat_m(n) = yasin_m(i,j)
            F_lon_m(n) = zatan_m(i,j)

            !TLM
            !---
            if ( abs(F_z_m(n)) .ne. 1.D0 ) then
               F_lat(n) = F_z(n) / sz2_m(i,j)
            else
               F_lat(n) = 0.D0
            endif
            F_lon(n) = (F_x_m(n)*F_y (n) - F_y_m(n)*F_x (n)) * rxy2_m(i,j)

            !TRAJECTORY + TLM
            !----------------
            if ( F_lon_m(n) .lt. 0.0 ) F_lon_m(n) = F_lon_m(n) + CONST_2PI_8 

         end do
      end do

   enddo
!$omp end parallel do

   !---------------------------------------------------------------------
   return
end subroutine adx_trajsp2_tl
