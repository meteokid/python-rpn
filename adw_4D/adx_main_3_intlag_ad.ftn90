!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

#include "model_macros_f.h"

!/**
subroutine adx_main_3_intlag7_ad (F_capxm   ,F_capym   ,F_capzm   ,                 &
                                  F_capxt   ,F_capyt   ,F_capzt   , F_fields_list , &
                                  F_capxm_tr,F_capym_tr,F_capzm_tr,                 &
                                  F_capxt_tr,F_capyt_tr,F_capzt_tr,F_fields_list_m, &
                                  F_fields_type_L, F_nfields,                       &
                                  F_doAdwStat_L, F_ni,F_nj,F_k0,F_nk_m,F_nk_t)
!
   implicit none
!
   !@objective ADJ of adx_main_3_intlag_tl 
!
   !@arguments
   logical :: F_doAdwStat_L  !I, compute stats if .true.
   integer :: F_ni,F_nj,F_nk_m,F_nk_t !I, pos array dims
   integer :: F_k0           !I, vertical scope F_k0 to F_nk_m,F_nk_t
   integer :: F_nfields      !I, nb of fields to advect
   logical, dimension(2,F_nfields)         :: F_fields_type_L !I, fields type
   character(len=8), dimension(2,F_nfields):: F_fields_list   !I, gmm flds lbls
   real, dimension(F_ni,F_nj,F_nk_m) :: F_capxm  , F_capym  , F_capzm   !I, upstream positions at t1
   real, dimension(F_ni,F_nj,F_nk_t) :: F_capxt  , F_capyt  , F_capzt   !I, upstream positions at t1
   real, dimension(F_ni,F_nj,F_nk_m) :: F_capxm_tr,F_capym_tr,F_capzm_tr!I, upstream positions at t1 TRAJ
   real, dimension(F_ni,F_nj,F_nk_t) :: F_capxt_tr,F_capyt_tr,F_capzt_tr!I, upstream positions at t1 TRAJ
   character(len=8), dimension(2,F_nfields):: F_fields_list_m !I, gmm flds lbls TRAJ
!
   !@author Monique Tanguay
!
   !@revisions
   ! v4_13 - Tanguay M.        - Adjustments GEM413
   ! v4_40 - Tanguay M.        - Revision TL/AD
   !**/
#include "adx_nml.cdk"
#include "adx_dims.cdk"
!!!#include "adx_poles.cdk"
#include "adx_grid.cdk"
#include "adx_interp.cdk"
#include "gmm.hf"
#include "lun.cdk"
#include "orh.cdk"
#include "ptopo.cdk"

   integer, parameter :: FIELD_IN  = 1
   integer, parameter :: FIELD_OUT = 2
   integer, parameter :: IS_MOM    = 1
   integer, parameter :: IS_WIND   = 2

   character(len=1) :: level_type_S

   real, pointer, dimension (:,:,:) :: fld_in,fld_out,fld_in_m

   character(len=8) :: F_out_S   !I, gmm label for interpolated field
   character(len=8) :: F_in_S    !I, gmm label for field to interpolate
   character(len=8) :: F_in_m_S  !I, gmm label for field to interpolate TRAJ

   type(gmm_metadata) :: mymeta

   real, dimension(adx_mlni,adx_mlnj,F_nk_t) :: wrkb_t, wrkc_t, wrkb_t_tr, wrkc_t_tr
   real, dimension(adx_mlni,adx_mlnj,F_nk_m) :: wrkb_m, wrkc_m, wrkb_m_tr, wrkc_m_tr

   real    :: fld_adwm_N   (adx_lminx:adx_lmaxx,adx_lminy:adx_lmaxy,F_nk_m,F_nfields), &
              fld_adwm_tr_N(adx_lminx:adx_lmaxx,adx_lminy:adx_lmaxy,F_nk_m,F_nfields)

   real    :: fld_adwt_N   (adx_lminx:adx_lmaxx,adx_lminy:adx_lmaxy,F_nk_t,F_nfields), &
              fld_adwt_tr_N(adx_lminx:adx_lmaxx,adx_lminy:adx_lmaxy,F_nk_t,F_nfields)

   real, dimension(F_ni,F_nj,F_nk_m,F_nfields) :: F_capxm_N, F_capym_N, F_capzm_N
   real, dimension(F_ni,F_nj,F_nk_t,F_nfields) :: F_capxt_N, F_capyt_N, F_capzt_N

   real, dimension(adx_mlni,adx_mlnj,F_nk_t,F_nfields) :: wrkc_t_N
   real, dimension(adx_mlni,adx_mlnj,F_nk_m,F_nfields) :: wrkc_m_N

   integer,dimension(:),pointer :: p_lcz
   real*8, dimension(:),pointer :: p_bsz_8, p_zbc_8, p_zabcd_8
   real*8, dimension(:),pointer :: p_zbacd_8, p_zcabd_8, p_zdabc_8
   real*8  :: p_z00_8

   integer :: nrow,kkmax,F_num,F_num_in,n,i,j,k,err,i0,j0,in,jn,istat 

   logical, parameter :: EXTEND_L = .true.
   logical :: is_south_L,F_mono_L,F_wind_L,F_mono_L_K(F_nfields)
   character(len=1) :: F_level_typ_K(F_nfields) 

   logical :: F_is_mom_L     !I, momentum level if .true. (thermo if not)

   logical done_L
   data done_L /.false./
   save done_L

   logical enough_L,residual_L
   integer ratio,rr,others,left_n,nn,ss,tt,max_serie,bnd_serie,lev,ind,n0,t0,s0

   integer, dimension(:,:)  ,allocatable :: field,level
   integer, dimension(:  )  ,allocatable :: thread

   integer, dimension(F_ni*F_nj*F_nk_t) :: exch_c1_t
   real   , dimension(F_ni*F_nj*F_nk_t) :: exch_n1_t, exch_xgg1_t, exch_xdd1_t
   real   , dimension(:,:), allocatable :: capx2_t_N,capy2_t_N,capz2_t_N

   integer, dimension(F_ni*F_nj*F_nk_m) :: exch_c1_m
   real   , dimension(F_ni*F_nj*F_nk_m) :: exch_n1_m, exch_xgg1_m, exch_xdd1_m
   real   , dimension(:,:), allocatable :: capx2_m_N,capy2_m_N,capz2_m_N

   integer, dimension(F_ni*F_nj*F_nk_t) :: exch_c1_t_tr
   real   , dimension(F_ni*F_nj*F_nk_t) :: exch_n1_t_tr, exch_xgg1_t_tr, exch_xdd1_t_tr
   real   , dimension(:), allocatable   :: capx2_t_tr,capy2_t_tr,capz2_t_tr

   integer, dimension(F_ni*F_nj*F_nk_m) :: exch_c1_m_tr
   real   , dimension(F_ni*F_nj*F_nk_m) :: exch_n1_m_tr, exch_xgg1_m_tr, exch_xdd1_m_tr
   real   , dimension(:), allocatable   :: capx2_m_tr,capy2_m_tr,capz2_m_tr

   real, dimension(:), pointer          :: wrka_m, wrka_t

   real, dimension(F_ni*F_nj*F_nk_m)    :: F_capym_tr_KEEP 
   real, dimension(F_ni*F_nj*F_nk_t)    :: F_capyt_tr_KEEP 

   integer adx_fro_n_m, adx_fro_s_m, adx_fro_a_m, &
           adx_for_n_m, adx_for_s_m, adx_for_a_m, & 
           adx_fro_n_t, adx_fro_s_t, adx_fro_a_t, &
           adx_for_n_t, adx_for_s_t, adx_for_a_t 

   integer adx_fro_n_m_TR,adx_for_n_m_TR,adx_fro_s_m_TR,adx_for_s_m_TR, &
           adx_fro_n_t_TR,adx_for_n_t_TR,adx_fro_s_t_TR,adx_for_s_t_TR

   real dummy

   !---------------------------------------------------------------------

   if (adx_lam_L) call handle_error(-1,'adx_main_3_intlag_ad','G_lam not done')

   call adx_get_ij0n (i0,in,j0,jn)

   if (adx_lam_L) then

!      NOT DONE

   else

      call adx_exch_1b_tr ( exch_n1_m_tr, exch_xgg1_m_tr, exch_xdd1_m_tr, exch_c1_m_tr,   &
                            F_capxm_tr , F_capym_tr , F_capzm_tr , F_capym_tr_KEEP,       &
                            F_ni,F_nj,F_nk_m,                                             & 
                            adx_fro_n_m, adx_fro_s_m, adx_fro_a_m,                        &
                            adx_for_n_m, adx_for_s_m, adx_for_a_m)

      call adx_exch_1b_tr ( exch_n1_t_tr, exch_xgg1_t_tr, exch_xdd1_t_tr, exch_c1_t_tr,   &
                            F_capxt_tr , F_capyt_tr , F_capzt_tr , F_capyt_tr_KEEP,       &
                            F_ni,F_nj,F_nk_t,                                             &
                            adx_fro_n_t, adx_fro_s_t, adx_fro_a_t,                        &
                            adx_for_n_t, adx_for_s_t, adx_for_a_t)

!     Zero adjoint variables
!     ----------------------
      allocate (wrka_m(max(1,adx_fro_a_m)))
      allocate (wrka_t(max(1,adx_fro_a_t)))

      do n=1,max(1,adx_fro_a_m)
         wrka_m (n) = 0.
      enddo
      do n=1,max(1,adx_fro_a_t)
         wrka_t (n) = 0.
      enddo

!     TRAJECTORY
!     ----------
      allocate ( capx2_m_tr(max(1,adx_fro_a_m)), &
                 capy2_m_tr(max(1,adx_fro_a_m)), &
                 capz2_m_tr(max(1,adx_fro_a_m)) )

      allocate ( capx2_t_tr(max(1,adx_fro_a_t)), &
                 capy2_t_tr(max(1,adx_fro_a_t)), &
                 capz2_t_tr(max(1,adx_fro_a_t)) )

      call adx_exch_2 ( capx2_m_tr, capy2_m_tr , capz2_m_tr         ,   &
                        exch_n1_m_tr, exch_xgg1_m_tr, exch_xdd1_m_tr,   &
                        adx_fro_n_m, adx_fro_s_m, adx_fro_a_m,          &
                        adx_for_n_m, adx_for_s_m, adx_for_a_m, 3)

      call adx_exch_2 ( capx2_t_tr, capy2_t_tr , capz2_t_tr         ,   &
                        exch_n1_t_tr, exch_xgg1_t_tr, exch_xdd1_t_tr,   &
                        adx_fro_n_t, adx_fro_s_t, adx_fro_a_t,          &
                        adx_for_n_t, adx_for_s_t, adx_for_a_t, 3)

      allocate ( capx2_m_N(max(1,adx_fro_a_m),F_nfields), &
                 capy2_m_N(max(1,adx_fro_a_m),F_nfields), &
                 capz2_m_N(max(1,adx_fro_a_m),F_nfields) )

      allocate ( capx2_t_N(max(1,adx_fro_a_t),F_nfields), &
                 capy2_t_N(max(1,adx_fro_a_t),F_nfields), &
                 capz2_t_N(max(1,adx_fro_a_t),F_nfields) )

   endif

!  Allocate arrays for series of threads
!  -------------------------------------
   bnd_serie = (F_nfields *           4*(F_nk_t/4)  ) / min(Ptopo_npeOpenMP,F_nfields*4) + &
               (F_nfields * (F_nk_t - 4*(F_nk_t/4)) ) / min(Ptopo_npeOpenMP,F_nfields)   + 10
!
   allocate ( field     (Ptopo_npeOpenMP, bnd_serie) )
   allocate ( level     (Ptopo_npeOpenMP, bnd_serie) )
   allocate ( thread    (                 bnd_serie) )

!  Zero adjoint variables
!  ----------------------
   wrkb_t     (:,:,:) = 0.
   wrkc_t     (:,:,:) = 0.
   exch_n1_t  (:)     = 0.
   exch_xgg1_t(:)     = 0.
   exch_xdd1_t(:)     = 0.
   wrkb_m     (:,:,:) = 0.
   wrkc_m     (:,:,:) = 0.
   exch_n1_m  (:)     = 0.
   exch_xgg1_m(:)     = 0.
   exch_xdd1_m(:)     = 0.

!$omp parallel 
!$omp do
   do n=1,F_nfields
      fld_adwm_N(:,:,:,n) = 0.
      fld_adwt_N(:,:,:,n) = 0.
      F_capxm_N (:,:,:,n) = 0.
      F_capym_N (:,:,:,n) = 0.
      F_capzm_N (:,:,:,n) = 0.
      F_capxt_N (:,:,:,n) = 0.
      F_capyt_N (:,:,:,n) = 0.
      F_capzt_N (:,:,:,n) = 0.
       wrkc_t_N (:,:,:,n) = 0.
       wrkc_m_N (:,:,:,n) = 0.
   enddo
!$omp enddo
   if (.not.adx_lam_L) then
!$omp do
   do n=1,F_nfields
      capx2_t_N(:,n) = 0. 
      capy2_t_N(:,n) = 0. 
      capz2_t_N(:,n) = 0.
      capx2_m_N(:,n) = 0. 
      capy2_m_N(:,n) = 0. 
      capz2_m_N(:,n) = 0.
   enddo
!$omp enddo
   endif
!$omp end parallel

!  --------------------------------------------------------
!  Calculations on TRAJ fields BEFORE adjoint interpolation
!  --------------------------------------------------------
   do n = F_nfields,1,-1

!     -----------------------------------------------------
!     Verify if MOMENTUM or THERMO 
!     -----------------------------------------------------
      F_level_typ_K(n) = 't'
      if (F_fields_type_L(IS_MOM,n)) F_level_typ_K(n) = 'm'
!     -----------------------------------------------------

      level_type_S = F_level_typ_K(n) 

      F_wind_L = F_fields_type_L(IS_WIND,n)

      F_in_m_S = F_fields_list_m(FIELD_IN ,n) 
      err = gmm_get(F_in_m_S ,fld_in_m ,mymeta)
      call handle_error(err,'adx_main_3_intlag_ad','gmm_get for '//trim(F_in_m_S)//', '//trim(F_in_m_S))

      F_mono_L_K(n) = .false.
      if (F_in_m_S(1:3) == 'TRM') F_mono_L_K(n) = adw_mono_L

      nrow = 999
      if (adx_lam_L) nrow = 0
      if (level_type_S == 'm') then
      call rpn_comm_xch_halox( fld_in_m,                            &
                    mymeta%l(1)%low,mymeta%l(1)%high,               &
                    mymeta%l(2)%low,mymeta%l(2)%high,               &
                    adx_mlni, adx_mlnj, F_nk_m, adx_halox, adx_haloy, &
                    adx_is_period_x, adx_is_period_y,               &
                    fld_adwm_tr_N(adx_lminx,adx_lminy,1,n), adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, adx_lni, nrow)
      else
      call rpn_comm_xch_halox( fld_in_m,                            &
                    mymeta%l(1)%low,mymeta%l(1)%high,               &
                    mymeta%l(2)%low,mymeta%l(2)%high,               &
                    adx_mlni, adx_mlnj, F_nk_t, adx_halox, adx_haloy, &
                    adx_is_period_x, adx_is_period_y,               &
                    fld_adwt_tr_N(adx_lminx,adx_lminy,1,n), adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, adx_lni, nrow)
      endif

!!! !$omp parallel (INSIDE ADX_POL)

      if (.not.adx_lam_L) then
         if (adx_is_south) then
            is_south_L = .true.
            if (level_type_S == 'm') then
            call adx_pole0s2 (fld_adwm_tr_N(adx_lminx,adx_lminy,1,n), fld_in_m,        &
                              adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, &
                              mymeta%l(1)%low,mymeta%l(1)%high,        &
                              mymeta%l(2)%low,mymeta%l(2)%high, F_nk_m,&
                              F_wind_L, EXTEND_L, is_south_L)
            else
            call adx_pole0s2 (fld_adwt_tr_N(adx_lminx,adx_lminy,1,n), fld_in_m,        &
                              adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, &
                              mymeta%l(1)%low,mymeta%l(1)%high,        &
                              mymeta%l(2)%low,mymeta%l(2)%high, F_nk_t,&
                              F_wind_L, EXTEND_L, is_south_L)
            endif
         endif

         if (adx_is_north) then
            is_south_L = .false.
            if (level_type_S == 'm') then
            call adx_pole0s2 (fld_adwm_tr_N(adx_lminx,adx_lminy,1,n), fld_in_m,        &
                              adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, &
                              mymeta%l(1)%low,mymeta%l(1)%high,        &
                              mymeta%l(2)%low,mymeta%l(2)%high, F_nk_m,&
                              F_wind_L, EXTEND_L, is_south_L)
            else
            call adx_pole0s2 (fld_adwt_tr_N(adx_lminx,adx_lminy,1,n), fld_in_m,        &
                              adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, &
                              mymeta%l(1)%low,mymeta%l(1)%high,        &
                              mymeta%l(2)%low,mymeta%l(2)%high, F_nk_t,&
                              F_wind_L, EXTEND_L, is_south_L)
            endif
         endif
      endif

!!! !$omp end parallel (INSIDE ADX_POL)

   enddo

!  -------------------------------------------------------
!  Calculations on ADJ fields BEFORE adjoint interpolation
!  -------------------------------------------------------
   do n = F_nfields,1,-1

      level_type_S = F_level_typ_K(n)

      F_out_S = F_fields_list  (FIELD_OUT,n)
      err = gmm_get(F_out_S, fld_out ,mymeta)
      call handle_error(err,'adx_main_3_intlag_ad','gmm_get for '//trim(F_out_S)//', '//trim(F_out_S))

      if (level_type_S == 'm') then
!$omp parallel do
         do k=F_nk_m,F_k0,-1
            wrkc_m(i0:in,j0:jn,k) = fld_out(i0:in,j0:jn,k)
         enddo
!$omp end parallel do
      else
!$omp parallel do
         do k=F_nk_t,F_k0,-1
            wrkc_t(i0:in,j0:jn,k) = fld_out(i0:in,j0:jn,k)
         enddo
!$omp end parallel do
      endif

!      ----------------------------------------------
!      Do HERE adjoint of interpolation for OUTSIDERS
!      ----------------------------------------------
       if (.not.adx_lam_L) then

           if (level_type_S == 'm') then
               kkmax   = adx_lnkm - 1
               p_z00_8 = adx_verZ_8%m(1)
               p_lcz     => adx_lcz%m
               p_bsz_8   => adx_bsz_8%m
               p_zabcd_8 => adx_zabcd_8%m
               p_zbacd_8 => adx_zbacd_8%m
               p_zcabd_8 => adx_zcabd_8%m
               p_zdabc_8 => adx_zdabc_8%m
               p_zbc_8   => adx_zbc_8%m
           else
               kkmax   = adx_lnkm
               p_z00_8 = adx_verZ_8%t(1)
               p_lcz     => adx_lcz%t
               p_bsz_8   => adx_bsz_8%t
               p_zabcd_8 => adx_zabcd_8%t
               p_zbacd_8 => adx_zbacd_8%t
               p_zcabd_8 => adx_zcabd_8%t
               p_zdabc_8 => adx_zdabc_8%t
               p_zbc_8   => adx_zbc_8%t
           endif

           if (level_type_S == 'm') then
               F_num_in = (adx_lmaxx-adx_lminx+1)*(adx_lmaxy-adx_lminy+1)*F_nk_m
           else
               F_num_in = (adx_lmaxx-adx_lminx+1)*(adx_lmaxy-adx_lminy+1)*F_nk_t
           endif

           if (level_type_S == 'm') then

               if (adx_for_a_m > 0) then
                   call adx_exch_3b_ad (wrkc_m, dummy, wrkb_m, dummy, exch_c1_m_tr, &
                                        1,F_ni,F_nj,F_nk_m,adx_for_a_m)
               endif

               call adx_exch_2_ad ( wrkb_m, dummy, dummy,                  &
                                    wrka_m, dummy, dummy,                  &
                                    adx_for_n_m, adx_for_s_m, adx_for_a_m, &
                                    adx_fro_n_m, adx_fro_s_m, adx_fro_a_m, 1)

               if (adx_fro_a_m > 0 ) then
                    call adx_lag3d_tricub_ad ( & 
                         wrka_m,fld_adwm_N   (adx_lminx,adx_lminy,1,n),capx2_m_N(1,n),capy2_m_N(1,n),capz2_m_N(1,n), &
                                fld_adwm_tr_N(adx_lminx,adx_lminy,1,n),capx2_m_tr    ,capy2_m_tr    ,capz2_m_tr    , &
                         adx_y00_8,adx_x00_8,p_z00_8,adx_ovdx_8,adx_ovdy_8,adx_ovdz_8,                               &
                         adx_lcx,adx_lcy,p_lcz, adx_bsx_8,adx_bsy_8,p_bsz_8,                                         &
                         adx_xabcd_8,adx_xbacd_8,adx_xcabd_8,adx_xdabc_8,                                            &
                         adx_yabcd_8,adx_ybacd_8,adx_ycabd_8,adx_ydabc_8,                                            &
                         p_zabcd_8,p_zbacd_8, p_zcabd_8, p_zdabc_8, p_zbc_8,                                         &
                         adx_fro_a_m, F_num_in, F_mono_L, 1, adx_fro_a_m, 1, 1, 1, 1, kkmax)
               endif

           else

               if (adx_for_a_t > 0) then
                   call adx_exch_3b_ad (wrkc_t, dummy, wrkb_t, dummy, exch_c1_t_tr, &
                                        1,F_ni,F_nj,F_nk_t,adx_for_a_t)
               endif

               call adx_exch_2_ad ( wrkb_t, dummy, dummy,                  &
                                    wrka_t, dummy, dummy,                  &
                                    adx_for_n_t, adx_for_s_t, adx_for_a_t, &
                                    adx_fro_n_t, adx_fro_s_t, adx_fro_a_t, 1)

               if (adx_fro_a_t > 0 ) then
                    call adx_lag3d_tricub_ad ( &
                         wrka_t,fld_adwt_N   (adx_lminx,adx_lminy,1,n),capx2_t_N(1,n),capy2_t_N(1,n),capz2_t_N(1,n), &
                                fld_adwt_tr_N(adx_lminx,adx_lminy,1,n),capx2_t_tr    ,capy2_t_tr    ,capz2_t_tr    , &
                         adx_y00_8,adx_x00_8,p_z00_8,adx_ovdx_8,adx_ovdy_8,adx_ovdz_8,                               &
                         adx_lcx,adx_lcy,p_lcz, adx_bsx_8,adx_bsy_8,p_bsz_8,                                         &
                         adx_xabcd_8,adx_xbacd_8,adx_xcabd_8,adx_xdabc_8,                                            &
                         adx_yabcd_8,adx_ybacd_8,adx_ycabd_8,adx_ydabc_8,                                            &
                         p_zabcd_8,p_zbacd_8, p_zcabd_8, p_zdabc_8, p_zbc_8,                                         &
                         adx_fro_a_t, F_num_in, F_mono_L, 1, adx_fro_a_t, 1, 1, 1, 1, kkmax)
               endif

           endif

           if (level_type_S == 'm') then
!$omp parallel do
             do k=F_nk_m,F_k0,-1
                wrkc_m_N(i0:in,j0:jn,k,n) = wrkc_m(i0:in,j0:jn,k)
             enddo
!$omp end parallel do
           else
!$omp parallel do
             do k=F_nk_t,F_k0,-1
                wrkc_t_N(i0:in,j0:jn,k,n) = wrkc_t(i0:in,j0:jn,k)
             enddo
!$omp end parallel do
           endif

       endif

   enddo
!
!  -------------------------------------------------------------------------------------------
!  Give a field to each thread only if all threads could be occupied with the remaining fields
!  -------------------------------------------------------------------------------------------
   ratio = F_nfields/Ptopo_npeOpenMP

   left_n = 1
   enough_L = .false.
!
   if( ratio.ne.0 ) then
!
!      Verify if the threads that won't be treated are enough
!      ------------------------------------------------------
       others = F_nfields - ratio * Ptopo_npeOpenMP
       enough_L = .true.
       if (others.ne.0.and.4*others.lt.Ptopo_npeOpenMP) enough_L = .false.
!
          if (Ptopo_myproc.eq.0.and.Lun_out.gt.0.and..not.done_L.and.ratio.ne.0) &
              write(Lun_out,*) 'CN = ',Orh_icn,': ADW_TRICUB_AD: Enough threads for the remaining fields', &
              ' if we give a field to each thread =', &
              enough_L
!
   endif

   if( ratio.ne.0.and.enough_L ) then
!
!  ------------------
   do rr = 1,ratio
!  ------------------
!
!$omp parallel do private(k,level_type_S,F_num,F_num_in,wrkc_t,wrkc_m,F_mono_L,                          & 
!$omp                     kkmax,p_z00_8,p_lcz,p_bsz_8,p_zabcd_8,p_zbacd_8,p_zcabd_8,p_zdabc_8,p_zbc_8)   &
!$omp             shared (wrkc_t_N,wrkc_m_N,F_capxm_N,F_capym_N,F_capzm_N,F_capxt_N,F_capyt_N,F_capzt_N, &
!$omp                     fld_adwm_N,fld_adwm_tr_N,fld_adwt_N,fld_adwt_tr_N,                             &
!$omp                     F_capxm_tr,F_capym_tr,F_capzm_tr,F_capxt_tr,F_capyt_tr,F_capzt_tr,F_mono_L_K,F_level_typ_K)

      do n = left_n, left_n + Ptopo_npeOpenMP - 1

         level_type_S = F_level_typ_K(n)

         if (level_type_S == 'm') then
             F_num = adx_mlni*adx_mlnj*F_nk_m
             F_num_in = (adx_lmaxx-adx_lminx+1)*(adx_lmaxy-adx_lminy+1)*F_nk_m
         else
             F_num = adx_mlni*adx_mlnj*F_nk_t
             F_num_in = (adx_lmaxx-adx_lminx+1)*(adx_lmaxy-adx_lminy+1)*F_nk_t
         endif
!        ----------------------------

         F_mono_L = F_mono_L_K(n) 

         if (level_type_S == 'm') then
             wrkc_m = 0.
             do k=F_nk_m,F_k0,-1
                wrkc_m(i0:in,j0:jn,k) = wrkc_m_N(i0:in,j0:jn,k,n)
             enddo
         else
             wrkc_t = 0.
             do k=F_nk_t,F_k0,-1
                wrkc_t(i0:in,j0:jn,k) = wrkc_t_N(i0:in,j0:jn,k,n)
             enddo
         endif

         if (level_type_S == 'm') then
             kkmax   = adx_lnkm - 1
             p_z00_8 = adx_verZ_8%m(1)
             p_lcz     => adx_lcz%m
             p_bsz_8   => adx_bsz_8%m
             p_zabcd_8 => adx_zabcd_8%m
             p_zbacd_8 => adx_zbacd_8%m
             p_zcabd_8 => adx_zcabd_8%m
             p_zdabc_8 => adx_zdabc_8%m
             p_zbc_8   => adx_zbc_8%m
         else
             kkmax   = adx_lnkm
             p_z00_8 = adx_verZ_8%t(1)
             p_lcz     => adx_lcz%t
             p_bsz_8   => adx_bsz_8%t
             p_zabcd_8 => adx_zabcd_8%t
             p_zbacd_8 => adx_zbacd_8%t
             p_zcabd_8 => adx_zcabd_8%t
             p_zdabc_8 => adx_zdabc_8%t
             p_zbc_8   => adx_zbc_8%t
         endif

         if (level_type_S == 'm') then 
             call adx_lag3d_tricub_ad (wrkc_m, fld_adwm_N   (adx_lminx,adx_lminy,1,n), F_capxm_N(1,1,1,n), F_capym_N(1,1,1,n), F_capzm_N(1,1,1,n), &
                                               fld_adwm_tr_N(adx_lminx,adx_lminy,1,n), F_capxm_tr        , F_capym_tr        , F_capzm_tr        , &
                  adx_y00_8,adx_x00_8,p_z00_8,adx_ovdx_8,adx_ovdy_8,adx_ovdz_8,          &
                  adx_lcx,adx_lcy,p_lcz, adx_bsx_8,adx_bsy_8,p_bsz_8,                    &
                  adx_xabcd_8,adx_xbacd_8,adx_xcabd_8,adx_xdabc_8,                       &
                  adx_yabcd_8,adx_ybacd_8,adx_ycabd_8,adx_ydabc_8,                       &
                  p_zabcd_8,p_zbacd_8, p_zcabd_8, p_zdabc_8, p_zbc_8,                    &
                  F_num, F_num_in, F_mono_L, i0, in, j0, jn, F_k0, F_nk_m, kkmax)
         else
             call adx_lag3d_tricub_ad (wrkc_t, fld_adwt_N   (adx_lminx,adx_lminy,1,n), F_capxt_N(1,1,1,n), F_capyt_N(1,1,1,n), F_capzt_N(1,1,1,n), &
                                               fld_adwt_tr_N(adx_lminx,adx_lminy,1,n), F_capxt_tr        , F_capyt_tr        , F_capzt_tr        , &
                  adx_y00_8,adx_x00_8,p_z00_8,adx_ovdx_8,adx_ovdy_8,adx_ovdz_8,          &
                  adx_lcx,adx_lcy,p_lcz, adx_bsx_8,adx_bsy_8,p_bsz_8,                    &
                  adx_xabcd_8,adx_xbacd_8,adx_xcabd_8,adx_xdabc_8,                       &
                  adx_yabcd_8,adx_ybacd_8,adx_ycabd_8,adx_ydabc_8,                       &
                  p_zabcd_8,p_zbacd_8, p_zcabd_8, p_zdabc_8, p_zbc_8,                    &
                  F_num, F_num_in, F_mono_L, i0, in, j0, jn, F_k0, F_nk_t, kkmax)
         endif

      end do
!$omp end parallel do 

      left_n = left_n + Ptopo_npeOpenMP
 
!  -----
   enddo
!  -----
 
   else
 
      left_n = 1 

   endif

   if (Ptopo_myproc.eq.0.and.Lun_out.gt.0.and..not.done_L) then 
       write(Lun_out,*) 'CN = ',Orh_icn,': ADW_TRICUB_AD: Fields to be interpolated if we give a field to each thread =', left_n - 1
       write(Lun_out,*) 'CN = ',Orh_icn,': ADW_TRICUB_AD: Number of remaining fields that will be treated using series of threads =', F_nfields - left_n + 1 
   endif
!
   if( left_n.le.F_nfields ) then
!
!     --------------------------------------------------------------------
!     Allocate untreated field to interpolate at prescribed vertical level 
!     for each thread in a series   
!     --------------------------------------------------------------------
      nn  = left_n - 1 
      lev = 1 
!
      residual_L = .false.
!
      do ss = 1,bnd_serie
!
!         Set number of threads in a series 
!         ---------------------------------
          thread(ss) = min(Ptopo_npeOpenMP,(F_nfields-left_n+1)*4)
          if (residual_L) then
          thread(ss) = min(Ptopo_npeOpenMP,(F_nfields-left_n+1)  )
          endif
!
          do tt = 1,thread(ss)
!
             nn = nn + 1

             if(nn.gt.F_nfields) then

                nn = left_n
!            
                if    (lev.le.  (F_nk_t/4)) then
                       lev = lev +   (F_nk_t/4)
                elseif(lev.gt.  (F_nk_t/4).and.lev.le.2*(F_nk_t/4)) then
                       lev = lev +   (F_nk_t/4)
                elseif(lev.gt.2*(F_nk_t/4).and.lev.le.3*(F_nk_t/4)) then
                       lev = lev +   (F_nk_t/4)
                elseif(lev.gt.3*(F_nk_t/4).and.lev.lt.4*(F_nk_t/4)) then
                       lev = lev - 3*(F_nk_t/4) + 1
                elseif(lev.eq.4*(F_nk_t/4).and.4*(F_nk_t/4).lt.F_nk_t.and..NOT.residual_L) then

!                      The current series should not use this thread
!                      ---------------------------------------------
                       thread(ss) = tt-1

                       residual_L = .true.

                       nn = F_nfields
!
!                      We start another series
!                      -----------------------

                       goto 50

                elseif(lev.eq.4*(F_nk_t/4).and.4*(F_nk_t/4).eq.F_nk_t.and..NOT.residual_L) then

!                      The current series should not use this thread
!                      ---------------------------------------------
                       thread(ss) = tt-1

                       goto 100

                elseif(residual_L.and.lev.lt.F_nk_t) then
 
                       lev = lev + 1

                elseif(residual_L.and.lev.eq.F_nk_t) then

                       thread(ss) = tt-1

                       goto 100
 
                endif

             endif

             field(tt,ss) = nn 
             level(tt,ss) = lev 
!
          enddo

   50     continue
 
      enddo
!
  100 continue

      max_serie = ss
!
      if ( thread(max_serie).eq.0 ) max_serie = max_serie - 1 
!
      if (Ptopo_myproc.eq.0.and.Lun_out.gt.0.and..not.done_L.and..not.residual_L) then 
          write(Lun_out,*) 'CN = ',Orh_icn,': ADW_TRICUB_AD: We have Residual levels                   =',residual_L
          write(Lun_out,*) 'CN = ',Orh_icn,': ADW_TRICUB_AD: Number of series for the remaining fields =',max_serie
      endif
!
!     ---------------------------------------------------
!     Do adjoint interpolation for each series of threads   
!     ---------------------------------------------------
      do ss = 1,max_serie
!
!$omp parallel do private(nn,lev,level_type_S,F_mono_L,wrkc_m,wrkc_t,                                          &
!$omp                     kkmax,p_z00_8,p_lcz,p_bsz_8,p_zabcd_8,p_zbacd_8,p_zcabd_8,p_zdabc_8,p_zbc_8,         &
!$omp                     F_num_in,F_num)                                                                      &
!$omp             shared (thread,field,level,F_level_typ_K,F_mono_L_K, wrkc_m_N,wrkc_t_N,                      &
!$omp                     fld_adwm_N,fld_adwm_tr_N,F_capxm_N,F_capym_N,F_capzm_N,F_capxt_N,F_capyt_N,F_capzt_N,&
!$omp                     F_capxm_tr,F_capym_tr,F_capzm_tr,F_capxt_tr,F_capyt_tr,F_capzt_tr)
!
          do tt = 1,thread(ss)
!
             nn           = field     (tt,ss)
             lev          = level     (tt,ss)
!
             level_type_S = F_level_typ_K(nn)

!            ------------------------------------------------------------------------
             if ((level_type_S == 'm'.and.lev.le.F_nk_m).OR.level_type_S == 't') then
!            ------------------------------------------------------------------------

         if (level_type_S == 'm') then
             F_num    = adx_mlni*adx_mlnj
             F_num_in = (adx_lmaxx-adx_lminx+1)*(adx_lmaxy-adx_lminy+1)*F_nk_m
         else
             F_num    = adx_mlni*adx_mlnj
             F_num_in = (adx_lmaxx-adx_lminx+1)*(adx_lmaxy-adx_lminy+1)*F_nk_t
         endif

             F_mono_L     = F_mono_L_K(nn) 
!
             if (level_type_S == 'm') then
                wrkc_m = 0.
                wrkc_m (i0:in,j0:jn,1) = wrkc_m_N (i0:in,j0:jn,lev,nn) 
             else
                wrkc_t = 0.
                wrkc_t (i0:in,j0:jn,1) = wrkc_t_N (i0:in,j0:jn,lev,nn) 
             endif

             if (level_type_S == 'm') then
                 kkmax   = adx_lnkm - 1
                 p_z00_8 = adx_verZ_8%m(1)
                 p_lcz     => adx_lcz%m
                 p_bsz_8   => adx_bsz_8%m
                 p_zabcd_8 => adx_zabcd_8%m
                 p_zbacd_8 => adx_zbacd_8%m
                 p_zcabd_8 => adx_zcabd_8%m
                 p_zdabc_8 => adx_zdabc_8%m
                 p_zbc_8   => adx_zbc_8%m
             else
                 kkmax   = adx_lnkm
                 p_z00_8 = adx_verZ_8%t(1)
                 p_lcz     => adx_lcz%t
                 p_bsz_8   => adx_bsz_8%t
                 p_zabcd_8 => adx_zabcd_8%t
                 p_zbacd_8 => adx_zbacd_8%t
                 p_zcabd_8 => adx_zcabd_8%t
                 p_zdabc_8 => adx_zdabc_8%t
                 p_zbc_8   => adx_zbc_8%t
             endif

!
!            Adjoint of interpolation
!            ------------------------
             if (level_type_S == 'm') then
                 call adx_lag3d_tricub_ad (wrkc_m,fld_adwm_N   (adx_lminx,adx_lminy,1,nn),   & 
                                           F_capxm_N (1,1,lev,nn),F_capym_N (1,1,lev,nn),F_capzm_N (1,1,lev,nn), &
                                                  fld_adwm_tr_N(adx_lminx,adx_lminy,1,nn),   &
                                           F_capxm_tr(1,1,lev)   ,F_capym_tr(1,1,lev)   ,F_capzm_tr(1,1,lev)   , &
                      adx_y00_8,adx_x00_8,p_z00_8,adx_ovdx_8,adx_ovdy_8,adx_ovdz_8,          &
                      adx_lcx,adx_lcy,p_lcz, adx_bsx_8,adx_bsy_8,p_bsz_8,                    &
                      adx_xabcd_8,adx_xbacd_8,adx_xcabd_8,adx_xdabc_8,                       &
                      adx_yabcd_8,adx_ybacd_8,adx_ycabd_8,adx_ydabc_8,                       &
                      p_zabcd_8,p_zbacd_8, p_zcabd_8, p_zdabc_8, p_zbc_8,                    &
                      F_num, F_num_in, F_mono_L, i0, in, j0, jn, 1, 1, kkmax)
             else
                 call adx_lag3d_tricub_ad (wrkc_t,fld_adwt_N   (adx_lminx,adx_lminy,1,nn),   &
                                           F_capxt_N (1,1,lev,nn),F_capyt_N (1,1,lev,nn),F_capzt_N (1,1,lev,nn), &
                                                  fld_adwt_tr_N(adx_lminx,adx_lminy,1,nn),   &
                                           F_capxt_tr(1,1,lev)   ,F_capyt_tr(1,1,lev)   ,F_capzt_tr(1,1,lev)   , &
                      adx_y00_8,adx_x00_8,p_z00_8,adx_ovdx_8,adx_ovdy_8,adx_ovdz_8,          &
                      adx_lcx,adx_lcy,p_lcz, adx_bsx_8,adx_bsy_8,p_bsz_8,                    &
                      adx_xabcd_8,adx_xbacd_8,adx_xcabd_8,adx_xdabc_8,                       &
                      adx_yabcd_8,adx_ybacd_8,adx_ycabd_8,adx_ydabc_8,                       &
                      p_zabcd_8,p_zbacd_8, p_zcabd_8, p_zdabc_8, p_zbc_8,                    &
                      F_num, F_num_in, F_mono_L, i0, in, j0, jn, 1, 1, kkmax)
             endif

!            ---------------------------------------------------------------------
             endif 
!            ---------------------------------------------------------------------
!
          enddo 
!
!$omp end parallel do 
!
      enddo
!
      endif

!  ------------------------------------------------------
!  Calculations on ADJ fields after adjoint interpolation
!  ------------------------------------------------------

   do n = F_nfields,1,-1

      level_type_S = F_level_typ_K(n)

      F_wind_L = F_fields_type_L(IS_WIND,n)

      F_out_S = F_fields_list  (FIELD_OUT,n)
      err = gmm_get(F_out_S,fld_out,mymeta)
      call handle_error(err,'adx_main_3_intlag_ad','gmm_get for '//trim(F_out_S)//', '//trim(F_out_S))

!     ADJ of Zero FLD_OUT
!     -------------------
      if (level_type_S == 'm') then 
!$omp parallel do
         do k=1,F_nk_m
         do j=mymeta%l(2)%low,mymeta%l(2)%high
         do i=mymeta%l(1)%low,mymeta%l(1)%high
            fld_out(i,j,k) = 0.
         enddo
         enddo
         enddo
!$omp end parallel do
      else
!$omp parallel do
         do k=1,F_nk_t
         do j=mymeta%l(2)%low,mymeta%l(2)%high
         do i=mymeta%l(1)%low,mymeta%l(1)%high
            fld_out(i,j,k) = 0.
         enddo
         enddo
         enddo
!$omp end parallel do
      endif

!     ADJ of
!     Extend values at the poles
!     --------------------------
!$omp parallel
      if (.not.adx_lam_L) then
         if (adx_is_north) then
            is_south_L = .false.
            if (level_type_S == 'm') then 
            call adx_pole0s2_ad(fld_adwm_N(adx_lminx,adx_lminy,1,n),     &
                                adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, &
                                mymeta%l(1)%low,mymeta%l(1)%high,        &
                                mymeta%l(2)%low,mymeta%l(2)%high, F_nk_m,&
                                F_wind_L, EXTEND_L, is_south_L)
            else
            call adx_pole0s2_ad(fld_adwt_N(adx_lminx,adx_lminy,1,n),     &
                                adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, &
                                mymeta%l(1)%low,mymeta%l(1)%high,        &
                                mymeta%l(2)%low,mymeta%l(2)%high, F_nk_t,&
                                F_wind_L, EXTEND_L, is_south_L)
            endif
         endif

         if (adx_is_south) then
            is_south_L = .true.
            if (level_type_S == 'm') then 
            call adx_pole0s2_ad(fld_adwm_N(adx_lminx,adx_lminy,1,n),     &
                                adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, &
                                mymeta%l(1)%low,mymeta%l(1)%high,        &
                                mymeta%l(2)%low,mymeta%l(2)%high, F_nk_m,&
                                F_wind_L, EXTEND_L, is_south_L)
            else
            call adx_pole0s2_ad(fld_adwt_N(adx_lminx,adx_lminy,1,n),     &
                                adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, &
                                mymeta%l(1)%low,mymeta%l(1)%high,        &
                                mymeta%l(2)%low,mymeta%l(2)%high, F_nk_t,&
                                F_wind_L, EXTEND_L, is_south_L)
            endif
         endif
      endif
!$omp end parallel

!     ADJ of
!     Exchange Haloes 
!     ---------------
      F_in_S = F_fields_list  (FIELD_IN ,n)
      err = gmm_get(F_in_S, fld_in ,mymeta)
      call handle_error(err,'adx_main_3_intlag_ad','gmm_get for '//trim(F_in_S)//', '//trim(F_in_S))

      nrow = 999
      if (adx_lam_L) nrow = 0
      if (level_type_S == 'm') then 
      call rpn_comm_adj_halox( fld_in,                                & 
                    mymeta%l(1)%low,mymeta%l(1)%high,                 &
                    mymeta%l(2)%low,mymeta%l(2)%high,                 &
                    adx_mlni, adx_mlnj, F_nk_m, adx_halox, adx_haloy, &
                    adx_is_period_x, adx_is_period_y,                 &
                    fld_adwm_N(adx_lminx,adx_lminy,1,n), adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, adx_lni, nrow)
      else
      call rpn_comm_adj_halox( fld_in,                                &
                    mymeta%l(1)%low,mymeta%l(1)%high,                 &
                    mymeta%l(2)%low,mymeta%l(2)%high,                 &
                    adx_mlni, adx_mlnj, F_nk_t, adx_halox, adx_haloy, &
                    adx_is_period_x, adx_is_period_y,                 &
                    fld_adwt_N(adx_lminx,adx_lminy,1,n), adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, adx_lni, nrow)
      endif
 
   end do

!  --------------------------
!  Combine ADJ capx,capy,capz
!  --------------------------
   do n = F_nfields,1,-1

         level_type_S = F_level_typ_K(n)

         if (level_type_S == 't') then

!$omp parallel do private(i,j,k) shared(n,F_capxt_N,F_capyt_N,F_capzt_N)
            do k=1,F_nk_t
            do j=1,F_nj
            do i=1,F_ni
               F_capxt  (i,j,k)   = F_capxt_N(i,j,k,n) + F_capxt(i,j,k)
               F_capyt  (i,j,k)   = F_capyt_N(i,j,k,n) + F_capyt(i,j,k)
               F_capzt  (i,j,k)   = F_capzt_N(i,j,k,n) + F_capzt(i,j,k)
               F_capxt_N(i,j,k,n) = 0.
               F_capyt_N(i,j,k,n) = 0.
               F_capzt_N(i,j,k,n) = 0.
             enddo
             enddo
             enddo
!$omp end parallel do

         endif

         if (level_type_S == 'm') then

!$omp parallel do private(i,j,k) shared(n,F_capxm_N,F_capym_N,F_capzm_N)
            do k=1,F_nk_m
            do j=1,F_nj
            do i=1,F_ni
               F_capxm  (i,j,k)   = F_capxm_N(i,j,k,n) + F_capxm(i,j,k)
               F_capym  (i,j,k)   = F_capym_N(i,j,k,n) + F_capym(i,j,k)
               F_capzm  (i,j,k)   = F_capzm_N(i,j,k,n) + F_capzm(i,j,k)
               F_capxm_N(i,j,k,n) = 0.
               F_capym_N(i,j,k,n) = 0.
               F_capzm_N(i,j,k,n) = 0.
            enddo
            enddo
            enddo
!$omp end parallel do

         endif

   end do

!  --------------------------------------------
!  Do HERE adjoint of positioning for OUTSIDERS
!  --------------------------------------------
   if (.not.adx_lam_L) then

        do n = F_nfields,1,-1

           level_type_S = F_level_typ_K(n)

           if (level_type_S == 'm') then

           call adx_exch_2_ad (capx2_m_N(1,n), capy2_m_N(1,n), capz2_m_N(1,n), &
                               exch_n1_m     , exch_xgg1_m   , exch_xdd1_m   , &
                               adx_fro_n_m, adx_fro_s_m, adx_fro_a_m,          &
                               adx_for_n_m, adx_for_s_m, adx_for_a_m, 3)
           else

           call adx_exch_2_ad (capx2_t_N(1,n), capy2_t_N(1,n), capz2_t_N(1,n), &
                               exch_n1_t     , exch_xgg1_t   , exch_xdd1_t   , &
                               adx_fro_n_t, adx_fro_s_t, adx_fro_a_t,          &
                               adx_for_n_t, adx_for_s_t, adx_for_a_t, 3)

           endif

        end do

   endif

 
   if (.not.adx_lam_L) then
 
         adx_fro_n_m_TR = adx_fro_n_m
         adx_for_n_m_TR = adx_for_n_m
         adx_fro_s_m_TR = adx_fro_s_m
         adx_for_s_m_TR = adx_for_s_m

         adx_fro_n_t_TR = adx_fro_n_t
         adx_for_n_t_TR = adx_for_n_t
         adx_fro_s_t_TR = adx_fro_s_t
         adx_for_s_t_TR = adx_for_s_t
 
         call adx_exch_1b_tr ( dummy, dummy, dummy, exch_c1_m_tr,                      &
                               F_capxm_tr , F_capym_tr , F_capzm_tr , F_capym_tr_KEEP, &
                               F_ni,F_nj,F_nk_m,                                       &
                               adx_fro_n_m, adx_fro_s_m, adx_fro_a_m,                  &
                               adx_for_n_m, adx_for_s_m, adx_for_a_m)

         call adx_exch_1b_tr ( dummy, dummy, dummy, exch_c1_t_tr,                      &
                               F_capxt_tr , F_capyt_tr , F_capzt_tr , F_capyt_tr_KEEP, &
                               F_ni,F_nj,F_nk_t,                                       &
                               adx_fro_n_t, adx_fro_s_t, adx_fro_a_t,                  &
                               adx_for_n_t, adx_for_s_t, adx_for_a_t)

         adx_fro_n_m = adx_fro_n_m_TR
         adx_for_n_m = adx_for_n_m_TR
         adx_fro_s_m = adx_fro_s_m_TR
         adx_for_s_m = adx_for_s_m_TR

         adx_fro_n_t = adx_fro_n_t_TR
         adx_for_n_t = adx_for_n_t_TR
         adx_fro_s_t = adx_fro_s_t_TR
         adx_for_s_t = adx_for_s_t_TR
 
         call adx_exch_1b_ad ( exch_n1_m   ,exch_xgg1_m    ,exch_xdd1_m,    &
                               F_capxm     ,F_capym        ,F_capzm    ,    &
                               exch_c1_m_tr,F_capym_tr_KEEP,                &
                               F_ni,F_nj,F_nk_m,adx_for_n_m,adx_for_s_m,adx_fro_n_m,adx_fro_s_m)

         call adx_exch_1b_ad ( exch_n1_t   ,exch_xgg1_t    ,exch_xdd1_t,    &        
                               F_capxt     ,F_capyt        ,F_capzt    ,    &
                               exch_c1_t_tr,F_capyt_tr_KEEP,                &
                               F_ni,F_nj,F_nk_t,adx_for_n_t,adx_for_s_t,adx_fro_n_t,adx_fro_s_t)
 
   endif

   deallocate ( field,level,thread  )

   if (.not.adx_lam_L) then
 
       deallocate ( capx2_t_tr,capy2_t_tr,capz2_t_tr  )
       deallocate ( capx2_m_tr,capy2_m_tr,capz2_m_tr  )
       deallocate ( capx2_t_N ,capy2_t_N ,capz2_t_N   )
       deallocate ( capx2_m_N ,capy2_m_N ,capz2_m_N   )

       deallocate (wrka_m)
       deallocate (wrka_t)

   endif

   if (Orh_icn.eq.1) done_L = .true.

 1001 format(' CN = ',i2,' : ADW_TRICUB_AD: Number of Residual Levels                     =',i2)
 1002 format(' CN = ',i2,' : ADW_TRICUB_AD: Number of series       before Residual levels =',i2)
 1003 format(' CN = ',i2,' : ADW_TRICUB_AD: Threads on last series before Residual levels =',i2)

   !---------------------------------------------------------------------
   return
end subroutine adx_main_3_intlag7_ad
