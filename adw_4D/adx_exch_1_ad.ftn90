!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#include "msg.h"
#include "stop_mpi.h"

!/**
subroutine adx_exch_1b_ad (F_x_out  ,F_y_out ,F_z_out,          &     
                           F_x_in   ,F_y_in  ,F_z_in ,          &
                           F_c_out_m,F_y_in_m,                  &
                           F_ni,F_nj,F_nk,adx_for_n,adx_for_s,adx_fro_n,adx_fro_s)
   implicit none

   !@objective ADJ of adx_exch_1b_tl 

   !@arguments
   integer :: F_ni,F_nj,F_nk       
   real,   dimension(F_ni*F_nj*F_nk) :: F_x_out,F_y_out,F_z_out
   integer,dimension(F_ni*F_nj*F_nk) :: F_c_out_m 

   real,   dimension(F_ni*F_nj*F_nk) :: F_x_in,F_y_in,F_z_in 
   real,   dimension(F_ni*F_nj*F_nk) :: F_y_in_m
   integer adx_for_n,adx_for_s,adx_fro_n,adx_fro_s

   !@author M.Tanguay 

   !@revisions
   ! v4_XX - Tanguay M.        - Revision

!**/
#include "adx_nml.cdk"
#include "adx_dims.cdk"
#include "adx_grid.cdk"
!!!#include "adx_poles.cdk"

   integer :: nwrn,nwrs,status
   integer :: ind,n
   integer adx_for_n_K,adx_for_s_K
   integer adx_for_n_R,adx_for_s_R

   !---------------------------------------------------------------------
   call msg(MSG_DEBUG,'adx_exch_1_ad')

   if (adw_exdg_L) then
      if (adx_fro_n+adx_fro_s>0) &
           print '(A,3I8)','BEFORE adx_exch_1_ad EXDG fro:', &
           adx_fro_n, adx_fro_s, adx_fro_n+adx_fro_s
      if (adx_for_n+adx_for_s>0) &
           print '(A,3I8)','BEFORE adx_exch_1_ad EXDG for:', &
           adx_for_n, adx_for_s, adx_for_n+adx_for_s
   endif

   adx_for_n_R = 0
   adx_for_s_R = 0
 
   adx_for_n_K = adx_for_n
   adx_for_s_K = adx_for_s

!  call RPN_COMM_swapns(1,adx_for_n,1,adx_for_s,           &
!       1,nwrn,adx_fro_n,1,nwrs,adx_fro_s,adx_is_period_y, &
!       status)
   call RPN_COMM_swapns(1,adx_fro_n,1,adx_fro_s,               &
        1,nwrn,adx_for_n_R,1,nwrs,adx_for_s_R,adx_is_period_y, &
        status)

   if (.not.adx_is_south) then

      do ind = (adx_for_s_R + adx_for_n_R),(adx_for_n_R + 1),-1

         n = F_c_out_m(ind)

         adx_for_s = ind - adx_for_n_R
         adx_for_n = adx_for_n_R

         if (F_y_in_m(adx_for_n+adx_for_s) <= adx_yy_8(adx_lminy+1)) then

             F_y_in(n) = 0. 

!!!          F_c_out(adx_for_n+adx_for_s) = 0

             F_z_in(n)                    = F_z_out(adx_for_n+adx_for_s) + F_z_in(n)
             F_z_out(adx_for_n+adx_for_s) = 0.
             F_y_in(n)                    = F_y_out(adx_for_n+adx_for_s) + F_y_in(n)
             F_y_out(adx_for_n+adx_for_s) = 0.
             F_x_in(n)                    = F_x_out(adx_for_n+adx_for_s) + F_x_in(n)
             F_x_out(adx_for_n+adx_for_s) = 0.

         endif

      enddo

   endif

   if (.not.adx_is_north) then

      do ind = adx_for_n_R,1,-1
 
         n = F_c_out_m(ind)

         adx_for_n = ind
 
         if (F_y_in_m(adx_for_n) >= adx_yy_8(adx_lmaxy-1)) then
!
             F_y_in(n) = 0.0

!!!          F_c_out(adx_for_n) = 0

             F_z_in(n)          = F_z_out(adx_for_n) + F_z_in(n)
             F_z_out(adx_for_n) = 0.
             F_y_in(n)          = F_y_out(adx_for_n) + F_y_in(n)
             F_y_out(adx_for_n) = 0.
             F_x_in(n)          = F_x_out(adx_for_n) + F_x_in(n)
             F_x_out(adx_for_n) = 0.

         endif

      enddo

   endif

!!!adx_for_a = adx_for_n + adx_for_s
!!!adx_fro_a = adx_fro_n + adx_fro_s
   adx_for_n = adx_for_n_K
   adx_for_s = adx_for_s_K

   call msg(MSG_DEBUG,'adx_exch_1_ad [end]')
   !---------------------------------------------------------------------
   return
end subroutine adx_exch_1b_ad
