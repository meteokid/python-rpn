!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!--------------------------------------------------------------------------
! This is free software, you can use/redistribute/modify it under the terms of
! the EC-RPN License v2 or any later version found (if not provided) at:
! - http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
! - EC-RPN License, 2121 TransCanada, suite 500, Dorval (Qc), CANADA, H9P 1J3
! - service.rpn@ec.gc.ca
! It is distributed WITHOUT ANY WARRANTY of FITNESS FOR ANY PARTICULAR PURPOSE.
!-------------------------------------------------------------------------- 
#include "msg.h"

!/**
module mod_msg
   implicit none
   public :: canWrite, msgLevelMin, msgUnit, msgFormat
   !@author  Stephane Chamberland, 2009-11
!**/
   logical,save :: isInit = .false.
   logical,save :: canWrite = .true.
   integer,save :: msgLevelMin = MSG_INFO
   integer,save :: msgUnit(MSG_NBLEVELS)
   character(len=MSG_MAXLEN),save :: msgFormat(MSG_NBLEVELS) 
end module mod_msg

!/**
subroutine msg_init()
   use mod_msg
   implicit none
   !@author  Stephane Chamberland, 2009-11
   !**/
   !---------------------------------------------------------------------
   if (.not.isInit) then
      isInit = .true.
      msgUnit(MSG_DEBUG)   = MSG_STDERR
      msgUnit(MSG_INFO)    = MSG_STDOUT
      msgUnit(MSG_WARNING) = MSG_STDOUT
      msgUnit(MSG_ERROR)   = MSG_STDERR
      msgUnit(MSG_CRITICAL)= MSG_STDERR

      msgFormat(MSG_DEBUG)   = '("DEBUG: ",a)'
      msgFormat(MSG_INFO)    = '("",a)'
      msgFormat(MSG_WARNING) = '("WARNING: ",a)'
      msgFormat(MSG_ERROR)   = '("ERROR: ",a)'
      msgFormat(MSG_CRITICAL)= '("CRITICAL ERROR: ",a)'
   endif
   !---------------------------------------------------------------------
   return
end subroutine msg_init


!/**
subroutine msg_set_p0only(F_myPE)
   use mod_msg, only: isInit,canWrite
   implicit none
   !@arguments
   integer :: F_myPE
   !@author  Stephane Chamberland, 2009-11
   !**/
   !---------------------------------------------------------------------
   if (.not.isInit) call msg_init()
   canWrite = .false.
   if (F_myPe == 0) canWrite = .true.
   !---------------------------------------------------------------------
   return
end subroutine msg_set_p0only


!/**
subroutine msg_set_can_write(F_canWrite_L)
   use mod_msg, only: isInit,canWrite
   implicit none
   logical :: F_canWrite_L
   !**/
   !---------------------------------------------------------------------
   if (.not.isInit) call msg_init()
   canWrite = F_canWrite_L
   !---------------------------------------------------------------------
   return
end subroutine msg_set_can_write


!/**
subroutine msg_set_minMessageLevel(F_msgLevel)
   use mod_msg, only: isInit,msgLevelMin
   implicit none
   !@arguments
   integer :: F_msgLevel
   !**/
   !---------------------------------------------------------------------
   if (.not.isInit) call msg_init()
   msgLevelMin = max(1,min(F_msgLevel,MSG_NBLEVELS))
   !---------------------------------------------------------------------
   return
end subroutine msg_set_minMessageLevel


!/**
subroutine msg_set_redirect2fileUnit(F_out_or_err,F_fileUnit)
   use mod_msg, only: isInit,msgUnit
   implicit none
   !@arguments
   integer :: F_out_or_err
   integer :: F_fileUnit
   !**/
   integer :: i, i0=1, i1=MSG_NBLEVELS
   !---------------------------------------------------------------------
   if (.not.isInit) call msg_init()
   if (F_out_or_err == MSG_STDERR) then
      i0=MSG_ERROR
   else if (F_out_or_err == MSG_STDOUT) then
      i1=MSG_WARNING
   else
      i0 = F_out_or_err
      i1 = F_out_or_err
   endif
   do i=i0,i1
      msgUnit(i) = F_fileUnit
   enddo
   !---------------------------------------------------------------------
   return
end subroutine msg_set_redirect2fileUnit


!/**
subroutine msg_toall(F_msgLevel,F_Message)
   use mod_msg, only: isInit,canWrite,msgUnit,msgFormat,msgLevelMin
   implicit none
   !@arguments
   integer :: F_msgLevel
   character(len=*) :: F_Message
   !@author  Stephane Chamberland, 2009-11
   !**/
   integer :: msgLevel
   logical :: canWrite_bk
   !---------------------------------------------------------------------
   canWrite_bk = canWrite
   canWrite = .true.
   call msg(F_msgLevel,F_Message)
   canWrite = canWrite_bk
   !---------------------------------------------------------------------
   return
end subroutine msg_toall


!/**
subroutine msg(F_msgLevel,F_Message)
   use mod_msg, only: isInit,canWrite,msgUnit,msgFormat,msgLevelMin
   implicit none
   !@arguments
   integer :: F_msgLevel
   character(len=*) :: F_Message
   !@author  Stephane Chamberland, 2009-11
   !**/
   integer :: msgLevel
   !---------------------------------------------------------------------
   if (.not.isInit) call msg_init()
   if (canWrite .and. F_msgLevel>=msgLevelMin) then
      msgLevel = max(1,min(F_msgLevel,MSG_NBLEVELS))
      write(msgUnit(msgLevel),trim(msgFormat(msgLevel))) trim(F_Message)
      call flush(msgUnit(msgLevel))
   endif
   !---------------------------------------------------------------------
   return
end subroutine msg


!/**
function msg_getUnit(F_msgLevel) result(F_msgUnit)
   use mod_msg, only: isInit,canWrite,msgUnit,msgLevelMin
   implicit none
   !@arguments
   integer :: F_msgLevel
   !@returns
   integer :: F_msgUnit
   !@author  Stephane Chamberland, 2009-11
   !**/
   integer :: msgLevel
   !---------------------------------------------------------------------
   if (.not.isInit) call msg_init()
   F_msgUnit = -1
   if (canWrite .and. F_msgLevel>=msgLevelMin) then
      msgLevel = max(1,min(F_msgLevel,MSG_NBLEVELS))
      F_msgUnit = msgUnit(msgLevel)
   endif
   !---------------------------------------------------------------------
   return
end function msg_getUnit
