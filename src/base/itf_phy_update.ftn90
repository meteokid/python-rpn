!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
!/**
      subroutine itf_phy_update3 (F_apply_L)
      use phy_itf, only: phy_get
      implicit none
#include <arch_specific.hf>

      logical,intent(in) :: F_apply_L

!authors 
!     Desgagne, McTaggart-Cowan, Chamberland -- Spring 2014
!
!revision
! v4_70 - authors          - initial version
   
#include <gmm.hf>
#include "glb_ld.cdk"
#include "grd.cdk"
#include "cstv.cdk"
#include "vt1.cdk"
#include "schm.cdk"
#include "tr3d.cdk"
#include "pw.cdk"

      character(len=GMM_MAXNAMELENGTH) :: trname_S
      integer nelements, init, busidx, istat, i,j,k,n, cnt
      real, dimension(:,:,:), pointer :: data3d,minus,ptr3d
      real, dimension(l_minx:l_maxx,l_miny:l_maxy,G_nk), target :: tdu,tdv
      real pr_p0_dyn(l_minx:l_maxx,l_miny:l_maxy), d_ps(l_ni)
      real, dimension(l_ni,l_nj,G_nk) :: qw_phy,d_qw
!
!-----------------------------------------------------------------
!
   if (F_apply_L) then

      if (Schm_source_ps_L) then
         qw_phy = 0. ; d_qw   = 0.
         do n= 1, Tr3d_ntr
            trname_S = 'TR/'//trim(Tr3d_name_S(n))//':P'
            istat = gmm_get(trim(trname_S),data3d)
            if ( (Tr3d_name_S(n)(1:2).eq.'HU') .or. &
                 (Schm_wload_L.and.Tr3d_wload(n)) )then
               ptr3d => tdu(Grd_lphy_i0:Grd_lphy_in,Grd_lphy_j0:Grd_lphy_jn,1:l_nk)
               if ( phy_get (ptr3d, trim(trname_S), F_npath='V', F_bpath='D', &
                             F_end=(/-1,-1,l_nk/), F_quiet=.true.) .lt. 0 ) cycle
!$omp parallel
!$omp do
               do k=1, l_nk
               do j=1+pil_s,l_nj-pil_n
               do i=1+pil_w,l_ni-pil_e
                  d_qw  (i,j,k)= d_qw  (i,j,k) + (tdu(i,j,k) - data3d(i,j,k))
                  qw_phy(i,j,k)= qw_phy(i,j,k) +  tdu(i,j,k)
                  data3d(i,j,k)= tdu   (i,j,k)
               enddo
               enddo
               enddo 
!$omp enddo
!$omp end parallel
            else
               ptr3d => data3d(Grd_lphy_i0:Grd_lphy_in,Grd_lphy_j0:Grd_lphy_jn,1:l_nk)
               istat = phy_get (ptr3d, trim(trname_S), F_npath='V', F_bpath='D',&
                                           F_end=(/-1,-1,l_nk/), F_quiet=.true. )
            endif
         enddo
      else
         do k= 1, Tr3d_ntr
            trname_S = 'TR/'//trim(Tr3d_name_S(k))//':P'
            istat = gmm_get(trim(trname_S),data3d)
            ptr3d => data3d(Grd_lphy_i0:Grd_lphy_in,Grd_lphy_j0:Grd_lphy_jn,1:l_nk)
            istat = phy_get ( ptr3d, trim(trname_S), F_npath='V', F_bpath='D',&
                              F_end=(/-1,-1,l_nk/), F_quiet=.true. )
         enddo
      endif

      istat = gmm_get (gmmk_ut1_s, ut1)
      istat = gmm_get (gmmk_vt1_s, vt1)
      istat = gmm_get (gmmk_tt1_s, tt1)
      istat = gmm_get (gmmk_pw_uu_copy_s,pw_uu_copy)
      istat = gmm_get (gmmk_pw_vv_copy_s,pw_vv_copy)
      istat = gmm_get (gmmk_pw_tt_copy_s,pw_tt_copy)
      istat = gmm_get (gmmk_pw_uu_plus_s,pw_uu_plus)
      istat = gmm_get (gmmk_pw_vv_plus_s,pw_vv_plus)
      istat = gmm_get (gmmk_pw_tt_plus_s,pw_tt_plus)

      ptr3d => pw_uu_plus(Grd_lphy_i0:Grd_lphy_in,Grd_lphy_j0:Grd_lphy_jn,1:l_nk)
      istat = phy_get(ptr3d,gmmk_pw_uu_plus_s,F_npath='V',F_bpath='D',F_end=(/-1,-1,l_nk/))

      ptr3d => pw_vv_plus(Grd_lphy_i0:Grd_lphy_in,Grd_lphy_j0:Grd_lphy_jn,1:l_nk)
      istat = phy_get(ptr3d,gmmk_pw_vv_plus_s,F_npath='V',F_bpath='D',F_end=(/-1,-1,l_nk/))

      ptr3d => pw_tt_plus(Grd_lphy_i0:Grd_lphy_in,Grd_lphy_j0:Grd_lphy_jn,1:l_nk)
      istat = phy_get(ptr3d,gmmk_pw_tt_plus_s,F_npath='V',F_bpath='D',F_end=(/-1,-1,l_nk/))

!$omp parallel
!$omp do
      do k= 1, G_nk
         tdu(l_minx:l_maxx,l_miny:0,k) = 0. ; tdu(l_minx:l_maxx,l_nj+1:l_maxy,k) = 0.
         tdv(l_minx:l_maxx,l_miny:0,k) = 0. ; tdv(l_minx:l_maxx,l_nj+1:l_maxy,k) = 0.
         tdu(l_minx:0,l_miny:l_maxy,k) = 0. ; tdu(l_ni+1:l_maxx,l_miny:l_maxy,k) = 0.
         tdv(l_minx:0,l_miny:l_maxy,k) = 0. ; tdv(l_ni+1:l_maxx,l_miny:l_maxy,k) = 0.
         tdu(1:l_ni,1:l_nj,k) = (pw_uu_plus(1:l_ni,1:l_nj,k)- &
                                 pw_uu_copy(1:l_ni,1:l_nj,k))
         tdv(1:l_ni,1:l_nj,k) = (pw_VV_plus(1:l_ni,1:l_nj,k)- &
                                 pw_VV_copy(1:l_ni,1:l_nj,k))
         pw_uu_copy(1:l_ni,1:l_nj,k) = tdu(1:l_ni,1:l_nj,k)
         pw_vv_copy(1:l_ni,1:l_nj,k) = tdv(1:l_ni,1:l_nj,k)
         pw_tt_copy(1:l_ni,1:l_nj,k) = (pw_tt_plus(1:l_ni,1:l_nj,k)- &
                                        pw_tt_copy(1:l_ni,1:l_nj,k))
      end do
!$omp enddo
!$omp end parallel

      call itf_phy_uvgridscal ( tdu, tdv, l_minx,l_maxx,l_miny,l_maxy, G_nk, .false. )

!$omp parallel do
      do k= 1, G_nk
         ut1(1:l_niu,:,k) = ut1(1:l_niu,:,k) + tdu(1:l_niu,:,k+1-1)
         vt1(:,1:l_njv,k) = vt1(:,1:l_njv,k) + tdv(:,1:l_njv,k+1-1)
      end do
!$omp end parallel do

      call tt2virt2 (tt1, .true., l_minx,l_maxx,l_miny,l_maxy, G_nk)

      if (Schm_source_ps_L) then

         istat = gmm_get(gmmk_st1_s,st1)
         call calc_pressure ( tdu, tdv, pr_p0_dyn, st1, l_minx,l_maxx, l_miny,l_maxy, l_nk )

      !Estimate source of surface pressure due to fluxes of water:
      !d(ps) = Vertical_Integral [ d(qw)/(1-qw_phy)] d(pi) (Claude Girard)
      !-------------------------------------------------------------------
!$omp parallel private(d_ps) shared(d_qw,qw_phy,tdu,pr_p0_dyn,st1)
!$omp do
         do j=1+pil_s,l_nj-pil_n
            d_ps= 0.
            do k=1,l_nk-1
            do i=1+pil_w,l_ni-pil_e
               d_ps(i)= d_ps(i) + (d_qw(i,j,k)/(1-qw_phy(i,j,k))) * (tdu(i,j,k+1)-tdu(i,j,k))
            enddo
            enddo
            do i=1+pil_w,l_ni-pil_e
               d_ps(i)= d_ps(i) + (d_qw(i,j,l_nk)/(1-qw_phy(i,j,l_nk))) * (pr_p0_dyn(i,j)-tdu(i,j,l_nk))
               st1(i,j)= log( (pr_p0_dyn(i,j) + d_ps(i)) / Cstv_pref_8)
            end do
         enddo
!$omp enddo
!$omp end parallel

         call pw_update_GPW() 

      endif

   else

      cnt = 0
      do k= 1, Tr3d_ntr
         if (trim(Tr3d_name_S(k)) == 'HU' .or.                          &
             any(Tr3d_from_gemntr_S(1:Tr3d_ntr_from_gemntr)==trim(Tr3d_name_S(k))))&
             cycle
         trname_S = 'TR/'//trim(Tr3d_name_S(k))//':P'
         istat = gmm_get(trim(trname_S),data3d)
         ptr3d => data3d(Grd_lphy_i0:Grd_lphy_in,Grd_lphy_j0:Grd_lphy_jn,1:l_nk)
         if ( phy_get ( ptr3d, trim(trname_S), F_npath='V', F_bpath='D',&
                        F_end=(/-1,-1,l_nk/), F_quiet=.true. ) .lt.0 ) cycle
         trname_S = 'TR/'//trim(Tr3d_name_S(k))//':M'
         if (Grd_yinyang_L) &
         call yyg_xchng (data3d, l_minx,l_maxx,l_miny,l_maxy, &
                         G_nk,.true., 'CUBIC')
         
         istat = gmm_get(trim(trname_S),minus)
         minus = data3d
         cnt   = cnt + 1
      end do

      if (cnt.gt.0) then
         istat = gmm_get(gmmk_tt1_s, tt1)
         call tt2virt2 (tt1, .true., l_minx,l_maxx,l_miny,l_maxy,l_nk)
         if (Grd_yinyang_L) then
            call yyg_xchng (tt1, l_minx,l_maxx,l_miny,l_maxy, &
                            G_nk, .false., 'CUBIC')
            call pw_update_T
         endif
         call pw_update_GPW
      endif

   endif
!
!-----------------------------------------------------------------
!
   return
   end subroutine itf_phy_update3
