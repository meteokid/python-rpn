!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "msg.h"
#include "stop_mpi.h"
!/**
subroutine adx_setint_lin_noptr()
   implicit none
   !---------------------------------------------------------------------
   call stop_mpi(STOP_ERROR,'adx_setint_lin_noptr','called a stub')
   !---------------------------------------------------------------------
   return
end subroutine adx_setint_lin_noptr

!/**
subroutine adx_setint_lin_noptr1(F_n, &
     F_capx, F_capy, F_capz, &
     F_x,    F_y,   F_z,&
     F_lcx, F_bsx_8, F_dix_8, &
     F_lcy, F_bsy_8, F_diy_8,&
     F_lcz, F_bsz_8, F_diz_8,&
     i0,in,j0,jn,k0,F_nk, F_num,F_nkm)
   implicit none
   !@objective sets localization and interpolation parameters
   !@arguments
   integer :: F_num           !I, nb points of computations
   integer :: F_nk,F_nkm      !I, nb levels
   integer :: i0,in,j0,jn,k0  !I, scope of the operator
   real,dimension(F_num) :: &
        F_x, F_y, F_z, &       !I, upstream position coor
        F_capz, F_capy, F_capx !O, x precomputed displacements and interp terms
   integer,dimension(F_num) :: &
        F_n                    !O, pos in the 3D volume of interpolation boxes

   integer,dimension(*) :: F_lcx,F_lcy,F_lcz
   real*8, dimension(*) :: F_bsx_8,F_bsy_8
   real*8, dimension(*) :: F_dix_8,F_diy_8
   real*8, dimension(0:2*F_nkm)    :: F_bsz_8
   real*8, dimension(-1:2*F_nkm+2) :: F_diz_8


   !@author  alain patoine
   !@revisions
   ! v3_00 - Desgagne & Lee    - Lam configuration
   ! v3_03 - Lee V. (from IBM) - added min,max on index calcs
   ! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
   ! v3_20 - Tanguay M.        - Correction for haloy.gt.2
   ! v4_10 - Plante A.         - Use super winds for thermo
   ! v4_14 - Plante A.         - Scope on vertical loop 
   !@description
   !Notes on computations of positions in the 3D volume of interpolation 
   !                   boxes for adx_trilin or adx_tricub
   !
   !  The same algorithm applies to finding the positions in the interpolation
   !  box for each X,Y,Z upstream position.
   !  For example, say a given F_x(i), we try to find "ii" on advection
   !  axis X (adx_xg_8) where F_x(i) is closest to the gridpoint adx_xg_8(ii) 
   !  and adx_xg_8(ii) must be less than or equal to F_x(i).
   !  The 3-D positions (ii,jj,kk) are stored in F_n, a folded 3-D array.
!**/
#include "adx_dims.cdk"
#include "adx_grid.cdk"
#include "adx_interp.cdk"
   integer :: ii, jj, kk, ij, i, j, k, n
   real*8  :: prd_8, prdt_8, p_z00_8
   !---------------------------------------------------------------------
   p_z00_8 = adx_verZ_8%t(1)

!$omp parallel private(n,prd_8,ii,prdt_8,jj,kk,ij)
!$omp do
   do k=k0,F_nk
      do j=j0,jn
         do i=i0,in
            n = (k-1)*adx_mlnij + ((j-1)*adx_mlni) + i
            prd_8 = dble(F_x(n))
            ii = (prd_8 - adx_x00_8) * adx_ovdx_8
            ii = F_lcx(ii+1) + 1

            ii = max(2,ii)
            ii = min(ii,adx_gni+2*adx_halox-2)

            prdt_8 = prd_8 - F_bsx_8(ii)
            if (prdt_8 < 0.0) then
               ii = max(2,ii - 1)
               prdt_8 = prd_8 - F_bsx_8(ii)
            endif
            F_capx(n) = prdt_8 * F_dix_8(ii)

            prd_8 = dble(F_y(n))
            jj = (prd_8 - adx_y00_8) * adx_ovdy_8
            jj = F_lcy(jj+1) + 1

            jj = max(adx_haloy,jj)
            jj = min(jj,adx_gnj+adx_haloy)

            prdt_8 = prd_8 - F_bsy_8(jj)
            if (prdt_8 < 0.0) then
               jj = max(adx_haloy,jj - 1)
               prdt_8 = prd_8 - F_bsy_8(jj)
            endif
            F_capy(n) = prdt_8 * F_diy_8(jj)

            prd_8 = dble(F_z(n))
            kk = (prd_8 - p_z00_8) * adx_ovdz_8
            kk = F_lcz(kk+1)
            prd_8 = prd_8 - F_bsz_8(kk)
            if (prd_8 < 0.0) kk = kk - 1
            F_capz(n) = prd_8 * F_diz_8(kk)
            if (prd_8 < 0.0) F_capz(n) = 1.0 + F_capz(n)
            ij = (jj-adx_int_j_off-1)*adx_nit + (ii-adx_int_i_off)
            F_n(n) = kk*adx_nijag + ij
         enddo
      enddo
   enddo
!$omp enddo
!$omp end parallel
   !---------------------------------------------------------------------
   return
end subroutine adx_setint_lin_noptr1
