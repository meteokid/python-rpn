!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "msg.h"
#include "stop_mpi.h"

subroutine adx_main_3_intlag5()
   call stop_mpi(STOP_ERROR,'adx_main_3_intlag5','called a stub')
   return
end subroutine adx_main_3_intlag5

!/**
subroutine adx_main_3_intlag6(F_px, F_py, F_pz, F_fields_list, &
     F_fields_type_L, F_nfields, F_is_mom_L, F_doAdwStat_L, F_ni,F_nj,F_nk)
   implicit none
   !@objective Interpolation of rhs
   !@arguments
   logical :: F_is_mom_L     !I, momentum level if .true. (thermo if not)
   logical :: F_doAdwStat_L  !I, compute stats if .true.
   integer :: F_ni,F_nj,F_nk !I, pos array dims
   integer :: F_nfields      !I, nb of fields to advect
   logical, dimension(2,F_nfields)         :: F_fields_type_L !I, fields type
   character(len=8), dimension(2,F_nfields):: F_fields_list   !I, gmm flds lbls
   real, dimension(F_ni,F_nj,F_nk) :: F_px, F_py, F_pz !I, upstream positions at t1
   !@author alain patoine
   !@revisions
   ! v2_31 - Desgagne & Tanguay  - removed stkmemw, introduce tracers
   ! v2_31                       - tracers not monotone if V4dg_conf.ne.0
   ! v3_00 - Desgagne & Lee      - Lam configuration
   ! v3_02 - Tanguay             - Restore tracers monotone if V4dg_conf.ne.0 
   ! v3_02 - Lee V.              - revert adx_exch_1 for GLB only, 
   ! v3_02                         added adx_ckbd_lam,adx_cfl_lam for LAM only
   ! v3_03 - Tanguay M.          - stop if adx_exch_1 is activated when 4D-Var
   ! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
   ! v3_11 - Gravel S.           - introduce key adx_mono_L 
   ! v3_20 - Gravel & Valin & Tanguay - Lagrange 3D
   ! v3_20 - Tanguay M.          - Improve alarm when points outside advection grid
   ! v3_20 - Dugas B.            - correct calculation for LAM when Glb_pil gt 7
   ! v3_21 - Desgagne M.         - if  Lagrange 3D, call adx_main_3_intlag
   ! v4_04 - Tanguay M.          - Staggered version TL/AD
   ! v4_05 - Lepine M.           - VMM replacement with GMM
   ! v1_10 - Plante A.           - Thermo upstream positions
   !**/
#include "adx_nml.cdk"
#include "adx_dims.cdk"
#include "adx_poles.cdk"
#include "adx_interp.cdk"
!!$   include "v4dg.inc" !TODO: remove this
   integer, parameter :: FIELD_IN  = 1
   integer, parameter :: FIELD_OUT = 2
   integer, parameter :: IS_MOM    = 1
   integer, parameter :: IS_WIND   = 2

   character(len=1) :: level_type_S

   integer :: n, nijkt,i,j,k
   integer :: i0,j0,in,jn, istat
   real, dimension(F_ni,F_nj,F_nk) :: pos_x, pos_y, pos_z
   real,dimension(3) :: minv,maxv

   integer, external :: adx_ckbd3
   !---------------------------------------------------------------------
   call msg(MSG_DEBUG, 'adx_main_3_intlag')

   nijkt  = F_ni * F_nj * adx_lnkt !TODO: Check if can use F_nk = nkm or nkt
   allocate( &
        adx_capx1(nijkt), &
        adx_capy1(nijkt), &
        adx_capz1(nijkt), &
        adx_n1(nijkt), &
        adx_xdd1(nijkt), &
        adx_xgg1(nijkt), &
        adx_ydd1(nijkt), &
        adx_ygg1(nijkt), &
        adx_c1(nijkt), &
        stat=istat)
   call handle_error_l(istat==0,'adx_main_3_intlag','Problem allocating mem')

   call adx_get_ij0n(i0,in,j0,jn)

   level_type_S = 't'
   if (F_is_mom_L) level_type_S = 'm'


!$omp parallel do private(n)
   do k = 1, F_nk
      do j = j0, jn
         do i = i0, in
            pos_x(i,j,k) =  F_px(i,j,k)
            pos_y(i,j,k) =  F_py(i,j,k)
            pos_z(i,j,k) =  F_pz(i,j,k)
         enddo
      enddo
   enddo
!$omp end parallel do

   IF_LAM: if (adx_lam_L) then

      if (F_doAdwStat_L) then
         call adx_cfl_lam2(pos_x, pos_y, pos_z,  &
              i0, in, j0, jn, F_ni,F_nj,F_nk, level_type_S)
      endif
      call adx_cliptraj2(pos_x, pos_y, i0, in, j0, jn, F_ni,F_nj,F_nk,  &
           'INTERP '//trim(level_type_S))

   else !IF_LAM

      call adx_exch_1b(adx_n1, adx_xgg1, adx_xdd1, adx_c1, &
           pos_x, pos_y, pos_z, F_ni,F_nj,F_nk)

      allocate( adx_capx2(max(1,adx_fro_a)), &
           adx_capy2(max(1,adx_fro_a)), &
           adx_capz2(max(1,adx_fro_a)) )

      !TODO: replace this by a single call v4d_chk_nbpts(adx_fro_a)
!!$         if (V4dg_conf .ne. 0) then
!!$            istat = 0
!!$            if (adx_fro_a > 0) istat = -1
!!$            call handle_error(istat,'adx_main_3_prep', &
!!$                 'TLM-ADJ NOT done: INCREASE HALO')
!!$         endif

      call adx_exch_2(adx_capx2, adx_capy2, adx_capz2, &
           adx_n1, adx_xgg1, adx_xdd1, &
           adx_fro_n, adx_fro_s, adx_fro_a, &
           adx_for_n, adx_for_s, adx_for_a, 3)

      istat = 1
      if (adx_fro_a>0 .and. adw_ckbd_L) then
         istat = adx_ckbd3(adx_capy2,adx_fro_n,adx_fro_s)
      endif
      !TODO: uncomment this: call handle_error(istat,'adx_main_3_intlag','Error raised in adx_ckbd')

   endif IF_LAM


   !- Keep positions in CAP fields
!$omp parallel private(n)
!$omp do
   do k=1,F_nk
      do j=j0,jn
         do i=i0,in
            n = (k-1)*F_ni*F_nj + (j-1)*F_ni + i
            adx_capx1(n) = pos_x(i,j,k)
            adx_capy1(n) = pos_y(i,j,k)
            adx_capz1(n) = pos_z(i,j,k)
         end do
      end do
   end do
!$omp enddo
!$omp end parallel

   if (adw_stats_L) then
      call glbstat2 (adx_capx1, 'cpx1', 'adx_3',  &
           1,F_ni, 1,F_nj, 1,adx_lnkt, &
           i0,in,j0,jn,1,F_nk)
      call glbstat2 (adx_capy1, 'cpy1', 'adx_3',  &
           1,F_ni, 1,F_nj, 1,adx_lnkt, &
           i0,in,j0,jn,1,F_nk)
      call glbstat2 (adx_capz1, 'cpz1', 'adx_3',  &
           1,F_ni, 1,F_nj, 1,adx_lnkt, &
           i0,in,j0,jn,1,F_nk)
   endif

   do n = 1, F_nfields
      if (F_fields_type_L(IS_MOM,n) .neqv. F_is_mom_L) cycle
      call adx_interp_gmm4( &
           F_fields_list(FIELD_OUT,n), F_fields_list(FIELD_IN,n), & 
           F_fields_type_L(IS_WIND,n), F_nk, &
           i0,in,j0,jn,level_type_S)
   end do

   if (.not.adx_lam_L) then
      deallocate(adx_capx2, adx_capy2, adx_capz2)
   endif

   deallocate( &
        adx_capx1, adx_capy1, adx_capz1, adx_n1, adx_xdd1, adx_xgg1, &
        adx_ydd1, adx_ygg1, adx_c1)

   call msg(MSG_DEBUG, 'adx_main_3_intlag [end]')
   !---------------------------------------------------------------------
   return
end subroutine adx_main_3_intlag6
