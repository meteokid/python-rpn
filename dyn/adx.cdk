! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
#include "type.cdk"

#if defined (DOC)
*
***comdeck adx.cdk
*______________________________________________________________________
*                                                                      |
* GRIDS USED IN THE ADVECTION CONTEXT                                  |
*                                                                      |
* revision                                                             |
* v3_20 - Gravel & Valin & Tanguay - Lagrange 3D                       | 
*                                    and Optimized SETINT/TRILIN       |
* v3_30 - McTaggart-Cowan R.	   - Add adx_interp_type options       |
*______________________________________________________________________|
*                                                                      |
* 3 different grids are refered to throughout the advection process:   |
*                                                                      |
* GLOBAL GRID:    Global domain                                        |
*                                                                      |
* ADVECTION GRID: In the general case, the tiles adjacent to the poles |
*                 would have an advection source grid periodic in x.   |
*                 For the other tiles, the advection grid would be the |
*                 same as the local grid.                              |
*                                                                      |
* LOCAL GRID:     Local domain                                         |
*                                                                      |
* All of these grids could include halos or not                        |
*______________________________________________________________________|
*                                                                      |
* VARIABLES FOR ADVECTION                                              |
*______________________________________________________________________|
*              |                                                       |
* NAME         | DESCRIPTION                                           |
*--------------|-------------------------------------------------------|
* adx_nkbz_L   | switch: .true. : no knot boundary condition for       |
*              |                  vertical interpolation               |
* adx_exdg_L   | switch: .true. : print diagnostics on the number of   |
*              |                  upstream positions exchanged among   |
*              |                  processors                           |
* adx_ckbd_L   | switch: .true. : check if upstream points from north  |
*              |                  and south pe's for which an interpo- |
*              |                  lation is requested are inside own   |
*              |                  advection source grid                |
* adx_mono_L   | switch: .true. : advection of tracers is monotonic    |
* adx_interp_type interpolation scheme for back-trajectories ("cubic"):|
*	       |  "cubic"         Lagrangian(h)/cubic(v) interpolation |
*	       |  "lag3d"         tri-Lagrangian 3D interpolation      |
*	       |  "lag3d_trunc "  truncated Lagrangian 3D interpolation|
* adx_nosetint_L switch: .true. : no setint for TRILIN (done inside)   |
* adx_hor_L    | switch: .true. : update horizontal positions          |
*              |                  for Optimized SETINT/TRILIN          |
* adx_ver_L    | switch: .true. : update vertical positions            |
*              |                  for Optimized SETINT/TRILIN          |
*----------------------------------------------------------------------|
* GRIDS SIZE SPECIFICATIONS                                            |
*----------------------------------------------------------------------|
* adx_halox    | advection specific halo in x                          |
* adx_haloy    | advection specific halo in y                          |
*              |                                                       |
* adx_nit      | \ total number of points in x,y direction in          |
* adx_njt      | / advection grid (including halos)                    |
*              |                                                       |
* adx_nic      | \ number of points in x,y direction in central        |
* adx_njc      | / portion of advection grid (excluding halos)         |
*              |                                                       |
* adx_int_i_off| offset global-advection grids in x                    |
* adx_int_j_off| offset global-advection grids in y                    |
*----------------------------------------------------------------------|
* GRIDS COORDINATES SPECIFICATIONS AND DEPENDENT PARAM                 |
*----------------------------------------------------------------------|
* adx_xg_8     | global grid x coordinates                             |
* adx_yg_8     | global grid y coordinates                             |
* adx_wx_8     | global grid weights proportional grid distances       |
* adx_xx_8     | local grid x coordinates                              |
* adx_cx_8     | local grid cos of x                                   |
* adx_sx_8     | local grid sin of x                                   |
* adx_yy_8     | local grid x coordinates                              |
* adx_cy_8     | local grid cos of y                                   |
* adx_sy_8     | local grid sin of y                                   |
* adx_cx2d_8   | local grid 2D array filled with cos of x              |
* adx_sx2d_8   | local grid 2D array filled with sin of x              |
* adx_cy2d_8   | local grid 2D array filled with cos of y              |
* adx_sy2d_8   | local grid 2D array filled with sin of y              |
*----------------------------------------------------------------------|
* UPSTREAM POSITIONS EXCHANGE PARAMETERS                               |
*----------------------------------------------------------------------|
* adx_for_n    | number of information points for  north neighbor      |
* adx_for_s    | number of information points for  south neighbor      |
* adx_for_a    | number of information points for  all   neighbor      |
* adx_fro_n    | number of information points from north neighbor      |
* adx_fro_s    | number of information points from south neighbor      |
* adx_fro_a    | number of information points from all   neighbor      |
*----------------------------------------------------------------------|
* LOCALISATION PARAMETERS                                              |
*----------------------------------------------------------------------|
* adx_ovdx_8   | \                                                     |
* adx_ovdy_8   |   inverse of shortest grid distance in x,y,z          |
* adx_ovdz_8   | /                                                     |
*              |                                                       |
* adx_x00_8    | \                                                     |
* adx_y00_8    | / reference coordinate for localisation in x,y,z      |
*              |                                                       |
* adx_lcx      | \                                                     |
* adx_lcy      |   fine grid to variable grid equivalence used for     |
* adx_lcz      | / fast localisation                                   |
*              |                                                       |
*----------------------------------------------------------------------|
* PRECOMPUTED INTERPOLATION PARAMETERS                                 |
*----------------------------------------------------------------------|
* adx_iln      | for interpolation of grid reflexion across the pole   |
* adx_lnr_8    | for interpolation of grid reflexion across the pole   |
* adx_bsx_8    | \                                                     |
* adx_dlx_8    |  |                                                    |
* adx_dix_8    |  |                                                    |
* adx_bsy_8    |  |                                                    |
* adx_dly_8    |  |                                                    |
* adx_diy_8    |   \ precomputed interpolation parameters along x,y,z  |
* adx_bsz_8    |   /                                                   |
* adx_dlz_8    |  |                                                    |
* adx_diz_8    |  |                                                    |
* adx_dbz_8    |  |                                                    |
* adx_qzz_8    |  |                                                    |
* adx_qzi_8    |  |                                                    |
* adx_xbc_8    |  | Coefficients for linear interpolation in x,y and z |
* adx_ybc_8    |  |                                                    |
* adx_zbc_8    |  |                                                    |
* adx_xabcd_8  |  | Coefficients for Lagrange 3D in x,y and z          |
* adx_xbacd_8  |  |                                                    |
* adx_xcabd_8  |  |                                                    |
* adx_xdabc_8  |  |                                                    |
* adx_yabcd_8  |  |                                                    |
* adx_ybacd_8  |  |                                                    |
* adx_ycabd_8  |  |                                                    |
* adx_ydabc_8  |  |                                                    |
* adx_zabcd_8  |  |                                                    |
* adx_zbacd_8  |  |                                                    |
* adx_zcabd_8  |  |                                                    |
* adx_zdabc_8  | /                                                     |
* adx_Fn_I     | Localisation indices for Optimized SETINT/TRILIN      |
*______________________________________________________________________
*                                                                      |
*  VARIABLES ASSOCIATED WITH CFL COMPUTATION FOR LAM (adx_CFL_LAM)     |
*______________________________________________________________________|
*                    |                                                 |
* NAME               | DESCRIPTION                                     |
*--------------------|-------------------------------------------------|
* adx_cfl(i,j,PE)    | i = the max value of the following:             |
*                    |     1: max cfl value found                      |
*                    |     2: the "I" grid point of max cfl found      |
*                    |     3: the "J" grid point of max cfl found      |
*                    |     4: the "K" grid point of max cfl found      |
*                    | j = the type of max cfl computed                |
*                    |     1: the largest horizontal courrant number   |
*                    |     2: the largest vertical   courrant number   |
*                    |     3: the largest 3-dimensional courrant number|
*                    |PE = the number of the PE (processor)            |
*                    |     The overall maximum cfl value of the entire |
*                    |     grid will be placed in PE 1 before printing |
* adx_trunc(i)       | i = the boundary where the trajectories were    |
*                    |     truncated and a count is placed here        |
*                    |     truncated and a count is placed here        |
*                    |     1: north                                    |
*                    |     2: south                                    |
*                    |     3: east                                     |
*                    |     4: west                                     |
*______________________________________________________________________|
*
#endif
*
      logical            adx_nkbz_L, adx_exdg_L, adx_ckbd_L, adx_trunc_traj_L,
     %                   adx_mono_L,adx_nosetint_L,adx_hor_L,adx_ver_L
*
      integer            adx_halox, adx_haloy,
     %                   adx_nic, adx_nit, adx_njc, adx_njt,
     %                   adx_int_i_off, adx_int_j_off,
     %                   adx_for_n, adx_for_s, adx_for_a,
     %                   adx_fro_n, adx_fro_s, adx_fro_a,
     %                   adx_trunc(4), adx_cfl_i(3,3)
*
      real*8             adx_ovdx_8, adx_ovdy_8, adx_ovdz_8, 
     %                   adx_x00_8,  adx_y00_8,  adx_cfl_8(3)
*
      character(len=64) :: adx_interp_type_S
*
      MARK_COMMON_BEG (adx_c)
      common / adx_c  /  adx_interp_type_S
      MARK_COMMON_END (adx_c)
*
      MARK_COMMON_BEG (adx_l)
      common / adx_l  /  adx_nkbz_L,adx_exdg_L,adx_nosetint_L,
     %                   adx_ckbd_L,adx_mono_L,adx_trunc_traj_L,
     %                   adx_hor_L, adx_ver_L
      MARK_COMMON_END (adx_l)
*
      MARK_COMMON_BEG (adx_ia)
      common / adx_ia /  adx_halox, adx_haloy
      MARK_COMMON_END (adx_ia)
*
      type (vertical_i)  adx_lcz

      common / adx_ib /  adx_nic, adx_nit, adx_njc, adx_njt,
     %                   adx_int_i_off, adx_int_j_off,
     %                   adx_for_n, adx_for_s, adx_for_a,
     %                   adx_fro_n, adx_fro_s, adx_fro_a,
     %                   adx_trunc, adx_cfl_i, adx_lcz
*
      type (vertical_8)  adx_bsz_8
      type (vertical_8)  adx_dlz_8
      type (vertical_8)  adx_diz_8
      type (vertical_8)  adx_dbz_8
      type (vertical_8)  adx_qzz_8
      type (vertical_8)  adx_qzi_8

      type (vertical_8)  adx_zbc_8
      type (vertical_8)  adx_zabcd_8
      type (vertical_8)  adx_zbacd_8
      type (vertical_8)  adx_zcabd_8
      type (vertical_8)  adx_zdabc_8
!
      common / adx_r8 /  adx_ovdx_8, adx_ovdy_8, adx_ovdz_8, 
     %                   adx_x00_8,  adx_y00_8,  adx_cfl_8,
     %                   adx_bsz_8,  adx_dlz_8,  adx_diz_8,
     %                   adx_dbz_8,  adx_qzz_8,  adx_qzi_8,
     %                   adx_zbc_8,  adx_zabcd_8,adx_zbacd_8,
     %                   adx_zcabd_8,adx_zdabc_8
*
      DCL_DYNVAR(adx,   xg_8,    real*8 , (*))
      DCL_DYNVAR(adx,   yg_8,    real*8 , (*))
      DCL_DYNVAR(adx,   wx_8,    real*8 , (*))
      DCL_DYNVAR(adx,   xx_8,    real*8 , (*))
      DCL_DYNVAR(adx,   cx_8,    real*8 , (*))
      DCL_DYNVAR(adx,   sx_8,    real*8 , (*))
      DCL_DYNVAR(adx,   yy_8,    real*8 , (*))
      DCL_DYNVAR(adx,   cy_8,    real*8 , (*))
      DCL_DYNVAR(adx,   sy_8,    real*8 , (*))
      DCL_DYNVAR(adx, cx2d_8,    real*8 , (*))
      DCL_DYNVAR(adx, sx2d_8,    real*8 , (*))
      DCL_DYNVAR(adx, cy2d_8,    real*8 , (*))
      DCL_DYNVAR(adx, sy2d_8,    real*8 , (*))
      DCL_DYNVAR(adx,    lcx,    integer, (*))
      DCL_DYNVAR(adx,    lcy,    integer, (*))
*
      DCL_DYNVAR(adx,  fn_I ,    integer, (*))
*
      DCL_DYNVAR(adx,  bsx_8,    real*8 , (*))
      DCL_DYNVAR(adx,  dlx_8,    real*8 , (*))
      DCL_DYNVAR(adx,  dix_8,    real*8 , (*))
      DCL_DYNVAR(adx,  bsy_8,    real*8 , (*))
      DCL_DYNVAR(adx,  dly_8,    real*8 , (*))
      DCL_DYNVAR(adx,  diy_8,    real*8 , (*))
*
      DCL_DYNVAR(adx,  iln  ,    integer, (*))
      DCL_DYNVAR(adx,  lnr_8,    real*8 , (*))
*
*
      DCL_DYNVAR(adx,  xbc_8,    real*8 , (*))
      DCL_DYNVAR(adx,  ybc_8,    real*8 , (*))
*
      DCL_DYNVAR(adx,xabcd_8,    real*8 , (*))
      DCL_DYNVAR(adx,xbacd_8,    real*8 , (*))
      DCL_DYNVAR(adx,xcabd_8,    real*8 , (*))
      DCL_DYNVAR(adx,xdabc_8,    real*8 , (*))
      DCL_DYNVAR(adx,yabcd_8,    real*8 , (*))
      DCL_DYNVAR(adx,ybacd_8,    real*8 , (*))
      DCL_DYNVAR(adx,ycabd_8,    real*8 , (*))
      DCL_DYNVAR(adx,ydabc_8,    real*8 , (*))
*
      DCL_DYNVAR(adx,  capx1,    real   , (*))
      DCL_DYNVAR(adx,  capy1,    real   , (*))
      DCL_DYNVAR(adx,  capz1,    real   , (*))
      DCL_DYNVAR(adx,   xdd1,    real   , (*))
      DCL_DYNVAR(adx,   ydd1,    real   , (*))
      DCL_DYNVAR(adx,   xgg1,    real   , (*))
      DCL_DYNVAR(adx,   ygg1,    real   , (*))
      DCL_DYNVAR(adx,    cz1,    real   , (*))
      DCL_DYNVAR(adx,     n1,    real   , (*))
      DCL_DYNVAR(adx,     c1,    real   , (*))
      DCL_DYNVAR(adx,   wrkb,    real   , (*))
      DCL_DYNVAR(adx,   wrkc,    real   , (*))
      DCL_DYNVAR(adx,  capx2,    real   , (*))
      DCL_DYNVAR(adx,  capy2,    real   , (*))
      DCL_DYNVAR(adx,  capz2,    real   , (*))
      DCL_DYNVAR(adx,   xdd2,    real   , (*))
      DCL_DYNVAR(adx,   ydd2,    real   , (*))
      DCL_DYNVAR(adx,   xgg2,    real   , (*))
      DCL_DYNVAR(adx,   ygg2,    real   , (*))
      DCL_DYNVAR(adx,    cz2,    real   , (*))
      DCL_DYNVAR(adx,     n2,    real   , (*))
      DCL_DYNVAR(adx,   wrka,    real   , (*))
