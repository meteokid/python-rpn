module Grid_Descriptors

  implicit none
  private

  ! Public methods
  public :: grid_descriptor                     !grid descriptor structure
  public :: gd_new                              !class constructor
  public :: gd_get                              !get instance variable value
  public :: gd_put                              !set instance variable value
  public :: gd_print                            !dump plain-text contents of instance
  public :: gd_write                            !write coordinates to a file
  public :: gd_levels                           !compute physical level information
  public :: gd_position                         !compute horizontal position information

  ! Public class variables
  integer, parameter, public :: GD_LEN_NAME=4   !maximum length of a variable name in the data file
  integer, parameter, public :: GD_OK=0         !method return value on success
  integer, parameter, public :: GD_ERROR=-1     !method return value on error
  real, parameter, public :: GD_MISSING=-9999.  !missing value returned for invalid entries

  ! Private class variables
  integer, parameter :: STDERR=0                !STDERR output unit
  integer, parameter :: LONG_STRING=1024        !number of characters in a long string
  character(len=GD_LEN_NAME) :: XNAME='>>'      !name of the x-direction coodinate
  character(len=GD_LEN_NAME) :: YNAME='^^'      !name of the y-direction coodinate
  character(len=GD_LEN_NAME) :: ZNAME='!!'      !name of the vertical coodinate
  integer, parameter :: MAX_VKIND=100           !maximum number of 'kind' (used in error check)
  integer, parameter :: KEY_LENGTH=4            !length of key string considered for get/put operations
  integer, parameter :: DIR_LENGTH=1            !length of directional identifier for get/put operations
  integer, parameter :: MAX_DESC_REC=10000      !maximum number of descriptor records in a single file
  character(len=1), dimension(3), parameter :: MATCH_GRTYP=(/'X','Y','Z'/) !grid types with ip1,2 to ig1,2 mapping

  ! Validity table
  integer, dimension(3), parameter :: ptop_8_valid=(/1002,5001,5002/)
  integer, dimension(2), parameter :: pref_8_valid=(/5001,5002/)
  integer, dimension(2), parameter :: rcoef1_8_valid=(/5001,5002/)
  integer, dimension(1), parameter :: rcoef2_8_valid=(/5002/)
  integer, dimension(4), parameter :: a_m_8_valid=(/1002,2001,5001,5002/)
  integer, dimension(4), parameter :: b_m_8_valid=(/1002,2001,5001,5002/)
  integer, dimension(1), parameter :: a_t_8_valid=(/5002/)
  integer, dimension(1), parameter :: b_t_8_valid=(/5002/)
  integer, dimension(4), parameter :: ip1_m_valid=(/1002,2001,5001,5002/)
  integer, dimension(1), parameter :: ip1_t_valid=(/5002/)
  integer, dimension(3), parameter :: ref_name_valid=(/1002,5001,5002/)

  ! FST file record structure
  type FSTD
     private
     integer :: ip3,ig1,ig2,ig3,ig4,dateo,deet,npas,datyp,nbits
     character(len=1) :: grtyp
     character(len=2) :: typvar
     character(len=4) :: nomvar
     character(len=12) :: etiket
  end type FSTD
  type FSTD_ext
     private
     integer :: ig1,ig2,ig3,ig4,dateo,deet,npas,datyp,nbits,ni,nj,nk
     integer :: ip1,ip2,ip3,swa,lng,dltf,ubc,extra1,extra2,extra3,datev
     character(len=1) :: grtyp
     character(len=2) :: typvar
     character(len=4) :: nomvar
     character(len=12) :: etiket
  end type FSTD_ext

  ! Horizontal coordinate structure
  type hcoord
     private
     type(FSTD) :: rec
     integer :: hcode
  end type hcoord

  ! Vertical coordinate structure
  type vcoord
     private
     character(len=GD_LEN_NAME) :: ref_name
     integer, dimension(:), pointer :: ip1_m=>null(),ip1_t=>null()
     real(kind=8), dimension(:), pointer :: a_m_8=>null(),b_m_8=>null(),a_t_8=>null(),b_t_8=>null()
     real(kind=8), dimension(:,:,:), pointer :: table=>null()
     real*8 :: ptop_8,pref_8,rcoef1_8,rcoef2_8
     type(FSTD) :: rec
     integer :: vcode,kind,version
  end type vcoord

  ! Combined coordinate structure
  type grid_descriptor
     private
     type(hcoord) :: xx,yy                      !x,y direction coordinate descriptors
     type(vcoord) :: zz                         !vertical coordinate descriptor
     integer :: ip1=0,ip2=0                     !ip1,2 values given to the 3D descriptor
     integer :: unit                            !file unit associated with this 3D descriptor
     logical :: match_ipig                      !do ip/ig matching for records
  end type grid_descriptor

  interface gd_new
     module procedure new_read
     module procedure new_build_vert
  end interface

  interface gd_get
     module procedure get_int
     module procedure get_int_1d
     module procedure get_real8
     module procedure get_real8_1d
     module procedure get_real8_3d
     module procedure get_char
  end interface

  interface gd_put
     module procedure put_int
     module procedure put_int_1d
     module procedure put_real8
     module procedure put_real8_1d
     module procedure put_real8_3d
     module procedure put_char
  end interface

  interface gd_print
     module procedure print_desc
  end interface

  interface gd_write
     module procedure write_desc
  end interface

  interface gd_levels
     module procedure levels_toplevel
     module procedure levels_readref
     module procedure levels_withref
     module procedure levels_withref_prof
  end interface

  interface gd_position
     module procedure position
  end interface

  interface size_ok
     module procedure size_ok_i1d
     module procedure size_ok_r81d
     module procedure size_ok_r83d
  end interface

  interface set_vcode
     module procedure set_vcode_d
     module procedure set_vcode_i
  end interface

  interface get_allocate
     module procedure get_allocate_i1d
     module procedure get_allocate_r81d
     module procedure get_allocate_r83d
  end interface

  interface desc_direction_getput
     module procedure desc_direction_getput_int
     module procedure desc_direction_getput_char
  end interface

  interface fstd_init
     module procedure fstd_init_v
  end interface

  interface flip_transfer
     module procedure flip_transfer_r8
     module procedure flip_transfer_char
  end interface

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Class constructor

   integer function new_read(self,unit,format,ip1,ip2) result(status)
      ! Coordinate constructor - read from a file and initialize instance
      type(grid_descriptor), intent(out) :: self  !Descriptor instance
      integer, intent(in) :: unit                 !File unit to read descriptor information from
      character(len=*), intent(in) :: format      !File format ('fst' or 'bin')
      integer, intent(in) :: ip1,ip2              !ip1,2 values of the desired descriptors

      ! Internal variables
      integer :: istat,key,error,kind,version,count,i
      integer :: fstinf,fstinl,fstluk,fstprm,ni,nj,nk,swa,lng,ubc,dltf,extra1,extra2,extra3
      integer, dimension(MAX_DESC_REC) :: keyList
      type(FSTD_ext) :: var
      real*8, dimension(:,:,:), allocatable :: l_table

      ! Set error status
      status = GD_ERROR

      ! Set instance variables
      self%unit = unit
      if (any((/ip1,ip2/) < 0)) then
         self%match_ipig = .false.
      else
         self%match_ipig = .true.
      endif

      ! Construct horizontal descriptors
      self%xx%rec%nomvar = '>>'
      self%yy%rec%nomvar = '^^'
      self%xx%hcode = -1
      self%yy%hcode = -1

      ! Construct vertical descriptor
      self%zz%rec%nomvar = ZNAME
      select case (trim(up(format)))

         ! RPN Standard file input
      case ('FST')
         key=fstinf(unit,ni,nj,nk,-1,' ',ip1,ip2,-1,' ',self%zz%rec%nomvar)
         if(key < 0)then
            write(STDERR,'("WARNING: cannot find '//trim(self%zz%rec%nomvar)//' with the following: ip1=",i10,",ip2=",i10)')ip1,ip2
            self%zz%vcode = -1
            return
         endif
         allocate(self%zz%table(ni,nj,nk),stat=istat)
         if (istat /= 0) then
            write(STDERR,*) 'ERROR: unable to allocate self%zz%table'
            return
         endif
         istat=fstluk(self%zz%table,key,ni,nj,nk)
         if(istat < 0)then
            write(STDERR,*) 'ERROR: problem with fstluk on '//trim(self%zz%rec%nomvar)
            return
         endif
         ! Sorry, I have to use fstprm!
         istat=fstprm(key, self%zz%rec%dateo, self%zz%rec%deet, self%zz%rec%npas, &
              ni, nj, nk, self%zz%rec%nbits, self%zz%rec%datyp, self%ip1, self%ip2, self%zz%rec%ip3, &
              self%zz%rec%typvar,self%zz%rec%nomvar, self%zz%rec%etiket, self%zz%rec%grtyp,&
              self%zz%rec%ig1, self%zz%rec%ig2, self%zz%rec%ig3, self%zz%rec%ig4, &
              swa,lng,dltf,ubc,extra1,extra2,extra3)         

         ! Check for multiple (different) descriptors
         error = fstinl(unit,ni,nj,nk,-1,' ',ip1,ip2,-1,' ',self%zz%rec%nomvar,keyList,count,size(keyList))
         if (error < 0) then
            write(STDERR,*) 'ERROR: problem retrieving '//trim(self%zz%rec%nomvar)//' keys for ip1,ip2: ',ip1,ip2
            self%zz%vcode = -1
            return
         endif
         if(count>1)then
            allocate(l_table(ni,nj,nk),stat=istat)
            if (istat /= 0) then
               write(STDERR,*) 'ERROR: unable to allocate l_table'
               return
            endif
            do i=2,count
               error=my_fstprm(keyList(i),var)
               if (error < 0) then
                  write(STDERR,*) 'ERROR: problem with my_fstprm in new_read'
                  self%zz%vcode = -1
                  return
               endif
               if(var%ip1 /= self%ip1 .or. var%ip2 /= self%ip2 .or. &
                    var%ni  /= ni     .or. var%nj  /= nj     .or.  var%nk  /= nk )then
                  write(STDERR,*) 'ERROR: found different vertical descriptors after wildcard (-1) search'
                  self%zz%vcode = -1
                  return
               endif
               istat=fstluk(l_table,keyList(i),ni,nj,nk)
               if(istat < 0)then
                  write(STDERR,*) 'ERROR: problem with fstluk on l_table i=',i
                  return
               endif
               if(any(l_table /= self%zz%table))then
                  write(STDERR,*) 'ERROR: found different entries in vertical descriptors after wildcard (-1) search'
                  return
               endif
            enddo
            deallocate(l_table)
         endif

         ! Fortran binary file input (must already be in the correct position)
      case ('BIN')
         read(unit) ni,nj,nk
         allocate(self%zz%table(ni,nj,nk),stat=istat)
         if (istat /= 0) then
            write(STDERR,*) 'ERROR: unable to allocate self%zz%table'
            return
         endif
         read(unit) self%zz%table
         self%zz%rec%dateo = 0
         self%zz%rec%deet = 0
         self%zz%rec%npas = 0
         self%zz%rec%nbits = 32
         self%zz%rec%datyp = 1
         self%zz%rec%ip3 = 0
         self%zz%rec%typvar = 'X'
         self%zz%rec%etiket = ''
         self%zz%rec%grtyp = 'X'
         self%zz%rec%ig1 = 0
         self%zz%rec%ig2 = 0
         self%zz%rec%ig3 = 0
         self%zz%rec%ig4 = 0

         ! Warn user on invalid input format specification
      case DEFAULT
         write(STDERR,*) 'ERROR: invalid constructor format request ',trim(format)
         return
      end select

      ! Set internal vcode (if all above was successful)
      error = set_vcode(self)
      select case (self%zz%vcode)
      case (1002)
         istat=decode_vert_1002(self)
         if(istat < 0)then
            write(STDERR,*) 'ERROR: problem with fstluk on '//trim(self%zz%rec%nomvar)
            return
         endif
      case (2001)
         istat=decode_vert_2001(self)
      case (5001)
         istat=decode_vert_5001(self)
         if(istat < 0)then
            write(STDERR,*) 'ERROR: problem with fstluk on '//trim(self%zz%rec%nomvar)
            return
         endif
      case (5002)
         istat=decode_vert_5002(self)
         if(istat < 0)then
            write(STDERR,*) 'ERROR: problem with fstluk on '//trim(self%zz%rec%nomvar)
            return
         endif
      case DEFAULT
         istat = get_version_info(self,kind,version)
         write(STDERR,*) 'ERROR: kind or version invalid :',kind,version
         return
      end select

      ! Set status and return
      if ( found_descriptor(self,'x') .or. &
           found_descriptor(self,'y') .or. &
           found_descriptor(self,'z')) status = GD_OK
      return
   end function new_read

   integer function new_build_vert(self,kind,version,nk,ip1,ip2, &
        ptop_8,pref_8,rcoef1,rcoef2,a_m_8,b_m_8,a_t_8,b_t_8, &
        ip1_m,ip1_t) result(status)
      ! Coordinate constructor - build vertical descriptor from arguments
      type(grid_descriptor), intent(out) :: self        !Descriptor instance    
      integer, intent(in) :: kind,version               !Kind,version to create
      integer, intent(in) :: nk                         !Number of levels
      integer, optional, intent(in) :: ip1,ip2          !IP1,2 values for FST file record [0,0]
      real, optional, intent(in) :: rcoef1,rcoef2       !R-coefficient values for rectification
      real*8, optional, intent(in) :: ptop_8            !Top-level pressure (Pa)
      real*8, optional, intent(in) :: pref_8            !Reference-level pressure (Pa)
      real*8, optional, dimension(:) :: a_m_8,a_t_8     !A-coefficients for momentum(m),thermo(t) levels
      real*8, optional, dimension(:) :: b_m_8,b_t_8     !B-coefficients for momentum(m),thermo(t) levels
      integer, optional, dimension(:) :: ip1_m,ip1_t    !Level ID (IP1) for momentum(m),thermo(t) levels

      ! Local variables
      integer :: error,nn,ig1,ig2,ig3,ig4,k
      character(len=4) :: cvcode
      logical :: missingInput

      ! Set error status
      status = GD_ERROR

      ! Initializations
      self%zz%rec%nomvar = ZNAME
      self%zz%kind=kind
      self%zz%version=version
      self%zz%rec%dateo=0
      self%zz%rec%ip3=0
      if (present(ip1)) self%ip1 = ip1
      if (present(ip2)) self%ip2 = ip2
      self%unit = -1      
      self%match_ipig=.true.

      ! Check for required inputs
      error = set_vcode(self,kind,version)
      missingInput = .false.
      if(is_valid(self,ptop_8_valid)) then
         if(present(ptop_8))then
            self%zz%ptop_8 = ptop_8
         else
            write(STDERR,*) 'ERROR: ptop_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,pref_8_valid)) then
         if(present(pref_8))then
            self%zz%pref_8 = pref_8
         else
            write(STDERR,*) 'ERROR: pref_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,rcoef1_8_valid)) then
         if(present(rcoef1))then
            self%zz%rcoef1_8 = rcoef1
         else
            write(STDERR,*) 'ERROR: rcoef1 is a required constructor entry'
            missingInput = .true.
         endif
      endif     
      if(is_valid(self,rcoef2_8_valid)) then
         if(present(rcoef2))then
            self%zz%rcoef2_8 = rcoef2
         else
            write(STDERR,*) 'ERROR: rcoef2 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,a_m_8_valid)) then
         if(present(a_m_8))then
            if (associated(self%zz%a_m_8)) deallocate(self%zz%a_m_8)
            allocate(self%zz%a_m_8(size(a_m_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating a_m_8 in new_build_vert'
               return
            endif
            self%zz%a_m_8 = a_m_8
         else
            write(STDERR,*) 'ERROR: a_m_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,b_m_8_valid)) then
         if(present(b_m_8))then
            if (associated(self%zz%b_m_8)) deallocate(self%zz%b_m_8)
            allocate(self%zz%b_m_8(size(b_m_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating b_m_8 in new_build_vert'
               return
            endif
            self%zz%b_m_8 = b_m_8
         else
            write(STDERR,*) 'ERROR: b_m_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,a_t_8_valid)) then
         if(present(a_t_8))then
            if (associated(self%zz%a_t_8)) deallocate(self%zz%a_t_8)
            allocate(self%zz%a_t_8(size(a_t_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating a_t_8 in new_build_vert'
               return
            endif
            self%zz%a_t_8 = a_t_8
         else
            write(STDERR,*) 'ERROR: a_t_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,b_t_8_valid)) then
         if(present(b_t_8))then
            if (associated(self%zz%b_t_8)) deallocate(self%zz%b_t_8)
            allocate(self%zz%b_t_8(size(b_t_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating b_t_8 in new_build_vert'
               return
            endif
            self%zz%b_t_8 = b_t_8
         else
            write(STDERR,*) 'ERROR: b_t_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,ip1_m_valid)) then
         if(present(ip1_m))then
            if (associated(self%zz%ip1_m)) deallocate(self%zz%ip1_m)
            allocate(self%zz%ip1_m(size(ip1_m)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating ip1_m in new_build_vert'
               return
            endif
            self%zz%ip1_m = ip1_m
         else
            write(STDERR,*) 'ERROR: ip1_m is a required constructor entry'
            missingInput = .true.
         endif
      endif      
      if(is_valid(self,ip1_t_valid)) then
         if(present(ip1_t))then
            if (associated(self%zz%ip1_t)) deallocate(self%zz%ip1_t)
            allocate(self%zz%ip1_t(size(ip1_t)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating ip1_t in new_build_vert'
               return
            endif
            self%zz%ip1_t = ip1_t
         else
            write(STDERR,*) 'ERROR: ip1_t is a required constructor entry'
            missingInput = .true.
         endif
      endif      
      if (is_valid(self,a_m_8_valid)) then
         if(present(a_m_8))then
            if (associated(self%zz%a_m_8)) deallocate(self%zz%a_m_8)
            allocate(self%zz%a_m_8(size(a_m_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating a_m_8 in new_build_vert'
               return
            endif
            self%zz%a_m_8 = a_m_8
         else
            write(STDERR,*) 'ERROR: a_m_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if (is_valid(self,b_m_8_valid)) then
         if(present(b_m_8))then
            if (associated(self%zz%b_m_8)) deallocate(self%zz%b_m_8)
            allocate(self%zz%b_m_8(size(b_m_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating b_m_8 in new_build_vert'
               return
            endif
            self%zz%b_m_8 = b_m_8
         else
            write(STDERR,*) 'ERROR: b_m_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if (missingInput) return

      ! Fill table with version-specific encoder
      select case (self%zz%vcode)
      case (1002)
         error = encode_vert_1002(self,nk)
      case (2001)
         error = encode_vert_2001(self)
      case (5001)
         error = encode_vert_5001(self,nk)
      case (5002)
         error = encode_vert_5002(self,nk)
      case DEFAULT
         write(STDERR,*) 'ERROR: unsupported kind and version : ',kind,version,' (vcode) ',self%zz%vcode
         return
      end select
      if (error /= GD_OK) then
         write(cvcode,'(i4)') self%zz%vcode
         write(STDERR,*) 'ERROR: problem with encode_vert_'//trim(cvcode)
         return
      endif

      ! Set status and return
      status = GD_OK
      return
   end function new_build_vert

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Get methods

  integer function get_int(self,key,value,dir) result(status)
    ! Retrieve the value of the requested instance variable
    type(grid_descriptor), intent(in) :: self           !Descriptor instance
    character(len=*), intent(in) :: key                 !Descriptor key to retrieve
    integer, intent(out) :: value                       !Retrieved value
    character(len=*), intent(in), optional :: dir       !Directional descriptor specification ['']
    
    ! Local variables
    integer :: error,ix,iy,iz
    character(len=LONG_STRING) :: mydir

    ! Set error status
    status = GD_ERROR

    ! Set default values
    mydir = ''
    if (present(dir)) mydir = up(dir(1:DIR_LENGTH))

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('DATE')
       ix = self%xx%rec%dateo; iy = self%yy%rec%dateo; iz = self%zz%rec%dateo
       error = desc_direction_getput(self,key,mydir,ix,iy,iz,value,'get')
    case ('IG_1')
       ix = self%xx%rec%ig1; iy = self%yy%rec%ig1; iz = self%zz%rec%ig1
       error = desc_direction_getput(self,key,mydir,ix,iy,iz,value,'get')
    case ('IG_2')
       ix = self%xx%rec%ig2; iy = self%yy%rec%ig2; iz = self%zz%rec%ig2
       error = desc_direction_getput(self,key,mydir,ix,iy,iz,value,'get')
    case ('IG_3')
       ix = self%xx%rec%ig3; iy = self%yy%rec%ig3; iz = self%zz%rec%ig3
       error = desc_direction_getput(self,key,mydir,ix,iy,iz,value,'get')
    case ('IG_4')
       ix = self%xx%rec%ig4; iy = self%yy%rec%ig4; iz = self%zz%rec%ig4
       error = desc_direction_getput(self,key,mydir,ix,iy,iz,value,'get')
    case ('IP_1')
       value = self%ip1
    case ('IP_2')
       value = self%ip2
    case ('IP_3')
       ix = self%xx%rec%ip3; iy = self%yy%rec%ip3; iz = self%zz%rec%ip3
       error = desc_direction_getput(self,key,mydir,ix,iy,iz,value,'get')
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (int)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function get_int

  integer function get_int_1d(self,key,value,dir) result(status)
    ! Retrieve the value of the requested instance variable
    type(grid_descriptor), intent(in) :: self           !Descriptor instance
    character(len=*), intent(in) :: key                 !Descriptor key to retrieve
    integer, dimension(:), pointer :: value             !Retrieved value
    character(len=*), intent(in), optional :: dir       !Directional descriptor specification ['']

    ! Internal variables
    integer :: istat,error

    ! Set error status
    status = GD_ERROR

    ! Check for an invalid direction specification
    if (present(dir)) write(STDERR,*) 'WARNING: ignoring dir= specified for '//trim(key)

    ! Garbage collection
    if (associated(value)) deallocate(value)
    nullify(value)

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('VIPM')
       if (is_valid(self,ip1_m_valid)) then
          istat = get_allocate(key,value,size(self%zz%ip1_m))
          if (istat /= 0) return
          value = self%zz%ip1_m
       else
          error = int(get_error(key))
          return
       endif
    case ('VIPT')
       if (is_valid(self,ip1_t_valid)) then
          istat = get_allocate(key,value,size(self%zz%ip1_t))
          if (istat /= 0) return
          value = self%zz%ip1_t
       else
          error = int(get_error(key))
          return
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (int 1D)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function get_int_1d

  integer function get_real8(self,key,value,dir) result(status)
    ! Retrieve the value of the requested instance variable
    type(grid_descriptor), intent(in) :: self   !Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to retrieve
    real(kind=8), intent(out) :: value          !Retrieved value
    character(len=*), intent(in), optional :: dir !Directional descriptor specification ['']

    ! Set error status
    status = GD_ERROR

    ! Check for an invalid direction specification
    if (present(dir)) write(STDERR,*) 'WARNING: ignoring dir= specified for '//trim(key)

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('PTOP')
       if (is_valid(self,ptop_8_valid)) then
          value = self%zz%ptop_8
       else
          value = dble(get_error(key))
          return
       endif
    case ('PREF')
       if (is_valid(self,pref_8_valid)) then
          value = self%zz%pref_8
       else
          value = dble(get_error(key))
          return
       endif
    case ('RC_1')
       if (is_valid(self,rcoef1_8_valid)) then
          value = self%zz%rcoef1_8
       else
          value = dble(get_error(key))
          return
       endif
    case ('RC_2')
       if (is_valid(self,rcoef2_8_valid)) then
          value = self%zz%rcoef2_8
       else
          value = dble(get_error(key))
          return
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (real8)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function get_real8

  integer function get_real8_1d(self,key,value,dir) result(status)
    ! Retrieve the value of the requested instance variable
    type(grid_descriptor), intent(in) :: self   !Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to retrieve
    real(kind=8), dimension(:), pointer :: value !Retrieved value
    character(len=*), intent(in), optional :: dir !Directional descriptor specification ['']

    ! Internal variables
    integer :: istat,error

    ! Set error status
    status = GD_ERROR

    ! Check for an invalid direction specification
    if (present(dir)) write(STDERR,*) 'WARNING: ignoring dir= specified for '//trim(key)

    ! Garbage collection
    if (associated(value)) deallocate(value)
    nullify(value)

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('CA_M')
       if (is_valid(self,a_m_8_valid)) then
          istat = get_allocate(key,value,size(self%zz%a_m_8))
          if (istat /= 0) return
          value = self%zz%a_m_8
       else
          error = int(get_error(key))
          return
       endif
    case ('CB_M')
       if (is_valid(self,b_m_8_valid)) then
          istat = get_allocate(key,value,size(self%zz%b_m_8))
          if (istat /= 0) return
          value = self%zz%b_m_8
       else
          error = int(get_error(key))
          return
       endif
    case ('CA_T')
       if (is_valid(self,a_t_8_valid)) then
          istat = get_allocate(key,value,size(self%zz%a_t_8))
          if (istat /= 0) return
          value = self%zz%a_t_8
       else
          error = int(get_error(key))
          return
       endif
    case ('CB_T')
       if (is_valid(self,b_t_8_valid)) then
          istat = get_allocate(key,value,size(self%zz%b_t_8))
          if (istat /= 0) return
          value = self%zz%b_t_8
       else
          error = int(get_error(key))
          return
       endif
    case ('COFA')
       if (is_valid(self,a_m_8_valid)) then
          istat = get_allocate(key,value,size(self%zz%a_m_8))
          if (istat /= 0) return
          value = self%zz%a_m_8
       else
          error = int(get_error(key))
          return
       endif
    case ('COFB')
       if (is_valid(self,b_m_8_valid)) then
          istat = get_allocate(key,value,size(self%zz%b_m_8))
          if (istat /= 0) return
          value = self%zz%b_m_8
       else
          error = int(get_error(key))
          return
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (real8 1D)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function get_real8_1d

  integer function get_real8_3d(self,key,value,dir) result(status)
    ! Retrieve the value of the requested instance variable
    type(grid_descriptor), intent(in) :: self   !Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to retrieve
    real(kind=8), dimension(:,:,:), pointer :: value !Retrieved value
    character(len=*), intent(in), optional :: dir !Directional descriptor specification ['']

    ! Internal variables
    integer :: istat

    ! Set error status
    status = GD_ERROR

    ! Check for an invalid direction specification
    if (present(dir)) write(STDERR,*) 'WARNING: ignoring dir= specified for '//trim(key)

    ! Garbage collection
    if (associated(value)) deallocate(value)
    nullify(value)

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('VTBL')
       istat = get_allocate(key,value,shape(self%zz%table))
       if (istat /= 0) return
       value = self%zz%table
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (real8 3D)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function get_real8_3d

  integer function get_char(self,key,value,dir) result(status)
    ! Retrieve the value of the requested instance variable
    type(grid_descriptor), intent(in) :: self   !Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to retrieve
    character(len=*), intent(out) :: value      !Retrieved value
    character(len=*), intent(in), optional :: dir !Directional descriptor specification ['']
    
    ! Local variables
    integer :: error
    character(len=LONG_STRING) :: mydir,cx,cy,cz

    ! Set error status
    status = GD_ERROR

    ! Set default values
    mydir = ''
    if (present(dir)) mydir = up(dir(1:DIR_LENGTH))

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('ETIK')
       cx = self%xx%rec%etiket; cy = self%yy%rec%etiket; cz = self%zz%rec%etiket
       error = desc_direction_getput(self,key,mydir,cx,cy,cz,value,'get')
    case ('NAME')
       cx = self%xx%rec%nomvar; cy = self%yy%rec%nomvar; cz = self%zz%rec%nomvar
       error = desc_direction_getput(self,key,mydir,cx,cy,cz,value,'get')
    case ('RFLD')
       if (is_valid(self,ref_name_valid)) then
          value = self%zz%ref_name
       else
          write(value,'(i8)') get_error(key)
          return
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (char)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function get_char

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Put methods

  integer function put_int(self,key,value,dir) result(status)
    ! Set the value of the requested instance variable
    type(grid_descriptor), intent(inout) :: self!Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    integer, intent(in) :: value                !Value to set
    character(len=*), intent(in), optional :: dir !Directional descriptor specification ['']
    
    ! Local variables
    integer :: error,myvalue
    character(len=LONG_STRING) :: mydir

    ! Set error status
    status = GD_ERROR

    ! Set default values
    mydir = ''
    if (present(dir)) mydir = up(dir(1:DIR_LENGTH))
    myvalue = value

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('DATE')
       error = desc_direction_getput(self,key,mydir,&
            self%xx%rec%dateo,self%yy%rec%dateo,self%zz%rec%dateo,myvalue,'put')
    case ('IG_1')
       error = desc_direction_getput(self,key,mydir,&
            self%xx%rec%ig1,self%yy%rec%ig1,self%zz%rec%ig1,myvalue,'put')
    case ('IG_2')
       error = desc_direction_getput(self,key,mydir,&
            self%xx%rec%ig2,self%yy%rec%ig2,self%zz%rec%ig2,myvalue,'put')
    case ('IG_3')
       error = desc_direction_getput(self,key,mydir,&
            self%xx%rec%ig3,self%yy%rec%ig3,self%zz%rec%ig3,myvalue,'put')
    case ('IG_4')
       error = desc_direction_getput(self,key,mydir,&
            self%xx%rec%ig4,self%yy%rec%ig4,self%zz%rec%ig4,myvalue,'put')
    case ('IP_1')
       self%ip1 = value
    case ('IP_2')
       self%ip2 = value
    case ('IP_3')
       error = desc_direction_getput(self,key,mydir,&
            self%xx%rec%ip3,self%yy%rec%ip3,self%zz%rec%ip3,myvalue,'put')
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (int)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function put_int

  integer function put_int_1d(self,key,value,dir) result(status)
    ! Set the value of the requested instance variable
    type(grid_descriptor), intent(inout) :: self        !Descriptor instance
    character(len=*), intent(in) :: key                 !Descriptor key to set
    integer, dimension(:), pointer :: value             !Value to set
    character(len=*), intent(in), optional :: dir       !Directional descriptor specification ['']

    ! Local variables
    integer :: error
    
    ! Set error status
    status = GD_ERROR

    ! Check for an invalid direction specification
    if (present(dir)) write(STDERR,*) 'WARNING: ignoring dir= specified for '//trim(key)

    ! Check for valid value
    if (.not.associated(value)) then
       write(STDERR,*) 'ERROR: unallocated value sent to gd_put for '//trim(key)
       return
    endif

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('VIPM')
       if (.not.size_ok(self%zz%ip1_m,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%zz%ip1_m = value
       if (.not.is_valid(self,ip1_m_valid)) status = put_error(key)
    case ('VIPT')
       if (.not.size_ok(self%zz%ip1_t,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%zz%ip1_t = value
       if (.not.is_valid(self,ip1_t_valid)) status = put_error(key)
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (real8 1D)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function put_int_1d

  integer function put_real8(self,key,value,dir) result(status)
    ! Set the value of the requested instance variable
    type(grid_descriptor), intent(inout) :: self!Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    real(kind=8), intent(in) :: value           !Value to set
    character(len=*), intent(in), optional :: dir !Directional descriptor specification ['']

    ! Local variables
    integer :: error

    ! Set error status
    status = GD_ERROR

    ! Check for an invalid direction specification
    if (present(dir)) write(STDERR,*) 'WARNING: ignoring dir= specified for '//trim(key)

    ! Map key name to derived-type element
    error = GD_OK
    select case (up(key(1:KEY_LENGTH)))
    case ('PTOP')
       self%zz%ptop_8 = value
       if (.not.is_valid(self,ptop_8_valid)) error = put_error(key)
    case ('PREF')
       self%zz%pref_8 = value
       if (.not.is_valid(self,pref_8_valid)) error = put_error(key)
    case ('RC_1')
       self%zz%rcoef1_8 = value
       if (.not.is_valid(self,rcoef1_8_valid)) error = put_error(key)
    case ('RC_2')
       self%zz%rcoef2_8 = value
       if (.not.is_valid(self,rcoef2_8_valid)) error = put_error(key)
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (real8)'
       return
    end select

    ! Check for sets of invalid values
    if (error /= GD_OK) return

    ! Set status and return
    status = GD_OK
    return
  end function put_real8

  integer function put_real8_1d(self,key,value,dir) result(status)
    ! Set the value of the requested instance variable
    type(grid_descriptor), intent(inout) :: self!Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    real(kind=8), dimension(:), pointer :: value !Value to set
    character(len=*), intent(in), optional :: dir !Directional descriptor specification ['']

    ! Local variables
    integer :: error
    
    ! Set error status
    status = GD_ERROR

    ! Check for an invalid direction specification
    if (present(dir)) write(STDERR,*) 'WARNING: ignoring dir= specified for '//trim(key)

    ! Check for valid value
    if (.not.associated(value)) then
       write(STDERR,*) 'ERROR: unallocated value sent to gd_put for '//trim(key)
       return
    endif

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('CA_M')
       if (.not.size_ok(self%zz%a_m_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%zz%a_m_8 = value
       if (.not.is_valid(self,a_m_8_valid)) status = put_error(key)
    case ('CB_M')
       if (.not.size_ok(self%zz%b_m_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%zz%b_m_8 = value
       if (.not.is_valid(self,b_m_8_valid)) status = put_error(key)
    case ('CA_T')
       if (.not.size_ok(self%zz%a_t_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%zz%a_t_8 = value
       if (.not.is_valid(self,a_t_8_valid)) status = put_error(key)
    case ('CB_T')
       if (.not.size_ok(self%zz%b_t_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%zz%b_t_8 = value
       if (.not.is_valid(self,b_t_8_valid)) status = put_error(key)
    case ('COFA')
       if (.not.size_ok(self%zz%a_m_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%zz%a_m_8 = value
       if (.not.is_valid(self,a_m_8_valid)) status = put_error(key)
    case ('COFB')
       if (.not.size_ok(self%zz%b_m_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%zz%b_m_8 = value
       if (.not.is_valid(self,b_m_8_valid)) status = put_error(key)
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (real8 1D)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function put_real8_1d

  integer function put_real8_3d(self,key,value,dir) result(status)
    ! Set the value of the requested instance variable
    type(grid_descriptor), intent(inout) :: self!Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    real(kind=8), dimension(:,:,:), pointer :: value !Value to set
    character(len=*), intent(in), optional :: dir !Directional descriptor specification ['']

    ! Set error status
    status = GD_ERROR

    ! Check for an invalid direction specification
    if (present(dir)) write(STDERR,*) 'WARNING: ignoring dir= specified for '//trim(key)

    ! Check for valid value
    if (.not.associated(value)) then
       write(STDERR,*) 'ERROR: unallocated value sent to gd_put for'//trim(key)
       return
    endif

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('VTBL')
       if (.not.size_ok(self%zz%table,value)) then
          write(STDERR,*) 'ERROR: value does not match table size in gd_put'
          return
       endif
       self%zz%table = value
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (real8 3D)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function put_real8_3d

  integer function put_char(self,key,value,dir) result(status)
    ! Set the value of the requested instance variable
    type(grid_descriptor), intent(inout) :: self!Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    character(len=*), intent(in) :: value       !Value to set
    character(len=*), intent(in), optional :: dir !Directional descriptor specification ['']

    ! Internal variables
    integer :: error
    character(len=LONG_STRING) :: mydir,myvalue

    ! Set error status
    status = GD_ERROR

    ! Set default values
    mydir = ''
    if (present(dir)) mydir = up(dir(1:DIR_LENGTH))
    if (len_trim(value) > LONG_STRING) then
       write(STDERR,*) 'WARNING: long string will be trimmed - ',trim(value)
    endif
    myvalue = value

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('ETIK')
       error = desc_direction_getput(self,key,mydir,&
            self%xx%rec%etiket,self%yy%rec%etiket,self%zz%rec%etiket,myvalue,'put')
    case ('NAME')
       error = desc_direction_getput(self,key,mydir,&
            self%xx%rec%nomvar,self%yy%rec%nomvar,self%zz%rec%nomvar,myvalue,'put')
    case ('RFLD')
       self%zz%ref_name = value
       if (.not.is_valid(self,ref_name_valid)) error = put_error(key)
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (char)'
       return
    end select

    ! Set status and return
    status = GD_OK
    return
  end function put_char

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Dump contents

  integer function print_desc(self,stdout) result(status)
    ! Dump plain text grid descriptor information to the requested file unit
    type(grid_descriptor), intent(in) :: self   !Descriptor instance
    integer, intent(in), optional :: stdout     !Output unit to write to [6]

    ! Internal variables
    integer :: my_stdout,stat,nk,k
    character(len=64) :: hr
    character(len=GD_LEN_NAME) :: name

    ! Set error status
    status = GD_ERROR

    ! Set default values
    my_stdout = 6
    if (present(stdout)) my_stdout = stdout

    ! Create horizontal rule
    hr = '-------------------------------------------------------'

    ! Dump general descriptor information
    write(my_stdout,*) '-- 3D Descriptor Information --'
    write(my_stdout,*) '  ip1=',self%ip1
    write(my_stdout,*) '  ip2=',self%ip2
    write(my_stdout,*) trim(hr)

    ! Dump horizontal descriptor information
    horizontal: if (found_descriptor(self,'x')) then
       write(my_stdout,*) '-- Horizontal Grid Descriptor Information --'
    else
       write(my_stdout,*) '* No Horizontal Grid Desriptor Information Found'
    endif horizontal

    ! Horizontal rule to separate descriptor directions
    write(my_stdout,*) trim(hr)

    ! Dump vertical descriptor information
    vertical: if (found_descriptor(self,'z')) then
       write(my_stdout,*) '-- Vertical Coordinate Information --'
       write(my_stdout,*)'  Descriptor Nomvar: ',trim(self%zz%rec%nomvar)
       write(my_stdout,'(a,i2,a,i3)')'   level kind =',self%zz%kind,', level version = ',self%zz%version
       if (is_valid(self,ptop_8_valid))  write(my_stdout,*)'  ptop=',self%zz%ptop_8,'Pa'
       if (is_valid(self,pref_8_valid))  write(my_stdout,*)'  pref=',self%zz%pref_8,'Pa'       
       if (is_valid(self,rcoef1_8_valid))write(my_stdout,*)'  rcoef1=',real(self%zz%rcoef1_8)
       if (is_valid(self,rcoef2_8_valid))write(my_stdout,*)'  rcoef2=',real(self%zz%rcoef2_8)
       if (is_valid(self,ref_name_valid))write(my_stdout,*)'  Surface field nomvar ',self%zz%ref_name
       select case (self%zz%vcode)
       case (1002)
          nk=size(self%zz%ip1_m)
          write(my_stdout,*)'  Number of levels (momentum levels)',nk
          write(my_stdout,*)'  Equation to compute hydrostatic pressure (pi): pi = A + B * P0*100'
       case (2001)
          nk=size(self%zz%ip1_m)
          write(my_stdout,*)'  Number of levels (pressure levels)',nk
          write(my_stdout,*)'  Equation to pressure (P): P = A'
       case (5001)
          nk=size(self%zz%ip1_m)
          write(my_stdout,*)'  Number of levels (momentum levels)',nk
          write(my_stdout,*)'  Equation to compute hydrostatic pressure (pi): pi = A + B * P0*100'
       case (5002)
          nk=size(self%zz%ip1_m)
          write(my_stdout,*)'  Number of levels (momentum levels)',nk-1
          write(my_stdout,*)'  Equation to compute hydrostatic pressure (pi): ln(pi) = A + B * ln(P0*100/pref)'
       end select
       
       if (is_valid(self,ip1_m_valid))then
          nk=size(self%zz%ip1_m)
          write(my_stdout,*)'  Momentum levels ip1, A, B:'
          do k=1,nk
             write(my_stdout,*)self%zz%ip1_m(k),self%zz%a_m_8(k),self%zz%b_m_8(k)
          enddo
       endif
       if (is_valid(self,ip1_t_valid))then
          nk=size(self%zz%ip1_t)
          write(my_stdout,*)'  Thermodynamic levels ip1, A, B:'
          do k=1,nk
             write(my_stdout,*)self%zz%ip1_t(k),self%zz%a_t_8(k),self%zz%b_t_8(k)
          enddo
       endif
    else
       write(my_stdout,*) '* No Vertical Coordinate Information Found'
    endif vertical

    ! Set status and return
    status = GD_OK
    return
  end function print_desc

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Write descriptors
  
  integer function write_desc(self,unit,format) result(status)     
    ! Write descriptors to the requested file
    type(grid_descriptor), intent(in) :: self   !Descriptor instance
    integer, intent(in) :: unit                 !File unit to write to
    character(len=*), intent(in) :: format      !File format ('fst' or 'bin')

    ! Local variables
    integer :: error,ni,nj,nk,fstecr
    real :: dummy

    ! Set error status
    status = GD_ERROR

    ! Array size from table
    ni=size(self%zz%table,dim=1)
    nj=size(self%zz%table,dim=2)
    nk=size(self%zz%table,dim=3)

    ! Write to the desired output file type
    select case (trim(up(format)))

    ! Write to an RPN Standard file
    case ('FST')
    error=fstecr(self%zz%table,dummy,-64,unit, &
         self%zz%rec%dateo,self%zz%rec%deet,self%zz%rec%npas,&
         ni,nj,nk,self%ip1,self%ip2,self%zz%rec%ip3,&
         self%zz%rec%typvar,self%zz%rec%nomvar,self%zz%rec%etiket,self%zz%rec%grtyp, &
         self%zz%rec%ig1,self%zz%rec%ig2,self%zz%rec%ig3,self%zz%rec%ig4,5,.true.)
    if(error < 0)then
       write(STDERR,*) 'ERROR: problem with fstecr in write_desc'
       return
    endif

    ! Write to a Fortran binary file
    case ('BIN')
       write(unit) ni,nj,nk
       write(unit) self%zz%table

    ! Warn user for unknown format
    case DEFAULT
       write(STDERR,*) 'WARNING: no write done for unknown format ',trim(format)
    end select

    ! Set status and return
    status = GD_OK
    return
  end function write_desc

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Compute vertical levelling

  integer function levels_toplevel(unit,fstkeys,levels,in_log) result(status)
    ! Top-level interface for computing physical levelling information
    integer, intent(in) :: unit                         !File unit associated with the key
    integer, dimension(:), intent(in) :: fstkeys        !Key of prototype field
    real, dimension(:,:,:), pointer :: levels           !Physical level values
    logical, optional, intent(in) :: in_log             !Compute levels in ln() [.false.]

    ! Local variables
    integer :: error,ig1,ig2,ig3,i
    character(len=LONG_STRING) :: grtyp
    logical :: construct,multiple_grids,my_in_log
    type(grid_descriptor) :: gd
    type(FSTD_ext) :: var

    ! Set error status
    status = GD_ERROR

    ! Set default values
    my_in_log = .false.
    if (present(in_log)) my_in_log = in_log

    ! Construct appropriate grid_descriptor object (rebuild if new ig1-3 values are found)
    multiple_grids = .false.
    grids: do i=1,size(fstkeys)
       error = my_fstprm(fstkeys(i),var)
       if (error /= GD_OK) then
          write(STDERR,*) 'ERROR: error return from fstprm wrapper for fst key ',fstkeys(i)
          return
       endif
       if (i==1) then
          ig1 = var%ig1
          ig2 = var%ig2
          ig3 = var%ig3
          grtyp = var%grtyp
       endif
       if (var%ig1 /= ig1 .or. var%ig2 /= ig2 .or. var%ig3 /= ig3 .or. trim(var%grtyp) /= trim(grtyp)) then
          write(STDERR,*) 'ERROR: multiple grids defined in fstkeys vector'
          return
       endif
    enddo grids

    ! Create grid descriptor instance and call level calculator
    if (any(MATCH_GRTYP == grtyp)) then
       error = new_read(gd,unit=unit,format='fst',ip1=ig1,ip2=ig2)
    else
       error = new_read(gd,unit=unit,format='fst',ip1=-1,ip2=-1)
    endif
    if (error /= GD_OK) then
       write(STDERR,*) 'ERROR: cannot build grid descriptor instance for fst key ',fstkeys(i)
       return
    endif
    error = levels_readref(gd,unit=unit,fstkeys=fstkeys,levels=levels,in_log=my_in_log)
    if (error /= GD_OK) then
       write(STDERR,*) 'ERROR: problem computing level information for fst key ',fstkeys(i)
       return
    endif

    ! Set status and return
    status = GD_OK
    return
  end function levels_toplevel

  integer function levels_readref(self,unit,fstkeys,levels,in_log) result(status)
    ! Reading referent, compute physical levelling information from the vertical description
    type(grid_descriptor), intent(in) :: self           !Descriptor instance
    integer, intent(in) :: unit                         !File unit associated with the key
    integer, dimension(:), intent(in) :: fstkeys        !Key of prototype field
    real, dimension(:,:,:), pointer :: levels           !Physical level values
    logical, optional, intent(in) :: in_log             !Compute levels in ln() [.false.]

    ! Internal variables
    integer :: fstinf,ni,nj,nk,sfc_key,istat,error,fstluk,i
    integer, dimension(size(fstkeys)) :: ip1_list
    type(FSTD_ext) prmk,prm_p0,prm_check
    real, dimension(:,:), pointer :: p0
    logical :: my_in_log

    ! Set error status
    status = GD_ERROR

    ! Set default values
    my_in_log = .false.
    if (present(in_log)) my_in_log=in_log

    ! Check input keys
    istat=my_fstprm(fstkeys(1),prmk)
    if(istat < 0)then
       write(STDERR,*) 'ERROR: problem with my_fstprm in levels_readref'
    endif
    check_times: do i=1,size(fstkeys)
       istat=my_fstprm(fstkeys(i),prm_check)
       ip1_list(i) = prm_check%ip1
       if (prm_check%datev /= prmk%datev) then
          write(STDERR,*) 'ERROR: multiple valid times given in fstkeys vector'
          return
       endif
       if (prm_check%ig1 /= prmk%ig1 .or. prm_check%ig2 /= prmk%ig2 .or. prm_check%ig3 /= prmk%ig3) then
          write(STDERR,*) 'ERROR: multiple grids given in fstkeys vector'
          return
       endif
    enddo check_times
    if (self%match_ipig) then
       if (prmk%ig1 /= self%ip1 .or. prmk%ig2 /= self%ip2) then
          write(STDERR,*) 'ERROR: fstkeys do not correspond to the correct grid descriptor'
          return
       endif
    endif

    ! Check surface field if needed
    sfc_valid: if (is_valid(self,ref_name_valid)) then
       sfc_key = fstinf(unit,ni,nj,nk,prmk%datev,prmk%etiket,-1,prmk%ip2,prmk%ip3,' ',self%zz%ref_name)
       if(sfc_key < 0)then
          write(STDERR,*) 'ERROR: cannot find ',self%zz%ref_name,' for :'
          write(STDERR,*) 'datev=',prmk%datev,' etiket=',prmk%etiket,' ip2=',prmk%ip2,' ip3=',prmk%ip3
          return   
       endif
       istat=my_fstprm(sfc_key,prm_p0)
       if(prm_p0%ni.ne.prmk%ni.or.prm_p0%nj.ne.prmk%nj)then
          write(STDERR,*) 'ERROR: horizontal grid mismatch for '//trim(self%zz%ref_name),ni,nj,' vs',prmk%ni,prmk%nj
          return
       endif
       if (self%match_ipig) then
          if (prm_p0%ig1 /= self%ip1 .or. prm_p0%ig2 /= self%ip2) then
             write(STDERR,*) 'ERROR: sfc_field ig1-2 do not correspond to the correct grid descriptor'
             return
          endif
       endif
       allocate(p0(ni,nj),stat=error)
       if (error /= 0) then
          write(STDERR,*) 'ERROR: cannot allocate space for p0 in levels_readref'
          return
       endif
       error = fstluk(p0,sfc_key,ni,nj,nk)
       if(error < 0 )then
          write(STDERR,*) 'ERROR: problem with fstluk '//trim(self%zz%ref_name)//' in levels_readref'
          return
       endif
       if (trim(self%zz%ref_name) == 'P0') p0 = p0*100. !convert mb to Pa
    else
       allocate(p0(1,1),stat=error)
       if (error /= 0) then
          write(STDERR,*) 'ERROR: cannot allocate space for p0 in levels_readref'
          return
       endif
       p0 = GD_MISSING
    endif sfc_valid
   
    ! Wrap call to level calculator
    error = levels_withref(self,sfc_field=p0,ip1_list=ip1_list,levels=levels,in_log=my_in_log)
    if (error /= GD_OK) then
       write(STDERR,*) 'ERROR: got error return from levels_withref in levels_readref'
       return
    endif

    ! Set status and return
    status = GD_OK
    return
  end function levels_readref

  integer function levels_withref_prof(self,ip1_list,levels,sfc_field,in_log) result(status)
     ! profile wraper for levels_withref
     type(grid_descriptor), intent(in) :: self                   !Descriptor instance
     integer, dimension(:), intent(in) :: ip1_list               !Key of prototype field
     real, dimension(:), pointer :: levels                       !Physical level values
     real, optional, intent(in) :: sfc_field                     !Surface field reference for coordinate [none]
     logical, optional, intent(in) :: in_log                     !Compute levels in ln() [.false.]          
     
     ! Local variables
     integer :: error,nk
     real, dimension(:,:), pointer :: sfc_field_2d
     real, dimension(:,:,:), pointer :: levels_3d
     
     ! Set error status
     status = GD_ERROR

     nk=size(ip1_list)

     allocate(sfc_field_2d(1,1),levels_3d(1,1,nk),stat=error)
     if (error /= 0) then
        write(STDERR,*) 'ERROR: cannot allocate space for p0/levels in levels_withref_prof'
        return
     endif
     sfc_field_2d=sfc_field
     ! Wrap call to level calculator    
     error = levels_withref(self,sfc_field=sfc_field_2d,ip1_list=ip1_list,levels=levels_3d,in_log=in_log)    
     if (error /= 0) then
        write(STDERR,*) 'ERROR: problem with levels_withref in levels_withref_prof'
        return
     endif
     if (associated(levels)) then
        if (size(levels) /= nk) then
           write (STDERR,*) 'WARNING: levels array size error - will be reallocated'
        endif
        deallocate(levels)
     endif
     allocate(levels(nk),stat=error)
     if (error /= 0) then
        write(STDERR,*) 'ERROR: cannot allocate space for levels in levels_withref_prof'
        return
     endif
     levels=levels_3d(1,1,1:nk)

     ! Set status and return
     status = GD_OK
     return

  end function levels_withref_prof

  integer function levels_withref(self,ip1_list,levels,sfc_field,in_log) result(status)
    ! Given referent, compute physical levelling information from the vertical description
    type(grid_descriptor), intent(in) :: self                   !Descriptor instance
    integer, dimension(:), intent(in) :: ip1_list               !Key of prototype field
    real, dimension(:,:,:), pointer :: levels                   !Physical level values
    real, dimension(:,:), optional, intent(in) :: sfc_field     !Surface field reference for coordinate [none]
    logical, optional, intent(in) :: in_log                     !Compute levels in ln() [.false.]
   
    ! Local variables
    integer kind,version,istat,ni,nj,nk,error
    logical :: my_in_log

    ! Set error status
    status = GD_ERROR

    ! Set default values
    my_in_log = .false.
    if (present(in_log)) my_in_log = in_log
    
    ! Set size of output and allocate space
    if (present(sfc_field)) then
       ni = size(sfc_field,dim=1); nj = size(sfc_field,dim=2); nk = size(ip1_list)
    else
      if (is_valid(self,ref_name_valid)) then
         write(STDERR,*) 'ERROR: reference field must be provided to levels_withref'
         return
      else
         ni = 1; nj = 1; nk = size(ip1_list)
      endif
    endif
    if (associated(levels)) then
       if (size(levels,dim=1) /= ni .or. size(levels,dim=2) /= nj .or. size(levels,dim=3) /= nk) then
          write (STDERR,*) 'WARNING: levels array size error - will be reallocated'
       endif
       deallocate(levels)
    endif
    allocate(levels(ni,nj,nk),stat=error)
    if (error /= 0) then
       write(STDERR,*) 'ERROR: cannot allocate space for levels in levels_withref'
       return
    endif

    ! Compute levels for known vertical coordinates
    select case (self%zz%vcode)
    case (1002)
       istat = compute_pressure_1002(self,sfc_field,ip1_list,levels,my_in_log)
    case (2001)
       istat = compute_pressure_2001(self,ip1_list,levels,my_in_log)
    case (5001)
       istat = compute_pressure_5001(self,sfc_field,ip1_list,levels,my_in_log)
    case (5002)
       istat = compute_pressure_5002(self,sfc_field,ip1_list,levels,my_in_log)
    case DEFAULT
       istat = get_version_info(self,kind,version)
       write(STDERR,*) 'ERROR: kind or version invalid :',kind,version
       return 
    end select
    if (istat /= GD_OK) then
       write(STDERR,*) 'ERROR: error computing pressure in levels_withref'
       return
    endif

    ! Set status and return
    status = GD_OK
    return
  end function levels_withref

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Compute full horizontal position

  integer function position(self,lat,lon) result(status)
    ! Compute the horizontal position based on the coordinate descriptors
    type(grid_descriptor), intent(in) :: self   !Descriptor instance
    real, dimension(:,:), intent(out), optional :: lat !Latitude array of grid
    real, dimension(:,:), intent(out), optional :: lon !Longitude array of grid

    ! Set error status
    status = GD_ERROR

    ! Set status and return
    status = GD_OK
    return
  end function position

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Convert string to upper-case

  function up (string) result(upper_string)
    ! Convert a string to all upper-case
    character(len=*), intent(in) :: string      !Input string to upper-case
    character(len=LONG_STRING) :: upper_string  !Upper-cased result
    integer :: i
    if (len_trim(string) > len(upper_string)) then
       write(STDERR,*) 'WARNING: long string truncated in up() ',trim(string)
    endif
    upper_string = string
    do i = 1,len_trim(string)
       if (string(i:i) >= 'a' .and. string(i:i) <= 'z') then
          upper_string(i:i) = achar(iachar(string(i:i)) - 32)
       endif
    enddo
    return
  end function up

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Check array sizes

  logical function size_ok_i1d(p1,p2) result(ok)
    ! Check size matching for 3d real8 arrays
    integer, dimension(:), pointer :: p1        !Input pointer 1
    integer, dimension(:), pointer :: p2        !Input pointer 2
    ok = .false.
    if (.not.associated(p1) .or. .not.associated(p2)) then
       write(STDERR,*) 'ERROR: unallocated pointer to check in size_ok'
       return
    endif
    if (size(p1,dim=1) == size(p2,dim=1)) ok = .true.
    return
  end function size_ok_i1d

  logical function size_ok_r81d(p1,p2) result(ok)
    ! Check size matching for 3d real8 arrays
    real(kind=8), dimension(:), pointer :: p1   !Input pointer 1
    real(kind=8), dimension(:), pointer :: p2   !Input pointer 2
    ok = .false.
    if (.not.associated(p1) .or. .not.associated(p2)) then
       write(STDERR,*) 'ERROR: unallocated pointer to check in size_ok'
       return
    endif
    if (size(p1,dim=1) == size(p2,dim=1)) ok = .true.
    return
  end function size_ok_r81d

  logical function size_ok_r83d(p1,p2) result(ok)
    ! Check size matching for 3d real8 arrays
    real(kind=8), dimension(:,:,:), pointer :: p1 !Input pointer 1
    real(kind=8), dimension(:,:,:), pointer :: p2 !Input pointer 2
    ok = .false.
    if (.not.associated(p1) .or. .not.associated(p2)) then
       write(STDERR,*) 'ERROR: unallocated pointer to check in size_ok'
       return
    endif
    if ( size(p1,dim=1) == size(p2,dim=1) .and. &
         size(p1,dim=2) == size(p2,dim=2) .and. &
         size(p1,dim=3) == size(p2,dim=3)) ok = .true.
    return
  end function size_ok_r83d

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Encoding functions

  integer function encode_vert_1002(self,nk) result(status)
     type(grid_descriptor), intent(inout) :: self       !Descriptor instance
     integer, intent(in) :: nk                          !Number of levels

     ! Local variables
     integer :: nn,error,k,ind
     integer, parameter :: skip=2
     real*8 :: for_char_8

     ! Set error status
     status = GD_ERROR

     ! Allocate table space
     if (associated(self%zz%table)) deallocate(self%zz%table)         
     allocate(self%zz%table(3,nk+skip,1),stat=error)
     if(error < 0)then
        write(STDERR,*) 'ERROR: cannot allocate self%zz%table in encode_vert_1002'
        return
     endif

     ! Fill standard file record entries
     error = fstd_init(self%zz,etiket='ETA_GEMV3',   &
          ig2=nint(self%zz%ptop_8*10.d0),            &
          ig3=0,         &
          ig4=0)
     if (error /= GD_OK) then
        write(STDERR,*) 'ERROR: cannot initialize fstd record entries'
        return
     end if
     self%zz%ref_name="P0"
     
     ! Vector size checks
     nn=size(self%zz%ip1_m)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for ip1_m, is ',nn,'should be ',nk
        return
     endif
     nn=size(self%zz%a_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for a_m_8, is ',nn,'should be ',nk
        return
     endif
     nn=size(self%zz%b_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for b_m_8, is ',nn,'should be ',nk
        return
     endif
     for_char_8=transfer(self%zz%ref_name,for_char_8)

     ! Fill header
     self%zz%table(1:3,1,1)=(/dble(self%zz%kind),dble(self%zz%version),dble(skip)/)
     self%zz%table(1:3,2,1)=(/self%zz%ptop_8    ,for_char_8, 0.d0/)

     ! Fill level data
     do k=1,nk
        ind=k+skip
        self%zz%table(1:3,ind,1)=(/dble(self%zz%ip1_m(k)),self%zz%a_m_8(k),self%zz%b_m_8(k)/)
     enddo     

     ! Set status and return
     status = GD_OK
  end function encode_vert_1002

  integer function encode_vert_2001(self) result(status)
     type(grid_descriptor), intent(inout) :: self       !Descriptor instance

     ! Local variables
     integer :: nn,ip1,nk,k,ind,error
     integer, parameter :: skip=1

     ! Set error status
     status = GD_ERROR

     ! Allocate table space
     nk = size(self%zz%a_m_8)
     if (associated(self%zz%table)) deallocate(self%zz%table)         
     allocate(self%zz%table(3,nk+skip,1),stat=error)
     if(error < 0)then
        write(STDERR,*) 'ERROR: cannot allocate self%zz%table in encode_vert_2001'
        return
     endif

     ! Fill standard file record entries
     error = fstd_init(self%zz,etiket='PRESSURE',ig2=0,ig3=0,ig4=0)
     if (error /= GD_OK) then
        write(STDERR,*) 'ERROR: cannot initialize fstd record entries'
        return
     end if

     ! Vector size checks
     nn=size(self%zz%a_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for a_m_8, is ',nn,'should be ',nk
        return
     endif
     
     ! Fill header
     self%zz%table(1:3,1,1)=(/dble(self%zz%kind),dble(self%zz%version),dble(skip)/)

     ! Fill pressure level data
     do k=1,nk
        ind=k+skip
        self%zz%table(1:3,ind,1)=(/dble(self%zz%ip1_m(k)),self%zz%a_m_8(k),self%zz%b_m_8(k)/)
     enddo

     ! Set status and return
     status = GD_OK
     return
   end function encode_vert_2001

  integer function encode_vert_5001(self,nk) result(status)
     type(grid_descriptor), intent(inout) :: self       !Descriptor instance
     integer, intent(in) :: nk                          !Number of levels

     ! Local variables
     integer :: nn,error,k,ind
     integer, parameter :: skip=3
     real*8 :: for_char_8

     ! Set error status
     status = GD_ERROR

     ! Allocate table space
     if (associated(self%zz%table)) deallocate(self%zz%table)         
     allocate(self%zz%table(3,nk+skip,1),stat=error)
     if(error < 0)then
        write(STDERR,*) 'ERROR: cannot allocate self%zz%table in encode_vert_5001'
        return
     endif

     ! Fill standard file record entries
     error = fstd_init(self%zz,etiket='HYB_GEMV3',   &
          ig2=nint(self%zz%ptop_8*10.d0),            &
          ig3=nint(self%zz%rcoef1_8*100.d0),         &
          ig4=0)
     if (error /= GD_OK) then
        write(STDERR,*) 'ERROR: cannot initialize fstd record entries'
        return
     end if
     self%zz%ref_name="P0"
     
     ! Vector size checks
     nn=size(self%zz%ip1_m)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for ip1_m, is ',nn,'should be ',nk
        return
     endif
     nn=size(self%zz%a_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for a_m_8, is ',nn,'should be ',nk
        return
     endif
     nn=size(self%zz%b_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for b_m_8, is ',nn,'should be ',nk
        return
     endif
     for_char_8=transfer(self%zz%ref_name,for_char_8)

     ! Fill header
     self%zz%table(1:3,1,1)=(/dble(self%zz%kind),dble(self%zz%version),dble(skip)/)
     self%zz%table(1:3,2,1)=(/self%zz%ptop_8    ,self%zz%pref_8       ,self%zz%rcoef1_8/)     
     self%zz%table(1:3,3,1)=(/for_char_8        ,0.d0                 ,0.d0/)

     ! Fill level data
     do k=1,nk
        ind=k+skip
        self%zz%table(1:3,ind,1)=(/dble(self%zz%ip1_m(k)),self%zz%a_m_8(k),self%zz%b_m_8(k)/)
     enddo     

     ! Set status and return
     status = GD_OK
  end function encode_vert_5001

  integer function encode_vert_5002(self,nk) result(status)
     type(grid_descriptor), intent(inout) :: self       !Descriptor instance
     integer, intent(in) :: nk                          !Number of levels

     ! Local variables
     integer :: nn,error,k,ind
     integer, parameter :: skip=3
     real*8 :: for_char_8
     character(len=8) :: ref_name,ref_name_flip

     ! Set error status
     status = GD_ERROR

     ! Allocate table space
     if (associated(self%zz%table)) deallocate(self%zz%table)         
     allocate(self%zz%table(3,(2*nk+3)+skip,1),stat=error)
     if(error < 0)then
        write(STDERR,*) 'ERROR: cannot allocate self%zz%table in encode_vert_5002'
        return
     endif

     ! Fill standard file record entries
     error = fstd_init(self%zz,etiket='STG_CP_GEMV4',   &
          ig2=nint(self%zz%ptop_8*10.d0),               &
          ig3=nint(self%zz%rcoef1_8*100.d0),            &
          ig4=nint(self%zz%rcoef2_8*100.d0))
     if (error /= GD_OK) then
        write(STDERR,*) 'ERROR: cannot initialize fstd record entries'
        return
     end if
     self%zz%ref_name="P0"
     
     ! Vector size checks
     nn=size(self%zz%ip1_m)
     if(nn.ne.nk+1)then
        write(STDERR,*) 'ERROR: wrong size for ip1_m, is ',nn,'should be ',nk+1
        return
     endif
     nn=size(self%zz%a_m_8)
     if(nn.ne.nk+1)then
        write(STDERR,*) 'ERROR: wrong size for a_m_8, is ',nn,'should be ',nk+1
        return
     endif
     nn=size(self%zz%b_m_8)
     if(nn.ne.nk+1)then
        write(STDERR,*) 'ERROR: wrong size for b_m_8, is ',nn,'should be ',nk+1
        return
     endif
     nn=size(self%zz%ip1_t)
     if(nn.ne.nk+2)then
        write(STDERR,*) 'ERROR: wrong size for ip1_t, is ',nn,'should be ',nk+2
        return
     endif
     nn=size(self%zz%a_t_8)
     if(nn.ne.nk+2)then
        write(STDERR,*) 'ERROR: wrong size for a_t_8, is ',nn,'should be ',nk+2
        return
     endif
     nn=size(self%zz%b_t_8)
     if(nn.ne.nk+2)then
        write(STDERR,*) 'ERROR: wrong size for b_t_8, is ',nn,'should be ',nk+2
        return
     endif
     if (len_trim(self%zz%ref_name) > len(ref_name)) then
        write(STDERR,*) 'ERROR: reference field name '//trim(self%zz%ref_name)//' longer than limit: ',len(ref_name)
        return
     endif
     error = flip_transfer(self%zz%ref_name,for_char_8)
     if (error /= GD_OK) then
        write(STDERR,*) 'ERROR: flip_transfer function returned error code from encode ',error
        return
     endif

     ! Fill header
     self%zz%table(1:3,1,1)=(/dble(self%zz%kind),dble(self%zz%version),dble(skip)/)
     self%zz%table(1:3,2,1)=(/self%zz%ptop_8    ,self%zz%pref_8       ,self%zz%rcoef1_8/)     
     self%zz%table(1:3,3,1)=(/self%zz%rcoef2_8  ,for_char_8           ,0.d0/)

     ! Fill momentum level data
     do k=1,nk+1
        ind=k+skip
        self%zz%table(1:3,ind,1)=(/dble(self%zz%ip1_m(k)),self%zz%a_m_8(k),self%zz%b_m_8(k)/)
     enddo     

     ! Fill thermodynamic level data
     do k=1,nk+2
        ind=k+skip+nk+1
        self%zz%table(1:3,ind,1)=(/dble(self%zz%ip1_t(k)),self%zz%a_t_8(k),self%zz%b_t_8(k)/)
     enddo

     ! Set status and return
     status = GD_OK
  end function encode_vert_5002

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Decoding functions

  integer function decode_vert_1002(self) result(status)
     type(grid_descriptor), intent(inout) :: self   !Descriptor instance
     
     ! Local variables
     integer :: skip,nj,nk,k,ind

     ! Set error status
     status = GD_ERROR

     ! Read header line 1
     self%zz%kind     = nint(self%zz%table(1,1,1))
     self%zz%version  = nint(self%zz%table(2,1,1))
     skip             = nint(self%zz%table(3,1,1))
     
     ! Read header line 2
     self%zz%ptop_8   = self%zz%table(1,2,1)
     self%zz%ref_name = transfer(self%zz%table(2,2,1),self%zz%ref_name)

     nj=size(self%zz%table,dim=2)

     nk=nj-skip

     ! Allocate and assign level data
     if (associated(self%zz%ip1_m)) deallocate(self%zz%ip1_m)
     allocate(self%zz%ip1_m(nk))
     if (associated(self%zz%a_m_8)) deallocate(self%zz%a_m_8)
     allocate(self%zz%a_m_8(nk))
     if (associated(self%zz%b_m_8)) deallocate(self%zz%b_m_8)
     allocate(self%zz%b_m_8(nk))     

     do k=1,nk
        ind=k+skip
        self%zz%ip1_m(k) = nint(self%zz%table(1,ind,1))
        self%zz%a_m_8(k) =      self%zz%table(2,ind,1)
        self%zz%b_m_8(k) =      self%zz%table(3,ind,1)
     enddo

     ! Set status and return
     status = GD_OK

  end function decode_vert_1002

  integer function decode_vert_2001(self) result(status)
    type(grid_descriptor), intent(inout) :: self   !Descriptor instance

    ! Local variables
    integer :: skip,nj,nk,k,ind
    
    ! Set error status
    status = GD_ERROR
    
    ! Read header line 1
    self%zz%kind     = nint(self%zz%table(1,1,1))
    self%zz%version  = nint(self%zz%table(2,1,1))
    skip             = nint(self%zz%table(3,1,1))

    nk = size(self%zz%table,dim=2) - skip

    ! Allocate and assign pressure level data
    if (associated(self%zz%ip1_m)) deallocate(self%zz%ip1_m)
    allocate(self%zz%ip1_m(nk))
    if (associated(self%zz%a_m_8)) deallocate(self%zz%a_m_8)
    allocate(self%zz%a_m_8(nk))
    if (associated(self%zz%b_m_8)) deallocate(self%zz%b_m_8)
    allocate(self%zz%b_m_8(nk))

    do k=1,nk
       ind=k+skip
       self%zz%ip1_m(k) = nint(self%zz%table(1,ind,1))
       self%zz%a_m_8(k) =      self%zz%table(2,ind,1)
       self%zz%b_m_8(k) =      self%zz%table(3,ind,1)
    end do

    ! Set status and return
    status = GD_OK

  end function decode_vert_2001
       
  integer function decode_vert_5001(self) result(status)
     type(grid_descriptor), intent(inout) :: self   !Descriptor instance
     
     ! Local variables
     integer :: skip,nj,nk,k,ind

     ! Set error status
     status = GD_ERROR

     ! Read header line 1
     self%zz%kind     = nint(self%zz%table(1,1,1))
     self%zz%version  = nint(self%zz%table(2,1,1))
     skip             = nint(self%zz%table(3,1,1))
     
     ! Read header line 2
     self%zz%ptop_8   = self%zz%table(1,2,1)
     self%zz%pref_8   = self%zz%table(2,2,1)
     self%zz%rcoef1_8 = self%zz%table(3,2,1)

     ! Read header line 3
     self%zz%ref_name = transfer(self%zz%table(1,3,1),self%zz%ref_name)

     nj=size(self%zz%table,dim=2)

     nk=nj-skip

     ! Allocate and assign level data
     if (associated(self%zz%ip1_m)) deallocate(self%zz%ip1_m)
     allocate(self%zz%ip1_m(nk))
     if (associated(self%zz%a_m_8)) deallocate(self%zz%a_m_8)
     allocate(self%zz%a_m_8(nk))
     if (associated(self%zz%b_m_8)) deallocate(self%zz%b_m_8)
     allocate(self%zz%b_m_8(nk))     

     do k=1,nk
        ind=k+skip
        self%zz%ip1_m(k) = nint(self%zz%table(1,ind,1))
        self%zz%a_m_8(k) =      self%zz%table(2,ind,1)
        self%zz%b_m_8(k) =      self%zz%table(3,ind,1)
     enddo

     ! Set status and return
     status = GD_OK

  end function decode_vert_5001

  integer function decode_vert_5002(self) result(status)
     type(grid_descriptor), intent(inout) :: self   !Descriptor instance
     
     ! Local variables
     integer :: skip,nj,nk,k,ind,error

     ! Set error status
     status = GD_ERROR

     ! Read header line 1
     self%zz%kind     = nint(self%zz%table(1,1,1))
     self%zz%version  = nint(self%zz%table(2,1,1))
     skip             = nint(self%zz%table(3,1,1))
     
     ! Read header line 2
     self%zz%ptop_8   = self%zz%table(1,2,1)
     self%zz%pref_8   = self%zz%table(2,2,1)
     self%zz%rcoef1_8 = self%zz%table(3,2,1)

     ! Read header line 3
     self%zz%rcoef2_8 =     self%zz%table(1,3,1)
     error = flip_transfer(self%zz%table(2,3,1),self%zz%ref_name)
     if (error /= GD_OK) then
        write(STDERR,*) 'ERROR: flip_transfer function returned an error code from decode ',error
        return
     endif
     nj=size(self%zz%table,dim=2)

     nk=(nj-3-skip)/2

     ! Allocate and assign momentum level data
     if (associated(self%zz%ip1_m)) deallocate(self%zz%ip1_m)
     allocate(self%zz%ip1_m(nk+1))
     if (associated(self%zz%a_m_8)) deallocate(self%zz%a_m_8)
     allocate(self%zz%a_m_8(nk+1))
     if (associated(self%zz%b_m_8)) deallocate(self%zz%b_m_8)
     allocate(self%zz%b_m_8(nk+1))     

     do k=1,nk+1
        ind=k+skip
        self%zz%ip1_m(k) = nint(self%zz%table(1,ind,1))
        self%zz%a_m_8(k) =      self%zz%table(2,ind,1)
        self%zz%b_m_8(k) =      self%zz%table(3,ind,1)
     enddo

     ! Allocate and assign thermodynamic level data
     if (associated(self%zz%ip1_t)) deallocate(self%zz%ip1_t)
     allocate(self%zz%ip1_t(nk+2))
     if (associated(self%zz%a_t_8)) deallocate(self%zz%a_t_8)
     allocate(self%zz%a_t_8(nk+2))
     if (associated(self%zz%b_t_8)) deallocate(self%zz%b_t_8)
     allocate(self%zz%b_t_8(nk+2))     

     do k=1,nk+2
        ind=k+skip+nk+1
        self%zz%ip1_t(k) = nint(self%zz%table(1,ind,1))
        self%zz%a_t_8(k) =      self%zz%table(2,ind,1)
        self%zz%b_t_8(k) =      self%zz%table(3,ind,1)
     enddo     

     ! Set status and return
     status = GD_OK

  end function decode_vert_5002

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Set and check the vertical code
  
  integer function set_vcode_d(self) result(status)
     ! Compute the internal vertical code from table
     type(grid_descriptor), intent(inout) :: self       !Descriptor instance

     ! Local variables
     integer :: kind,version
     
     ! Set error status and check initialization
     status = GD_ERROR
     if (.not.associated(self%zz%table)) then
        write(STDERR,*) 'ERROR: set_vcode called before constructor'
        return
     endif

     ! Wrap call to integer mangling
     status = get_version_info(self,kind,version)
     if (status /= GD_OK) then
        write(STDERR,*) 'ERROR: cannot decode table to read kind and version: ',kind,version
        return
     endif
     status = set_vcode(self,kind,version)

     ! Set status and return
     status = GD_OK
     return
  end function set_vcode_d

  integer function set_vcode_i(self,kind,version) result(status)
     ! Compute the internal vertical code from kind and version
     type(grid_descriptor), intent(inout) :: self       !Descriptor instance
     integer, intent(in) :: kind,version                !Kind and version of vertical coord

     ! Set error status
     status = GD_ERROR

     ! Check for valid entries (version is limited by the mangling equation)
     if (kind > MAX_VKIND .or. kind < 0 .or. version > 999 .or. version < 0) then
        write(STDERR,*) 'ERROR: invalid kind or version ',kind,version
        return
     endif

     ! Mangle the kind and version information
     self%zz%vcode = kind*1000+version

     ! Set status and return
     status = GD_OK
     return
  end function set_vcode_i

  integer function get_version_info(self,kind,version) result(status)
    ! Retrieve kind and version information from the table
    type(grid_descriptor), intent(in) :: self          !Descriptor instance
    integer, intent(out) :: kind,version               !Kind and version of vertical coord

    ! Set error status
    status = GD_ERROR
    
    ! Retrieve kind and version information from table
    kind = nint(self%zz%table(1,1,1))
    version = nint(self%zz%table(2,1,1))

    ! Set status and return
    status = GD_OK
    return
  end function get_version_info

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Descriptor operation support functions

  logical function found_descriptor(self,dir) result(found)
     ! Is the descriptor for the specified dimension valid?
     type(grid_descriptor), intent(in) :: self          !Descriptor instance
     character(len=*), intent(in) :: dir                !Direction 'x','y','z'
     found = .false.
     select case (up(dir))
     case ('X')
        if (self%xx%hcode >= 0) found = .true.
     case ('Y')
        if (self%yy%hcode >= 0) found = .true.
     case ('Z')
        if (self%zz%vcode >= 0) found = .true.
     case DEFAULT
        write(STDERR,*) 'WARNING: invalid direction '//trim(dir)// &
             'given to found_descriptor'
     end select
     return
  end function found_descriptor

  character(len=1) function desc_direction(self,key,dir) result(ok_dir)
    ! Return a valid direction if one exists, otherwise return a blank string
    type(grid_descriptor), intent(in) :: self           !Descriptor instance
    character(len=*), intent(in) :: key                 !Key to retrieve
    character(len=*), intent(in) :: dir                 !Direction 'x','y','z'
    character(len=LONG_STRING) :: mydir
    ok_dir = ''
    mydir = up(dir(1:DIR_LENGTH))
    if (len_trim(dir) == 0) then
       write(STDERR,*) 'ERROR: directional argument dir= (x, y, or z) required for '//trim(key)
       return
    endif
    if (dir == 'X') then
       if (found_descriptor(self,'X')) then
          ok_dir = dir
          write(STDERR,10) trim(self%xx%rec%nomvar),trim(key)
       else
          return
       endif
    elseif (dir == 'Y') then
       if (found_descriptor(self,'Y')) then
          ok_dir = dir
       else
          write(STDERR,10) trim(self%yy%rec%nomvar),trim(key)
          return
       endif
    elseif (dir == 'Z') then
       if (found_descriptor(self,'Z')) then
          ok_dir = dir
       else
          write(STDERR,10) trim(self%zz%rec%nomvar),trim(key)
          return
       endif
    endif
10  format('ERROR: descriptor ',a,' not initialized for ',a,' request')
    return
  end function desc_direction

  integer function desc_direction_getput_int(self,key,dir,valx,valy,valz,value,getput) result(status)
    ! Perform get/put operations for directional descriptor keys
    type(grid_descriptor), intent(in) :: self           !Descriptor instance
    character(len=*), intent(in) :: key                 !Key to retrieve
    character(len=*), intent(in) :: dir                 !Direction 'x','y','z'
    integer, intent(inout) :: valx,valy,valz            !x,y,z direction values of the element
    integer, intent(inout) :: value                     !get/put value of the element
    character(len=*), intent(in) :: getput              !'get' or 'put' operation
    status = GD_ERROR
    if (.not.any(getput == (/'get','put'/))) then
       write(STDERR,*) 'ERROR: invalid operation '//trim(getput)//' attempted in desc_direction_getput for '//trim(key)
       return
    endif
    select case (desc_direction(self,key,dir))
    case ('X')
       if (getput == 'get') then
          value = valx
       else
          valx = value
       endif
    case ('Y')
       if (getput == 'get') then
          value = valy
       else
          valy = value
       endif
    case ('Z')
       if (getput == 'get') then
          value = valz
       else
          valz = value
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: direction '//trim(dir)//' not valid for this descriptor instance for '//trim(key)
       return
    end select
  end function desc_direction_getput_int

  integer function desc_direction_getput_char(self,key,dir,valx,valy,valz,value,getput) result(status)
    ! Perform get/put operations for directional descriptor keys
    type(grid_descriptor), intent(in) :: self           !Descriptor instance
    character(len=*), intent(in) :: key                 !Key to retrieve
    character(len=*), intent(in) :: dir                 !Direction 'x','y','z'
    character(len=*), intent(inout) :: valx,valy,valz   !x,y,z direction values of the element
    character(len=*), intent(inout) :: value            !get/put value of the element
    character(len=*), intent(in) :: getput              !'get' or 'put' operation
    status = GD_ERROR
    if (.not.any(getput == (/'get','put'/))) then
       write(STDERR,*) 'ERROR: invalid operation '//trim(getput)//' attempted in desc_direction_getput for '//trim(key)
       return
    endif
    select case (desc_direction(self,key,dir))
    case ('X')
       if (getput == 'get') then
          value = valx
       else
          valx = value
       endif
    case ('Y')
       if (getput == 'get') then
          value = valy
       else
          valy = value
       endif
    case ('Z')
       if (getput == 'get') then
          value = valz
       else
          valz = value
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: direction '//trim(dir)//' not valid for this descriptor instance for '//trim(key)
       return
    end select
  end function desc_direction_getput_char

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Get/Put support functions
  
  real function get_error(key) result(value)
    ! Write error message and return a missing value
    character(len=*), intent(in) :: key
    write(STDERR,*) 'WARNING: attempt to retrieve invalid key '//trim(key)//' returns GD_MISSING'
    value = dble(GD_MISSING)
    return
  end function get_error

  integer function get_allocate_i1d(key,value,len) result(istat)
    ! Allocate space for the result value and report error
    character(len=*), intent(in) :: key
    integer, dimension(:), pointer :: value
    integer, intent(in) :: len
    allocate(value(len),stat=istat)
    if (istat /= 0) then
       write(STDERR,*) 'ERROR: unable to allocate space for '//trim(key)//' request'
    endif
  end function get_allocate_i1d
  
  integer function get_allocate_r81d(key,value,len) result(istat)
    ! Allocate space for the result value and report error
    character(len=*), intent(in) :: key
    real*8, dimension(:), pointer :: value
    integer, intent(in) :: len
    allocate(value(len),stat=istat)
    if (istat /= 0) then
       write(STDERR,*) 'ERROR: unable to allocate space for '//trim(key)//' request'
    endif
  end function get_allocate_r81d

    integer function get_allocate_r83d(key,value,len) result(istat)
    ! Allocate space for the result value and report error (len is result of 'shape()')
    character(len=*), intent(in) :: key
    real*8, dimension(:,:,:), pointer :: value
    integer, dimension(:), intent(in) :: len
    if (size(len) < 3) then
       write(STDERR,*) 'ERROR: wrong array shape specified for '//trim(key)
       istat = -1
       return
    endif
    allocate(value(len(1),len(2),len(3)),stat=istat)
    if (istat /= 0) then
       write(STDERR,*) 'ERROR: unable to allocate space for '//trim(key)//' request'
    endif
  end function get_allocate_r83d

  integer function put_error(key) result(error)
    character(len=*), intent(in) :: key
    write(STDERR,*) 'WARNING: attempt to set useless value for '//trim(key)
    error = GD_ERROR
    return
  end function put_error

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Validity inquiry functions

  logical function is_valid(self,element_valid) result(valid)
     ! Check for validity of the element
     type(grid_descriptor) :: self           !Descriptor instance
     integer, dimension(:) :: element_valid
     valid = .false.
     if (any(element_valid == self%zz%vcode) .or. &
          any(element_valid == self%xx%hcode) .or. &
          any(element_valid == self%yy%hcode)) valid = .true.
     return
  end function is_valid

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) FSTD support functions

  integer function fstd_init_v(self,etiket,ig2,ig3,ig4) result(status)
    ! Initialize common elements of the fstd record
    type(vcoord), intent(inout) :: self         !Descriptor instance (directional)
    character(len=*), intent(in) :: etiket      !Stamp (etiket) entry
    integer, intent(in) :: ig2,ig3,ig4          !IG2-4 values
    status = GD_ERROR
    self%rec%grtyp='X'
    self%rec%deet=0
    self%rec%npas=0
    self%rec%etiket=trim(etiket)
    self%rec%typvar='X'     
    self%rec%ig1=self%vcode
    self%rec%ig2=ig2
    self%rec%ig3=ig3
    self%rec%ig4=ig4
    status = GD_OK
  end function fstd_init_v

  integer function my_fstprm(fstkey,record) result(status)
    ! Use fstprm function to get information about the record
    integer, intent(in) :: fstkey               !Key from FST file record
    type(FSTD_ext) :: record                    !Record information
    integer :: error,ni,nj,nk
    integer, external :: fstprm,fstinf
    real*8 :: nhours
    status = GD_ERROR
    error=fstprm(fstkey,record%dateo,record%deet,record%npas, &
         record%ni,record%nj,record%nk,record%nbits,record%datyp,record%ip1,record%ip2, &
         record%ip3,record%typvar,record%nomvar,record%etiket,record%grtyp, &
         record%ig1,record%ig2,record%ig3,record%ig4,record%swa, &
         record%lng,record%dltf,record%ubc,record%extra1,record%extra2, &
         record%extra3)
    if (error < 0) then
       write(6,*) 'ERROR: cannot fstprm for fstkey ',fstkey
       return
    end if
    nhours=record%deet*record%npas/3600.d0
    call incdatr(record%datev,record%dateo,nhours)
    status = GD_OK
  end function my_fstprm

  logical function is_big_endian() result(bend)
    ! Determine the endianness of the machine
    character(len=4) :: str
    select case (transfer(1094861636,str))
    case ('ABCD')
       bend = .true.
    case ('DCBA')
       bend = .false.
    case DEFAULT
       write(STDERR,*) 'WARNING: unable to determine bit ordering in is_big_endian'
       bend = .false.
    end select
    return
  end function is_big_endian

  integer function flip_transfer_r8(str,val_out) result(status)
    ! Convert string to a little-endian 8-byte real
    character(len=*), intent(in) :: str                 !string to convert
    real*8, intent(out) :: val_out                      !8-byte real for output
    integer :: i,cnt
    character(len=8) :: str_cvt
    status = GD_ERROR; val_out = 0.d0
    if (len_trim(str) > len(str_cvt)) then
       write(STDERR,*) 'ERROR: string length to flip_transfer (',len_trim(str),') exceeds limit: ',len(str)
       return
    endif
    if (is_big_endian()) then
       cnt = 1
       do i=len(str_cvt),1,-1
          if (cnt <= len_trim(str)) then
             str_cvt(i:i) = str(cnt:cnt)
             cnt = cnt+1
          else
             str_cvt(i:i) = ' '
          endif
       enddo
    else
       str_cvt = str
    endif
    val_out = transfer(str_cvt,val_out)
    status = GD_OK
    return
  end function flip_transfer_r8

  integer function flip_transfer_char(val,str_out) result(status)
    ! Convert a little-endian 8-byte real to a string
    real*8, intent(in) :: val                           !8-byte real to convert
    character(len=*), intent(out) :: str_out            !string for output
    integer :: i,cnt
    character(len=8) :: str_cvt
    logical :: overflow
    status = GD_ERROR; str_out = ''
    str_cvt = transfer(val,str_cvt)
    if (is_big_endian()) then
       cnt = 1; overflow = .false.
       do i=len(str_cvt),1,-1
          if (cnt <= len(str_out)) then
             str_out(cnt:cnt) = str_cvt(i:i)
             cnt = cnt+1
          else
             if (ichar(str_cvt(i:i)) > 32) overflow = .true.
          endif
       enddo
    else
       str_out = str_cvt
    endif
    if (overflow) then
       write(STDERR,*) 'ERROR: string length to flip_transfer (',len(str_out),') is insufficient: ',len_trim(str_cvt)
       return
    endif
    status = GD_OK
    return
  end function flip_transfer_char

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Pressure computation functions

  integer function compute_pressure_1002(self,sfc_field,ip1_list,levels,in_log) result(status)
    ! Compute pressure for all levels specified in ip1_list
    type(grid_descriptor), intent(in) :: self           !Descriptor instance
    real, dimension(:,:), intent(in) :: sfc_field       !Surface field reference for coordinate
    integer, dimension(:), intent(in) :: ip1_list       !List of IP1 levels to calculate on
    real, dimension(:,:,:), pointer  :: levels          !Physical level values
    logical, intent(in) :: in_log                       !Compute level values in ln()

    ! Internal variables
    integer :: i,j,error,nk
    real*8, dimension(size(sfc_field,dim=1),size(sfc_field,dim=2)) :: s_8
    real*8, dimension(size(ip1_list)) :: aa_8,bb_8
    logical :: found,my_in_log

    ! Set error status
    status = GD_ERROR

    ! Set size of output
    nk = size(ip1_list)
    
    ! Find ip1 values
    do i=1,nk
       found = .false.
       do j=1,size(self%zz%ip1_m)
          if (self%zz%ip1_m(j) == ip1_list(i)) then
             found = .true.
             aa_8(i) = self%zz%a_m_8(j)
             bb_8(i) = self%zz%b_m_8(j)
             exit
          endif
       enddo
       if (.not.found) then
          write(STDERR,*) 'ERROR: cannot find ip1 ',ip1_list(i),' in compute_pressure_1002'
          return
       endif
    enddo

    ! Compute pressure
    do i=1,nk
       levels(:,:,i) = aa_8(i) + bb_8(i)*sfc_field
    enddo
    if (in_log) levels = log(levels)

    ! Set status and return
    status = GD_OK
    return
 end function compute_pressure_1002

  integer function compute_pressure_2001(self,ip1_list,levels,in_log) result(status)
    ! Compute pressure for all levels specified in ip1_list
    type(grid_descriptor), intent(in) :: self           !Descriptor instance
    integer, dimension(:), intent(in) :: ip1_list       !List of IP1 levels to calculate on
    real, dimension(:,:,:), pointer  :: levels          !Physical level values
    logical, intent(in) :: in_log                       !Compute level values in ln()

    ! Local variables
    integer :: i,j,nk
    real*8, dimension(size(ip1_list)) :: aa_8,bb_8
    logical :: found
    
    ! Set error status
    status = GD_ERROR
    
    ! Set size of output
    nk = size(ip1_list)

    ! Find ip1 values
    do i=1,nk
       found = .false.
       do j=1,size(self%zz%ip1_m)
          if (self%zz%ip1_m(j) == ip1_list(i)) then
             found = .true.
             aa_8(i) = self%zz%a_m_8(j)
             bb_8(i) = self%zz%b_m_8(j)
          endif
       enddo
       if (.not.found) then
          write(STDERR,*) 'ERROR: cannot find ip1 ',ip1_list(i),' in compute_pressure_2001'
          return
       endif
    enddo

    ! Compute pressure
    do i=1,nk
       levels(:,:,i) = aa_8(i) + 0.d0*bb_8(i)
    enddo
    if (in_log) levels = log(levels)

    ! Set status and return
    status = GD_OK
    return

  end function compute_pressure_2001

  integer function compute_pressure_5001(self,sfc_field,ip1_list,levels,in_log) result(status)
    ! Compute pressure for all levels specified in ip1_list
    type(grid_descriptor), intent(in) :: self           !Descriptor instance
    real, dimension(:,:), intent(in) :: sfc_field       !Surface field reference for coordinate
    integer, dimension(:), intent(in) :: ip1_list       !List of IP1 levels to calculate on
    real, dimension(:,:,:), pointer  :: levels          !Physical level values
    logical, intent(in) :: in_log                       !Compute level values in ln()

    ! Internal variables
    integer :: i,j,error,nk
    real*8, dimension(size(sfc_field,dim=1),size(sfc_field,dim=2)) :: s_8
    real*8, dimension(size(ip1_list)) :: aa_8,bb_8
    logical :: found,my_in_log

    ! Set error status
    status = GD_ERROR

    ! Set size of output
    nk = size(ip1_list)
    
    ! Find ip1 values
    do i=1,nk
       found = .false.
       do j=1,size(self%zz%ip1_m)
          if (self%zz%ip1_m(j) == ip1_list(i)) then
             found = .true.
             aa_8(i) = self%zz%a_m_8(j)
             bb_8(i) = self%zz%b_m_8(j)
             exit
          endif
       enddo
       if (.not.found) then
          write(STDERR,*) 'ERROR: cannot find ip1 ',ip1_list(i),' in compute_pressure_5001'
          return
       endif
    enddo

    ! Compute pressure
    do i=1,nk
       levels(:,:,i) = aa_8(i) + bb_8(i)*sfc_field
    enddo
    if (in_log) levels = log(levels)

    ! Set status and return
    status = GD_OK
    return
 end function compute_pressure_5001

  integer function compute_pressure_5002(self,sfc_field,ip1_list,levels,in_log) result(status)
    ! Compute pressure for all levels specified in ip1_list
    type(grid_descriptor), intent(in) :: self           !Descriptor instance
    real, dimension(:,:), intent(in) :: sfc_field       !Surface field reference for coordinate
    integer, dimension(:), intent(in) :: ip1_list       !List of IP1 levels to calculate on
    real, dimension(:,:,:), pointer  :: levels          !Physical level values
    logical, intent(in) :: in_log                       !Compute level values in ln()

    ! Internal variables
    integer :: i,j,error,nk
    real*8, dimension(size(sfc_field,dim=1),size(sfc_field,dim=2)) :: s_8
    real*8, dimension(size(ip1_list)) :: aa_8,bb_8
    logical :: found,my_in_log

    ! Set error status
    status = GD_ERROR

    ! Set size of output
    nk = size(ip1_list)
    
    ! Find ip1 values
    do i=1,nk
       found = .false.
       do j=1,size(self%zz%ip1_m)
          if (self%zz%ip1_m(j) == ip1_list(i)) then
             found = .true.
             aa_8(i) = self%zz%a_m_8(j)
             bb_8(i) = self%zz%b_m_8(j)
             exit
          endif
       enddo
       if (.not.found) then
          do j=1,size(self%zz%ip1_t)
             if (self%zz%ip1_t(j) == ip1_list(i)) then
                found = .true.
                aa_8(i) = self%zz%a_t_8(j)
                bb_8(i) = self%zz%b_t_8(j)
                exit
             endif
          enddo
       endif
       if (.not.found) then
          write(STDERR,*) 'ERROR: cannot find ip1 ',ip1_list(i),' in compute_pressure_5002'
          return
       endif
    enddo

    ! Compute pressure
    s_8 = log(dble(sfc_field)/self%zz%pref_8)
    do i=1,nk
       levels(:,:,i) = aa_8(i) + bb_8(i)*s_8
    enddo
    if (.not.in_log) levels = exp(levels)

    ! Set status and return
    status = GD_OK
    return
 end function compute_pressure_5002

end module Grid_Descriptors
