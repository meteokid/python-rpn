*** s/r uvs2psd - Computes model coordinate vertical velocity "psd"
*                 diagnostically.
*
#include "model_macros_f.h"
*
      subroutine uvs2psd (F_psd, F_uu, F_vv, F_csh, DIST_DIM, Nk)
*
      implicit none
*
      integer DIST_DIM, Nk
      real    F_psd(DIST_SHAPE,Nk+1), F_csh(DIST_SHAPE),
     $        F_uu(DIST_SHAPE,Nk), F_vv (DIST_SHAPE,Nk)
*
*authors
*      Plante A. juin 2006 based on Methot et Patoine - sept 1995 - cmc
*
*revision
*
*arguments
*______________________________________________________________________
*        |                                             |           |   |
* NAME   |             DESCRIPTION                     | DIMENSION |I/O|
*--------|---------------------------------------------|-----------|---|
* F_psd  | vertical velocity ( pi*-dot )               | 3D (Nk+1) | o |
*--------|---------------------------------------------|-----------|---|
* F_uu   | x component of velocity                     | 3D (Nk)   | i |
* F_vv   | y component of velocity                     | 3D (Nk)   | i |
* F_csh  | 2.*exp(s*.5).*sinh(s*.5);                   | 2D (1)    | i |
*________|_____________________________________________|___________|___|
*
*implicits
#include "glb_ld.cdk"
#include "geomg.cdk"
#include "intuv.cdk"
#include "type.cdk"
#include "ver.cdk"
*
*modules
*
      integer i, j, k,i0,in,j0,jn
      real pr1, pr2
      real uv(DIST_SHAPE,Nk,2),dvi(DIST_SHAPE,Nk+1)
      real w2(DIST_SHAPE,Nk),pi(DIST_SHAPE)
**
*     ________________________________________________________________
*

c      call glbstat (F_csh,'csh',LDIST_DIM,1,LDIST_DIM,1,1)

      call rpn_comm_xch_halo( F_csh, LDIST_DIM, l_ni, l_nj , 1,
     %                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
*
c      call glbstat (F_uu,'uu',LDIST_DIM,G_nk,LDIST_DIM,1,G_nk  )
c      call glbstat (F_vv,'vv',LDIST_DIM,G_nk,LDIST_DIM,1,G_nk  )
!$omp parallel private (pr1,pr2)
*              __              *
*     compute  \/ . ( V dpi/dpi )
*
!$omp do
      do k=1,G_nk
         do j = 1, l_nj
         do i = 1, l_niu
            uv(i,j,k,1) = F_uu(i,j,k) * (
     $      (1.-intuv_c0xxu_8(i))*(1.+(ver_dpib_8%m(k)*F_csh(i,j)))
     $       +  intuv_c0xxu_8(i) *(1.+(ver_dpib_8%m(k)*F_csh(i+1,j))) )
         end do
         end do
         do j = 1, l_njv
         do i = 1, l_ni
            uv(i,j,k,2) = F_vv(i,j,k) * (
     $      (1.-intuv_c0yyv_8(j))*(1.+(ver_dpib_8%m(k)*F_csh(i,j)))
     $       +  intuv_c0yyv_8(j) *(1.+(ver_dpib_8%m(k)*F_csh(i,j+1))) )
         end do
         end do
      end do
!$omp enddo
*
c      call glbstat (uv(l_minx,l_miny,1,1),'Buv1',LDIST_DIM,G_nk,1,l_niu,1,l_nj ,1,G_nk)
c      call glbstat (uv(l_minx,l_miny,1,2),'Buv2',LDIST_DIM,G_nk,1,l_ni ,1,l_njv,1,G_nk)
!$omp single
      call rpn_comm_xch_halo (uv,                    LDIST_DIM, l_niu,l_nj,
     $                 G_nk,G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo (uv(l_minx,l_miny,1,2), LDIST_DIM, l_ni,l_njv,
     $                 G_nk,G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
!$omp end single
*
!$omp do
      do k=1,G_nk
         call caldiv_2 ( w2(l_minx,l_miny,k), uv(l_minx,l_miny,k,1), 
     $                   uv(l_minx,l_miny,k,2), LDIST_DIM, 1 )
      end do
!$omp enddo
*
*                   *
*                 pi
*                /  gnk
*                |   __             *      *
*     compute    |   \/ . ( V dpi/dpi ) dpi
*                |
*                /  *
*                 pi
*                   k
*
!$omp single

c      call glbstat (uv(l_minx,l_miny,1,1),'Auv1',LDIST_DIM,G_nk,1,l_niu,1,l_nj ,1,G_nk)
c      call glbstat (uv(l_minx,l_miny,1,2),'Auv2',LDIST_DIM,G_nk,1,l_ni ,1,l_njv,1,G_nk)

      i0=1
      in=l_niu      
      j0=1
      jn=l_nj
      if (G_lam)then
         if(l_west)  i0 = 2
         if(l_south) j0 = 2
         if(l_north) jn = l_njv
      endif
c      call glbstat (w2,'w2',LDIST_DIM,G_nk,i0,in,j0,jn,1,G_nk)
      call intm2t (dvi,w2,1.0,ver_hz_8%m,LDIST_DIM,G_nk,i0,in,j0,jn)
c      call glbstat (dvi,'dvi',LDIST_DIM,G_nk+1,i0,in,j0,jn,1,G_nk+1)

!$omp end single
*
*                .*
*     compute pi
*                k
*
!$omp do
      do k=1,G_nk+1
         if (G_lam)then
c           For glbstat only.
            F_psd(1:l_ni,1:l_nj,k)=0.
         endif
         if(k.eq.1.or.k.eq.G_nk+1)then
            F_psd(i0:in,j0:jn,k) = 0.
         else
            do j=j0,jn
            do i=i0,in
               pr1 = 1.0 + ver_dpib_8%t(k) * F_csh(i,j)
               F_psd(i,j,k) = ( ( ver_z_8%t(k)*ver_boz_8%t(k)/
     $           (ver_z_8%t(G_nk+1)*ver_boz_8%t(G_nk+1)) -1.)* dvi(i,j,1) 
     $           + dvi(i,j,k)
     $           )/pr1
            end do
            end do
         endif
      end do
!$omp enddo
*
!$omp end parallel
*
*     ________________________________________________________________
*
      return
      end

