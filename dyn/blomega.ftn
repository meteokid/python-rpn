***s/r blomega - output omega, and omega related variables
*
#include <model_macros_f.h>
*
      subroutine blomega(F_dostep,F_dostep_max)
*
#include "impnone.cdk"
*
      integer F_dostep(*)
      integer F_dostep_max
*
*author
*     james caveen/andre methot - rpn july/nov 1995
*
*revision
* v2_00 - Lee V.            - initial MPI version (from blomega v1_03)
* v2_21 - J. P. Toviessi    - set dieze (#) slab output and rename 
* v2_21                       truncate model output names to 4 characters
* v2_30 - Lee V.            - reorganize slab output to be more efficient
* v2_31 - Lee V.            - minimize size of local dynamic memory
* v2_31 - Moffet R.         - ZZ computed for output (dz/dt)
* v2_32 - Lee V.            - reduce dynamic allocation size
* v3_00 - Desgagne & Lee    - Lam configuration
*
*object
*     See above id.
*	
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_dostep     I    - array containing indices corresponding to the
*                     timestep sets that requires output at this time step.
* F_dostep_max I    - size of F_dostep array
*
*
*implicits
#include "glb_ld.cdk"
#include "dimout.cdk"
#include "vt1.cdk"
#include "geomg.cdk"
#include "lun.cdk"
#include "out.cdk"
#include "out2.cdk"
#include "setsor.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "dslab.cdk"
#include "grid.cdk"
*
*modules
      integer  vmmlod, vmmuld, vmmget, vmmuln, vmmulk, getvndx
      external vmmlod, vmmuld, vmmget, vmmuln, vmmulk, getvndx
*
**
      integer cnmvar, cn3dvar, cnnkey
      parameter (cnmvar = 6, cn3dvar = 3, cnnkey= 5)
*
*    declaration for local work array and pointer for loading each field
*
      integer pnkey,pni3dx(cn3dvar),pni3d,pnww3d,levset,i0,in,j0,jn
      integer pnlkey(cnnkey),pnindex
      integer pnerr, i,j,k,ii,jj,kk,iii,jjj
      character*8 ptmvar(cnmvar), pt3dvar(cn3dvar)
      logical pl3dvar(cn3dvar)
      real prprlvl
      real prmult(cn3dvar),  pradd(cn3dvar)

      real w1(LDIST_SHAPE), w2(LDIST_SHAPE)
      real t1(LDIST_SHAPE,G_nk), t2(LDIST_SHAPE,G_nk),
     $     t3(LDIST_SHAPE,G_nk)
*
*     Declarations for slab output
      integer mxout_p,mxout_e
      character*4, dimension(:,:),allocatable :: var_e_S,var_p_S
      character*1, dimension(:,:),allocatable :: typvar_e_S,typvar_p_S
      integer,     dimension(:,:),allocatable :: ip1_e,  ip1_p
      integer,     dimension(:,:),allocatable :: bit_e,  bit_p
      real,        dimension(:,:),allocatable :: mtval_e,mtval_p
      integer,     dimension(:),  allocatable :: mtout_e,mtout_p
      integer,     dimension(:,:),allocatable :: xnio
* ___________________________________________________________________
*
*     1.0     initialization of data
*_______________________________________________________________________
*
*     lists of model variables that can be output by blomega
*     at time levels t0,t2,th and t1
      data ptmvar /
     $     'PSD0','TDT0','PSDH','PSD1','TDT1','ZZ1'/
*     list of derived 3-D variables that may be produced by blomega
      data pt3dvar /'WW','WE','ZZ'/
      integer pnww,pnwe,pnzz,pnindex
*     index of each symbol in the list
      data pnww,pnwe,pnzz
     $    /   1,   2,   3/
*
*     initialize conversion of units
*
      data prmult / cn3dvar*1.0 /
      data pradd  / cn3dvar*0.0 /
      prmult(pnwe) = 1.0 / (Geomg_z_8(l_nk) - Geomg_z_8(1))
*_______________________________________________________________________
*
*   check if output is required for the 3-D model variables
*
      pni3d = 0
      do i=1,cnmvar
         pnindex=getvndx(ptmvar(i))
         if (pnindex.gt.0) then
             pni3d = pni3d + Setsor_useit(pnindex)
         else
            if (Lun_out.gt.0) write(Lun_out,*)
     $           'Error in BLOMEGA:INDEX not found for ',ptmvar(i)
            stop
         endif
      enddo

      if (pni3d.gt.0) then
          call slab3dvar(ptmvar,cnmvar,F_dostep,F_dostep_max,0)
      endif
*
*   check if output is required for the 3-D derived variables
      pni3d = 0
      pnww3d=0
      do i=1,cn3dvar
         pni3dx(i)=getvndx(pt3dvar(i))
         if (pni3dx(i).gt.0) then
             pni3d = pni3d + Setsor_useit(pni3dx(i))
             if (i.eq.1) then
                 pnww3d = Setsor_useit(pni3dx(i))
             endif
         else
            if (Lun_out.gt.0) write(Lun_out,*)
     $           'Error in BLOMEGA:INDEX not found for ',pt3dvar(i)
            stop
         endif
      enddo
      if(pni3d .le. 0) then
*        no more output required
            return
      endif

* NOTE: WW is the only variable that can be outputted on both pressure
*       and eta levels while the other variables are outputted in ETA only.
*       Therefore, memory is allocated all at once and the logic in
*       determining what is needed to be outputted is done once. If any
*       more variables are needed to be outputted in pressure variables,
*       this routine should be re-structured like BLOCTHM.
*
      mxout_p = 1 + pnww3d*Dslab_max_lev_p
      mxout_e = 1 + pni3d*l_nk
      allocate ( var_e_S(mxout_e,Grid_sets),
     %           typvar_e_S(mxout_e,Grid_sets),
     %           ip1_e(mxout_e,Grid_sets),
     %           bit_e(mxout_e,Grid_sets),
     %           mtval_e(LDIST_SIZ*mxout_e,Grid_sets),
     %           mtout_e(Grid_sets),
     %           var_p_S(mxout_p,Grid_sets),
     %           typvar_p_S(mxout_p,Grid_sets),
     %           ip1_p(mxout_p,Grid_sets),
     %           bit_p(mxout_p,Grid_sets),
     %           mtval_p(LDIST_SIZ*mxout_p,Grid_sets),
     %           mtout_p(Grid_sets),
     %           xnio(LDIST_SIZ,Grid_sets) )
      call set_dslab(0,xnio,LDIST_SIZ,Grid_sets)
*
      do i=1,Grid_sets
         mtout_e(i)=0
         mtout_p(i)=0
      enddo
*_______________________________________________________________________
*
*     4.0    Load and Get required fields
*_______________________________________________________________________

         pnlkey(1) = VMM_KEY(psdt1)
         pnlkey(2) = VMM_KEY(tdt1)
         pnlkey(3) = VMM_KEY(st1)
         pnlkey(4) = VMM_KEY(fit1)
         pnlkey(5) = VMM_KEY(zz1)
*
         pnerr = vmmlod(pnlkey,5)
*
         pnerr = VMM_GET_VAR(psdt1)
         pnerr = VMM_GET_VAR(tdt1)
         pnerr = VMM_GET_VAR(st1)
         pnerr = VMM_GET_VAR(fit1)
         pnerr = VMM_GET_VAR(zz1)

*_______________________________________________________________________
*
*     5.0    Computations for Vertical motions
*_______________________________________________________________________
*
         i0 = 1   
         in = l_ni
         j0 = 1   
         jn = l_nj
         if (Setsor_useit(pni3dx(pnww)).ge.1) then
             call calomeg(t1, psdt1, tdt1, st1, LDIST_DIM, G_nk,
     $                                         i0,in,j0,jn)
             call verder (t2,t1,Out2_wlnph,2.0,2.0,LDIST_DIM,G_nk,
     $                                         i0,in,j0,jn)
         endif
         if (Setsor_useit(pni3dx(pnzz)).ge.1) then
*
             call calzz(t3, fit1, zz1, LDIST_DIM, G_nk,
     $                                         i0,in,j0,jn)
         endif

*
         do 100 jj=1,F_dostep_max
*        For every Timestep set that outputs at the current timestep

            do 80 kk=1,Outd_sets

               if (Outd_step(kk).eq.F_dostep(jj))then
*     if the Timestep set for this request set Outd(kk) outputs
*     at the current timestep (Lctl_step)

                  levset = Outd_lev(kk)

                  do 70 ii=1,Outd_var_max(kk)
                     pnkey = 0
                     do i=1,cn3dvar
                        if (Outd_var(ii,kk).eq.pni3dx(i)) then
*                       if 3-D variable is found in this request set
                            pl3dvar(i) = .true.
                            pnkey=pnkey+1
                        else
                            pl3dvar(i) = .false.
                        endif
                     enddo
                     if (pnkey.gt.0) then
*_______________________________________________________________________
*
*     7.0A   Output (WW,WE,ZZ) on ETA levels
*_______________________________________________________________________
                       if (Level_typ(levset) .eq. 'E') then
*
                         do 50 jjj = 1, Level_max(levset)
                           k = nint(Level(jjj,levset))
                           if (pl3dvar(pnww)) then
                              call insrtslab_d(t1,w1,LDIST_DIM,G_nk,k,
     $                        kk,prmult(pnww),pradd(pnww),pni3dx(pnww),
     $                        Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                        typvar_e_S,ip1_e,bit_e,mtval_e,
     $                        LDIST_SIZ,mxout_e,Grid_sets)
                           endif
                           if (pl3dvar(pnwe)) then
                              call insrtslab_d(psdt1,w1,LDIST_DIM,G_nk,k,
     $                        kk,prmult(pnwe),pradd(pnwe),pni3dx(pnwe),
     $                        Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                        typvar_e_S,ip1_e,bit_e,mtval_e,
     $                        LDIST_SIZ,mxout_e,Grid_sets)
                           endif
                           if (pl3dvar(pnzz)) then
                              call insrtslab_d(t3,w1,LDIST_DIM,G_nk,k,
     $                        kk,prmult(pnzz),pradd(pnzz),pni3dx(pnzz),
     $                        Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                        typvar_e_S,ip1_e,bit_e,mtval_e,
     $                        LDIST_SIZ,mxout_e,Grid_sets)
                           endif
                           
 50                      continue
                       else
*                ...assume pressure levels
*_______________________________________________________________________
*
*     7.0B   Output WW on PRESSURE levels
*     note only for WW because WE is really PSDT1 on eta and not useful for ZZ
*_______________________________________________________________________
*
                          do jjj = 1, Level_max(levset)
                             prprlvl = Level(jjj,levset) * 100.0
                             if (pl3dvar(pnww)) then
                                 call prgen(w2,t1,t2,Out2_wlnph,prprlvl,
     $                                Out_cubww_L,LDIST_DIM,G_nk)
                                 call insrtslab_d(w2,w1,LDIST_DIM,1,1,
     $                               kk,prmult(pnww),pradd(pnww),pni3dx(pnww),
     $                               Level_ip1(jjj,levset),mtout_p, var_p_S,
     $                               typvar_p_S,ip1_p,bit_p,mtval_p,
     $                               LDIST_SIZ,mxout_p,Grid_sets)
                             endif
                          enddo
                       endif
                     endif
 70               continue
               endif
 80         continue
 100     continue
*     
*     unload work fields and unlock global output fields
*
      pnerr = vmmuln(pnlkey,5)
*
* ___________________________________________________________________
      call writslab_d(Dslab_fhand_e,Dslab_slab_e,Dslab_nnio,'dm',
     %                Dslab_ext_S,mtout_e, var_e_S,typvar_e_S,ip1_e,bit_e,
     %                mtval_e,xnio,LDIST_SIZ,mxout_e,Grid_sets)
      call writslab_d(Dslab_fhand_p,Dslab_slab_p,Dslab_nnio,'dp',
     %                Dslab_ext_S,mtout_p, var_p_S,typvar_p_S,ip1_p,bit_p,
     %                mtval_p,xnio,LDIST_SIZ,mxout_p,Grid_sets)
      deallocate ( var_e_S, ip1_e, bit_e, mtval_e, typvar_e_S,
     %             var_p_S, ip1_p, bit_p, mtval_p, typvar_p_S,
     %             xnio )
* ___________________________________________________________________
      return
      end
