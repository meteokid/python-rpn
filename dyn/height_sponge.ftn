! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------

***s/r  pressure_sponge -  Performs vertical blending
*
#include "model_macros_f.h"
*
      subroutine height_sponge ()
      implicit none
*author 
*     Plante A.           - May 2004 
*
*revision
*
*object
*
*arguments
*       none
*
*implicits
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "vt1.cdk"
#include "schm.cdk"
#include "nest.cdk"
#include "lun.cdk"
#include "zblen.cdk"
#include "dcst.cdk"
#include "mtn.cdk"
#include "p_geof.cdk"
#include "geomg.cdk"
#include "ptopo.cdk"
*
      integer  vmmlod,vmmget,vmmuld
      external vmmlod,vmmget,vmmuld
*
      integer err,key(7),i,j,k,nvar, longueur
      integer n

      real betav_m(LDIST_SHAPE,l_nk),betav_t(LDIST_SHAPE,l_nk+1),ubar
      real fi_t(LDIST_SHAPE,l_nk+1)

*----------------------------------------------------------------------
*
      key(1)=VMM_KEY(ut1)
      key(2)=VMM_KEY(vt1)
      key(3)=VMM_KEY(wt1)
      key(4)=VMM_KEY(tt1)
      key(5)=VMM_KEY(st1)
      nvar = 5
*
      if (.not.Schm_hydro_L) then
         key(6)=VMM_KEY(qt1)
         nvar = 6
      endif
*
      err = vmmlod(key,nvar)
      err = VMM_GET_VAR(ut1)
      err = VMM_GET_VAR(vt1)
      err = VMM_GET_VAR(wt1)
      err = VMM_GET_VAR(tt1)
      err = VMM_GET_VAR(st1)
      if (.not.Schm_hydro_L) then
         err = VMM_GET_VAR(qt1)
      else
         qt1_= 0
      endif
*
      call set_betav(betav_m,betav_t,st1,LDIST_DIM,l_nk)

      ubar=mtn_flo/Dcst_rayt_8

      call apply(ut1  ,ubar,betav_m,LDIST_DIM, l_nk)
      call apply(vt1  ,0.  ,betav_m,LDIST_DIM, l_nk)
      call apply(wt1  ,0.  ,betav_t,LDIST_DIM, l_nk+1)
      if(.not.Schm_hydro_L) then
         call apply(qt1(l_minx,l_miny,1),0.,betav_m,LDIST_DIM, l_nk)
         do j=1,l_nj
         do i=1,l_ni
            qt1(i,j,0)=-qt1(i,j,1)
         enddo
         enddo
      endif
      if(Zblen_spngtt_L)then
         call apply_tt(tt1,betav_t,st1,LDIST_DIM, l_nk)
      endif
*
      err = vmmuld(key,nvar)
*
*----------------------------------------------------------------------
      return
      end

c=======================================================================
#include "model_macros_f.h"

      subroutine apply(ff,value,betav, DIST_DIM, Nk)

      implicit none

      integer  DIST_DIM, Nk 

#include "glb_pil.cdk"
#include "glb_ld.cdk"

      real ff(DIST_SHAPE,Nk),value,betav(DIST_SHAPE,Nk)

      integer i,j,k,i0,in,j0,jn 

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj     
      if (l_west ) i0 = 1+pil_w
      if (l_east ) in = l_ni-pil_e
      if (l_south) j0 = 1+pil_s
      if (l_north) jn = l_nj-pil_n

      do k=1,Nk
         do j=j0,jn
            do i=i0,in
               ff(i,j,k)=(1.-betav(i,j,k))*ff(i,j,k)+betav(i,j,k)*value
            enddo
         enddo
      enddo
      
      return

      end
c=======================================================================
#include "model_macros_f.h"

      subroutine apply_tt(tt,betav_t, F_s,DIST_DIM, Nk)

      implicit none

      integer  DIST_DIM, Nk 

#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "mtn.cdk"
#include "cstv.cdk"
#include "type.cdk"
#include "ver.cdk"

      real tt(DIST_SHAPE,Nk+1),F_s(DIST_SHAPE)
      real betav_t(DIST_SHAPE,Nk+1)

      real capc1,my_tt,a00,a02,tempo,hauteur

      integer i,j,k,i0,in,j0,jn 

      a00 = mtn_nstar * mtn_nstar/Dcst_grav_8
      capc1 = Dcst_grav_8*Dcst_grav_8/(mtn_nstar*mtn_nstar*Dcst_cpd_8*mtn_tzero)

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj     
      if (l_west ) i0 = 1+pil_w
      if (l_east ) in = l_ni-pil_e
      if (l_south) j0 = 1+pil_s
      if (l_north) jn = l_nj-pil_n

      do k=1,Nk
         do j=j0,jn
            do i=i0,in
               tempo = exp(Ver_z_8%t(k)+Ver_b_8%t(k)*F_s(i,j))
               a02 = (tempo/Cstv_pisrf_8)**Dcst_cappa_8
               hauteur=-log((capc1-1.+a02)/capc1)/a00
               my_tt=mtn_tzero*((1.-capc1)*exp(a00*hauteur)+capc1)
               tt(i,j,k)=(1.-betav_t(i,j,k))*tt(i,j,k)+
     $              betav_t(i,j,k)*my_tt
            enddo
         enddo
      enddo
      
      return

      end
c=======================================================================
