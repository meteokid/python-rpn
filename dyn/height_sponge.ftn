
***s/r  height_sponge -  Performs vertical blending
*
#include "model_macros_f.h"
*
      subroutine height_sponge ()
      implicit none
*author 
*     Plante A.           - May 2004 
*
*revision
*
*object
*
*arguments
*       none
*
*implicits
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "vt0.cdk"
#include "vtx.cdk"
#include "func.cdk"
#include "schm.cdk"
#include "nest.cdk"
#include "lun.cdk"
#include "zblen.cdk"
#include "dcst.cdk"
#include "mtn.cdk"
#include "p_geof.cdk"
#include "geomg.cdk"
#include "ptopo.cdk"
#include "matlab.cdk"
*
      integer  vmmlod,vmmget,vmmuld
      external vmmlod,vmmget,vmmuld
*
      integer err,key(9),i,j,k,nvar, longueur
      integer n

      real betav_m(LDIST_SHAPE,l_nk),betav_t(LDIST_SHAPE,l_nk+1),work
      real fi_t(LDIST_SHAPE,l_nk+1)

*----------------------------------------------------------------------
*
      key(1)=VMM_KEY(ut0)
      key(2)=VMM_KEY(vt0)
      key(3)=VMM_KEY(tt0)
      key(4)=VMM_KEY(psdt0)
      key(5)=VMM_KEY(fiptx)
      key(6)=VMM_KEY(topo)
      key(7)=VMM_KEY(csh)
      nvar = 7
*
      if (.not.Schm_hydro_L) then
         key(8)=VMM_KEY(wt0)
         key(9)=VMM_KEY(qsect0)
         nvar = 9
      endif
*
      err = vmmlod(key,nvar)
      err = VMM_GET_VAR(ut0)
      err = VMM_GET_VAR(vt0)
      err = VMM_GET_VAR(tt0)
      err = VMM_GET_VAR(psdt0)
      err = VMM_GET_VAR(fiptx)
      err = VMM_GET_VAR(topo)
      err = VMM_GET_VAR(csh)
      if (.not.Schm_hydro_L) then
         err = VMM_GET_VAR(wt0)
         err = VMM_GET_VAR(qsect0)
      else
         wt0_ = 0
         qsect0_= 0
      endif
*
      call set_betav(betav_m,betav_t,fi_t,fiptx,tt0,
     $     LDIST_DIM,l_nk)

      work=mtn_flo/Dcst_rayt_8

      if(matlab_write_L)then
         if(Ptopo_myproc.eq.0)then
            open(unit=62,file=
     $        matlab_dir_S(1:longueur(matlab_dir_S))//'from_fortran_height_sponge.bin',
     $           status='replace',form='unformatted')
            write(62)G_ni-lam_pil_w-lam_pil_e
            write(62)G_nk
         endif
         call write_matlab_3d(62,betav_m)
         call write_matlab_3d_th(62,betav_t)
         call write_matlab_3d(62,ut0)
         call write_matlab_3d_th(62,tt0)
         call write_matlab_3d_v(62,fiptx)
         if (.not.Schm_hydro_L) 
     &        call write_matlab_3d_th(62,wt0)
      endif

      call applique(ut0  ,work,betav_m,LDIST_DIM, l_nk)
      call applique(vt0  ,0.  ,betav_m,LDIST_DIM, l_nk)
      call applique(psdt0,0.  ,betav_t,LDIST_DIM, l_nk+1)
      if (.not.Schm_hydro_L) then
         call applique(wt0,0.    ,betav_t,LDIST_DIM, l_nk+1)
c        Note : qsect0 has l_nk+2 level but sponge is on top so
c               we drop the las level. Also, the weights could be
c               adjusted since these are momentum levels but betav_m
c               is only of lengh l_nk
         call applique(qsect0,0. ,betav_t,LDIST_DIM, l_nk+1)
      endif
      if(Zblen_spngtt_L)then
         call applique_tt(tt0,fi_t,betav_t,LDIST_DIM, l_nk)
*        Recomputing the geopotential from new t      
         call diag_fip(fiptx,csh,tt0,qsect0,topo,
     $                            LDIST_DIM,l_nk)         
      endif
*
      if(matlab_write_L)then
         call write_matlab_3d(62,ut0)
         call write_matlab_3d_th(62,tt0)
         call write_matlab_3d_v(62,fiptx)
         if (.not.Schm_hydro_L) 
     &        call write_matlab_3d_th(62,wt0)
         if(Ptopo_myproc.eq.0)close(62)
      endif

      err = vmmuld(key,nvar)
*
*----------------------------------------------------------------------
      return
      end

c=======================================================================
#include "model_macros_f.h"

      subroutine applique(ff,value,betav, DIST_DIM, Nk)

      implicit none

      integer  DIST_DIM, Nk 

#include "glb_pil.cdk"
#include "glb_ld.cdk"

      real ff(DIST_SHAPE,Nk),value,betav(DIST_SHAPE,Nk)

      integer i,j,k,i0,in,j0,jn 

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj     
      if (l_west ) i0 = 1+pil_w
      if (l_east ) in = l_ni-pil_e
      if (l_south) j0 = 1+pil_s
      if (l_north) jn = l_nj-pil_n

      do k=1,Nk
         do j=j0,jn
            do i=i0,in
               ff(i,j,k)=(1.-betav(i,j,k))*ff(i,j,k)+betav(i,j,k)*value
            enddo
         enddo
      enddo
      
      return

      end
c=======================================================================
#include "model_macros_f.h"

      subroutine applique_tt(tt,fi_t,betav_t, DIST_DIM, Nk)

      implicit none

      integer  DIST_DIM, Nk 

#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "mtn.cdk"

      real tt(DIST_SHAPE,Nk+1),fi_t(DIST_SHAPE,Nk+1)
      real betav_t(DIST_SHAPE,Nk+1)

      real capc1,my_tt,a00

      integer i,j,k,i0,in,j0,jn 

      a00 = mtn_nstar * mtn_nstar/Dcst_grav_8
      capc1 = Dcst_grav_8*Dcst_grav_8/(mtn_nstar*mtn_nstar*Dcst_cpd_8*mtn_tzero)

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj     
      if (l_west ) i0 = 1+pil_w
      if (l_east ) in = l_ni-pil_e
      if (l_south) j0 = 1+pil_s
      if (l_north) jn = l_nj-pil_n

      do k=1,Nk
         do j=j0,jn
            do i=i0,in
               my_tt=mtn_tzero*((1.-capc1)*
     $              exp(a00*fi_t(i,j,k)/Dcst_grav_8)+capc1)
               tt(i,j,k)=(1.-betav_t(i,j,k))*tt(i,j,k)+
     $              betav_t(i,j,k)*my_tt
            enddo
         enddo
      enddo
      
      return

      end
c=======================================================================
#include "model_macros_f.h"

      subroutine set_betav(betav_m,betav_t,fi_t,fip,tt, DIST_DIM, Nk)

      implicit none

      integer  DIST_DIM, Nk 

#include "glb_pil.cdk"
#include "cstv.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "zblen.cdk"

      real betav_m(DIST_SHAPE,Nk),betav_t(DIST_SHAPE,Nk+1)
      real fip(DIST_SHAPE,0:Nk+1),tt(DIST_SHAPE,Nk)
      real fi_t(DIST_SHAPE,Nk+1)

      real*8 work1,work2

      integer i,j,k,i0,in,j0,jn 

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj     
      if (l_west ) i0 = 1+pil_w
      if (l_east ) in = l_ni-pil_e
      if (l_south) j0 = 1+pil_s
      if (l_north) jn = l_nj-pil_n

c     Compute PHI on thermo level
      do k=2,l_nk
         do j=j0,jn
            do i=i0,in
               fi_t(i,j,k) = .5d0*(fip(i,j,k)+Ver_fistr_8%m(k)
     $                       +fip(i,j,k-1)+Ver_fistr_8%m(k-1))
            enddo
         enddo
      enddo
      do j=j0,jn
         do i=i0,in
c           fi_t(i,j,1)=fi(i,j,1)
            fi_t(i,j,1)=.5d0*(fip(i,j,1)+fip(i,j,0))
     $                    +Ver_fistr_8%m(1)
            fi_t(i,j,Nk+1)=.5d0*(fip(i,j,Nk+1)+fip(i,j,Nk))
         enddo
      enddo
      do k=1,l_nk
         do j=j0,jn
            do i=i0,in
               work1=(fip(i,j,k)+Ver_fistr_8%m(k))/Dcst_grav_8-Zblen_hmin
               work2=(fip(i,j,1)+Ver_fistr_8%m(1))/Dcst_grav_8-Zblen_hmin
               work1=min(1.d0,max(0.d0,work1/work2))
               betav_m(i,j,k)=work1*work1
               work1=fi_t(i,j,k)/Dcst_grav_8-Zblen_hmin
               work1=min(1.d0,max(0.d0,work1/work2))
               betav_t(i,j,k)=work1*work1
            enddo
         enddo
      enddo

c     Set betav_ to zero at surface.
      k=l_nk+1
      do j=j0,jn
         do i=i0,in
            betav_t(i,j,k)=0.
         enddo
      enddo

      return

      end
