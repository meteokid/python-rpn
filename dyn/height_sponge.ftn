
***s/r  height_sponge -  Performs vertical blending
*
#include "model_macros_f.h"
*
      subroutine height_sponge ()
      implicit none
*author 
*     Plante A.           - May 2004 
*
*revision
*
*object
*
*arguments
*       none
*
*implicits
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "vt1.cdk"
#include "vtx.cdk"
#include "func.cdk"
#include "schm.cdk"
#include "nest.cdk"
#include "lun.cdk"
#include "zblen.cdk"
#include "dcst.cdk"
#include "mtn.cdk"
#include "p_geof.cdk"
#include "geomg.cdk"
#include "ptopo.cdk"
*
      integer  vmmlod,vmmget,vmmuld
      external vmmlod,vmmget,vmmuld
*
      integer err,key(9),i,j,k,nvar, longueur
      integer n

      real betav_m(LDIST_SHAPE,l_nk),betav_t(LDIST_SHAPE,l_nk+1),work
      real fi_t(LDIST_SHAPE,l_nk+1)

*----------------------------------------------------------------------
*
      key(1)=VMM_KEY(ut1)
      key(2)=VMM_KEY(vt1)
      key(3)=VMM_KEY(tt1)
      key(4)=VMM_KEY(zdt1)
      key(5)=VMM_KEY(fiptx)
      key(6)=VMM_KEY(topo)
      key(7)=VMM_KEY(st1)
      nvar = 7
*
      if (.not.Schm_hydro_L) then
         key(8)=VMM_KEY(wt1)
         key(9)=VMM_KEY(qt1)
         nvar = 9
      endif
*
      err = vmmlod(key,nvar)
      err = VMM_GET_VAR(ut1)
      err = VMM_GET_VAR(vt1)
      err = VMM_GET_VAR(tt1)
      err = VMM_GET_VAR(zdt1)
      err = VMM_GET_VAR(fiptx)
      err = VMM_GET_VAR(topo)
      err = VMM_GET_VAR(st1)
      if (.not.Schm_hydro_L) then
         err = VMM_GET_VAR(wt1)
         err = VMM_GET_VAR(qt1)
      else
         wt1_ = 0
         qt1_= 0
      endif
*
      call set_betav(betav_m,betav_t,fi_t,fiptx,tt1,
     $     LDIST_DIM,l_nk)

      work=mtn_flo/Dcst_rayt_8

      call applique(ut1  ,work,betav_m,LDIST_DIM, l_nk)
      call applique(vt1  ,0.  ,betav_m,LDIST_DIM, l_nk)
      call applique(zdt1 ,0.  ,betav_t,LDIST_DIM, l_nk+1)
      if (.not.Schm_hydro_L) then
         call applique(wt1,0.    ,betav_t,LDIST_DIM, l_nk+1)
c        Note : qt1 has l_nk+2 level but sponge is on top so
c               we drop the las level. Also, the weights could be
c               adjusted since these are momentum levels but betav_m
c               is only of lengh l_nk
         call applique(qt1,0. ,betav_t,LDIST_DIM, l_nk+1)
      endif
      if(Zblen_spngtt_L)then
         call applique_tt(tt1,fi_t,betav_t,LDIST_DIM, l_nk)
*        Recomputing the geopotential from new t      
         call diag_fip(fiptx,st1,tt1,qt1,topo,
     $                            LDIST_DIM,l_nk)         
      endif
*
      err = vmmuld(key,nvar)
*
*----------------------------------------------------------------------
      return
      end

c=======================================================================
#include "model_macros_f.h"

      subroutine applique(ff,value,betav, DIST_DIM, Nk)

      implicit none

      integer  DIST_DIM, Nk 

#include "glb_pil.cdk"
#include "glb_ld.cdk"

      real ff(DIST_SHAPE,Nk),value,betav(DIST_SHAPE,Nk)

      integer i,j,k,i0,in,j0,jn 

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj     
      if (l_west ) i0 = 1+pil_w
      if (l_east ) in = l_ni-pil_e
      if (l_south) j0 = 1+pil_s
      if (l_north) jn = l_nj-pil_n

      do k=1,Nk
         do j=j0,jn
            do i=i0,in
               ff(i,j,k)=(1.-betav(i,j,k))*ff(i,j,k)+betav(i,j,k)*value
            enddo
         enddo
      enddo
      
      return

      end
c=======================================================================
#include "model_macros_f.h"

      subroutine applique_tt(tt,fi_t,betav_t, DIST_DIM, Nk)

      implicit none

      integer  DIST_DIM, Nk 

#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "mtn.cdk"

      real tt(DIST_SHAPE,Nk+1),fi_t(DIST_SHAPE,Nk+1)
      real betav_t(DIST_SHAPE,Nk+1)

      real capc1,my_tt,a00

      integer i,j,k,i0,in,j0,jn 

      a00 = mtn_nstar * mtn_nstar/Dcst_grav_8
      capc1 = Dcst_grav_8*Dcst_grav_8/(mtn_nstar*mtn_nstar*Dcst_cpd_8*mtn_tzero)

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj     
      if (l_west ) i0 = 1+pil_w
      if (l_east ) in = l_ni-pil_e
      if (l_south) j0 = 1+pil_s
      if (l_north) jn = l_nj-pil_n

      do k=1,Nk
         do j=j0,jn
            do i=i0,in
               my_tt=mtn_tzero*((1.-capc1)*
     $              exp(a00*fi_t(i,j,k)/Dcst_grav_8)+capc1)
               tt(i,j,k)=(1.-betav_t(i,j,k))*tt(i,j,k)+
     $              betav_t(i,j,k)*my_tt
            enddo
         enddo
      enddo
      
      return

      end
c=======================================================================
#include "model_macros_f.h"

      subroutine set_betav(betav_m,betav_t,fi_t,fip,tt, DIST_DIM, Nk)

      implicit none

      integer  DIST_DIM, Nk 

#include "glb_pil.cdk"
#include "cstv.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "zblen.cdk"

      real betav_m(DIST_SHAPE,Nk),betav_t(DIST_SHAPE,Nk+1)
      real fip(DIST_SHAPE,0:Nk+1),tt(DIST_SHAPE,Nk)
      real fi_t(DIST_SHAPE,Nk+1)

      real*8 work1,work2

      integer i,j,k,i0,in,j0,jn 

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj     
      if (l_west ) i0 = 1+pil_w
      if (l_east ) in = l_ni-pil_e
      if (l_south) j0 = 1+pil_s
      if (l_north) jn = l_nj-pil_n

c     Compute PHI on thermo level
      do k=2,l_nk
         do j=j0,jn
            do i=i0,in
               fi_t(i,j,k) = .5d0*(fip(i,j,k)+Ver_fistr_8%m(k)
     $                       +fip(i,j,k-1)+Ver_fistr_8%m(k-1))
            enddo
         enddo
      enddo
      do j=j0,jn
         do i=i0,in
c           fi_t(i,j,1)=fi(i,j,1)
            fi_t(i,j,1)=.5d0*(fip(i,j,1)+fip(i,j,0))
     $                    +Ver_fistr_8%m(1)
            fi_t(i,j,Nk+1)=.5d0*(fip(i,j,Nk+1)+fip(i,j,Nk))
         enddo
      enddo
      do k=1,l_nk
         do j=j0,jn
            do i=i0,in
               work1=(fip(i,j,k)+Ver_fistr_8%m(k))/Dcst_grav_8-Zblen_hmin
               work2=(fip(i,j,1)+Ver_fistr_8%m(1))/Dcst_grav_8-Zblen_hmin
               work1=min(1.d0,max(0.d0,work1/work2))
               betav_m(i,j,k)=work1*work1
               work1=fi_t(i,j,k)/Dcst_grav_8-Zblen_hmin
               work1=min(1.d0,max(0.d0,work1/work2))
               betav_t(i,j,k)=work1*work1
            enddo
         enddo
      enddo

c     Set betav_ to zero at surface.
      k=l_nk+1
      do j=j0,jn
         do i=i0,in
            betav_t(i,j,k)=0.
         enddo
      enddo

      return

      end
