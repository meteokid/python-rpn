***s/r e_anallev - extraction of analysis levels
*
#include <model_macros_f.h>
*
      subroutine e_anallev (xfi,yfi,latfi,lonfi)
      implicit none
*
      real xfi(*), yfi(*), latfi(*), lonfi(*)
*
#include "e_maxprms.cdk"
#include "e_locdim.cdk"
#include "e_files.cdk"
#include "e_times.cdk"
#include "e_anal.cdk"
#include "e_zgrids.cdk"
#include "e_option.cdk"
#include "e_grids.cdk"
#include "did.cdk"
#include "bmf.cdk"
#include "out1.cdk"
#include "ptopo.cdk"
*
      logical   e_samegrid
      integer   fstinf, fstinl, fstprm, fstlir, fstluk,
     $          read_decode_hyb, newdate
      external  fstinf, fstinl, fstprm, fstlir, fstluk, e_samegrid,
     $          read_decode_hyb, newdate
*
      integer  dte, det, ipas, p1, p2, p3, g1, g2, g3, g4, bit,
     $         dty, swa, lng, dlf, ubc, ex1, ex2, ex3, kind, err
      character*1   typ, grd, blk_S
      character*4   var
      character*12  lab
      real      difsig,x1,x2
      real, allocatable, dimension(:) :: topp
      real*8    pdip2
      parameter (difsig = 1.e-5)
      integer list(nkmax), i, j, k, nib, l, m, ier
*
* ---------------------------------------------------------------------
*
      iday=-1
      ip2a=-1
      ip3a=-1
      tva = ' '
      labanl = ' '
      write (6, 1001)
*_____________________________________________________________________
*
* 1-    Check Analysis levels and variables  
*_____________________________________________________________________
*
*                    Determine the level type in analysis: part 1
*                    check if analysis is on eta or hybrid coordinates
*
      l = read_decode_hyb(anal, 'HY', -1, -1, ' ',-1,ptopa,prefa,rcoefa)
      if (l .lt. 0) then
         glhybanl=.false.
         l = fstinf(anal, i, j, k, -1, ' ', -1, -1, -1, ' ', 'PT')
         if (l .lt. 0) then
            gletaanl=.false.
         else
            gletaanl=.true.
            rcoefa = 1.0
            prefa = 800.0
            allocate(topp(i*j))
            err = fstluk(topp, l, i,j,k)
            ptopa = topp(1)
            do i=2,i*j
               if (abs(topp(i)-ptopa).gt.difsig) then
                   write(6,*)'ERROR: PT in ETA analysis is not uniform'
                   write(6,*)'ERROR: TOPP(',i,')=',topp(i),' ptopa=',ptopa
                   call e_arret('e_anallev')
               endif
            enddo
            ptopa = topp(1)
            deallocate (topp)
         endif
      else
         gletaanl=.false.
         glhybanl=.true.
      endif
*                     Check moisture variable and find out
*                     if it is given by 'ES' or 'HU'
      vh = 'HU'
      l = fstinf(anal, i, j, k, -1, ' ', -1, -1, -1, ' ', vh)
*
      if ( l .lt. 0 ) then
         vh = 'ES'
         l = fstinf(anal, i, j, k, -1, ' ', -1, -1, -1, ' ', vh)
         if ( l .lt. 0 ) then
         write(6,*) 'No moisture variables are found in analysis'
         write(6,*) 'Either HU or ES must be in the analysis file.'
         call e_arret('e_anallev')
         endif
      endif
*                      Check temperature variable and find
*                      out if it is given by 'TT' or 'VT'
      vt = 'VT'
      l = fstinf(anal, i, j, k, -1, ' ', -1, -1, -1, ' ', vt)
*
      if ( l .lt. 0 ) then
         vt = 'TT'
         l = fstinf(anal, i, j, k, -1, ' ', -1, -1, -1,' ', vt )
         if ( l .lt. 0 ) then
         write(6,*) 'No temperature variables are found in analysis'  
         write(6,*) 'Either TT or VT must be in the analysis file.'
         call e_arret('e_anallev')
         endif
      endif
*
*     Get the information on the temperature field from the analysis
*     ig1a,ig2a,ig3a,ig4a are the grid descriptors for the TT/VT field
*
      i = fstprm(l, idayo, deet, npas, nia, nja, k, bit, dty, ip1a,ip2a,
     x           ip3a, tva, var, labanl,grda, ig1a,ig2a,ig3a,ig4a,swa,
     x           lng, dlf, ubc, ex1, ex2, ex3 )
*
*                      Determine the level type in analysis: part 2
*                      discriminate between pressure or sigma/eta
*
*     Allocate space for positional parameters of analysis grid
*
      call hpalloc(p_grxaxi,nia,ier,1)
      call hpalloc(p_gryayi,nja,ier,1)
*
*     Set global logical variables to default values
      glsiganl  = .false.
      GLHORINT  = .false.
*
      if (  (ip1a .ge. 2000) .and. (ip1a .le. 12000) ) then
      
         if ( glhybanl ) then
            print*,' ===> Analysis on HYBRID vertical coordinates.'
         else if (gletaanl) then
            print*,' ===> Analysis on ETA vertical coordinates.'
         else
            glsiganl = .true.
            print*,' ===> Analysis on SIGMA vertical coordinates.'
         endif

      else

         glsiganl = .false.
         gletaanl = .false.
         glhybanl = .false.
         print*,' ===> Analysis on PRESSURE vertical coordinates.'
*
      endif
      if (( gletaanl .or. glsiganl .or.glhybanl ) .and. 
     $     ( VH .eq. 'ES' )) then
         write(6,*) 'ERROR: Moisture variable(VH) must be HU '
         write(6,*) 'when analysis is on sigma/eta/hybrid.'
         call e_arret('E_ANALLEV')
      endif
*                                extract analysis levels list and check
*                                descriptors consistency
      lv = 0
      l  = fstinl ( anal, i, j, k, -1, labanl, -1, ip2a, ip3a, tva,
     x                                        var, list, m, lvmax)
*
*  Check if other temperature records have the same dimensions, same 
*  grid, and get all the levels available in the analyse file
*
      do l=1,m
         ier = fstprm(list(l), dte, det, ipas, i, j, k, bit, dty,
     x             ip1a, ip2a, ip3a, tva, var, labanl, grd, g1, g2, g3,
     x               g4, swa, lng, dlf, ubc, ex1, ex2, ex3 )

         if(nia.ne.i .or. nja.ne.j) then
            write(6,*)':  LEVEL ',ip1a,' DIMENSION MISMATCH'
            call e_arret( 'e_anallev')
         elseif(grda.ne.grd .or. ig1a.ne.g1 .or. ig2a.ne.g2 .or.
     x          ig3a .ne.g3  .or. ig4a .ne.g4) then
            write(6,*)':  LEVEL ',ip1a,' GRID MISMATCH'
            call e_arret( 'e_anallev')
         elseif(( (glsiganl .or. gletaanl .or. glhybanl) 
     $            .and. ip1a.lt.2000)
     x          .or.
     x      (.not.(glsiganl .or. gletaanl .or. glhybanl) 
     $           .and. ip1a.ge.2000)) then
            write(6,*)':  LEVEL ',ip1a,' LEVEL INCONSISTENCY'
            call e_arret( 'e_anallev')
         else
            lv     = lv+1
            na(lv) = ip1a
         endif
      enddo
*
      if (lv .lt. 16 .and. 
     $     .not.(glsiganl .or. gletaanl .or. glhybanl)) then
         write(6,*)': NEED 16 OR MORE PRESSURE LEVELS. ',
     x                     lv, ' levels found'
         call e_arret('e_anallev')
      endif
*
*     Conversion of ip1 analysis levels coding to pressure or eta
*
      do i=1,lv
         call convip(na(i), rna(i), kind,-1, blk_S,.false.)
      enddo

*     Sort levels in ascending order
      call e_sortr (rna, lv)
*
      if( gletaanl .or. glsiganl .or. glhybanl ) then
         do i=1,lv
            call convip(na(i), rna(i), 1,+1, blk_S,.false.)
         end do
      else
*        pressure levels
         do i=1,lv
            call convip(na(i), rna(i), 2,+1, blk_S,.false.)
            lna(i) = alog(rna(i))
         enddo
      endif
*
      print*, ' ANALYSIS LEVELS FOUND ARE:'
      do i=1,lv
         write(6,801) rna(i),i
      end do 
      if (glhybanl.or.gletaanl) then
          write(6,*)  'analysis ptopa=',ptopa
          write(6,*)  'analysis rcoefa=',rcoefa
          write(6,*)  'analysis prefa=',prefa
      endif
*
*_____________________________________________________________________
*
* 2-    Check analysis HORIZONTAL grid (source grid)            
*_____________________________________________________________________

      if  ( grda .eq. 'Z') then
         GLHORINT = .not. e_samegrid( anal,xfi,yfi )
      else
         GLHORINT = .true.
      endif
*
      if( GLHORINT ) then
         write(6,*)'HORIZONTAL interpolation required'
      else 
         write(6,*)'NO HORIZONTAL interpolation required'
      endif
*
      pdip2=float(ip2a)
      call incdatr(iday, idayo, pdip2)
      call datmgp2(idate)
      write(6,1002) idate
      Out1_date = idate(14)
      Out1_anlv = lv
      err = newdate (Out1_date,bmf_time1,bmf_time2,-3)
      Bmf_hh   = bmf_time2/1000000
      Bmf_mm   = bmf_time2/10000-Bmf_hh*100
      Bmf_ss   = bmf_time2/100-Bmf_hh*10000-Bmf_mm*100      
      bmf_dtyp = 41
*
      write(6,*)'nia     =',nia,'  nja =',nja
      write(6,*)'GLHORINT  =', GLHORINT
      write(6,*)'glhybanl=', glhybanl
      write(6,*)'gletaanl=', gletaanl
      write(6,*)'glsiganl=', glsiganl
*
      Did_vt = .false.
      if (VT .eq. 'VT') Did_vt = .true.
      Did_es = .false.
      if (VH .eq. 'ES') Did_es = .true.
      Did_vrtc = 'PRS'
      if (glsiganl) Did_vrtc = 'SIG'
      if (gletaanl) Did_vrtc = 'ETA'
      if (glhybanl) Did_vrtc = 'HYB'
      Did_horint = GLHORINT
*      
      call bmf_splitstart (Ptopo_npex,Ptopo_npey,'./process/','BM',
     $                             Bmf_time1,Bmf_hh,Bmf_mm,Bmf_ss)
      call bmf_splitwrall ('RNA ',LV,1,1,Bmf_time1,Bmf_time2, 
     $                                    0,0,bmf_dtyp,0,RNA)
      if (glhybanl.or.gletaanl) then
          call bmf_splitwrall('PTOP',1,1,1,Bmf_time1,Bmf_time2
     .                                   ,0,0,bmf_dtyp,0,ptopa)
          call bmf_splitwrall('PREF',1,1,1,Bmf_time1,Bmf_time2
     .                                   ,0,0,bmf_dtyp,0,prefa)
          call bmf_splitwrall('RCOF',1,1,1,Bmf_time1,Bmf_time2
     .                                   ,0,0,bmf_dtyp,0,rcoefa)
      endif
      print *,'pni=',pni
      call e_bmfsplitxy2 (latfi,nifi,njfi,'LA  ',1,1,pni,0,0,0)
      call e_bmfsplitxy2 (lonfi,nifi,njfi,'LO  ',1,1,pni,0,0,0)
*
 801  format (' LEVEL anal = ',d15.8,2X,' k = ',i4)
 1001 format(/,'EXTRACTION OF ANALYSIS LEVELS (S/R E_ANALLEV)',/40('-'))
 1002 format(' DATE = ', 6i5 , 7a4 , i10 )
*
* ---------------------------------------------------------------------
*
      return
      end
