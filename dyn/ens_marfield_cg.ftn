***   s/r ens_marfield_cg - define a markov chain field
*     
#include <model_macros_f.h>
*     
      subroutine ens_marfield_cg(fgem)
*
      use spharmt
      implicit none
*     
*     author   
*     Lubos Spacek - February 2005
*     
*     revision
*
*object
*	
*arguments     none
*
*implicits
#include "dcst.cdk"
#include "lun.cdk"
#include "mem.cdk"
#include "p_bus.cdk"
#include "busind.cdk"
#include "lctl.cdk"
#include "cstv.cdk"
#include "glb_ld.cdk"
#include "ptopo.cdk"
#include "rstr.cdk"
#include "step.cdk"
#include "hgc.cdk"
#include "ens_param.cdk"
#include "ens_vt1.cdk"
#include "ens_stochphy.cdk"
*
*modules
       integer, external :: read_db_file,write_db_file,vmmlod, vmmget, vmmuld
       real,    external :: plgndr, ran1, gasdev
       integer, external :: fnom,fstouv,fstfrm,fclos
       integer, external :: ezgdef_fmem,ezqkdef,ezsint,ezdefset,ezsetopt

*
* nlat, nlon                 dimension of the Gaussian grid
* mzt                        Nombre d'onde vertical
* idum                       Semence du générateur de nombres aléatoires
*
      integer :: l ,m, mz, mzp, i, j, k, naloc, indx, ier, ii, jj
      integer :: iv(32),iy,iset,gset,idum
      integer :: gdgem,gdgauss, keys(5), nmstrt, nm, n, mtrunc, nomet
      real    :: xf,offi,offj
      real xfi(l_ni),yfi(l_nj)
      real*8  :: rad2deg_8
*
* pabusper pointer vers le bus permanent busper (busper2)
* paidum   pointer vers l'etat du generateur sauvegarde idum
      real busper, busper2(max(1,p_bper_siz))
      pointer (pabusper,busper(*))
      pointer (paiv,iv),(paiy,iy),(paiset,iset),(pagset,gset),(paidum, idum)
*
*      variables et champs auxiliaires reels
* dt   Pas de temps du modèle (secondes)
* tau  Temps de décorrélation du champ aléatoire f(i,j) (secondes)
* eps  EXP(-dt/tau)
      real    :: pi, dt, eps, sig2, x, z
      type (sphere) :: sphere_dat 
      real,    dimension(l_ni,l_nj,l_nk)    :: fgem
      real,    dimension(:),    allocatable :: veco1,xsiv,xcov
      complex, dimension(:,:),  allocatable :: pnm
      real,    dimension(:,:,:),allocatable :: fgau, fgau_str, fgem_str
      complex, dimension(:),    allocatable :: pnm2
      real,    dimension(:,:),  allocatable :: fgau2, fgau2_str, fgem2_str
*
* variables et champs auxiliaires complexes
      complex,dimension(:,:),allocatable :: hoco,veco
!
! Initialise les variables de Ens_nml.cdk
!
      xmn = Ens_mc_min ; xmx = Ens_mc_max   ; xme    = Ens_mc_mean
      std = Ens_mc_std ; tau = Ens_mc_tau   ; aa     = Ens_mc_str
      nlon= Ens_gg_nlon; nlat= Ens_gg_nlat  ; ntrunc = Ens_gg_trnh
      nmdim=Ens_gg_dim ; mzt = Ens_gg_mzt   ; ar     = 6.37122e6
                                              mtrunc = Ens_gg_trnl
*
      keys(1)=VMM_KEY(anm)
      keys(2)=VMM_KEY(znm)
      ier=vmmlod(keys,2)
      ier=VMM_GET_VAR(anm)
      ier=VMM_GET_VAR(znm)

      dt=real(Cstv_dt_8)
      pi=real(Dcst_pi_8)
      rad2deg_8=180.0d0/Dcst_pi_8
*     
      if ( .not.Mem_phyncore_L ) then
*          pabusper => busper2(1:p_bper_siz+1)
!           xnerr = read_db_file (Lun_waphy,xncoupe,1)
!           xnerr = read_db_file (Lun_waphy,busper,p_bper_siz)
         if (Lun_out.gt.0) write( Lun_out,1008 )
         call gem_stop( 'ens_marfield_cg',-1 )
      endif
*     
*     Valeurs initiales des composantes principales
*     
*     Assure that busper is to 1 at the begining in inichamp1
*
      if ( Lctl_step .eq. 1 .or. Rstri_sdon.eq.1) then
         if (Lun_out.gt.0) then
            write( Lun_out,1000)
            write( Lun_out,1009)xmn,xmx,xme,std,tau,ntrunc,nlon,nlat,2*mzt+1
         endif
cc         return
      endif
*     Rstri_rstn_L
      if ( Lctl_step .eq. 1) then
         paiv  =loc(dumdum( 1,1))
         paiy  =loc(dumdum(33,1))
         paiset=loc(dumdum(34,1))
         pagset=loc(dumdum(35,1))
         paidum=loc(dumdum(36,1))
         dumdum(:,1)=0
         eps=exp(-dt/Ens_mc_tau)
         std=Ens_mc_std
         idum=-Ens_memb
!         xf=pi/REAL(nlon*(nlon+2)/2)/REAL(2*mzt+1)
         xf=pi/REAL((ntrunc-mtrunc+1)*(ntrunc+mtrunc+1)/2)/REAL(2*mzt+1)
         do mz=-mzt,mzt
           do l=1,nmdim
             anm(l,mz)=CMPLX(
     .          std*gasdev(iv,iy,iset,gset,idum)*sqrt((1.-eps**2)*xf),
     .          std*gasdev(iv,iy,iset,gset,idum)*sqrt((1.-eps**2)*xf))
           enddo
         enddo
*
         do mz=1,Ens_ncha2
         mzp=mz+1
         dumdum(:,mzp)=0
         paiv  =loc(dumdum( 1,mzp))
         paiy  =loc(dumdum(33,mzp))
         paiset=loc(dumdum(34,mzp))
         pagset=loc(dumdum(35,mzp))
         paidum=loc(dumdum(36,mzp))
         idum=-Ens_memb
         xf=pi/REAL((Ens_trnh2(mz)-Ens_trnl2(mz)+1)*
     .                          (Ens_trnh2(mz)+Ens_trnl2(mz)+1)/2)
         eps=exp(-dt/Ens_tau2(mz))
         std=Ens_std2(mz)
         do l=1,Ens_dim2(mz)
             znm(l,mz)=CMPLX(
     .          std*gasdev(iv,iy,iset,gset,idum)*sqrt((1.-eps**2)*xf),
     .          std*gasdev(iv,iy,iset,gset,idum)*sqrt((1.-eps**2)*xf))
           enddo
         enddo
      endif

!     
!     Precalcul exponentials in vertical
!     
      naloc=(2*mzt+1)*l_nk
      allocate(veco1(naloc),xsiv(naloc),xcov(naloc))
      allocate(veco(l_nk,-mzt:mzt))
      allocate(fgau(nlon,nlat,l_nk))
      allocate(pnm(nmdim,l_nk))
!     
      indx=0
      do mz=-mzt,mzt
         do k=1,l_nk
            z=real(k-1)*2.*pi/real(l_nk)
            indx=indx+1
            veco1(indx)=mz*z
         enddo
      enddo
!     
      naloc=(2*mzt+1)*l_nk
      call vssincos(xsiv,xcov,veco1,naloc)
!     
      indx=0
      do mz=-mzt,mzt
         do k=1,l_nk
            indx = indx+1
            veco(k,mz)=cmplx(xcov(indx),xsiv(indx))
         enddo
      enddo
!     
      deallocate(veco1,xsiv,xcov)
!     
!     Begin Markov chains
!
      paiv  =loc(dumdum( 1,1))
      paiy  =loc(dumdum(33,1))
      paiset=loc(dumdum(34,1))
      pagset=loc(dumdum(35,1))
      paidum=loc(dumdum(36,1))
      xf=pi/REAL((ntrunc-mtrunc+1)*(ntrunc+mtrunc+1)/2)/REAL(2*mzt+1)
      eps=exp(-dt/Ens_mc_tau)
      std=Ens_mc_std
      do mz=-mzt,mzt
         do l=1,nmdim
            anm(l,mz)=CMPLX(eps*real (anm(l,mz))+
     .      std*gasdev(iv,iy,iset,gset,idum)*sqrt((1.-eps**2)*xf),
     .      eps*aimag(anm(l,mz))+
     .      std*gasdev(iv,iy,iset,gset,idum)*sqrt((1.-eps**2)*xf))
          enddo
      enddo
!
      do mz=1,Ens_ncha2
         mzp=mz+1
         paiv  =loc(dumdum( 1,mzp))
         paiy  =loc(dumdum(33,mzp))
         paiset=loc(dumdum(34,mzp))
         pagset=loc(dumdum(35,mzp))
         paidum=loc(dumdum(36,mzp))
         xf=pi/REAL((Ens_trnh2(mz)-Ens_trnl2(mz)+1)*
     .                          (Ens_trnh2(mz)+Ens_trnl2(mz)+1)/2)
         eps=exp(-dt/Ens_tau2(mz))
         std=Ens_std2(mz)
         do l=1,Ens_dim2(mz)
            znm(l,mz)=CMPLX(eps*real (znm(l,mz))+
     .      std*gasdev(iv,iy,iset,gset,idum)*sqrt((1.-eps**2)*xf),
     .      eps*aimag(znm(l,mz))+
     .      std*gasdev(iv,iy,iset,gset,idum)*sqrt((1.-eps**2)*xf))
           enddo
      enddo


      pnm=(0.,0.)
      do mz=-mzt,mzt
         do k=1,l_nk
!            z=(k-1)*2.*pi/real(l_nk)
!            do l=1,nmdim
!               pnm(l,k)=pnm(l,k)+anm(l,mz)*veco(k,mz)
!            enddo
             nmstrt=0
             nomet=mtrunc
             do m=1,ntrunc+1
                do n=nomet,ntrunc+1-m+1
                   nm=nmstrt+n
                   pnm(nm,k)=pnm(nm,k)+anm(nm,mz)*veco(k,mz)
                enddo
                nmstrt = nmstrt + ntrunc+1-m+1
                nomet=max(1,nomet-1)
             enddo
         enddo
      enddo

      call spharmt_init(sphere_dat,nlon,nlat,ntrunc,ar)
      do k=1,l_nk
         pnm(1,k)=(0.0,0.0)
         call spharm(sphere_dat,fgau(1,1,k),pnm(1,k),-1)
      enddo
      call spharmt_destroy(sphere_dat)
!     
*
*
**    Interpolation to the processors grids and fill in perbus
*
c     offi = Ptopo_gindx(1,Ptopo_myproc+1)-1
c     offj = Ptopo_gindx(3,Ptopo_myproc+1)-1
c     do i=1,l_ni
c        indx = offi + i
c        xfi(i) = G_xg_8(indx)*rad2deg_8
c     end do
c     do i=1,l_nj
c        indx = offj + i
c        yfi(i) = G_yg_8(indx)*rad2deg_8
c     end do
c     dgid_myp = ezgdef_fmem (l_ni , l_nj , 'Z', 'E', Hgc_ig1ro,
c    $          Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
      gdgauss = ezqkdef(nlon,nlat,'G', 0,0,0,0,0)

      ier = ezdefset(dgid_myp, gdgauss)
      ier = ezsetopt('INTERP_DEGREE', 'LINEAR')
c     ier = ezsetopt('VERBOSE', 'YES')
      do k=1,l_nk
         ier = ezsint(fgem(1,1,k),fgau(1,1,k))
      enddo
!    Check the limits, stretch, and add mean if stretching asked
!    for the physics perturbation
!
      if(aa/=0.and.aa/=1)then
         where (abs(fgau) > 1.)
            fgau=sign(1.,fgau)
         end where

         allocate(fgau_str(nlon,nlat,l_nk),fgem_str(l_ni,l_nj,l_nk))
         sig2=1./LOG((aa/(aa-1.))**2)
         fgau_str=fgau*(aa*exp(-fgau**2/2./sig2)+2.-aa)*(xmx-xme)
         if(xme/=0.0) fgau_str=fgau_str+xme
*
         do k=1,l_nk
            ier = ezsint(fgem_str(1,1,k),fgau_str(1,1,k))
         enddo
*
         do j=1,p_nj
            jj=j+p_offj
            pabusper = loc (Phy_busper3D((j-1)*p_bper_siz+1))
            do k=1,l_nk
               do i=1,p_ni
                  ii=i+p_offi
                  indx = (k-1)*p_ni+i-1
                  busper(mrkv+indx)=fgem_str(ii,jj,k)
               enddo
            enddo
         enddo
         deallocate(fgau_str,fgem_str)
      else
*
         do j=1,p_nj
            jj=j+p_offj
            pabusper = loc (Phy_busper3D((j-1)*p_bper_siz+1))
            do k=1,l_nk
               do i=1,p_ni
                  ii=i+p_offi
                  indx = (k-1)*p_ni+i-1
                  busper(mrkv+indx)=1.0
               enddo
            enddo
         enddo
      endif
      deallocate(fgau,pnm,veco)
*====================================

      allocate(fgem2_str(l_ni,l_nj))
      do mz=1,Ens_ncha2
         allocate(fgau2(Ens_nlon2(mz),Ens_nlat2(mz)))
         allocate(fgau2_str(Ens_nlon2(mz),Ens_nlat2(mz)))
         allocate(pnm2(Ens_dim2(mz)))
         pnm2=(0.,0.)
             mtrunc=Ens_trnl2(mz)
             ntrunc=Ens_trnh2(mz)
             nmstrt=0
             nomet=mtrunc
             do m=1,ntrunc+1
                do n=nomet,ntrunc+1-m+1
                   nm=nmstrt+n
                   pnm2(nm)=znm(nm,mz)
                enddo
                nmstrt = nmstrt + ntrunc+1-m+1
                nomet=max(1,nomet-1)
             enddo

        call spharmt_init(sphere_dat,
     .                 Ens_nlon2(mz),Ens_nlat2(mz),Ens_trnh2(mz),ar)

           call spharm(sphere_dat,fgau2,pnm2,-1)

        call spharmt_destroy(sphere_dat)

*
*
**    Interpolation to the processors grids and fill in perbus
*
        gdgauss = ezqkdef(Ens_nlon2(mz),Ens_nlat2(mz),'G', 0,0,0,0,0)

        ier = ezdefset(dgid_myp, gdgauss)
        ier = ezsetopt('INTERP_DEGREE', 'LINEAR')
c       ier = ezsetopt('VERBOSE', 'YES')

c         ier = ezsint(fgem,fgau)


!    Check the limits, stretch, and add mean if stretching asked
!    for the physics perturbation
!
           where (abs(fgau2) > 1.)
              fgau2=sign(1.,fgau2)
           end where
      if(Ens_str2(mz)/=0.0)then
*
         sig2=1./LOG((Ens_str2(mz)/(Ens_str2(mz)-1.))**2)
         fgau2_str=fgau2*(Ens_str2(mz)*exp(-fgau2**2/2./sig2)+2.-Ens_str2(mz))*
     .  (Ens_max2(mz)-Ens_mean2(mz))
         if(Ens_mean2(mz)/=0.0) fgau2_str=fgau2_str+Ens_mean2(mz)
*
            ier = ezsint(fgem2_str,fgau2_str)
*
         do j=1,p_nj
            jj=j+p_offj
            pabusper = loc (Phy_busper3D((j-1)*p_bper_siz+1))
               do i=1,p_ni
                  ii=i+p_offi
                  indx = (mz-1)*p_ni+i-1
                  busper(mrk2+indx)=fgem2_str(ii,jj)
               enddo
         enddo
      else
                  do j=1,p_nj
            jj=j+p_offj
            pabusper = loc (Phy_busper3D((j-1)*p_bper_siz+1))
               do i=1,p_ni
                  ii=i+p_offi
                  indx = (mz-1)*p_ni+i-1
                  busper(mrk2+indx)=1.0
               enddo
         enddo
       endif
         deallocate(fgau2,fgau2_str,pnm2)
      enddo
*
      deallocate(fgem2_str)
*     
      ier = vmmuld( -1, 0 )
*
 1000 format(
     %     /,'INITIALIZE SCHEMES CONTROL PARAMETERS (S/R ENS_MARFIELD_CG)',
     %     /,'======================================================')
 1008 format(' Physics must be incore!')
 1009 format(
     %     /,'MARKOV CHAIN FIELD      MIN    MAX    MEA    STD   TAU  TRUNC ',
     %       'NLON/NLAT/NNIV',
     %     /,20X,4F7.1,1X,F7.0,I4,1X,3(I4,' '),/)
      return
      END subroutine ens_marfield_cg

