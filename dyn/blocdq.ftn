***s/r blocdq - calculate and output divergence and vorticity fields
*
#include <model_macros_f.h>
*
      subroutine blocdq (F_dostep,F_dostep_max)
*
#include "impnone.cdk"
*
      integer F_dostep(*)
      integer F_dostep_max
*
*author
*     james caveen/andre methot - rpn july/nov 1995
*
*revision
* v2_00 - Lee V.            - initial MPI version (from blocdq v1_03)
* v2_21 - J. P. Toviessi    - set dieze (#) slab output and rename 
* v2_21                       truncate model output names to 4 characters
* v2_30 - Lee V.            - reorganize slab output to be more efficient
* v2_32 - Lee V.            - reduce dynamic allocation size
* v3_00 - Desgagne & Lee    - Lam configuration
*
*object
*     output all the fields related to horizontal vorticity
*     and horizontal divergence.
*	
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_dostep     I    - array containing indices corresponding to the
*                     timestep sets that requires output at this time step.
* F_dostep_max I    - size of F_dostep array
*
*
*implicits
#include "glb_ld.cdk"
#include "lun.cdk"
#include "dimout.cdk"
#include "out.cdk"
#include "out2.cdk"
#include "vt1.cdk"
#include "setsor.cdk"
#include "outd.cdk"
#include "dcst.cdk"
#include "level.cdk"
#include "dslab.cdk"
#include "grid.cdk"
*
*modules
      integer  vmmlod, vmmuld, vmmget, vmmuln, vmmulk, getvndx
      external vmmlod, vmmuld, vmmget, vmmuln, vmmulk, getvndx
*
**
      integer cn3dvar
      parameter ( cn3dvar = 6 )
      integer pni3dx(cn3dvar), i,j,k, ii,jj,kk,jjj,pni3d
      integer pnlkeyw(2),pnerr, pnkey,pni3d
      character*8  pt3dvar(cn3dvar)
      integer levset,i0,in,j0,jn
      real prmult(cn3dvar), pradd(cn3dvar), prprlvl
      logical pl3dvar(cn3dvar)
* ___________________________________________________________________
*
*     1.0     initialization of data
*_______________________________________________________________________
*
*     list of derived 3-D variables that may be produced by blocdq
      data pt3dvar /'DS','Q3','QS','DD','QQ','QR'/
*     index of each symbol in the list
      integer pnds, pnq3, pnqs, pndd, pnqq, pnqr
      data pnds,pnq3,pnqs,pndd,pnqq,pnqr
     $    /   1,   2,   3,   4,   5,   6/
*     constants for unit conversion prmult and pradd
      data prmult / cn3dvar*1.0 /
      data pradd  / cn3dvar*0.0 /
*
      real w1(LDIST_SHAPE), w2(LDIST_SHAPE), w3(LDIST_SHAPE)
      real t1(LDIST_SHAPE,G_nk), t2(LDIST_SHAPE,G_nk)
      real t3(LDIST_SHAPE,G_nk), t4(LDIST_SHAPE,G_nk)
      real t5(LDIST_SHAPE,G_nk), t6(LDIST_SHAPE,G_nk)
      real t7(LDIST_SHAPE,G_nk), t8(LDIST_SHAPE,G_nk)
      real t9(LDIST_SHAPE,G_nk)
*
*     Declarations for slab output

      integer mxout_e,mxout_e
      character*4, dimension(:,:),allocatable :: var_e_S
      character*1, dimension(:,:),allocatable :: typvar_e_S
      integer,     dimension(:,:),allocatable :: ip1_e
      integer,     dimension(:,:),allocatable :: bit_e
      real,        dimension(:,:),allocatable :: mtval_e
      integer,     dimension(:)  ,allocatable :: mtout_e
      integer,     dimension(:,:),allocatable :: xnio

*_______________________________________________________________________
*
*   check if output is required for the derived variables
*
      pni3d = 0
      do i=1,cn3dvar
         pni3dx(i)=getvndx(pt3dvar(i))
         pl3dvar(i)=.false.
         if (pni3dx(i).gt.0) then
             pni3d = pni3d + Setsor_useit(pni3dx(i))
         else
            if (Lun_out.gt.0) write(Lun_out,*)
     $           'Error in BLOCDQ:INDEX not found for ',pt3dvar(i)
            stop
         endif
      enddo
      if (pni3d.le.0) then
*        no output required
            return
      endif
*_______________________________________________________________________
      mxout_e = 1 + pni3d*(max(l_nk,Dslab_max_lev_p))
      allocate ( var_e_S(mxout_e,Grid_sets),
     %           typvar_e_S(mxout_e,Grid_sets),
     %           ip1_e(mxout_e,Grid_sets),
     %           bit_e(mxout_e,Grid_sets),
     %           mtval_e(LDIST_SIZ*mxout_e,Grid_sets),
     %           mtout_e(Grid_sets),
     %           xnio(LDIST_SIZ,Grid_sets) )
      call set_dslab(0,xnio,LDIST_SIZ,Grid_sets)
      do i=1,Grid_sets
         mtout_e(i)=0
      enddo
*_______________________________________________________________________
*
*     3.0    Load and Get required fields
*_______________________________________________________________________
*
      pnlkeyw(1) = VMM_KEY(ut1)
      pnlkeyw(2) = VMM_KEY(vt1)
      pnerr = vmmlod(pnlkeyw,2)
      pnerr = VMM_GET_VAR(ut1)
      pnerr = VMM_GET_VAR(vt1)

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj

*_______________________________________________________________________
*
*     4.0     Calculation  DS, Q3
*_______________________________________________________________________
*
      call rpn_comm_xch_halo (ut1,LDIST_DIM,l_ni,l_nj,G_nk,
     $         G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
      call rpn_comm_xch_halo (vt1,LDIST_DIM,l_ni,l_nj,G_nk,
     $         G_halox,G_haloy,G_periodx,G_periody,l_ni,0)

*  Calculate horizontal divergence (DS)  in pi* vertical coordinate
      call caldiv_2 (t1, ut1, vt1, LDIST_DIM, G_nk)

*  Calculate horizontal relative vorticity (Q3) in pi* vertical coordinate
      call calvor (t2, ut1, vt1 ,t3, LDIST_DIM, G_nk)
      if (G_lam) then
          if (l_west) then
            do k=1,G_nk
             do j=2,l_njv
                t1(1,j,k)=t1(2,j,k)
                t2(1,j,k)=t2(2,j,k)
             enddo
            enddo
          endif
          if (l_east) then
            do k=1,G_nk
             do j=2,l_njv
                t1(l_ni,j,k)=t1(l_niu,j,k)
                t2(l_ni,j,k)=t2(l_niu,j,k)
             enddo
            enddo
          endif
          if (l_south) then
            do k=1,G_nk
             do i=1,l_ni
                t1(i,1,k)=t1(i,2,k)
                t2(i,1,k)=t2(i,2,k)
             enddo
            enddo
          endif
          if (l_north) then
            do k=1,G_nk
             do i=1,l_ni
                t1(i,l_nj,k)=t1(i,l_njv,k)
                t2(i,l_nj,k)=t2(i,l_njv,k)
             enddo
            enddo
          endif
      endif
*_______________________________________________________________________
*
*     5.0     Calculation  DD, QR and vertical derivatives
*_______________________________________________________________________
*
      if ( (Setsor_useit(pni3dx(pndd)) .ge. 1) .or.
     %     (Setsor_useit(pni3dx(pnqr)) .ge. 1) .or.
     %     (Setsor_useit(pni3dx(pnqq)) .ge. 1) ) then
        do k=1,l_nk
        do j= j0, jn
        do i= i0, in
           t5(i,j,k) = t1(i,j,k)
           t6(i,j,k) = t2(i,j,k)
        enddo
        enddo
        enddo
* Calculate horizontal divergence (DD) and relative vorticity (QR) 
*     in pressure vertical coordinate
        call calddqr( t5, t6, Out2_wlnph, ut1, vt1,
     $                t3, t4, t7, t8, t9, LDIST_DIM, G_nk)
* Calculate vertical derivative of DD(t5) with respect to Out2_wlnph
        call verder (t7,t5,Out2_wlnph,2.0,2.0,LDIST_DIM,G_nk,i0,in,j0,jn)
* Calculate vertical derivative of QR(t6) with respect to Out2_wlnph
        call verder (t8,t6,Out2_wlnph,2.0,2.0,LDIST_DIM,G_nk,i0,in,j0,jn)
      endif

* Calculate vertical derivative of DS(t1) with respect to Out2_wlnph
      call verder (t3,t1,Out2_wlnph,2.0,2.0,LDIST_DIM,G_nk,i0,in,j0,jn)
*     get vertical derivative of Q3(wijk2) with respect to Out2_wlnph
      call verder (t4,t2,Out2_wlnph,2.0,2.0,LDIST_DIM,G_nk,i0,in,j0,jn)

*  Unload 2 3-D fields (ut1,vt1).

      pnerr = vmmuln(pnlkeyw,2)
*_______________________________________________________________________
*
*     6.0     Calculation of the Coriolis parameter 
*_______________________________________________________________________
*
*  Calculate coriolis parameter
      if ( (Setsor_useit(pni3dx(pnqs)) .ge. 1) .or.
     $     (Setsor_useit(pni3dx(pnqq)) .ge. 1) ) then
        do j= j0, jn
        do i= i0, in
           w3(i,j) = 2.0 * Dcst_omega_8 * sin(Out2_wlao(i,j))
        enddo
        enddo
      endif
*_______________________________________________________________________
*
*     7.0A   Output of DS, Q3, QS, DD, QR, and QQ on ETA levels
*_______________________________________________________________________
      do 400 jj=1,F_dostep_max
*          For every Timestep set that outputs at the current timestep

      do 300 kk=1,Outd_sets
      if (Outd_step(kk).eq.F_dostep(jj))then
*     if the Timestep set for this request set Outd(kk) outputs
*     at the current timestep (Lctl_step)

          levset = Outd_lev(kk)

          if (Level_typ(levset) .eq. 'E') then
          do 200 ii=1,Outd_var_max(kk)

          pnkey = 0

          do i=1,cn3dvar
          if (pni3dx(i) .eq. Outd_var(ii,kk)) then
*             if 3-D variable is found in this request set
              pl3dvar(i) = .true.
              pnkey = pnkey + 1
          else
              pl3dvar(i) = .false.
          endif
          enddo

          if (pnkey.gt.0) then
*         if any 3-D variables are requested for output in this set

*
             do 150 jjj = 1, Level_max(levset)
               k = nint(Level(jjj,levset))
               if (pl3dvar(pnds)) then
                   call insrtslab_d(t1,w2,LDIST_DIM,G_nk,k,
     $               kk,prmult(pnds),pradd(pnds),pni3dx(pnds),
     $               Level_ip1(jjj,levset),mtout_e, var_e_S,
     $               typvar_e_S,ip1_e,bit_e,mtval_e,
     $               LDIST_SIZ,mxout_e,Grid_sets)
               endif
               if (pl3dvar(pnq3)) then
                   call insrtslab_d(t2,w2,LDIST_DIM,G_nk,k,
     $               kk,prmult(pnq3),pradd(pnq3),pni3dx(pnq3),
     $               Level_ip1(jjj,levset),mtout_e, var_e_S,
     $               typvar_e_S,ip1_e,bit_e,mtval_e,
     $               LDIST_SIZ,mxout_e,Grid_sets)
               endif
               if (pl3dvar(pnqs)) then
                     do j= j0, jn
                        do i= i0, in
                           w1(i,j) = t2(i,j,k) + w3(i,j)
                        enddo
                     enddo
                     call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                    kk,prmult(pnqs),pradd(pnqs),pni3dx(pnqs),
     $                    Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                    typvar_e_S,ip1_e,bit_e,mtval_e,
     $                    LDIST_SIZ,mxout_e,Grid_sets)
               endif
               if(pl3dvar(pndd)) then
                  call insrtslab_d(t5,w2,LDIST_DIM,G_nk,k,
     $              kk,prmult(pndd),pradd(pndd),pni3dx(pndd),
     $              Level_ip1(jjj,levset),mtout_e, var_e_S,
     $              typvar_e_S,ip1_e,bit_e,mtval_e,
     $              LDIST_SIZ,mxout_e,Grid_sets)
               endif
               if(pl3dvar(pnqr)) then
                  call insrtslab_d(t6,w2,LDIST_DIM,G_nk,k,
     $              kk,prmult(pnqr),pradd(pnqr),pni3dx(pnqr),
     $              Level_ip1(jjj,levset),mtout_e, var_e_S,
     $              typvar_e_S,ip1_e,bit_e,mtval_e,
     $              LDIST_SIZ,mxout_e,Grid_sets)
               endif
               if(pl3dvar(pnqq)) then
                     do j= j0, jn 
                        do i= i0, in
                           w1(i,j) = t6(i,j,k) + w3(i,j)
                        enddo
                     enddo
                  call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $              kk,prmult(pnqq),pradd(pnqq),pni3dx(pnqq),
     $              Level_ip1(jjj,levset),mtout_e, var_e_S,
     $              typvar_e_S,ip1_e,bit_e,mtval_e,
     $              LDIST_SIZ,mxout_e,Grid_sets)
               endif
 150         continue
             endif
 200        continue
            endif
            endif
 300     continue
 400     continue
      call writslab_d(Dslab_fhand_e,Dslab_slab_e,Dslab_nnio,'dm',
     %                Dslab_ext_S,mtout_e, var_e_S,typvar_e_S,ip1_e,bit_e,
     %                mtval_e,xnio,LDIST_SIZ,mxout_e,Grid_sets)
      do i=1,Grid_sets
         mtout_e(i)=0
      enddo
*_______________________________________________________________________
*
*     7.0B   Output of DS, Q3, QS, DD, QR, and QQ on PRESSURE levels
*_______________________________________________________________________
         do 800 jj=1,F_dostep_max
*           For every Timestep set that outputs at the current timestep

         do 700 kk=1,Outd_sets

         if (Outd_step(kk).eq.F_dostep(jj))then
*           if the Timestep set for this request set Outd(kk) outputs
*           at the current timestep (Lctl_step)

            levset = Outd_lev(kk)
*
            if (Level_typ(levset) .eq. 'P') then
            do 600 ii=1,Outd_var_max(kk)

               pnkey = 0
*
               do 540 i=1,cn3dvar
                  if (pni3dx(i) .eq. Outd_var(ii,kk)) then
*                 if 3-D variable is found in this request set
                     pl3dvar(i) = .true.
                     pnkey = pnkey + 1
                  else
                     pl3dvar(i) = .false.
                  endif
 540           continue

*         if any 3-D variables are requested for output in this set
               if (pnkey.gt.0) then
             do 550 jjj = 1, Level_max(levset)
*
               prprlvl = Level(jjj,levset) * 100.0

               if (pl3dvar(pnds)) then
                    call prgen( w1,  t1, t3, Out2_wlnph,
     %                          prprlvl, Out_cubds_L, LDIST_DIM,G_nk)
                    call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                kk,prmult(pnds),pradd(pnds),pni3dx(pnds),
     $                Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                typvar_e_S,ip1_e,bit_e,mtval_e,
     $                LDIST_SIZ,mxout_e,Grid_sets)
               endif
               if (pl3dvar(pnq3).or.pl3dvar(pnqs)) then
                    call prgen( w1,  t2, t4, Out2_wlnph,
     %                prprlvl, Out_cubqs_L, LDIST_DIM,G_nk)
               endif
               if(pl3dvar(pnq3)) then
                    call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                kk,prmult(pnq3),pradd(pnq3),pni3dx(pnq3),
     $                Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                typvar_e_S,ip1_e,bit_e,mtval_e,
     $                LDIST_SIZ,mxout_e,Grid_sets)
               endif
               if(pl3dvar(pnqs)) then
                    do j= j0, jn 
                    do i= i0, in
                       w1(i,j) = w1(i,j) + w3(i,j)
                    enddo
                    enddo
                    call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                kk,prmult(pnqs),pradd(pnqs),pni3dx(pnqs),
     $                Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                typvar_e_S,ip1_e,bit_e,mtval_e,
     $                LDIST_SIZ,mxout_e,Grid_sets)
               endif
               if (pl3dvar(pndd)) then
                    call prgen( w1,  t5, t7, Out2_wlnph,
     %                       prprlvl, Out_cubdd_L, LDIST_DIM,G_nk)
                    call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                kk,prmult(pndd),pradd(pndd),pni3dx(pndd),
     $                Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                typvar_e_S,ip1_e,bit_e,mtval_e,
     $                LDIST_SIZ,mxout_e,Grid_sets)
               endif
               if ( pl3dvar(pnqr) .or. pl3dvar(pnqq) ) then
                    call prgen( w1,  t6, t8, Out2_wlnph,
     %                prprlvl, Out_cubqq_L, LDIST_DIM,G_nk)
               endif
               if (pl3dvar(pnqr)) then
                    call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                kk,prmult(pnqr),pradd(pnqr),pni3dx(pnqr),
     $                Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                typvar_e_S,ip1_e,bit_e,mtval_e,
     $                LDIST_SIZ,mxout_e,Grid_sets)
               endif
               if (pl3dvar(pnqq)) then
                     do j= j0, jn 
                        do i= i0, in
                           w1(i,j) = w1(i,j) + w3(i,j)
                        enddo
                     enddo
                    call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                kk,prmult(pnqq),pradd(pnqq),pni3dx(pnqq),
     $                Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                typvar_e_S,ip1_e,bit_e,mtval_e,
     $                LDIST_SIZ,mxout_e,Grid_sets)
               endif
 550         continue
             endif
 600      continue
          endif
          endif
 700     continue
 800  continue
      call writslab_d(Dslab_fhand_p,Dslab_slab_p,Dslab_nnio,'dp',
     %                Dslab_ext_S,mtout_e, var_e_S,typvar_e_S,ip1_e,bit_e,
     %                mtval_e,xnio,LDIST_SIZ,mxout_e,Grid_sets)
      deallocate ( var_e_S, ip1_e, bit_e, mtval_e,typvar_e_S,mtout_e, xnio )
* ___________________________________________________________________
*

      return
      end
