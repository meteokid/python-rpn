!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "msg.h"

!/**
subroutine adx_interp_gmm4 (F_out_S, F_in_S,  &
                            F_wind_L, F_nk, i0,in,j0,jn, F_lev_S)
   implicit none
   !@objective
   !@arguments
   character(len=*) :: F_out_S !I, gmm label for interpolated field
   character(len=*) :: F_in_S  !I, gmm label for field to interpolate
   logical :: F_wind_L         !I, .true. if field is wind like
   integer :: F_nk             !I, number of vertical levels
   integer :: i0,in,j0,jn      !I, scope of operator
   character(len=*) :: F_lev_S !I, m/t : Momemtum/thermo level
   !@revisions
   !  2009-12,  Stephane Chamberland: original code from adx_main_3
!**/
#include "gmm.hf"
#include "glb_ld.cdk"
#include "adx_dims.cdk"
#include "adx_nml.cdk"
#include "adx_dyn.cdk"
   type(gmm_metadata) :: mymeta
   logical :: mono_L
   integer :: i,j,k,i1,i2,j1,j2,err
   real, pointer, dimension (:,:,:) :: fld_in,fld_out
   !---------------------------------------------------------------------
   call msg(MSG_DEBUG,'adx_interp_gmm')

   err =     gmm_get(F_in_S ,fld_in ,mymeta)
   err = min(gmm_get(F_out_S,fld_out,mymeta),err)
   call handle_error(err,'adx_interp_gmm','gmm_get for '//trim(F_in_S)//', '//trim(F_out_S))

   mono_l = .false.
   if (F_in_S(1:3) == 'TR/') mono_L = adw_mono_L

   if (adw_stats_L) then
      call glbstat2(fld_in, F_in_S, 'adx_int',  &
           mymeta%l(1)%low,mymeta%l(1)%high, mymeta%l(2)%low,mymeta%l(2)%high,&
           1,F_nk, i0,in,j0,jn,1,F_nk)
   endif

   call adx_interp4 (fld_out, fld_in,                        &
                     mymeta%l(1)%low,mymeta%l(1)%high,       &
                     mymeta%l(2)%low,mymeta%l(2)%high, F_nk, &
                     F_wind_L, mono_L, i0,in,j0,jn, F_lev_S)


   if (adw_stats_L) then
      call glbstat2(fld_out, F_out_S, 'adx_int',  &
           mymeta%l(1)%low,mymeta%l(1)%high, mymeta%l(2)%low,mymeta%l(2)%high,&
           1,F_nk, i0,in,j0,jn,1,F_nk)
   endif

   call msg(MSG_DEBUG,'adx_interp_gmm [end]')
   !---------------------------------------------------------------------
   return

end subroutine adx_interp_gmm4
