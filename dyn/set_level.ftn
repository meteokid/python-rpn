***s/r set_level - initialization of common block LEVEL
*
#include "model_macros_f.h"
*
      integer function set_level (F_argc,F_argv_S,F_cmdtyp_S,F_v1,F_v2)
*
#include "impnone.cdk"
*
        integer F_argc,F_v1,F_v2
        character *(*) F_argv_S(0:F_argc),F_cmdtyp_S     
*
*author Vivian Lee - RPN - April 1999
*
*revision
* v2_00 - Lee V.         - initial MPI version
* v2_10 - Lee V.         - corrected so that all eta levels are
* v2_10                    outputted when a "-1" is indicated
* v2_21 - Dugas B.       - use convip
* v2_30 - Lee V.         - reduced dimension of Level_typ to 1
* v2_31 - Lee V.         - output on Ver_hyb coordinates
* v2_32 - Lee V.         - levset is now an ID defined by user, not the 
* v2_32                    actual "set" number forced to be in sequence
* v3_01 - Lee V.         - new ip1 encoding (kind=5 -- unnormalized)
* v3_02 - Lee V.         - eliminate levels repeated in one level set
* V3_22 - Plante A.      - staggered version
*
*
*object
*       initialization of the common block LEVEL. This function is
*       called when the keyword "levels" is found in the first word
*       of the directives in the input file given in the statement
*       "process_f_callback". This feature is enabled by the
*       ARMNLIB "rpn_fortran_callback" routine (called in "srequet")
*       which allows a different way of passing user directives than
*       the conventional FORTRAN namelist. This function will process
*       the following example command read from the named input file.
*
* ie:  levels=1,pres,[1000.,925.,850.];
*
*       The "rpn_fortran_callback" routine will process the above
*       statement and return 5 arguments to this function. For more
*       information to how this is processed, see "SREQUET".
*	
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_argc       I    - number of elements in F_argv_S
* F_argv_S     I    - array of elements received
*                     if F_argv_S(ii) contains "[", the value in this
*                     argument indicates number of elements following it.
* F_cmdtyp_S   I    - character command type - not used
* F_v1         I    - integer parameter 1 - not used
* F_v2         I    - integer parameter 2 - not used
*----------------------------------------------------------------
*
*Notes:
*
*    levels=levelset#,pres/eta/arbitrary,{list};
* ie:  levels=2,eta,[1,5,10];
*      levels=3,eta,<1,28,2>;
*      levels=4,eta,-1;
*
*      Should label the levelset# sequentially: 1,2,3,....
*      'eta'       - model levels (eta)
*      'pres'      - pressure (hPa)
*      '-1' with "eta" levels will give all model levels.
*      [a,b,c] means level a,b and c are requested
*      <a,b,c> means levels a to b, incrementing every c are requested
*
*implicits
#include "glb_ld.cdk"
#include "dimout.cdk"
#include "level.cdk"
#include "lun.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
*
**
      logical press_L,eta_L,found_L
      character*5 stuff_S,blank_S
      integer i,j,k,ii,idx,levset,num,kindip1,modeip1,ilevel,nk_t
      real current,hyb_val(MAXLEV,MAXSET),hyb_val_m(MAXLEV,MAXSET)
*
*     ---------------------------------------------------------------
*
      nk_t=G_nk+2
      
      if (Lun_out.gt.0) then
          write(Lun_out,*)
          write(Lun_out,*) ' ',F_argv_S(0),'=',F_argv_S(1),',',F_argv_S(2),',',(F_argv_S(i),i=3,F_argc)
      endif
      set_level = 0
      read( F_argv_S(1), * ) levset
      Level_sets = Level_sets + 1

      if (Level_sets.gt.MAXSET) then

          if (Lun_out.gt.0)
     $    write(Lun_out,*)'SET_LEVEL WARNING: Too many sets of LEVELS'
          Level_sets = Level_sets -1
          set_level=1
          return

      endif

      j=Level_sets
      i=0
      Level_id(j)=levset

*      i is the counter for the number of levels requested

      press_L = .false.
      eta_L   = .false.
      kindip1 = -1

      do 100 ii=2,F_argc

         if (index(F_argv_S(ii),'[').gt.0) then

            stuff_S=F_argv_S(ii)
            read( stuff_S(2:4), * ) num

         else if (F_argv_S(ii).eq.'eta') then
            if (press_L) then
                if (Lun_out.gt.0) write(Lun_out,*)
     $              'SET_LEVEL WARNING: Only one level type can be defined'
                Level_sets = Level_sets -1
                set_level=1
                return
            endif

*           kindip1 = 1 => hybrid
            kindip1 = 1
            modeip1 = +1
            if (Level_kind_ip1.eq.5) modeip1 = +2
            eta_L = .true.
         else if (F_argv_S(ii).eq.'pres') then
            if (eta_L) then
                if (Lun_out.gt.0) write(Lun_out,*)
     $              'SET_LEVEL WARNING: Only one level type can be defined'
                Level_sets = Level_sets -1
                set_level=1
                return
            endif

            kindip1 = 2
            press_L = .true.

         else if (kindip1.ge.1) then

            i = i+1
            read( F_argv_S(ii), * ) current

            if (current.eq.-1) then

               if (eta_L) then

*                 Request for all model levels but 
*                 all variables on thermo levels (eta).
*                 This means that momentum variables will be interpolated
*                 on thermo levels.
                  
                  Level_typ(j)='M'

                  i = i-1
                  
                  do idx=1,nk_t
*                    Thermo levels
                     i = i+1
                     Hyb_Val(i,j) = ver_hyb_8%t( idx )
c                    Pour valeur de ptop/pref 'a 1.0 utiliser la ligne suivante :
c                     Hyb_Val(i,j) = ver_hybm_8%t( idx )
                     Level(i,j) = float( idx )
                  end do

               endif

            else if (current.eq.0) then
*
*              request diagnostic level

                 Level_typ(j)='M'
                 Hyb_Val(i,j) = 0.
                 Level(i,j) = 12000.

            else 

               if (kindip1.eq.1) then

                  if (eta_L) then
                                       
                     Level_typ(j)='M'
                     
                     if (current .lt. 0 .or. current.gt.nk_t) then
                        if (Lun_out.gt.0) write(Lun_out,*)
     $                       'SET_LEVEL WARNING: Level index out of range'
                        i = i - 1
                     else
                        idx = nint(current)
                        Hyb_Val(i,j) = ver_hybm_8%t( idx )
                        Level(i,j) = float( idx )
                     endif
                     
                  endif
                  
               else if (kindip1.eq.2) then

                  Level_typ(j)='P'
                  hyb_val(i,j)=current
                  level(i,j) = current
                  level_m(i,j) = current

               else

                  if (Lun_out.gt.0) write(Lun_out,*)
     $              'SET_LEVEL WARNING: Level type not recognizable'
                  Level_sets = Level_sets -1
                  set_level=1
                  return

               endif

            endif

         endif

 100  continue

      if (i.gt.MAXLEV) then

         if (Lun_out.gt.0)
     $   write(Lun_out,*)'SET_LEVEL WARNING: Requested levels > MAXLEV'
         Level_sets = Level_sets -1
         set_level = 1
         return

      endif

      if (i.eq.0) then

         if (Lun_out.gt.0)
     $   write(Lun_out,*)'SET_LEVEL WARNING: No levels requested'
         Level_sets = Level_sets -1
         set_level = 1
         return

      endif
*     Eliminate repeated levels in one Level set
      ilevel = 1
      do ii = 2, i
         found_L = .false.
         do k = 1, ii-1
            if ( Hyb_Val(ii,j).eq.Hyb_Val(k,j) ) found_L = .true.
         enddo
         if (.not. found_L) then
             ilevel = ilevel + 1
             Hyb_Val(ilevel,j) = Hyb_Val(ii,j)
             Level(ilevel,j)    = Level(ii,j)
             Hyb_Val_m(ilevel,j) = Hyb_Val_m(ii,j)
             Level_m(ilevel,j)    = Level_m(ii,j)
         endif
      enddo

      Level_max(Level_sets)=ilevel
      Level_max_m(Level_sets)=ilevel
      if(Level_max(Level_sets).gt.G_nk)Level_max_m(Level_sets)=G_nk

      if (Lun_out.gt.0) then

         write(Lun_out,*) ' Level_set(',j,') : Level_id=',Level_id(j)
         write(Lun_out,*) ' Level_typ=',Level_typ(j)
         if(eta_L)then
            write(Lun_out,*) ' Thermo levels (Variables on momentum levels will be interpolated)'
            write(Lun_out,*) ' Hybrid values for thermo levels:'
            write(Lun_out,'(8f11.7)') (Hyb_Val(i,j),i=1,Level_max(j))
            write(Lun_out,*) ' Thermo level index:'
            write(Lun_out,'(8i11)') (nint(Level(i,j)),i=1,Level_max(j))
         endif
         if(press_L)then
            write(Lun_out,*) ' Pressure Levels'
            write(Lun_out,'(8i7)') (nint(Hyb_Val(i,j)),i=1,Level_max(j))
         endif
         
      endif
*     
 6002 format(' SET_LEVEL WARNING: pressure level out of range =',e10.5)
*
*     ---------------------------------------------------------------
*
      return
      end

