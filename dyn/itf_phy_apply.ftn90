!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r itf_phy_apply - apply tendencies to dynamical variables
!
#include "model_macros_f.h"
!
      subroutine itf_phy_apply ( F_apply_L )
      use nest_blending, only: nest_blend
      implicit none
!
      logical,intent(IN) :: F_apply_L
!
!author
!     Michel Roch - rpn - april 1994
!
!revision
! v2_00 - Desgagne M.       - initial MPI version
! v2_30 - Edouard S.        - change call to uv2tdzd
! v2_31 - Desgagne M.       - clean up and introduce h2o tracers
! v3_00 - Laroche S.        - adaptation to include simplified physics
! v3_02 - Plante A.         - water loading
! v3_03 - Desgagne M.       - new switches for secondary tendencies
! v3_12 - Dugas B.          - no longer zero out tendencies in the LAM
!                             blending area, following Lam_0ptend_L
! v3_20 - Laroche S.        - slight modification to rpn_comm_xch_halo call
! v3_21 - Tanguay M.        - Zero wk5 for hatoprg
! v3_21 - Desgagne M.       - Revision OpenMP
! v3_30 - Spacek L.         - Eliminate filter for condensation tendencies
!                             and arguments F_tcond,F_qdifv
! v4_03 - Spacek L.         - Staggered version
! v4_04 - Spacek L.         - correction pnt_trp(1) to pnt_trp(HUCOND)!
! v4_05 - Lee V.            - remove OMP on Schm_wload, correction on h2o loop
! v4_06 - Lepine M.         - VMM replacement with GMM
!
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "cstv.cdk"
#include "nest.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "geomg.cdk"
#include "lam.cdk"
#include "vt1.cdk"
#include "vtx.cdk"
#include "p_geof.cdk"
#include "pw.cdk"
#include "itf_phy_buses.cdk"
!
      logical nest_it, flag_u, flag_v
      integer i, j, k, n, err, cnt, UU_indx, VV_indx, km1
      real wk2(LDIST_SHAPE,p_nk),con(YDIST_SHAPE),con2, &
           tdu(LDIST_SHAPE,p_nk),tdv(LDIST_SHAPE,p_nk)
      real, pointer, dimension(:,:,:) :: tr,trm
!*
!     __________________________________________________________________
!
      flag_u  = .False. ; flag_v = .false.
      wk2     = 0.
!
      nest_it = ( Lam_0ptend_L .and. G_lam .and. &
                ((Lam_blend_Hx.gt.0).or.(Lam_blend_Hy.gt.0)) )
!
      con(:)  = cos(geomg_y_8(:)) / Dcst_rayt_8
!
      if (.not. F_apply_L) then
      
         cnt = 0
         do n=1,p_bvol_top

         if (volnm(n)(1:5) .eq. 'PHYTD') then
            cnt = cnt + 1
            nullify(tr,trm)
            gmmstat = gmm_get('TR/'//trim(volnm(n)(7:))//':P',tr,meta3d)
	    if (gmmstat.eq.0) then
               if (trim(volnm(n)(7:)).ne.'HU') then
                  gmmstat = gmm_get('TR/'//trim(volnm(n)(7:))//':M',trm,meta3d)
                  do k=1,p_nk-1
                  do j= 1+pil_s, l_nj-pil_n
                  do i= 1+pil_w, l_ni-pil_e
                     tr(i,j,k)  = tr(i,j,k) + Cstv_dt_8*phy_tend(i,j,k,cnt)
                     trm(i,j,k) = tr(i,j,k)
                  end do
                  end do
                  end do
               endif
            endif
         endif

         end do

         return

      endif

      cnt     = 0
      UU_indx = 0
      VV_indx = 0

      do n = 1, p_bvol_top

         if (volnm(n)(1:5) .eq. 'PHYTD') then
            cnt = cnt + 1
            if  (volnm(n)(7:)  .eq. 'UU') UU_indx=cnt
            if  (volnm(n)(7:)  .eq. 'VV') VV_indx=cnt
            if ((volnm(n)(7:)  .eq. 'UU') .or. (volnm(n)(7:)  .eq. 'VV') ) cycle

            if ( nest_it ) call nest_blend (phy_tend(:,:,:,cnt),wk2, &
                                            LDIST_DIM,1,p_nk,'M')
            nullify(tr)
            gmmstat = gmm_get('TR/'//trim(volnm(n)(7:))//':P',tr,meta3d)
	    if (gmmstat.eq.0) then
               do k=1,p_nk
               do j= 1+pil_s, l_nj-pil_n
               do i= 1+pil_w, l_ni-pil_e
                  tr(i,j,k) = tr(i,j,k) + Cstv_dt_8*phy_tend(i,j,k,cnt)
               end do
               end do
               end do
            endif

            if (volnm(n)(7:)  .eq. 'TT'   ) then
               nullify(pw_tplus,tt1)
               gmmstat = gmm_get('PW_TT:P',pw_tplus,meta3d)
               gmmstat = gmm_get(gmmk_tt1_s,tt1     ,meta3d)
               do k= 1, p_nk
               do j= 1+pil_s, l_nj-pil_n
               do i= 1+pil_w, l_ni-pil_e
                  pw_tplus(i,j,k) = pw_tplus(i,j,k) + Cstv_dt_8*phy_tend(i,j,k,cnt)
               end do
               end do
               end do
               call tt2virt (tt1, .true., 'P')
            endif

         endif

      end do
!
      if ((UU_indx.gt.0) .and. (VV_indx.gt.0)) then
         nullify(ut1,vt1,pw_uplus,pw_vplus)
         gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
         gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
         gmmstat = gmm_get('PW_UU:P',pw_uplus,meta3d)
         gmmstat = gmm_get('PW_VV:P',pw_vplus,meta3d)

! TODO: update pw_uplus, pw_vplus here instead of pw_update

	 tdu = 0. ; tdv = 0.
         do k= 1, p_nk
         do j= 1, l_nj
         do i= 1, l_ni
!            tdu(i,j,k) = phy_tend(i,j,k,UU_indx)
!            tdv(i,j,k) = phy_tend(i,j,k,VV_indx)
         end do
         end do
         end do

         if ( nest_it ) then
!            call nesajr (phy_tend(l_minx,l_miny,1,UU_indx), wk2, LDIST_DIM,p_nk,0,0,Lam_blend_Hx,Lam_blend_Hy,Lam_blend_T)
!            call nesajr (phy_tend(l_minx,l_miny,1,VV_indx), wk2, LDIST_DIM,p_nk,0,0,Lam_blend_Hx,Lam_blend_Hy,Lam_blend_T)
!            call nesajr (tdu, wk2, LDIST_DIM,p_nk,0,0,Lam_blend_Hx,Lam_blend_Hy,Lam_blend_H_z)
!            call nesajr (tdv, wk2, LDIST_DIM,p_nk,0,0,Lam_blend_Hx,Lam_blend_Hy,Lam_blend_H_z)
         endif
         do k= 1, p_nk
         do j= 1+pil_s, l_nj-pil_n
         do i= 1+pil_w, l_ni-pil_e
!            pw_uplus(i,j,k) = pw_uplus(i,j,k) + Cstv_dt_8*phy_tend(i,j,k,UU_indx)
!            pw_vplus(i,j,k) = pw_vplus(i,j,k) + Cstv_dt_8*phy_tend(i,j,k,VV_indx)
!ccc            pw_uplus(i,j,k) = pw_uplus(i,j,k) + Cstv_dt_8*tdu(i,j,k)
!ccc            pw_vplus(i,j,k) = pw_vplus(i,j,k) + Cstv_dt_8*tdv(i,j,k)
         end do
         end do
         end do

         do k= 1, p_nk
         do j= 1, l_nj
         do i= 1, l_ni
            tdu(i,j,k) = phy_tend(i,j,k,UU_indx)*con(j)
            tdv(i,j,k) = phy_tend(i,j,k,VV_indx)*con(j)
         end do
         end do
         end do

         call itf_phy_uvgridscal (tdu, tdv, LDIST_DIM, p_nk, .false. )

         if ( nest_it ) then
            call nest_blend (tdu,wk2,LDIST_DIM,1,p_nk,'U')
            call nest_blend (tdv,wk2,LDIST_DIM,1,p_nk,'V')
         endif
!
         do k=1,l_nk+1
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_niu-pil_e
               ut1 (i,j,k) =  ut1(i,j,k) + Cstv_dt_8*tdu(i,j,k+1)
            end do
            end do
            do j= 1+pil_s, l_njv-pil_n
            do i= 1+pil_w, l_ni-pil_e
               vt1 (i,j,k) =  vt1(i,j,k) + Cstv_dt_8*tdv(i,j,k+1)
            end do
            end do
         end do
!
      endif
!
      if (Schm_pheat_L) then
         nullify(st1,fiptx,topo)
         gmmstat = gmm_get(gmmk_st1_s  ,st1  ,meta2d)
         gmmstat = gmm_get(gmmk_fiptx_s,fiptx,meta3d)
         gmmstat = gmm_get(gmmk_topo_s ,topo ,meta2d)
         call diag_fip(fiptx,st1,tt1,topo, &
                       1+pil_w,l_ni-pil_e,1+pil_s,l_nj-pil_n,l_nk)
      endif
!
!     __________________________________________________________________
!
      return
      end
