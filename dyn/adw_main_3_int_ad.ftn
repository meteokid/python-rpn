***s/r adw_main_3_int_ad - ADJ of adw_main_3_int_tl 
*
#include <model_macros_f.h>
*
      subroutine adw_main_3_int_ad ( F_u, F_v, F_w, F_um, F_vm, F_wm )
*
#include "impnone.cdk"
      real F_u (*),F_v (*),F_w (*)
      real F_um(*),F_vm(*),F_wm(*)
*
*author
*     monique tanguay
*
*revision
* v2_31 - Tanguay M.        - initial MPI version
* v3_00 - Tanguay M.        - adapt to restructured adw_main 
* v3_00 - Tanguay M.        - restore vectorization in adjoint of semi-Lag.
* v3_02 - Tanguay M.        - restore tracers monotone if V4dg_conf.ne.0
*
*language
*     fortran 77
*
*object
*     see id section
*
*ADJ of
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
*        |                                                       |     |
*        |                                                       |     |
* F_u,F_v| 3 components of upstream positions at t1 at input     |  iw |
* F_w    | used as work field afterward                          |     |
*________|_______________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "ptopo.cdk"
#include "geomg.cdk"
#include "orh.cdk"
#include "lun.cdk"
#include "schm.cdk"
#include "offc.cdk"
#include "cstv.cdk"
#include "rhsc.cdk"
#include "v4dg.cdk"
#include "adw.cdk"
#include "tr2d.cdk"
#include "tr3d.cdk"
#include "vt1.cdk"
#include "vt0.cdk"
#include "adwm.cdk"
#include "rhscm.cdk"
#include "vt1m.cdk"
#include "vt0m.cdk"
*
*modules
      integer  vmmlod, vmmget, vmmuld
      external vmmlod, vmmget, vmmuld
************************************************************************
      integer i0,in,j0,jn
      integer pnerr, pnlkey1(30), key1(Tr3d_ntr), key0(Tr3d_ntr), 
     $        key1_, key0_, pnlod, err
      integer key1m(Tr3d_ntr), key0m(Tr3d_ntr), key1m_, key0m_ 
*
      integer n, nij, nijk, nijkag, i,j,k
*
      real*8 aaa_8
      real tr,tr0
      pointer (patr, tr(LDIST_SHAPE,*)),(patr0, tr0(LDIST_SHAPE,*))
      real trm,tr0m
      pointer (patrm, trm(LDIST_SHAPE,*)),(patr0m, tr0m(LDIST_SHAPE,*))
*
*     ---------------------------------------------------
*     Allocate extra space TRAJ (x y z upstream position)
*     ---------------------------------------------------
      real F_um_1(l_ni*l_nj*l_nk),F_vm_1(l_ni*l_nj*l_nk)
      real F_wm_1(l_ni*l_nj*l_nk)
*
*     -----------------------
*     Define extra work space
*     -----------------------
      real work(LDIST_SHAPE,l_nk)
*
      real*8, parameter :: ZERO_8 = 0.0
*
      logical plpr_L
*
*     ------------------------------------------
*     Variables needed to restore  vectorization
*     in semi-Lagrangian adjoint interp.
*     (Based on Clive Temperton ECMWF method)
*     ------------------------------------------
      integer inca,ibase1,ibase2,count,stencil,nfld,kdim,ksep,klev,ilevels,
     %        istart,istop,ij,jinc,indice,nijplus,iscrap,group,
     %        myint1,myint2,plus1,plus2,minus1,minus2,ijk
      real scrap,tempo
      logical lscrap_L
      integer, dimension(:,:),allocatable :: kinc
      real   , dimension(:,:),allocatable :: zinc
      real   , dimension(:)  ,allocatable :: buff
*     ______________________________________________________
*
      if(.not. Schm_hydro_L) call gem_stop('adw_main_3_int_ad',-1)
      if(     Tr2d_ntr.ne.0) call gem_stop('adw_main_3_int_ad',-1)
      if(     G_lam        ) call gem_stop('adw_main_3_int_ad',-1)
*     ______________________________________________________
*
      if (Lun_debug_L) write (Lun_out,1000)
*
*     Flag for diagnostics
*     --------------------
      plpr_L = .false.
*
      nij    = l_ni   *l_nj
      nijk   = l_ni   *l_nj   *l_nk
      nijkag = Adw_nit*Adw_njt*l_nk
      call hpalloc(Adw_capx1_   ,nijk,      err,1)
      call hpalloc(Adw_capy1_   ,nijk,      err,1)
      call hpalloc(Adw_capz1_   ,nijk,      err,1)
      call hpalloc(Adw_n1_      ,nijk,      err,1)
      call hpalloc(Adw_xdd1_    ,nijk,      err,1)
      call hpalloc(Adw_xgg1_    ,nijk,      err,1)
      call hpalloc(Adw_ydd1_    ,nijk,      err,1)
      call hpalloc(Adw_ygg1_    ,nijk,      err,1)
      call hpalloc(Adw_cz1_     ,nijk,      err,1)
      call hpalloc(Adw_c1_      ,nijk,      err,1)
      call hpalloc(Adw_wrkb_    ,nijk,      err,1)
      call hpalloc(Adw_wrkc_    ,nijk,      err,1)
*
      call hpalloc(Adwm_capx1m_ ,nijk,      err,1)
      call hpalloc(Adwm_capy1m_ ,nijk,      err,1)
      call hpalloc(Adwm_capz1m_ ,nijk,      err,1)
      call hpalloc(Adwm_n1m_    ,nijk,      err,1)
      call hpalloc(Adwm_xdd1m_  ,nijk,      err,1)
      call hpalloc(Adwm_xgg1m_  ,nijk,      err,1)
      call hpalloc(Adwm_ydd1m_  ,nijk,      err,1)
      call hpalloc(Adwm_ygg1m_  ,nijk,      err,1)
      call hpalloc(Adwm_cz1m_   ,nijk,      err,1)
      call hpalloc(Adwm_c1m_    ,nijk,      err,1)
      call hpalloc(Adwm_wrkbm_  ,nijk,      err,1)
      call hpalloc(Adwm_wrkcm_  ,nijk,      err,1)
*
*     Zero adjoint variables 
*     ----------------------
      do n=1,nijk
         Adw_capx1(n) = ZERO_8
         Adw_capy1(n) = ZERO_8
         Adw_capz1(n) = ZERO_8
         Adw_n1   (n) = ZERO_8
         Adw_xdd1 (n) = ZERO_8
         Adw_xgg1 (n) = ZERO_8
         Adw_ydd1 (n) = ZERO_8
         Adw_ygg1 (n) = ZERO_8
         Adw_cz1  (n) = ZERO_8
         Adw_c1   (n) = ZERO_8
         Adw_wrkb (n) = ZERO_8
         Adw_wrkc (n) = ZERO_8
      enddo
*
*     -------------------------------------
*     Prepare restoration  of vectorization
*     in semi-Lagrangian adjoint interp.
*     -------------------------------------
*
*        Modify dimension for efficiency
*        -------------------------------
         nijplus = nij
         if(2*(nij/2).eq.nij) nijplus = nij + 1
*
*        Size of the stencil for 3D cubic interpolation
*        ----------------------------------------------
         stencil = 64
*
*        Set if done in 1 or 2 groups
*        ----------------------------------------------------------------------------
*        NOTE: This is used to allow a trade off between the memory of buffer and
*              the size of the loop where increments F_zinc are added back to buffer.
*        ----------------------------------------------------------------------------
*        NOTE: If group=1, all variables to interpolate are done together.
*              If group=2, the variables to interpolate are divided in 2 groups.
*                          Remark:group=29 will refer to the 2nd group of variables.
*        ----------------------------------------------------------------------------
         group = 2
*
*        Set coloring of vertical levels
*        -------------------------------
         ksep   = 0
         myint2 = 0
          plus2 = 0
         minus2 = 0
         do k =1,l_nk
         do j =1,l_nj
         do i =1,l_ni
            ijk = nij*(k-1) + l_ni*(j-1) + i
            tempo  =         l_nk*(      F_wm(ijk)-Geomg_z_8(k))/
     %                            (Geomg_z_8(l_nk)-Geomg_z_8(1))
            myint1 = int(abs(tempo)) + 1
            if(tempo.gt.0.) then
               plus1 = myint1
               plus2 = max(plus2,plus1)
            else
               minus1 = - myint1
               minus2 = - max(- minus2,- minus1)
            endif
            myint2 = max(myint2,myint1)
         enddo
         enddo
         enddo
         ksep = max(ksep,- minus2 + plus2 + 1)
         if(plpr_L) write(6,*) ' Ptopo_myproc =',Ptopo_myproc,
     %                         ' TRICUB ksep minus2 plus2 =',ksep,minus2,plus2
*
************************************************************************
*
*     ----------------------------------------------------
*     Preserve x y z upstream position in extra space TRAJ
*     ----------------------------------------------------
      do n =1,nijk
         F_um_1(n)  = F_um(n)
         F_vm_1(n)  = F_vm(n)
         F_wm_1(n)  = F_wm(n)
      enddo
*
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west) i0=4
          if (l_east) in=l_niu-2
          if (l_south) j0=4
          if (l_north) jn=l_njv-2
      endif
*
*     ----------
*     TRAJECTORY
*     ----------
      call adw_setint ( Adwm_n1m,Adwm_capx1m,Adwm_xgg1m,Adwm_xdd1m,Adwm_capy1m,Adwm_ygg1m,
     %                  Adwm_ydd1m, Adwm_capz1m, Adwm_cz1m, F_um, F_vm, F_wm,
     %                 .true., .true., .false., nijk,i0,in,j0,jn,l_nk)
*
*     --------------------
*     ADJOINT CALCULATIONS
*     --------------------
***********************************************************************
* ADJ of
* Perform interpolation
***********************************************************************
*
*     ----------------------------------
*     NOTE: F_u  F_v  used as WORK SPACE
*     NOTE: F_um F_vm used as WORK SPACE
*     ----------------------------------
*
 3000 continue
*
*     -------------------------------------
*     Prepare restoration  of vectorization
*     in semi-Lagrangian adjoint interp.
*     -------------------------------------
*
*        Number of fields to treat
*        -------------------------
         if(group.eq.1) then
*
            nfld = 4
            if(Orh_icn.eq.Schm_itcn) nfld = nfld +  Tr3d_ntr
*
         elseif(group.eq.2.or.group.eq.29) then
*
            nfld = 2
            if(Orh_icn.eq.Schm_itcn.and.group.eq.2) nfld = 2 +  Tr3d_ntr
*
         else
            call gem_stop('adw_main_3_int_ad',-1)
         endif
*
*        Number of independent positions at a given level
*        ------------------------------------------------
         kdim = stencil*nfld
*
         if(group.eq.29) deallocate(kinc,zinc,buff)
*
*        Allocation
*        ----------
         allocate (kinc(nijplus,kdim*l_nk),zinc(nijplus,kdim*l_nk),
     %             buff(nijkag*nfld*2))
*
*        Zero adjoint variables
*        ----------------------
         do i = 1,kdim*nijplus*l_nk
            kinc(i,1) = 0
         enddo
*
         do i = 1,kdim*nijplus*l_nk
            zinc(i,1) = 0
         enddo
*
         do i = 1,nijkag*nfld*2
            buff(i) = ZERO_8
         enddo
*
*        Zero counter
*        ------------
         count = 0
*
         if(group.eq.29) goto 3001
*
*     -----------------------------------
*     -----------------------------------
*     Adjoint of interpolations (IPART=1)
*     ----------------------------------------------------------------------------------------
*     NOTE:In adw_interp_ad, IPART=1 i.e does the adjoint of tri-cubic semi-Lagrangian interp.
*          but keeps in zinc the increments causing unvectorization.
*     ----------------------------------------------------------------------------------------
*     ----------------------------------------------------------------------------------------
*
*     --------------------------------------------
*     Adjoint of 3D Tracer interpolation (IPART=1)
*     --------------------------------------------
      if ( Orh_icn .eq. Schm_itcn ) then
*
* ADJ of
* tr3d advection
*
      aaa_8 = ( Offc_a1_8 / Offc_b0_8 )/ Cstv_dt_8
*
      key0_ = VMM_KEY (trt0)
      key0m_= VMM_KEY (trt0m)
      do n=1,Tr3d_ntr
         key0 (n)= key0_  + n
         key0m(n)= key0m_ + n
      end do
      if (Tr3d_ntr.gt.0) then
         err = vmmlod(key0, Tr3d_ntr)
         err = vmmlod(key0m,Tr3d_ntr)
         do n=1,Tr3d_ntr
            err = vmmget(key0 (n),patr0, tr0 )
            err = vmmget(key0m(n),patr0m,tr0m)
            do k=1,G_nk
            do j=1,l_nj
            do i=1,l_ni
*              ADJ 
*              ---
               tr0(i,j,k) = Cstv_tau_8*tr0(i,j,k)
            end do
            end do
            end do
*
*           Transfer field in extra work space
*           ----------------------------------
            do k=1,l_nk
            do j=l_miny,l_maxy
            do i=l_minx,l_maxx
               work(i,j,k) = tr0(i,j,k)
                tr0(i,j,k) = ZERO_8
            enddo
            enddo
            enddo
*
*           Fix localization parameters
*           ---------------------------
            count  =    count+1
            inca   =   (count-1) * stencil
            ibase1 = 2*(count-1) * nijkag
            ibase2 = ibase1      + nijkag
*
*           Adjoint of interpolation (IPART=1)
*           ----------------------------------
            call adw_interp_ad (work,scrap,scrap,scrap,
     %                               tr0m, F_um, F_vm,
     %                          .false.,.true.,LDIST_DIM,l_nk,
     %                          1,inca,zinc,kdim,nij,nijplus,l_nk,ksep)
*
*           Set kinc separately from adw_interp_ad
*           --------------------------------------
            call v4d_kinc ( Adwm_n1m,nijk,.false.,ibase1,ibase2,inca,kinc,kdim,
     %                      nij,nijplus,l_nk,ksep)
*
         end do
         err = vmmuld(key0, Tr3d_ntr)
         err = vmmuld(key0m,Tr3d_ntr)
      endif
*
      endif
*
*     -----------------------------------------------
*     Adjoint of RCN and RTH interpolations (IPART=1)
*     -----------------------------------------------
*
*     VMM Initializations
*     -------------------
      pnlkey1(1) = VMM_KEY(rcn)
      pnlkey1(2) = VMM_KEY(rth)
      pnlod = 2
*
      pnlkey1(1+pnlod) = VMM_KEY(rcnm)
      pnlkey1(2+pnlod) = VMM_KEY(rthm)
      pnlod = 2+pnlod
*
      pnerr = vmmlod(pnlkey1,pnlod)
*
      pnerr = VMM_GET_VAR(rcn)
      pnerr = VMM_GET_VAR(rth)
*
      pnerr = VMM_GET_VAR(rcnm)
      pnerr = VMM_GET_VAR(rthm)
*
*     Transfer field in extra work space
*     ----------------------------------
      do k=1,l_nk
      do j=l_miny,l_maxy
      do i=l_minx,l_maxx
         work(i,j,k) = rth(i,j,k)
          rth(i,j,k) = ZERO_8
      enddo
      enddo
      enddo
*
*     Fix localization parameters
*     ---------------------------
      count  =    count+1
      inca   =   (count-1) * stencil
      ibase1 = 2*(count-1) * nijkag
      ibase2 = ibase1      + nijkag
*
*     Adjoint of interpolation (IPART=1)
*     ----------------------------------
      call adw_interp_ad (work,scrap,scrap,scrap,
     %                         rthm, F_um, F_vm,
     %                    .false.,.false.,LDIST_DIM,l_nk,
     %                    1,inca,zinc,kdim,nij,nijplus,l_nk,ksep)
*
*     Set kinc separately from adw_interp_ad
*     --------------------------------------
      call v4d_kinc ( Adwm_n1m,nijk,.false.,ibase1,ibase2,inca,kinc,kdim,
     %                nij,nijplus,l_nk,ksep)
*
*     Transfer field in extra work space
*     ----------------------------------
      do k=1,l_nk
      do j=l_miny,l_maxy
      do i=l_minx,l_maxx
         work(i,j,k) = rcn(i,j,k)
          rcn(i,j,k) = ZERO_8
      enddo
      enddo
      enddo
*
*     Fix localization parameters
*     ---------------------------
      count  =    count+1
      inca   =   (count-1) * stencil
      ibase1 = 2*(count-1) * nijkag
      ibase2 = ibase1      + nijkag
*
      call adw_interp_ad (work,scrap,scrap,scrap,
     %                         rcnm, F_um, F_vm,
     %                    .false.,.false.,LDIST_DIM,l_nk,
     %                    1,inca,zinc,kdim,nij,nijplus,l_nk,ksep)
*
*     Set kinc separately from adw_interp_ad
*     --------------------------------------
      call v4d_kinc ( Adwm_n1m,nijk,.false.,ibase1,ibase2,inca,kinc,kdim,
     %                nij,nijplus,l_nk,ksep)
*
      pnerr = vmmuld(-1,0)
*
      if(group.eq.2) goto 3002
*
 3001 continue
*
*     -------------------------------------------------
*     Adjoint of RVW2 and RUW2 interpolations (IPART=1)
*     -------------------------------------------------
*
*     VMM Initializations
*     -------------------
      pnlkey1(1) = VMM_KEY(ruw2)
      pnlkey1(2) = VMM_KEY(rvw2)
      pnlod = 2
*
      pnlkey1(1+pnlod) = VMM_KEY(ruw1m)
      pnlkey1(2+pnlod) = VMM_KEY(rvw1m)
      pnlod = 2+pnlod
*
      pnerr = vmmlod(pnlkey1,pnlod)
*
      pnerr = VMM_GET_VAR(ruw2)
      pnerr = VMM_GET_VAR(rvw2)
*
      pnerr = VMM_GET_VAR(ruw1m)
      pnerr = VMM_GET_VAR(rvw1m)
*
*     Fix localization parameters
*     ---------------------------
      count  =    count+1
      inca   =   (count-1) * stencil
      ibase1 = 2*(count-1) * nijkag
      ibase2 = ibase1      + nijkag
*
*     Adjoint of interpolation (IPART=1)
*     ----------------------------------
      call adw_interp_ad (rvw2,scrap,scrap,scrap,
     %                         rvw1m,F_um, F_vm,
     %                    .true.,.false.,LDIST_DIM,l_nk,
     %                    1,inca,zinc,kdim,nij,nijplus,l_nk,ksep)
*
*     Set kinc separately from adw_interp_ad
*     --------------------------------------
      call v4d_kinc ( Adwm_n1m,nijk,.false.,ibase1,ibase2,inca,kinc,kdim,
     %                nij,nijplus,l_nk,ksep)
*
*     Fix localization parameters
*     ---------------------------
      count  =    count+1
      inca   =   (count-1) * stencil
      ibase1 = 2*(count-1) * nijkag
      ibase2 = ibase1      + nijkag
*
*     Adjoint of interpolation (IPART=1)
*     ----------------------------------
      call adw_interp_ad (ruw2,scrap,scrap,scrap,
     %                         ruw1m,F_um, F_vm,
     %                    .true.,.false.,LDIST_DIM,l_nk,
     %                    1,inca,zinc,kdim,nij,nijplus,l_nk,ksep)
*
*     Set kinc separately from adw_interp_ad
*     --------------------------------------
      call v4d_kinc ( Adwm_n1m,nijk,.false.,ibase1,ibase2,inca,kinc,kdim,
     %                nij,nijplus,l_nk,ksep)
*
      pnerr = vmmuld(-1,0)
*
 3002 continue
*
*     ------------------------------
*     Introduce increments in buffer
*     ------------------------------
*
*     ----------------------------------------------------
*     CAUTION: DO NOT CHANGE the following loop ordering
*     1) Loop on JINC must be innermost for vectorization
*     2) The chopping is done to guarantee safety
*        of the vectorization
*     ----------------------------------------------------
      do ij = 1,nij
         istop  = 0
*
         do klev=1,ksep
*
            ilevels=(l_nk-klev)/ksep + 1
            istart = istop + 1
            istop  = istart+ilevels*kdim-1
*
*VDIR NODEP
            do jinc=istart,istop
               buff(kinc(ij,jinc)) = buff(kinc(ij,jinc)) + zinc(ij,jinc)
            enddo
*
         enddo
      enddo
*
*     -------------------------------------
*     -------------------------------------
*     Transfer of buffer in model variables
*     -----------------------------------------------------------------------------------------
*     NOTE:In adw_interp_ad, IPART=2 i.e does the adjoint of 2nd derivate and addition to field   
*     -----------------------------------------------------------------------------------------
*     -----------------------------------------------------------------------------------------
*
      count = 0 
*
      if(group.eq.29) goto 3003
*
*     --------------------------------------------
*     Adjoint of 3D Tracer interpolation (IPART=2)
*     --------------------------------------------
      if ( Orh_icn .eq. Schm_itcn ) then
*
      aaa_8 = ( Offc_a1_8 / Offc_b0_8 )/ Cstv_dt_8
*
*     VMM Initializations
*     -------------------
      key1_ = VMM_KEY (trt1)
      key0_ = VMM_KEY (trt0)
      do n=1,Tr3d_ntr
         key1 (n)= key1_  + n
         key0 (n)= key0_  + n
      end do
      if (Tr3d_ntr.gt.0) then
         err = vmmlod(key1, Tr3d_ntr)
         err = vmmlod(key0, Tr3d_ntr)
         do n=1,Tr3d_ntr
            err = vmmget(key1 (n),patr,  tr  )
            err = vmmget(key0 (n),patr0, tr0 )
*
*           Fix localization parameters   
*           ---------------------------
            count  =    count+1
            ibase1 = 2*(count-1) * nijkag
            ibase2 = ibase1      + nijkag  
*
*           Adjoint of interpolation (IPART=2) 
*           ----------------------------------
            call adw_interp_ad (scrap, tr0,buff(ibase1+1),buff(ibase2+1),
     %                               scrap,scrap,         scrap,
     %                          .false.,lscrap_L,LDIST_DIM,l_nk,
     %                          2,iscrap,scrap,iscrap,iscrap,iscrap,iscrap,iscrap)
*
            do k=1,G_nk
            do j=1,l_nj
            do i=1,l_ni
*              ADJ 
*              ---
               tr (i,j,k) = - aaa_8*tr0(i,j,k) + tr(i,j,k)
               tr0(i,j,k) = ZERO_8
            end do
            end do
            end do
         end do
         err = vmmuld(key1, Tr3d_ntr)
         err = vmmuld(key0, Tr3d_ntr)
      endif
*
      endif
*
*     -----------------------------------------------
*     Adjoint of RCN and RTH interpolations (IPART=2) 
*     -----------------------------------------------
*
*     VMM Initializations
*     -------------------
      pnlkey1(1) = VMM_KEY(rcn)
      pnlkey1(2) = VMM_KEY(rth)
      pnlod = 2 
*
      pnerr = vmmlod(pnlkey1,pnlod)
*
      pnerr = VMM_GET_VAR(rcn)
      pnerr = VMM_GET_VAR(rth)
*
*     Fix localization parameters   
*     ---------------------------
      count  =    count+1
      ibase1 = 2*(count-1) * nijkag
      ibase2 = ibase1      + nijkag  
*
*     Adjoint of interpolation (IPART=2) 
*     ----------------------------------
      call adw_interp_ad (scrap,  rth,buff(ibase1+1),buff(ibase2+1),
     %                          scrap,scrap,         scrap,
     %                    .false.,lscrap_L,LDIST_DIM,l_nk,
     %                    2,iscrap,scrap,iscrap,iscrap,iscrap,iscrap,iscrap)
*
*     Fix localization parameters   
*     ---------------------------
      count  =    count+1
      ibase1 = 2*(count-1) * nijkag
      ibase2 = ibase1      + nijkag  
*
*     Adjoint of interpolation (IPART=2) 
*     ----------------------------------
      call adw_interp_ad (scrap,  rcn,buff(ibase1+1),buff(ibase2+1),
     %                          scrap,scrap,         scrap,
     %                    .false.,lscrap_L,LDIST_DIM,l_nk,
     %                    2,iscrap,scrap,iscrap,iscrap,iscrap,iscrap,iscrap)
*
      pnerr = vmmuld(-1,0)
*
      if(group.eq.2) then
         group = 29
         goto 3000
      endif
*
 3003 continue
*
*     -------------------------------------------------
*     Adjoint of RVW2 and RUW2 interpolations (IPART=2) 
*     -------------------------------------------------
*
*     VMM Initializations
*     -------------------
      pnlkey1(1) = VMM_KEY(ruw1)
      pnlkey1(2) = VMM_KEY(rvw1)
      pnlod = 2 
*
      pnerr = vmmlod(pnlkey1,pnlod)
*
      pnerr = VMM_GET_VAR(ruw1)
      pnerr = VMM_GET_VAR(rvw1)
*
*     Fix localization parameters   
*     ---------------------------
      count  =    count+1
      ibase1 = 2*(count-1) * nijkag
      ibase2 = ibase1      + nijkag  
*
*     Adjoint of interpolation (IPART=2) 
*     ----------------------------------
      call adw_interp_ad (scrap, rvw1,buff(ibase1+1),buff(ibase2+1),
     %                          scrap,scrap,         scrap,
     %                     .true.,lscrap_L,LDIST_DIM,l_nk,
     %                    2,iscrap,scrap,iscrap,iscrap,iscrap,iscrap,iscrap)
*
*     Fix localization parameters   
*     ---------------------------
      count  =    count+1
      ibase1 = 2*(count-1) * nijkag
      ibase2 = ibase1      + nijkag  
*
*     Adjoint of interpolation (IPART=2) 
*     ----------------------------------
      call adw_interp_ad (scrap, ruw1,buff(ibase1+1),buff(ibase2+1),
     %                          scrap,scrap,         scrap,
     %                     .true.,lscrap_L,LDIST_DIM,l_nk,
     %                    2,iscrap,scrap,iscrap,iscrap,iscrap,iscrap,iscrap)
*
      pnerr = vmmuld(-1,0)
*
***********************************************************************
* Deallocate
***********************************************************************
      deallocate(kinc,zinc,buff)
*
************************************************************************
*
*     ---------------------------------------------------
*     Reset x y z upstream position from extra space TRAJ
*     ---------------------------------------------------
      call adw_setint_ad ( Adw_n1,    Adw_capx1,  Adw_xgg1,  Adw_xdd1,  Adw_capy1,  Adw_ygg1,
     %                     Adw_ydd1,  Adw_capz1,  Adw_cz1,   F_u,       F_v,        F_w,
     %                                                       F_um_1,    F_vm_1,     F_wm_1,
     %                     .true., .true., .false., nijk,i0,in,j0,jn,l_nk)
*
***********************************************************************
* Deallocate
***********************************************************************
      call hpdeallc(Adw_capx1_   ,err,1)
      call hpdeallc(Adw_capy1_   ,err,1)
      call hpdeallc(Adw_capz1_   ,err,1)
      call hpdeallc(Adw_n1_      ,err,1)
      call hpdeallc(Adw_xdd1_    ,err,1)
      call hpdeallc(Adw_xgg1_    ,err,1)
      call hpdeallc(Adw_ydd1_    ,err,1)
      call hpdeallc(Adw_ygg1_    ,err,1)
      call hpdeallc(Adw_cz1_     ,err,1)
      call hpdeallc(Adw_c1_      ,err,1)
      call hpdeallc(Adw_wrkb_    ,err,1)
      call hpdeallc(Adw_wrkc_    ,err,1)
*
      call hpdeallc(Adwm_capx1m_ ,err,1)
      call hpdeallc(Adwm_capy1m_ ,err,1)
      call hpdeallc(Adwm_capz1m_ ,err,1)
      call hpdeallc(Adwm_n1m_    ,err,1)
      call hpdeallc(Adwm_xdd1m_  ,err,1)
      call hpdeallc(Adwm_xgg1m_  ,err,1)
      call hpdeallc(Adwm_ydd1m_  ,err,1)
      call hpdeallc(Adwm_ygg1m_  ,err,1)
      call hpdeallc(Adwm_cz1m_   ,err,1)
      call hpdeallc(Adwm_c1m_    ,err,1)
      call hpdeallc(Adwm_wrkbm_  ,err,1)
      call hpdeallc(Adwm_wrkcm_  ,err,1)
*
      pnerr = vmmuld(-1,0)
*
 1000  format(3X,'ADJ of ADVECT THE RIGHT-HAND-SIDES: (S/R ADW_MAIN_3_INT_AD)')
*
      return
      end
