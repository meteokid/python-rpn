***s/r e_intwind - Wind components horizontal interpolation
*
#include <model_macros_f.h>
*
      subroutine e_intwind ( xu, yu, xv, yv, nu, nv )
#include "impnone.cdk"
*
      integer nv, nu
      real xu(*), yu(*), xv(*), yv(*) 
*
*author       M ROCH     - july 95 - from intvent
*
*revision
* v2_30 - Sandrine Edouard       - adapt for vertical hybrid coordinate
* v2_30 - L. Corbeil             - replaced ecriseq by BMF stuff, 
* v2_30                            removed vertical interpolation
* v2_31 - M. Desgagne            - removed toppu,toppv from calling sequence
* v2_31                            and corrected date/time recording
* v3_00 - Desgagne & Lee    - Lam configuration
*
*object
*        see above ID
*
*ARGUMENTS
*______________________________________________________________________
*                    |                                                 |
* NAME               | DESCRIPTION                                     |
*--------------------|-------------------------------------------------|
*  All are inputs                                                      |
*--------------------|-------------------------------------------------|
*  Xu                | coordinates along x for U grid                  |
*  Yu                | coordinates along y for U grid                  |
*  Xv                | coordinates along x for V grid                  |
*  Yv                | coordinates along y for V grid                  |
*----------------------------------------------------------------------
*
*IMPLICITS
#include "e_locdim.cdk"
#include "e_maxprms.cdk"
#include "e_option.cdk"
#include "e_files.cdk"
#include "e_anal.cdk"
#include "e_grids.cdk"
#include "e_zgrids.cdk"
#include "e_times.cdk"
#include "e_topo.cdk"
#include "did.cdk"
#include "dcst.cdk"
#include "grd.cdk"
#include "bmf.cdk"
#include "hgc.cdk"
*
      integer  ezqkdef,ezgdef_fmem,ezdefset,ezsetopt,ezuvint,
     $         ezsetopt,fstinf,fstlir,fstprm,e_rdhint2
      external ezqkdef,ezgdef_fmem,ezdefset,ezsetopt,ezuvint,
     $         ezsetopt,fstinf,fstlir,fstprm,e_rdhint2
*
      integer i, j, k, l, m,src_gid,dst_gid,
     $        key1, key2, nic, njc, ni1, nj1,nk1,nkc,err
      integer dte, det, ipas, p1, p2, p3, g1, g2, g3, g4, bit,
     $        dty, swa, lng, dlf, ubc, ex1, ex2, ex3
      character*1 typ,grd
      character*4 vtt,vhh,var
      character*12 lab
      real topu(nu), topv(nv), gzsu(nu,lv), gzsv(nv,lv), anlpsu(nu),
     $     anlpsv(nv), uu(nu), vw(nu), vv(nv), uw(nv), uvw(nu), 
     $     huu_temp(nu,lv), huv_temp(nv,lv),ttu_temp(nu,lv),
     $     ttv_temp(nv,lv), c1
      real, dimension (:), allocatable :: w1,w2
*
* ---------------------------------------------------------------------
*
      if (.not.glhorint) then
* ---------------------------------------------------------------------
*        NO INTERPOLATION REQUIRED
*        ANALYSIS and MODEL HAVE SAME GRID,SAME LEVELS,
*                                SAME TOPOGRAPHY, TOP PRESSURE
*---------------------------------------------------------------------
         
         if (LAM) then
             write(stdout,*)'CHECKING FOR UT1 and VT1 winds'
             write(stdout,*)'niu=',niu,' nju=',nju,' niv=',niv,' njv=',njv
             write(stdout,*)'nifi=',nifi,' njfi=',njfi
             m = fstinf(anal,i,j,k,IDAY,' ', na(1),ip2a,ip3a,tva,'UT1')
             if ( m.lt.0 .or. j.ne.nju .or. i.ne.niu ) then
                  write(stdout,*)'UT1  NOT AVAILABLE'
                  write(stdout,*)'ERROR: LAM GRID must use UT1, VT1 winds'
                  call e_arret( 'e_intwind' )
             endif
             m = fstinf(anal,i,j,k,iday,' ', na(1),ip2a,ip3a,tva,'VT1')
             if ( m.lt.0 .or. i.ne.niv .or. j.ne.njv ) then
                  write(stdout,*)'VT1  NOT AVAILABLE'
                  write(stdout,*)'ERROR: LAM GRID must use UT1, VT1 winds'
                  call e_arret( 'e_intwind' )
             endif

            write(stdout,*)'READING  UT1 and VT1 winds (on U and V grid)'
            DO 200 L=1,LV

               m = fstlir(uu,anal,i,j,k,iday,' ',na(L),ip2a,
     %                                               ip3a,tva,'UT1')
               if (m.lt.0 .or. i.ne.niu .or. j.ne.nju) then
                   write(stdout,*)'e_intwind: UT1  NOT AVAILABLE'
                   call e_arret( 'e_intwind' )
               endif

               m = fstlir(vv,anal,i,j,k,iday,' ',na(L),ip2a,
     %                                               ip3a,tva,'VT1')
               if (m.lt.0 .or. i.ne.niv .or. j.ne.njv) then
                     write(stdout,*)'e_intwind: VT1  NOT AVAILABLE'
                     call e_arret( 'e_intwind' )
               endif
               call e_bmfsplitxy2 (uu,niu,nju,'UU  ',L,lv,pniu,0,0,0)
               call e_bmfsplitxy2 (vv,niv,njv,'VV  ',L,lv,pni ,0,0,0)
200         CONTINUE

         else
*
           key1 = fstinf(anal,nic,njc,nkc,iday,' ',na(1),ip2a,ip3a,' ',
     $                                                            'UU')
           key2 = fstinf(anal,nic,njc,nkc,iday,' ',na(1),ip2a,ip3a,' ',
     $                                                            'VV')
           if (    (key1.lt.0).or.(key2.lt.0)
     $          .or.nic.ne.nifi.or.njc.ne.njfi) then
              write (6,*) 'UU  and/or VV NOT AVAILABLE'
              call e_arret( 'e_intwind' )
           endif
           err = fstprm (key1, DTE, DET, IPAS, ni1, nj1, nk1, BIT, DTY, 
     $              P1, P2, P3, TYP, VAR, LAB, GRD, G1, G2, G3, G4, SWA,
     $              LNG, DLF, UBC, EX1, EX2, EX3)
           do 100 L=1,LV
              m = fstlir (uu, anal, i, j, k, iday, labanl, na(L), ip2a,
     %                                                 ip3a, tva, 'UU')
              if (m.lt.0 .or. i.ne.nifi  .or. j.ne.njfi) then
                 write(stdout,*)'ERROR: UU NOT AVAILABLE,'
                 call e_arret( 'e_intwind' )
              endif
 
              m = fstlir(vw, anal, i, j, k, iday, labanl, na(L), ip2a,
     %                                                ip3a, tva, 'VV')
              if (m.lt.0 .or. i.ne.nifi  .or. j.ne.njfi) then
                 write(stdout,*)'ERROR: VV NOT AVAILABLE,'
                 call e_arret( 'e_intwind' )
              endif
*
              call e_arak (uu, vv, vw, uvw, niu, njfi, nju, njv, 1)
              call e_bmfsplitxy2 (uu,niu,nju,'UU  ',L,lv,pniu,0,0,0)
              call e_bmfsplitxy2 (vv,niv,njv,'VV  ',L,lv,pni ,0,0,0)
 100       continue
        endif
*
*---------------------------------------------------------------------
*
*     INTERPOLATION REQUIRED
*
*---------------------------------------------------------------------
*
      else
*
         key1=fstinf(anal,nic,njc,nkc,iday,' ',na(1),ip2a,ip3a,' ','UU')
         key2=fstinf(anal,nic,njc,nkc,iday,' ',na(1),ip2a,ip3a,' ','VV')
         if ((key1.lt.0).or.(key2.lt.0)) then
            write (6,*) 'UU  and/or VV NOT AVAILABLE'
            call e_arret( 'e_intwind' )
         endif
         err= fstprm (key1, DTE, DET, IPAS, ni1, nj1, nk1, BIT, DTY, P1,
     $                P2, P3, TYP, VAR, LAB, GRD, G1, G2, G3, G4, SWA,
     $                LNG, DLF, UBC, EX1, EX2, EX3)

         allocate (w1(nic*njc),w2(nic*njc))
         do 300 L=1,lv

            m = fstlir (w1, anal, i, j, k, iday, ' ', na(L), ip2a,
     %                                            ip3a, ' ', 'UU')
            if (m.lt.0 .or. i.ne.nic  .or. j.ne.njc ) then
               write(stdout,*)'ERROR: UU NOT AVAILABLE,'
               call e_arret( 'e_intwind' )
            endif
            m = fstlir (w2, anal, i, j, k, iday, ' ', na(L), ip2a,
     %                                            ip3a, ' ', 'VV')
            if (m.lt.0 .or. i.ne.nic  .or. j.ne.njc ) then
               write(stdout,*)'ERROR: VV NOT AVAILABLE,'
               call e_arret( 'e_intwind' )
            endif
*
*         Horizontal Interpolation on U grid and V grids
*
            src_gid = ezqkdef (nic, njc, GRD, g1, g2, g3, g4, anal)
            dst_gid = ezgdef_fmem (niu , nju , 'Z', 'E', Hgc_ig1ro,
     $                 Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xu, yu)
            err = ezdefset ( dst_gid, src_gid )
            err = ezsetopt ('INTERP_DEGREE', 'CUBIC')
            err = ezuvint (uu,vw,w1,w2)
*
            dst_gid = ezgdef_fmem (niv , njv , 'Z', 'E', Hgc_ig1ro,
     $                 Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xv, yv)
            err = ezdefset ( dst_gid, src_gid )
            err = ezsetopt ('INTERP_DEGREE', 'CUBIC')
            err = ezuvint (uw,vv,w1,w2)
*
            call e_bmfsplitxy2 (uu,niu,nju,'UU  ',L,lv,pniu,0,0,0)
            call e_bmfsplitxy2 (vv,niv,njv,'VV  ',L,lv,pni ,0,0,0)
*
 300     continue
         deallocate (w1,w2)
*
*---------------------------------------------------------------------
      endif
*---------------------------------------------------------------------
*
      if ( Topo_init_L ) then
         err = e_rdhint2(topu,yu,xu,niu,nju,'ME',1,-1,-1,' ','C',
     $                       .true.,.true.,'CUBIC',geophy,stdout)
         err = e_rdhint2(topv,yv,xv,niv,njv,'ME',2,-1,-1,' ','C',
     $                       .true.,.true.,'CUBIC',geophy,stdout)
         do i=1,nu
            topu(i) = max(0.0, topu(i))
         enddo
         do i=1,nv
            topv(i) = max(0.0, topv(i))
         enddo
         call e_filtopx (topu,niu,nju,'U')
         call e_filtopx (topv,niv,njv,'V')
         if (.not.lam)then
            call statfld(topu  ,'TOPU',0,"",1,niu,1,nju,1,1,1,1,
     $                                              niu-1,nju,1)
            call statfld(topv  ,'TOPV',0,"",1,niv,1,njv,1,1,1,1,
     $                                              niv-1,njv,1)
         else
            call statfld(topu,'TOPU',0,"",1,niu,1,nju,1,1,1,1,niu,nju,1)
            call statfld(topv,'TOPV',0,"",1,niv,1,njv,1,1,1,1,niv,njv,1)
         endif
      else
         do i=1,nu
            topu(i) = 0.0
         enddo
         do i=1,nv
            topv(i) = 0.0
         enddo
      endif
*
      call e_bmfsplitxy2 (topu,niu,nju,'TOPU',1,1,pniu,0,0,0)
      call e_bmfsplitxy2 (topv,niv,njv,'TOPV',1,1,pni ,0,0,0)
*      
      if ( gletaanl .or. glsiganl .or. glhybanl ) then
         write(stdout,*)'PREPARATION FOR SIGMA/ETA/HYB to HYBRID'
         c1 = 10. * Dcst_grav_8
         call e_lianalx4 (gzsu(1,lv), yu, xu, niu, nju, 'GZ  ',
     $                        0.0, c1, 12000, 1,.false.,.true.)
         call e_lianalx4 (gzsv(1,lv), yv, xv, niv, njv, 'GZ  ',
     $                        0.0, c1, 12000, 1,.false.,.true.)
         call e_bmfsplitxy2 (gzsu(1,lv),niu,nju,'GZU ',1,1,pniu,0,0,0)
         call e_bmfsplitxy2 (gzsv(1,lv),niv,njv,'GZV ',1,1,pni ,0,0,0)
         call statfld(gzsu(1,lv),'GZSU',0,"",1,niu,1,nju,1,1,1,1,
     $                                               niu-1,nju,1)
         call statfld(gzsv(1,lv),'GZSV',0,"",1,niv,1,njv,1,1,1,1,
     $                                               niv-1,njv,1)
         call e_lianalx4 (anlpsu, yu,xu,niu, nju, 'P0  ', 0.0, 100.,
     $                                          0, 1,.false.,.true.)
         call e_lianalx4 (anlpsv, yv,xv,niv, njv, 'P0  ', 0.0, 100.,
     $                                          0, 1,.false.,.true.)
         call e_bmfsplitxy2 (anlpsu,niu,nju,'APSU',1,1,pniu,0,0,0)
         call e_bmfsplitxy2 (anlpsv,niv,njv,'APSV',1,1,pni ,0,0,0)
         call statfld(anlpsu,'APSU',0,"",1,niu,1,nju,1,1,1,1,niu-1,
     $                                                       nju,1)
         call statfld(anlpsv,'APSV',0,"",1,niv,1,njv,1,1,1,1,niv-1,
     $                                                       njv,1)
         vtt=vt//'  '
         c1 = Dcst_tcdk_8
         call e_lianalx4 (ttu_temp,yu, xu, niu, nju, vtt, c1, 1. ,
     $                                    na,lv, .false., .true. )
         call e_lianalx4 (ttv_temp,yv, xv, niv, njv, vtt, c1, 1. ,
     $                                    na,lv, .false., .true. )
         if (vt.eq.'TT') then
            vhh='HU  '
            call e_lianalx4 (huu_temp,yu, xu, niu, nju, vhh, 0., 1.,
     $                                      na,lv, .false., .true. )
            call e_lianalx4 (huv_temp,yv, xv, niv, njv, vhh, 0., 1.,
     $                                      na,lv, .false., .true. )
            call mfotvt (ttu_temp,ttu_temp,huu_temp,niu*nju,lv,niu*nju)
            call mfotvt (ttv_temp,ttv_temp,huv_temp,niv*njv,lv,niv*njv)
         endif
         do k=1,lv
            call e_bmfsplitxy2 (ttu_temp(1,k),niu,nju,'VTU ',k,lv,
     $                                                 pniu,0,0,0)
            call e_bmfsplitxy2 (ttv_temp(1,k),niv,njv,'VTV ',k,lv,
     $                                                  pni,0,0,0)
         enddo
      else
         write(stdout,*)'PREPARATION FOR PRESSURE to HYBRID'
         c1 = 10.
         call e_lianalx4 (gzsu, yu, xu, niu, nju, 'GZ  ',
     $                    0.0, c1, na, lv,.false.,.true.)
         call e_lianalx4 (gzsv, yv, xv, niv, njv, 'GZ  ',
     $                    0.0, c1, na, lv,.false.,.true.)
         do k=1,lv
           call e_bmfsplitxy2 (gzsu(1,k),niu,nju,'GZU ',k,lv,pniu,0,0,0)
           call e_bmfsplitxy2 (gzsv(1,k),niv,njv,'GZV ',k,lv,pni ,0,0,0)
         enddo
         call statfld (gzsu,'GZU ',0,"",1,niu,1,nju,lv,1,1,1,niu-1,
     $                                                      nju,lv)
         call statfld (gzsv,'GZV ',0,"",1,niv,1,njv,lv,1,1,1,niv-1,
     $                                                      njv,lv)
      endif
*
* ---------------------------------------------------------------------
*
      return
      end
