! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
c  s/r set_hybv    - Using Laprise & Girard, generates de A and B of the
c                    hybrid coordinate and the analytical derivative of 
c                    d(psurf*B)/d(A + psurf*B), Also sets Z and other
c                    related vertical parameters.
c
#include "model_macros_f.h"
c
      subroutine set_hybv ()
      implicit none
c
c author 
c      A. Plante  - CMC - mai 2006
c
c revision
c
c object
c    Using Laprise & Girard, generates de A and B of the hybrid coordinate
c    see: Laprise & Girard, 1990, J. of Climate, eq. 5.1
c    Based on subroutine genab and genab2 also includes the evaluation
c    of other parameters related to the vertical discretazation.
c
c               vvvvvvvvvvvvvvvvv Ver_z_8%m(0) Virtual level
c
c    model top  ================= Ver_z_8%t(1) = Ztop
c
c               - - - - - - - - - Ver_z_8%m(1)
c
c               ================= Ver_z_8%t(2) = ( Ver_z_8%m(2) + Ver_z_8%m(1) ) / 2
c
c               - - - - - - - - - Ver_z_8%m(2)
c
c                      ...
c
c               - - - - - - - - - Ver_z_8%m(G_nk-1)
c
c               ================= Ver_z_8%t(G_nk) = ( Ver_z_8%m(nk) + Ver_z_8%m(nk-1) ) / 2
c
c               - - - - - - - - - Ver_z_8%m(G_nk)
c               o o o o o o o o o Special level 
c model surface ================= Ver_z_8%t(G_nk+1) = Zsrf
c
c               vvvvvvvvvvvvvvvvv Ver_z_8%m(G_nk+1) Virtual level
c
c arguments
c none
c
#include "glb_ld.cdk"
#include "lun.cdk"
#include "dcst.cdk"
#include "pres.cdk"
#include "cstv.cdk"
#include "grd.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
c

      integer k,istat
      real*8 zero, half, one, two,etatop_8
      parameter(zero=0.d0,half=0.5d0,one=1.d0,two=2.d0)
c     __________________________________________________________________
c
c
      if(Grd_rcoef.ne.1)then
c     BEWARE
c     if rcoef is greater than 1., pref is subject to restriction for
c     stability reasons.
         call gem_stop('set_hybv : rcoef must be one for staggered version',-1)
      endif
c
      allocate(
     $            Ver_a_8%m(0:G_nk+1),     Ver_a_8%t(G_nk+1),
     $            Ver_b_8%m(0:G_nk+1),     Ver_b_8%t(G_nk+1),
     $            Ver_z_8%m(0:G_nk+1),     Ver_z_8%t(G_nk+1),
     $           Ver_dz_8%m(  G_nk  ),    Ver_dz_8%t(G_nk+1),
     $          Ver_idz_8%m(  G_nk  ),   Ver_idz_8%t(G_nk+1),
     $         Ver_dbdz_8%m(  G_nk  ),  Ver_dbdz_8%t(G_nk+1),
     $        Ver_fistr_8%m(  G_nk  ), Ver_fistr_8%t(G_nk+1),
     $        Ver_a_spcl_8%m( G_nk+1),Ver_a_spcl_8%t(G_nk+2),
     $        Ver_b_spcl_8%m( G_nk+1),Ver_b_spcl_8%t(G_nk+2),
     $                                            stat=istat)
      call check_alloc(istat,'set_hybv ',1)
c
      Cstv_RTstr_8= Dcst_rgasd_8*Cstv_Tstr_8
      Cstv_pref_8 = 100000.d0
      Cstv_pisrf_8= 100000.d0
      if(Cstv_pitop_8.eq.-one)
     $   Cstv_pitop_8 = 100.d0*dble(Pres_ptop)
c
      Cstv_Zsrf_8 = log(Cstv_pisrf_8)
      Cstv_Ztop_8 = log(Cstv_pitop_8)
c
c
c     ----------------------------------------------------------
c    |                                                          |
c    |   Set A, B and Z for momentum and thermodynamic levels   |
c    |                                                          |
c    |   according to the formula:   Z = A(eta) + B(eta)*Zsrf   |
c    |   kcode is assigned to this formula                      |
c     ----------------------------------------------------------
c
      Ver_kcode=1
      call genab_8 (Ver_kcode,Ver_a_spcl_8%m,Ver_b_spcl_8%m,
     %                        Ver_a_spcl_8%t,Ver_b_spcl_8%t,
     %              Ver_hybm_8%m, Cstv_pitop_8,Cstv_pref_8,Grd_rcoef,G_nk)
c     Note:
c     genab_8 defines:
c        Ver_a_spcl_8%m which is the same as Ver_a_8%m from 1 to G_nk
c        Ver_b_spcl_8%m which is the same as Ver_b_8%m from 1 to G_nk
c        Ver_a_spcl_8%t which is the same as Ver_a_8%t from 2 to G_nk
c        Ver_b_spcl_8%t which is the same as Ver_b_8%t from 2 to G_nk

      do k=1,G_nk
         Ver_a_8%m(k) = Ver_a_spcl_8%m(k)
         Ver_b_8%m(k) = Ver_b_spcl_8%m(k)
      enddo
      do k=2,G_nk
         Ver_a_8%t(k) = Ver_a_spcl_8%t(k)
         Ver_b_8%t(k) = Ver_b_spcl_8%t(k)
      enddo
c
c     Now define the rest:
c
c     Momentum levels  
      etatop_8= Cstv_Ztop_8/log(Cstv_pref_8)

      do k = 1, G_nk
         Ver_z_8%m(k) = Ver_a_8%m(k)+Ver_b_8%m(k)*Cstv_Zsrf_8
      enddo
c
c     Top virtual level
      Ver_b_8%m(0)=               -Ver_b_8%m(1)
      Ver_a_8%m(0)=two*Cstv_Ztop_8-Ver_a_8%m(1)
      Ver_z_8%m(0)= Ver_a_8%m(0)+Ver_b_8%m(0)*Cstv_Zsrf_8
c
c     Bottom virtual level
      Ver_b_8%m(G_nk+1)=two-Ver_b_8%m(G_nk)
      Ver_a_8%m(G_nk+1)=   -Ver_a_8%m(G_nk)
      Ver_z_8%m(G_nk+1)= Ver_a_8%m(G_nk+1)+Ver_b_8%m(G_nk+1)*Cstv_Zsrf_8
c     
c     Thermodynamic levels
c
c     True Top
      Ver_b_8%t(1)=zero
      Ver_a_8%t(1)=Cstv_Ztop_8
      Ver_z_8%t(1)=Cstv_Ztop_8
c
      do k = 2, G_nk
         Ver_z_8%t(k) = Ver_a_8%t(k)+Ver_b_8%t(k)*Cstv_Zsrf_8
      enddo
c
c     True Bottom: surface
      Ver_b_8%t(G_nk+1)=one
      Ver_a_8%t(G_nk+1)=zero
      Ver_z_8%t(G_nk+1)=Cstv_Zsrf_8
c
c     --------------
c     Compute fistar
c     --------------
c     
      do k = 1, G_nk
         Ver_fistr_8%m(k)=-Cstv_RTstr_8*(Ver_z_8%m(k)-Cstv_Zsrf_8)
         Ver_fistr_8%t(k)=-Cstv_RTstr_8*(Ver_z_8%t(k)-Cstv_Zsrf_8)
      enddo
      Ver_fistr_8%t(G_nk+1)=zero
c
c     -------------------------
c     Compute dZ, 1/dZ and dbdZ
c     -------------------------
c
      do k=1,G_nk
           Ver_dz_8%m(k) =  Ver_z_8%t(k+1)-Ver_z_8%t(k)
          Ver_idz_8%m(k) =  one/Ver_dz_8%m(k)
         Ver_dbdz_8%m(k) = (Ver_b_8%t(k+1)-Ver_b_8%t(k))*Ver_idz_8%m(k)
      enddo      
c     
      do k=1,G_nk+1
           Ver_dz_8%t(k) = Ver_z_8%m(k) - Ver_z_8%m(k-1)
          Ver_idz_8%t(k) = one/Ver_dz_8%t(k)
         Ver_dbdz_8%t(k) = (Ver_b_8%m(k)-Ver_b_8%m(k-1))*Ver_idz_8%t(k)
      enddo

c     SETUP for OUTPUT
c     Note : Ver_hyb_8%t is not defined for rcoef!=1 (except at top and
c            sfc) but we put some reasonable value in it for the time being 
c            since some process like the Vertical sponge may use this.
c            Also the output need it for IP1 encoding
      allocate( Ver_hyb_8%t(G_nk+2),Ver_hybm_8%t(G_nk+2),
     $          Ver_hyb%t(G_nk+2),  Ver_hybm%t(G_nk+2),
     $         stat=istat)
      call check_alloc(istat,'set_hybv',2)
c
c
c     Top level
      Ver_hyb_8%t(1     )=half*Ver_hyb_8%m(1)
c     No Top special level
c     Bot special level
      Ver_hyb_8%t(G_nk+1)=half*(Ver_hyb_8%m(G_nk)+1.0d0)
c     Diag level
      Ver_hyb_8%t(G_nk+2)=one
C     Top and surface
      Ver_hybm_8%t(1)=etatop_8
      Ver_hybm_8%t(G_nk+2)=one
C     Special levels
      Ver_hybm_8%t(G_nk+1)=half*(Ver_hybm_8%m(G_nk)+one)
      do k = 2, G_nk
         Ver_hybm_8%t(k)=half*(Ver_hybm_8%m(k)+Ver_hybm_8%m(k-1))
         Ver_hyb_8%t(k)=half*(Ver_hyb_8%m(k)+Ver_hyb_8%m(k-1))
      enddo
c
      Ver_hybm%t(1) = Ver_hybm_8%t(1)
      Ver_hybm%t(G_nk+2) = Ver_hybm_8%t(G_nk+2)
c     Diag levels for output
      Ver_hyb%t(G_nk+2)  = Ver_hyb_8%t(G_nk+2)
      Ver_hyb%m(G_nk+1)  = Ver_hyb_8%t(G_nk+2)

      do k = 1, G_nk+1
         Ver_hyb%t(k)  = Ver_hyb_8%t(k)
         Ver_hybm%t(k) = Ver_hybm_8%t(k)
      enddo
c     __________________________________________________________________
c
      return
      end
