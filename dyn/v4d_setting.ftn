***s/r v4d_setting - Additional settings for 4D-Var 
*
#include <model_macros_f.h>
*
      subroutine v4d_setting 
*
      use v4d_prof, only: Pr_wopen_L, Pr_ropen_L, Pr_read_L, Pr_llfrm_L, Pr_traj0to9_L, 
     %                    Pr_varindx, Pr_varname, Pr_dsnooze_8, Pr_traj0to9_L, Pr_mode_S
*
      use v4dz
*
#include "impnone.cdk"
*
*author
*     M.Tanguay
*
*revision
* v2_10 - Tanguay M.        - initial MPI version
* v2_31 - Tanguay M.        - move v4d_setscalp after set_dync 
*                           - WA files incore
*                           - adapt for tracers in tr3d  
* v3_00 - Ek N.             - initializations for V4dg_4dvar_L and for interp. of profiles 
* v3_00 - Tanguay M.        - adapt to Simon's exchange
*                           - incore option for WA file Conversion 
* v3_00 - Laroche S.        - additions for simplified physics
* v3_01 - Tanguay M.        - add V4dg_sgvc_L
*                           - introduce GAUSS=GEM option
* v3_02 - Buehner M.        - added section for ref state file for NLMX event (SV job)
*                           - changed call readlalo to readinit
*                           - no 3hr preliminary integration for SV job
* v3_02 - Tanguay M.        - V4dz_degree in namelist var4d
*
*object
*     1) Allocate WA files and VMM space
*     2) Set control variables 
*     3) Set inner product in control space variables
*	
*arguments
*     none
*
*implicits
#include "glb_ld.cdk"
#include "lun.cdk"
#include "geomg.cdk"
#include "v4dg.cdk"
#include "v4dc.cdk"
#include "step.cdk"
#include "schm.cdk"
#include "tr3d.cdk"
#include <prof_f.h>
#include "dcst.cdk"
#include "ptopo.cdk"
#include "path.cdk"
*
*modules
      external hpalloc,longueur
*
      integer pnerr,timobmax,i,j,i1,i2,j1,j2,ni,lun_4dvar,longueur,
     %        ierr,fnom,ilun_out,status,offi,offj,indx,err
*
      real,   allocatable, dimension(:)   :: groots
*
      real*8 G_xgauss_8, G_ygauss_8
      pointer (paxgauss_8, G_xgauss_8(1-G_ni:2*G_ni)),
     $        (paygauss_8, G_ygauss_8(1-G_nj:2*G_nj))
*
      real*8 rad2deg_8,deg2rad_8
      real*8, parameter :: CLXXX_8 = 180.0
      real*8, parameter :: ONE_8   = 1.0 
      real*8, parameter :: TWO_8   = 2.0 
*
      character(len=256) cfilename_S
      character(len=3)  cprocno_S
*
*C    -------------------------------
*C    Allocate WA files and VMM space
*C    -------------------------------
*
*        Allocate WA file and VMM space for TRAJECTORY
*        ---------------------------------------------
         call v4d_settraj()
*
         if(V4dg_conf/100.eq.1) then
*
*           Allocate WA files and VMM space for OBSERVATIONS and FORCINGS
*           -------------------------------------------------------------
            call v4d_setobfr ()
*
         endif
*
*C    ---------------------------------------------------------
*C    Allocate memory if WA files are replaced by incore arrays 
*C    ---------------------------------------------------------
      if(V4dg_incore_L) then
*
*         Estimate size of TRINCORE defined in V4d_RWTRAJ
*         -----------------------------------------------
             V4dg_trsize = 0 
*
*            V4dg_numtr.eq.1
*            ---------------
             V4dg_trsize = V4dg_trsize + Step_total*(5*l_ni*l_nj*l_nk + 1*l_ni*l_nj) 
*
*            V4dg_numtr.eq.2
*            ---------------
             V4dg_trsize = V4dg_trsize + Step_total*(1*l_ni*l_nj*l_nk + 0*l_ni*l_nj) 
*
*            V4dg_numtr.eq.3
*            ---------------
             V4dg_trsize = V4dg_trsize + Step_total*(9*l_ni*l_nj*l_nk + 1*l_ni*l_nj) 
*
*            V4dg_numtr.eq.4
*            ---------------
             V4dg_trsize = V4dg_trsize + Step_total*(4*l_ni*l_nj*l_nk + 0*l_ni*l_nj)*Schm_itcn 
*
*            V4dg_numtr.eq.5
*            ---------------
             V4dg_trsize = V4dg_trsize + Step_total*(3*l_ni*l_nj*l_nk + 0*l_ni*l_nj)*Schm_itcn 
*
*            V4dg_numtr.eq.6
*            ---------------
             V4dg_trsize = V4dg_trsize + Step_total*(3*l_ni*l_nj*l_nk + 1*l_ni*l_nj)*Schm_itcn 
*
*
*            Estimate size for the physic interface 
*            --------------------------------------
*
*            V4dg_numtr.eq.10
*            ----------------
             V4dg_trsize = V4dg_trsize + Step_total*(5*l_ni*l_nj*l_nk + 0*l_ni*l_nj) 
*
*            V4dg_numtr.eq.11
*            ----------------
             V4dg_trsize = V4dg_trsize + Step_total*(4*l_ni*l_nj*l_nk + 1*l_ni*l_nj) 
*
             call hpalloc (V4dg_trincore_, V4dg_trsize, pnerr, 1)
*
*
*         Estimate size of PHINCORE defined in V4d_RWPHYS
*         -----------------------------------------------
             V4dg_phsize = 0
*
*            Sigma levels
*            ------------
             V4dg_phsize = V4dg_phsize +          1*(1*l_ni*l_nj*l_nk + 0*l_ni*l_nj)
*
*            KM and KT
*            ---------
             V4dg_phsize = V4dg_phsize + Step_total*(2*l_ni*l_nj*l_nk + 0*l_ni*l_nj)
*
             call hpalloc (V4dg_phincore_, V4dg_phsize, pnerr, 1)
*
*
          if(V4dg_conf/100.eq.1) then
*
          if(V4dg_inv.ne.1) timobmax = Step_total/V4dg_stepob + 1
          if(V4dg_inv.eq.1) timobmax = Step_total/V4dg_stepob
*
*         Estimate size of FRINCORE defined in V4d_RWOBFR
*         -----------------------------------------------
             V4dg_frsize = 0
*
             V4dg_frsize = V4dg_frsize + timobmax *(3*l_ni*l_nj*l_nk + 1*l_ni*l_nj)
*
             call hpalloc (V4dg_frincore_, V4dg_frsize, pnerr, 1)
*
*         Estimate size of OBINCORE defined in V4d_RWOBFR
*         -----------------------------------------------
             V4dg_obsize = 0
*
             V4dg_obsize = V4dg_obsize + timobmax *(3*l_ni*l_nj*l_nk + 1*l_ni*l_nj)
*
             call hpalloc (V4dg_obincore_, V4dg_obsize, pnerr, 1)
*
          if(V4dg_4dvar_L.or.V4dg_sgvc_L) then
*
*         Maximal timobmax since V4dg_stepob is still unknown
*         ---------------------------------------------------
          timobmax = Step_total + 1 
*
*         Estimate size of CVINCORE defined in V4d_RWCONV
*         -----------------------------------------------
             V4dg_cvsize = 0
*
             V4dg_cvsize = V4dg_cvsize + (1+timobmax) *( (1 + Tr3d_ntr)*l_nk + 1 )*l_ni*l_nj
*
             call hpalloc (V4dg_cvincore_, V4dg_cvsize, pnerr, 1)
*
*         Estimate size of NLINCORE defined in V4d_RWNLPERT
*         -------------------------------------------------
             V4dg_nlsize = 0
*
             V4dg_nlsize = V4dg_nlsize + (1+timobmax) *( (3 + Tr3d_ntr)*l_nk + 1 )*l_ni*l_nj
*
             call hpalloc (V4dg_nlincore_, V4dg_nlsize, pnerr, 1)
*
          endif
*
          endif
*
      endif
*
*C    -------------------------------------
*C    Set control variables for 4D-Var runs
*C    -------------------------------------
*
         if (Lun_out.gt.0) write(Lun_out,1000)
*
*        Initialize dimensions
*        ---------------------
         V4dc_ncv    = l_ni * ((2+Tr3d_ntr)*l_nj + l_njv) * l_nk + l_ni * l_nj 
*
*        V4dc_nupd is the number of updates for building Hessian in M1QN3
*        ----------------------------------------------------------------
         V4dc_nupd   = 10
c        if(V4dg_conf/100.eq.1) V4dc_nupd = 1 
*
         V4dc_nwkmin = 4 * V4dc_ncv + V4dc_nupd * (2 * V4dc_ncv + 1)
*
*        Initialize memory arrays 
*        ------------------------
         call hpalloc(V4dc_xcv_   , V4dc_ncv   , pnerr, 1)
         call hpalloc(V4dc_gcv_   , V4dc_ncv   , pnerr, 1)
         call hpalloc(V4dc_scalp_ , V4dc_ncv   , pnerr, 1)
         call hpalloc(V4dc_ycv_   , V4dc_ncv   , pnerr, 1)
         call hpalloc(V4dc_wkmin_ , V4dc_nwkmin, pnerr, 1)
*
*C    ----------------------------------------------
*C    Move inner product calculations after set_dync
*C    ----------------------------------------------
*C    call v4d_setscalp ()
*
      if(V4dg_4dvar_L.or.V4dg_sgvc_L) then
*
*        Redirect output to allow printings for each proc
*        ------------------------------------------------
         lun_4dvar = 0 
         write(cprocno_S,fmt='(i1)') Ptopo_myproc
         cfilename_S = Path_dfwmil_S(1:longueur(Path_dfwmil_S))//
     $                 '/output/Output_From_Proc_No.'//trim(cprocno_S)
         ierr = fnom(lun_4dvar,trim(cfilename_S),'SEQ+APPEND',0)
*
         ilun_out = Lun_out
         Lun_out  = lun_4dvar
*
*        Define path to the "exchange" directory with 3D-Var 
*        ---------------------------------------------------
         Path_xchg_S = Path_dfwmil_S(1:longueur(Path_dfwmil_S))//'/xchgdir'
*
*        Flag to do 3hr TRAJ run to get to the starting date of the assimilation
*        -----------------------------------------------------------------------
         Pr_traj0to9_L = .false.
*
*          Do not perform initial 3hr integration for SV job - initial time = synoptic time!!!!
*          ------------------------------------------------------------------------------------
           if(V4dg_sgvc_L) Pr_traj0to9_L = .false.       
*
         write(Lun_out,*) 'Flag to do 3hr TRAJ run TRAJ0TO9_L = ',Pr_traj0to9_L
*
*        Initialization of static information regarding PROF files 
*        ---------------------------------------------------------
         Pr_llfrm_L = .true.
         Pr_dsnooze_8 = 0.01
         Pr_mode_S = 'FILE'
         write(Lun_out,*) 'SNOOZE TIME = ',Pr_dsnooze_8,' LLFRM = ',Pr_llfrm_L
*
         if(V4dg_sgvc_L) then
*
*        Input parameters from 3dvar
*        ---------------------------
         call v4d_readinit ()
*
         else
*
*        Initialize the obs variable indices
*        -----------------------------------
         Pr_varindx(1) = V3D_UTRU
         Pr_varindx(2) = V3D_VTRU
         Pr_varindx(3) = V3D_TEMP
         Pr_varindx(4) = V3D_SPHU
         Pr_varindx(5) = V2D_PSUR
*
         Pr_varname = (/'UU', 'VV', 'TT', 'HU', 'SP'/)
*
*        Flag to allow model-profile file to be opened 
*        ---------------------------------------------
         Pr_wopen_L = .false.     
*
*        Flag to allow adjoint model-profile file to be opened 
*        -----------------------------------------------------
         Pr_ropen_L = .false.     
*
*        Input obs lists if not already done.
*        -----------------------------------
         call v4d_readinit ()
*
*        ----------------------------------------------------
*        Initialization for EZSCINT interpolation of profiles  
*        ----------------------------------------------------
*
*        -------------------------------------------------------
*        Type of interpolation V4dz_degree now in namelist var4d
*        -------------------------------------------------------
*        NOTE: 1= Linear and 3=Cubic Lagrange
*        -------------------------------------------------------
*
*        Type of input grid
*        ------------------
         V4dz_grtypi = 'Z'
*
*        Initialize dimensions I1,I2,J1,J2, axes AX,AY
*        and differences CX,CY of input grid used in interpolation
*        ---------------------------------------------------------
*
*        Dimensions with halo
*        --------------------
         V4dz_i1 = l_minx
         V4dz_i2 = l_maxx
         V4dz_j1 = l_miny
         V4dz_j2 = l_maxy
*
*        Keep horizontal dimensions of input grid used in interpolation
*        --------------------------------------------------------------
         i1 = V4dz_i1
         i2 = V4dz_i2
         j1 = V4dz_j1
         j2 = V4dz_j2
*
*        Dimension of Heart in x if grid = 'Z'
*        -------------------------------------
         ni = l_ni
*
*        Define axes of input grid
*        -------------------------
         allocate ( V4dz_ax(i2-i1+1), STAT=status )
         allocate ( V4dz_ay(j2-j1+1), STAT=status )
*
         rad2deg_8 = CLXXX_8/Dcst_pi_8
*
*        Prescribe global GEM scalar Z grid axes 
*        ---------------------------------------
         if(.not.V4dg_ga_eq_ge_L) then
*
         do i=i1,i2
            V4dz_ax(i-i1+1) = Geomg_x_8(i) * rad2deg_8
         enddo
         do j=j1,j2
            V4dz_ay(j-j1+1) = Geomg_y_8(j) * rad2deg_8
         enddo
*
*        Prescribe Gaussian grid axes 
*        ----------------------------
         else
*
         deg2rad_8 = acos( -ONE_8 )/CLXXX_8
*
*        Evaluate latitudes of Gaussian grid 
*        -----------------------------------
         allocate ( groots(G_nj), STAT=status )
*
         call ez_glat (V4dz_ay,groots,G_nj,0)
*
         deallocate( groots, STAT=status )
*
         call hpalloc (paxgauss_8      , 6*G_ni, err, 1)
         call hpalloc (paygauss_8      , 6*G_nj, err, 1)
*
*        Evaluate Extended Global Gaussian grid in radians 
*        -------------------------------------------------
         do i=1,G_ni
            G_xgauss_8(i) = float(i-1) * (360./float(G_ni)) * deg2rad_8  
         end do
         do j=1,G_nj
            G_ygauss_8(j) = V4dz_ay(j) * deg2rad_8 
         enddo
*
         do i=-G_ni+1,0
            G_xgauss_8(i) = G_xgauss_8(i+G_ni) - TWO_8*Dcst_pi_8
         end do
         do i=G_ni+1,2*G_ni
            G_xgauss_8(i) = G_xgauss_8(i-G_ni) + TWO_8*Dcst_pi_8
         end do
*
         G_ygauss_8( 0    ) = -(G_ygauss_8(1) + Dcst_pi_8)
         G_ygauss_8(-1    ) = -TWO_8*Dcst_pi_8 -
     $                        (G_ygauss_8(0)+G_ygauss_8(1)+G_ygauss_8(2))
         G_ygauss_8(G_nj+1) =  Dcst_pi_8 - G_ygauss_8(G_nj)
         G_ygauss_8(G_nj+2) =  TWO_8*Dcst_pi_8 -
     $                        (G_ygauss_8(G_nj+1)+G_ygauss_8(G_nj)+G_ygauss_8(G_nj-1))
         do j=-2,-G_nj+1,-1
            G_ygauss_8(j) = 1.01*G_ygauss_8(j+1)
         end do
         do j=G_nj+3,2*G_nj
            G_ygauss_8(j) = 1.01*G_ygauss_8(j-1)
         end do
*
*        Evaluate Local grid as subset of Global grid 
*        --------------------------------------------
         offi = Ptopo_gindx(1,Ptopo_myproc+1)-1
         offj = Ptopo_gindx(3,Ptopo_myproc+1)-1
*
         do i=1-G_halox,l_ni+G_halox
            indx = offi + i
            V4dz_ax(i) = G_xgauss_8(indx) * rad2deg_8
         end do
         do j=1-G_haloy,l_nj+G_haloy
            indx = offj + j
            V4dz_ay(j) = G_ygauss_8(indx) * rad2deg_8 
         end do
*
         call hpdeallc (paxgauss_8, err )
         call hpdeallc (paygauss_8, err )
*
         endif
*
*        Evaluate AX,AY differences in CX,CY for cubic interpolation
*        -----------------------------------------------------------
         if(V4dz_degree.eq.3) then
*
            allocate ( V4dz_cx(6*(i2-i1+1)), STAT=status )
            allocate ( V4dz_cy(6*(j2-j1+1)), STAT=status )
*
            call v4d_nwtncof (V4dz_cx,V4dz_cy,V4dz_ax,V4dz_ay,i1,i2,j1,j2,
     %                        ni,V4dz_grtypi)
*
         endif
*
         endif
*
      endif
*
 1000 format(
     +//,'Additional settings for 4D-VAR (S/R V4D_SETTING)',
     + /,'================================================',
     +//)
*
*     ---------------------------------------------------------------
*
      return
      end
