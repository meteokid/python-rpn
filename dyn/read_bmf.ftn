! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r read_bmf - read the dynamics fields from entrance programs
*
#include "model_macros_f.h"
*
      subroutine read_bmf(za_8,zb_8,lvm, zat_8,zbt_8,lvt,
     $                    u_temp,lniu,lnju, v_temp,lniv,lnjv,
     $                    hu_temp,tt_temp,gz_temp,ps,topo_temp,
     $                    lni,lnj,nktmp)
      implicit none
      integer lni,lnj,lniu,lnju,lniv,lnjv,lvm,lvt,nktmp
      real*8  za_8(lvm),zb_8(lvm),zat_8(lvt),zbt_8(lvt)
      real,   dimension(lni,lnj      ) :: ps,topo_temp
      real,   dimension(lni,lnj,nktmp) :: hu_temp,gz_temp,tt_temp
      real    u_temp(lniu,lnju,nktmp), v_temp(lniv,lnjv,nktmp)
*
*author 
*     Luc Corbeil, mai 2002
*
*revision
* v3_01 - Corbeil L.           - initial version
* v3_10 - Lee V.               - unique bmfscraps...
* v3_11 - Gravel S.            - provide for variable topography
* v3_12 - Dugas B. & Winger K. - read TD in pressure-mode rather than HU
* v3_21 - Dugas B.             - replace TD by ES in pressure mode
* v3_30 - Tanguay M.           - Modify Check topo when no interpolation 
* v3_30 - McTaggart-Cowan R.   - update implementation of variable orography
*
*object
*	
*arguments
*	none
*
*implicits
#include "glb_ld.cdk"
#include "bmf.cdk"
#include "grd.cdk"
#include "dcst.cdk"
#include "acq.cdk"
#include "schm.cdk"
*modules
      integer  bmf_get
      external bmf_get
*
      character*32 pe_file
      integer hh,mm,ss, nerr, err, length, i,j,k
      integer, parameter :: maxerr = 400
      integer, dimension(maxerr) ::  error
      integer, allocatable, dimension(:) :: bmfni,bmfnj,bmfnk,
     $         bmfdatyp,bmfvtime1,bmfvtime2,
     $         bmfscrap,bmfscrap1,bmfscrap2,bmfscrap3,bmfscrap4,bmfscrap5,
     $                  bmfscrap6,bmfscrap7,bmfscrap8,bmfscrap9
      character*4, allocatable, dimension(:) :: bmfnom
**
*     ---------------------------------------------------------------
*
*     Read the BMF file associated to each Ptopo_myproc
      do i=1,maxerr
         error(i) = -1
      end do
      nerr=0
*
*     Initialization of some switches and dimensions
*
      err = bmf_get ('AHAV',bmf_time1,bmf_time2,Acqi_datasp,-1,-1.,
     $                                               1,2,1,1,1,1)
*
      Acql_horzint = (Acqi_datasp(1).eq.1)
      Acql_hybanl  = (Acqi_datasp(2).eq.1)
      Acql_etaanl  = (Acqi_datasp(2).eq.2)
      Acql_siganl  = (Acqi_datasp(2).eq.3)
      Acql_prsanl  = (Acqi_datasp(2).eq.4)
      Acql_ecmanl  = (Acqi_datasp(2).eq.5)
      Acql_staganl  = (Acqi_datasp(2).eq.6)
      Acql_vertint = Acql_horzint
      if (Acql_ecmanl) lvm  = lvm+1
      if (.not.Acql_staganl) Acql_vertint = .true.
      if (Acql_staganl) Acql_hybanl=.true.
*
      error(1) = bmf_get ('ZA  ',bmf_time1,bmf_time2,-1,-1.,za_8 ,1,
     $                                           lvm,1,1,1,1)
      error(2) = bmf_get ('ZB  ',bmf_time1,bmf_time2,-1,-1.,zb_8 ,1,
     $                                           lvm,1,1,1,1)
      error(3) = bmf_get ('ZAT ',bmf_time1,bmf_time2,-1,-1.,zat_8,1,
     $                                           lvt,1,1,1,1)
      error(4) = bmf_get ('ZBT ',bmf_time1,bmf_time2,-1,-1.,zbt_8,1,
     $                                           lvt,1,1,1,1)
      error(5) = bmf_get ('ME  ',bmf_time1,bmf_time2,-1,topo_temp,-1.,
     $                                               1,lni,1,lnj,1,1)
*
      do j=1,lnj
      do i=1,lni
         topo_temp (i,j) = dble(topo_temp(i,j)) * Dcst_grav_8
      end do
      end do
      nerr = nerr + 2
*
      nerr = nerr + 1
      error(nerr) = bmf_get('UU  ',bmf_time1,bmf_time2,-1,u_temp,-1,
     $                               1,lniu,1,lnju,1,nktmp)
*  
      nerr = nerr + 1
      error(nerr) = bmf_get('VV  ',bmf_time1,bmf_time2,-1,v_temp,-1,
     $                               1,lniv,1,lnjv,1,nktmp)
*
      if (Schm_offline_L) then
          gz_temp = 0;
      else if (Acql_prsanl) then
         error(nerr) = bmf_get('GZ  ',bmf_time1,bmf_time2,-1,
     $                 gz_temp,-1.,1,lni,1,lnj,1,nktmp)
      else
         nerr = nerr + 1
         error(nerr) = bmf_get('GZ  ',bmf_time1,bmf_time2,-1,
     $                 gz_temp(1,1,lvt),-1.,1,lni,1,lnj,1,1)
      endif
*
      if (Acql_prsanl) then
         nerr = nerr + 1
         error(nerr) = bmf_get('HU  ',bmf_time1,bmf_time2,-1,hu_temp,-1.,
     $                                   1,lni,1,lnj,1,nktmp)
         error(nerr) = bmf_get('VT  ',bmf_time1,bmf_time2,-1,tt_temp,-1.,
     $                                   1,lni,1,lnj,1,nktmp)
         Acql_vertint = .true.
      else
         if (Acql_siganl) Acqr_ptopa = 0.
         nerr = nerr + 1
         error(nerr) = bmf_get('P0  ',bmf_time1,bmf_time2,-1,ps,
     $                                       -1.,1,lni,1,lnj,1,1)
         nerr = nerr + 1
         error(nerr) = bmf_get('VT  ',bmf_time1,bmf_time2,-1,tt_temp,
     $                                 -1.,1,lni,1,lnj,1,nktmp)
         nerr = nerr + 1
         error(nerr) = bmf_get('HU  ',bmf_time1,bmf_time2,-1,hu_temp,-1.,
     $                                   1,lni,1,lnj,1,nktmp)
      endif
*
      if (Acql_ecmanl ) then
         nerr = nerr + 1
         error(nerr) = bmf_get('US  ',bmf_time1,bmf_time2,-1,
     $                 u_temp(1,1,lvm+1),-1.,
     $                 1,lniu,1,lnju,1,1)
         nerr = nerr + 1
         error(nerr) = bmf_get('VS  ',bmf_time1,bmf_time2,-1,
     $                 v_temp(1,1,lvm+1),-1.,
     $                 1,lniv,1,lnjv,1,1)
         nerr = nerr + 1
         error(nerr) = bmf_get('TE  ',bmf_time1,bmf_time2,-1,
     $                 tt_temp(1,1,lvm+1),-1.,
     $                 1,lni,1,lnj,1,1)
         nerr = nerr + 1
         error(nerr) = bmf_get('HE  ',bmf_time1,bmf_time2,-1,
     $                 hu_temp(1,1,lvm+1),-1.,
     $                 1,lni,1,lnj,1,1)
      endif
*
*     Check for error in BMF_GETS above...
      err = 0
      do i=1,nerr
         err = err + error(i)
      end do
*     
      call rpn_comm_allreduce (err,error(1),1,"MPI_INTEGER",
     $                                 "MPI_SUM","grid",nerr)
*
      if (error(1).ne.0) call gem_stop ('read_bmf',-1)
*
*     ---------------------------------------------------------------
*
      return
      end
