! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
**s/r out_thm - output  temperature, humidity and mass fields
*
#include "model_macros_f.h"
*
      subroutine out_thm(F_fiptx,F_tt1,F_st1,F_qct1,F_qh,F_hut1,
     %                   F_zdt1,F_wt1,F_zz1,
     %                   F_vtm,F_hum1, F_st1m,F_piup,
     %                   F_wlnph_m,F_wlnph_ta,F_ptop,F_p0,F_wlao,F_topo,
     %                   F_posit,F_huv,
     %                   F_ninj,F_nk,F_levtyp_S,F_rf,
     %                   F_indo,F_nko,F_nkot,F_set)
*
      implicit none
*
      character*1 F_levtyp_S
      integer F_nk,F_ninj,F_nko,F_nkot,F_indo(*),F_set
      real F_rf(*)

      real F_fiptx  (F_ninj,0:F_nk+1), F_tt1  (F_ninj,F_nk+2),
     %     F_qct1   (F_ninj,F_nk+2), F_qh     (F_ninj,F_nk+2),
     %     F_hut1   (F_ninj,F_nk+2), F_wt1    (F_ninj,F_nk+1),
     %     F_zdt1   (F_ninj,F_nk+1), F_zz1    (F_ninj,F_nk+1),
     %     F_vtm    (F_ninj,F_nk+1), F_piup   (F_ninj,F_nk+1),
     %     F_hum1   (F_ninj,F_nk+1), F_wlnph_m(F_ninj,F_nk+1),
     %     F_wlnph_ta(F_ninj,F_nk+2),
     %     F_posit  (F_ninj*(F_nk+1)*6),F_huv(F_ninj*(F_nk+2+4)*2),
     %     F_ptop(F_ninj),F_p0(F_ninj),F_st1(F_ninj),F_st1m(F_ninj),
     %     F_wlao(F_ninj),F_topo(F_ninj)
   
*
*author
*     james caveen/andre methot  - rpn june/nov 1995
*
*revision
* v2_00 - Lee V.            - initial MPI version (from blocthm v1_03)
* v2_11 - Desgagne M.       - ptop reproducubility
* v2_21 - Desgagne M.       - new calling sequence for glbdist + correct
* v2_21                       calling sequence mfohra
* v2_21 - J. P. Toviessi    - set dieze (#) slab output and rename
* v2_21                       truncate model output names to 4 characters
* v2_30 - Lee V.            - reorganize slab output to be more efficient
* v2_30 - Edouard S.        - adapt for vertical hybrid coordinate
* v2_30                     - change call to p0vt2gz_hyb
* v2_32 - Lee V.            - reduce dynamic allocation size, add HU,ME output
* v3_00 - Desgagne & Lee    - Lam configuration
* v3_01 - Lee V.            - Added output of ThetaW
* v3_01 - Morneau J.        - remove conversion to Celcius for TL or AD output
* v3_02 - Plante A.         - Water loading
* v3_02 - Lee V.            - LA and LO output (not physics), add QC output
* v3_03 - Lee V.            - correct bug for illegal access to all h2o tracers
* v3_03                       if Schm_phyms_L is false.
* v3_11   Tanguay M.        - Add TLM and ADJ increments TT and P0
*                           - Extend TRAJ for conversion for DYNOUT2
* v3_20   Lee V.            - Output in blocks, standard files
* v3_21 - Lee V.            - Output Optimization
* v3_22 - Tanguay M.        - pad fit1 (undefined values when Out3_vt2gz
* is F)
* v3_22 - Lee V.            - reduced args in calling sequence for calzz
* v3_30 - Bilodeau/Tanguay  - Output pair (TT,HU) for the adjoint
* v3_30 - Plante A.         - Correction for THETA (TH) output
*
*object
*     See above id.
*
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_dostep     I    - array containing indices corresponding to the
*                     timestep sets that requires output at this time step.
* F_dostep_max I    - size of F_dostep array
*
c Index vectors for level identifications
c ----------------------------------------
c 
c vector for the momentum level : Ver_hyb_8%m.
c
c vector for the momentum-top-surface level int_ta
c    Ver_hyb_8%t : Thermo levels with special levels ("o" on figure below),

c                Ver_hyb_8%m(1:G_nk) Ver_hyb_8%t(1:G_nk+2) 
c model top
c ===========1        -             X\ Depending on dpdlogz           
c o o o o o o2                      X/
c - - - - - -3        X             -           
c
c ===========4        -             X           
c  
c    ...             ...           ...          
c
c
c ===========2*k      -             X           
c
c - - - - - -2*k+1    X             -           
c
c    ...             ...           ...          
c
c - - - - - -2*G_nk+1 X             -           
c o o o o o o2*G_nk+2 -             X           
c ===========2*G_nk+3 -             X           
c model surface
c
c----------------------------------------------------------------------
* 
*implicits

#include "glb_ld.cdk"
#include "dcst.cdk"
#include "geomn.cdk"
#include "schm.cdk"
#include "out.cdk"
#include "out3.cdk"
#include "grd.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "ptopo.cdk"
#include "v4dg.cdk"
#include "lctl.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
*
*modules
*
**
      type :: stg_i
         integer :: t,m,p
      end type stg_i

      real theta_p0

      parameter (theta_p0=100000.)

      integer i,j,k,kl,ii,my_nko
      real wk1(G_ni,G_nj),wk2(G_ni,G_nj)
      real wk3(G_ni,G_nj+2),wk4(G_ni,G_nj+2)
      real w1(F_ninj), w2(F_ninj)
      real w3(F_ninj,F_nk+2)
      real px_pres(F_ninj,F_nko)
      real hu_pres(F_ninj,F_nko)
      real td_pres(F_ninj,F_nko)
      real th_pres(F_ninj,F_nko)
      real w5(F_ninj,F_nko)
      real prprlvl(F_nko)
      real tt_pres(F_ninj,F_nko)
      real vt_pres(F_ninj,F_nko)
      real px_ta(F_ninj,F_nk+2),px_m(F_ninj,F_nk+1), th(F_ninj,F_nk+2)
      real tt(F_ninj,F_nk+2),hu(F_ninj,F_nk+2),t8(F_ninj,F_nk+2),
     $     vt(F_ninj,F_nk+2),gz(F_ninj,F_nk), omega(F_ninj,F_nk+2)
      real fbot(F_ninj),wlnph_top(F_ninj),wlnph_bot(F_ninj)
      real ps_temp(F_ninj)
      real w4(F_ninj,0:F_nk+1),a_ta(F_nk+2),b_ta(F_nk+2)
      integer pnindo(F_nk+2)
      integer :: lastdt = -1
      real, dimension(:,:), pointer :: gz_m_plus,gz_ta,ttx,htx
      save lastdt,gz_m_plus,gz_ta,htx,ttx
* ___________________________________________________________________
*
*     1.0     initialization of data
*_______________________________________________________________________
*
      integer     
     $        pngz,pnvt,pntt,pnes,pntd,
     $        pnhr,pnpx,pnhu,pntw,pnqc,
     $        pnww,pnwe,pnzz,pnth
      integer pnpn,psum,pnpt,pnp0,pnla,pnlo,pnme,pnmx

      integer nbit(0:Outd_var_max(F_set)+1),filt(0:Outd_var_max(F_set)+1)
      real    coef(0:Outd_var_max(F_set)+1)
      logical V4dgconf_L

*     initialize conversion of units

      real*8, parameter :: ZERO_8 = 0.0
      real    prmult_pngz, prmult_pnpx, prmult_pnme, prmult_pnwe
      real    pradd_pnvt,  pradd_pntt,  pradd_pntd,  pradd_pnwe
      real    ver_hyb_w(F_nk+2)

      prmult_pngz  = 0.1 / Dcst_grav_8
      prmult_pnpx  = 0.01
      prmult_pnme  = 1.0 / Dcst_grav_8
      prmult_pnwe  = 1.0 / (Ver_z_8%t(l_nk) - Ver_z_8%t(1))

      pradd_pnwe   = ZERO_8

      V4dgconf_L = V4dg_conf .ne. 0

      if (V4dgconf_L .and. (v4dg_tl_L .or. v4dg_ad_L)) then
        pradd_pnvt   = ZERO_8
        pradd_pntt   = ZERO_8
        pradd_pntd   = ZERO_8
      else
        pradd_pnvt   = -Dcst_tcdk_8
        pradd_pntt   = -Dcst_tcdk_8
        pradd_pntd   = -Dcst_tcdk_8
      endif

c     See figure above
      do ii=1,G_nk+2
         a_ta(ii)=Ver_a_spcl_8%t(ii)
         b_ta(ii)=Ver_b_spcl_8%t(ii)
      enddo

      pnpn=0
      pnpt=0
      pnp0=0
      pnla=0
      pnlo=0
      pnme=0
      pnmx=0

      pngz=0
      pnvt=0
      pntt=0
      pnes=0
      pntd=0
      pnhr=0
      pnpx=0
      pnhu=0
      pntw=0
      pnqc=0
      pnww=0
      pnwe=0
      pnzz=0
      pnth=0

      do ii=0,Outd_var_max(F_set)
         coef(ii)=0.0
         filt(ii)=0
         nbit(ii)=0
      enddo
      
      do ii=1,Outd_var_max(F_set)
        if (Outd_var_S(ii,F_set).eq.'PN') pnpn=ii
        if (Outd_var_S(ii,F_set).eq.'PT') pnpt=ii
        if (Outd_var_S(ii,F_set).eq.'P0') pnp0=ii
        if (Outd_var_S(ii,F_set).eq.'LA') pnla=ii
        if (Outd_var_S(ii,F_set).eq.'LO') pnlo=ii
        if (Outd_var_S(ii,F_set).eq.'ME') pnme=ii
        if (Outd_var_S(ii,F_set).eq.'MX') pnmx=ii
        nbit(ii)=Outd_nbit(ii,F_set)
        filt(ii)=Outd_filtpass(ii,F_set)
        coef(ii)=Outd_filtcoef(ii,F_set)
      enddo

      do ii=1,Outd_var_max(F_set)
         if (Outd_var_S(ii,F_set).eq.'GZ') pngz=ii
         if (Outd_var_S(ii,F_set).eq.'VT') pnvt=ii
         if (Outd_var_S(ii,F_set).eq.'TT') pntt=ii
         if (Outd_var_S(ii,F_set).eq.'ES') pnes=ii
         if (Outd_var_S(ii,F_set).eq.'TD') pntd=ii
         if (Outd_var_S(ii,F_set).eq.'HR') pnhr=ii
         if (Outd_var_S(ii,F_set).eq.'PX') pnpx=ii
         if (Outd_var_S(ii,F_set).eq.'HU') pnhu=ii
         if (Outd_var_S(ii,F_set).eq.'TW') pntw=ii
         if (Outd_var_S(ii,F_set).eq.'QC') pnqc=ii
         if (Outd_var_S(ii,F_set).eq.'WW') pnww=ii
         if (Outd_var_S(ii,F_set).eq.'WE') pnwe=ii
         if (Outd_var_S(ii,F_set).eq.'ZZ') pnzz=ii
         if (Outd_var_S(ii,F_set).eq.'TH') pnth=ii
        nbit(ii)=Outd_nbit(ii,F_set)
        filt(ii)=Outd_filtpass(ii,F_set)
        coef(ii)=Outd_filtcoef(ii,F_set)
      enddo

      if (pnpt.ne.0.and.Grd_rcoef.ne.1.0) pnpt=0

      psum=pnpn+pnpt+pnp0+pnla+pnlo+pnme+pnmx

      psum=psum + 
     $     pngz+pnvt+pntt+pnes+pntd+pnhr+pnpx+pnhu+
     $     pntw+pnqc+pnww+pnwe+pnzz+pnth

      if (psum.eq.0)return

      call out_padbuf(F_tt1,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)

      call out_padbuf(F_fiptx,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)
      call out_padbuf(F_hut1,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)
      call out_padbuf(F_qh,l_minx,l_maxx,l_miny,l_maxy,F_nk+2) 
      call out_padbuf(F_wlao,l_minx,l_maxx,l_miny,l_maxy,1) 
      call out_padbuf(F_wt1,l_minx,l_maxx,l_miny,l_maxy,F_nk+1)

*_______________________________________________________________________
*
*     Compute Virtual temperature
      if (.not.V4dgconf_L .or. (V4dgconf_L.and.V4dg_di_L)) then
*        With water loading
         call mfottvh (w3,F_tt1,F_hut1,F_qh,F_ninj,F_nk+2,F_ninj)
         do k=1,l_nk+2
            do i=1,F_ninj
               vt (i,k) = F_tt1(i,k) + w3(i,k) * F_qh(i,k)
               hu (i,k) = F_hut1(i,k)
            enddo
         enddo
      else
*        Without water loading
         do k=1,l_nk+2
            do i=1,F_ninj
               vt (i,k) = F_tt1(i,k)
               hu (i,k) = F_hut1(i,k)
            enddo
         enddo
      endif

*     Bring virtual temperature from top/surface to special levels
*     and add diagnostic temperature (2 m) at G_nk+2
*     Keep dynamic temperature at top
      if(Schm_phyms_L)then
         do i=1,F_ninj
            vt(i,G_nk+2)=F_tt1(i,G_nk+2)
            hu(i,G_nk+2)=F_hut1(i,G_nk+2)
         enddo
      else
         do i=1,F_ninj
c           vt(i,G_nk+1)=F_tt1(i,G_nk+1)
c           hu(i,G_nk+1)=F_hut1(i,G_nk+1)
            vt(i,G_nk+1)=.5*(F_tt1(i,G_nk)+F_tt1(i,G_nk+1))
            vt(i,G_nk+2)=F_tt1(i,G_nk+1)
            hu(i,G_nk+1)=.5*(F_hut1(i,G_nk)+F_hut1(i,G_nk+1))
            hu(i,G_nk+2)=F_hut1(i,G_nk+1)
         enddo
      endif
         
c      i=(l_maxx-l_minx+1)*(101-1+G_haloy)+158+G_halox
c      print*,'i,j,vt(i,G_nk+1),hu(i,G_nk+1)=',vt(i,G_nk+1),hu(i,G_nk+1)
c      print*,'i,j,vt(i,G_nk+2),hu(i,G_nk+2)=',vt(i,G_nk+2),hu(i,G_nk+2)

      call out_padbuf(vt,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)
      call out_padbuf(hu,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)

*     Compute or store Geopotential Height (GZ)

      do k=1,l_nk
      do i=1,F_ninj
         gz (i,k) = F_fiptx(i,k)+Ver_fistr_8%m(k)
      enddo
      enddo

*_________________________________________________________________
*
*     2.0    Output 2D variables 
*_________________________________________________________________
*
      if (pnme.ne.0)then
            call ecris_fst2(F_topo,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $        'ME  ',prmult_pnme,0.0,-1,1,1, 1, nbit(pnme) )
         endif
      if (pnmx.ne.0)then
            call ecris_fst2(F_topo,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $        'MX  ',1.0,0.0,-1,1,1, 1, nbit(pnmx) )
         endif
      if (pnpt.ne.0)
     $    call ecris_fst2(F_ptop,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $        'PT  ',.01,0.0,-1,1, 1, 1, nbit(pnpt) )
      if (pnla.ne.0)
     $    call ecris_fst2(Geomn_latrx,1,l_ni,1,l_nj,0.0,
     $        'LA  ',1.0,0.0,-1,1, 1, 1, nbit(pnla) )
      if (pnlo.ne.0)
     $    call ecris_fst2(Geomn_lonrx,1,l_ni,1,l_nj,0.0,
     $        'LO  ',1.0,0.0,-1,1, 1, 1, nbit(pnlo) )

*_______________________________________________________________________
*
*     3.0    Precomputations for output over pressure levels or PN or 
*            GZ on thermo levels
*
*        The underground extrapolation can use precalculated
*        temperatures over fictitious underground geopotential levels.
*        The number of fictitious levels is "Out3_nundr".
*        The levels in meters are stored in "Out3_zund(Out3_nundr)".
*        Both "Out3_nundr" and "Out3_zund" are user's given 
*        parameters.
*_______________________________________________________________________
*

      If (lastdt .eq. -1) then
          allocate ( ttx(F_ninj,Out3_nundr),htx(F_ninj,Out3_nundr),
     %               gz_ta(F_ninj,F_nk+2), gz_m_plus(F_ninj,0:F_nk+1) )
      endif

c     Compute GZ on thermo levels in gz_ta
      if ( Out3_nundr.gt.0 .and. lastdt .ne. Lctl_step ) then
         do i= 1, F_ninj
            do k=1,l_nk
               gz_m_plus(i,k)=gz(i,k)
            enddo
               gz_m_plus(i,l_nk+1)=F_topo(i)
            gz_m_plus(i,0)=.5*(F_fiptx(i,1)+F_fiptx(i,0))+
     $              Ver_fistr_8%t(1)
            gz_ta(i,l_nk+2)=F_topo(i)
         enddo
         call vertint3(gz_ta,gz_m_plus,F_posit,F_huv,F_ninj,G_nk+1,G_nk+2)
         
       do 200 kl=1,Out3_nundr

         do 150 i=1,F_ninj

*        Store fictitious height level in htx

         htx(i,kl) = Out3_zund(kl) * Dcst_grav_8

*        Determine if fictitious level is above or below ground

         w1(i) = F_topo(i) - htx(i,kl)

         if ( w1(i) .gt. 0 ) then

*           fictitious level is under ground:
*           temperature is obtained by linear EXTrapolation
*           identify under ground grid point
* 
            if ( abs( F_wlao(i)*180./Dcst_pi_8 ) .ge. 49. ) then

                w1(i) = vt(i,G_nk+2) +       .0005 * w1(i)
            else
                w1(i) = vt(i,G_nk+2) + Dcst_stlo_8 * w1(i)
            endif

            w2(i) = 1.0

        else

*           fictitious level is above ground:
*           temperature is obtained by linear INTerpolation
*           identify above ground grid point

            do k=l_nk+1,1,-1
               w1(i) = gz_ta (i,k) - htx(i,kl)
               if ( w1(i) .gt. 0. ) goto 10
            enddo
 10         continue
            
            w2(i)= - (   vt(i,k) -    vt(i,k+1) ) /
     %               (gz_ta(i,k) - gz_ta(i,k+1) )
            
            w1(i) = vt (i,k) + w2(i) * w1(i)

            w2(i) = 0.0

         endif

 150     continue

         call glbcolc (wk1,G_ni,G_nj,w1,l_minx,l_maxx,l_miny,l_maxy,1)
         call glbcolc (wk2,G_ni,G_nj,w2,l_minx,l_maxx,l_miny,l_maxy,1)

*        For all under ground grid points at level htx(i,kl)
*        recompute temperature by HORIZONTAL interpolation
*
         if (Ptopo_myproc.eq.0) 
     $        call liebman_2 (wk1,wk2,wk3,wk4,0.1,G_ni,G_nj)

         call glbdist (wk1,G_ni,G_nj,w1,l_minx,l_maxx,l_miny,l_maxy,
     $                         1,G_halox,G_haloy)

         do i=1,F_ninj
            ttx(i,kl) = w1(i)
         enddo

*        At this point:
*        temperature field is stored in ttx for future use
*        fictitious levels  are stored in htx for future use

 200   continue

      endif
      lastdt = Lctl_step

      call out_padbuf(ttx,l_minx,l_maxx,l_miny,l_maxy,Out3_nundr) 
      call out_padbuf(htx,l_minx,l_maxx,l_miny,l_maxy,Out3_nundr) 

*     Calculate PN
      if (pnpn.ne.0) then
          call vslog(w2,F_p0,F_ninj)
          call pnm2(w1,F_tt1(1,F_nk+1),F_topo,w2,F_wlao,
     $         ttx,htx,Out3_nundr,l_minx,l_maxx,l_miny,l_maxy,1)
          if (filt(pnpn).gt.0)
     $      call filter(w1,filt(pnpn),coef(pnpn),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, 1)
          call ecris_fst2(w1,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $        'PN  ',.01,0.0,-1,1, 1, 1, nbit(pnpn) )
      endif

*     Calculate P0
      if (pnp0.ne.0) then

         if(.not.V4dgconf_L .or. (V4dgconf_L .and. V4dg_di_L)) then
             do i= 1, F_ninj
                w1(i) = F_p0(i)
             enddo

          elseif(V4dgconf_L .and. V4dg_tl_L) then
             print*,'Ajuster code pour staggering'
             call gem_stop('out_thm',-2)
             do i= 1, F_ninj
                w1(i) =  Ver_z_8%t(F_nk+1) * exp(F_st1m(i)) * F_st1(i)
             enddo

          elseif(V4dgconf_L .and. V4dg_ad_L) then
             print*,'Ajuster code pour staggering'
             call gem_stop('out_thm',-3)
             do i= 1, F_ninj
                w1(i) = F_st1(i)/(Ver_z_8%t(F_nk+1) * exp(F_st1m(i)))
             enddo
          endif

          if (filt(pnp0).gt.0)
     $       call filter(w1,filt(pnp0),coef(pnp0),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, 1)
          call ecris_fst2(w1,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $        'P0  ',.01,0.0,-1,1, 1, 1, nbit(pnp0) )

      endif

      if (pnww.ne.0) then
cccparallel
         call calomeg_adv (omega,F_st1,F_piup,LDIST_DIM,F_nk,.true.)
cvl      calomeg  gives values to F_nk+1 ! 
cccend parallel
         do i= 1, F_ninj
            omega(i,F_nk+2)=omega(i,F_nk+1)
         enddo         
      endif

      if (pnth.ne.0) then
         do k= 1,F_nk+1
            do i= 1, F_ninj
               th(i,k)= F_tt1(i,k)*(theta_p0/exp(F_wlnph_ta(i,k)))**Dcst_cappa_8
            enddo
         enddo
         do i= 1, F_ninj
            th(i,F_nk+2)= F_tt1(i,F_nk+2)*(theta_p0/exp(F_wlnph_ta(i,F_nk+2)))**Dcst_cappa_8
         enddo
      endif

      if (F_levtyp_S .eq. 'M') then

*_______________________________________________________________________
*
*     4.0   Output 3-D Derived Variables on ETA levels (momentum/thermo)
*_______________________________________________________________________
         
         if (pnww.ne.0.or.pnwe.ne.0.or.pnzz.ne.0) then
             do k=2,F_nk
                Ver_hyb_w(k)= Ver_hyb%t(k)
             enddo
             Ver_hyb_w(1)= 0.0
             Ver_hyb_w(F_nk+1)= 1.0
             Ver_hyb_w(F_nk+2)= 1.0
         endif 
         if (pnwe.ne.0)then
            do k= 1,F_nk
            do i= 1, F_ninj
                  t8(i,k) = F_zdt1(i,k)
            enddo
            enddo
            do i= 1, F_ninj
               t8(i,F_nk+1) = F_zdt1(i,F_nk)
               t8(i,F_nk+2) = F_zdt1(i,F_nk+1)
            enddo
            call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb_w,
     $           'WE  ',prmult_pnwe,0.0,Out_kind,F_nk+2, F_indo, F_nkot, nbit(pnwe) )
         endif
         if (pngz.ne.0)then
             do i=1,F_nk+2
                 pnindo(i)= i
             enddo
             call ecris_fst2(gz_m_plus(1,1),
     $        l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m,
     $        'GZ  ',prmult_pngz,0.0,Out_kind,F_nk+1, pnindo, F_nk, nbit(pngz) )
             call ecris_fst2(gz_ta,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $        'GZ  ',prmult_pngz,0.0,Out_kind,F_nk+2,pnindo,F_nk+2,nbit(pngz))
         endif
         if (pnvt.ne.0)then
            call ecris_fst2(vt,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $           'VT  ',1.0,pradd_pnvt,Out_kind,F_nk+2, F_indo, F_nkot, nbit(pnvt) )
         endif
         if (pnth.ne.0) then
               call ecris_fst2(th,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $              'TH  ',1.0,0.0,Out_kind,F_nk+2,F_indo,F_nkot,nbit(pnvt) )               
         endif
         if (pnhu.ne.0) then

            if (Out3_cliph_L) then
                do k= 1,F_nk+2
                 do i= 1, F_ninj
                    t8(i,k) = amax1( hu(i,k), 0. )
                 enddo
                enddo
                call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $        'HU  ',1.0,     0.0,  Out_kind,F_nk+2, F_indo, F_nkot,nbit(pnhu) )
            else
                call ecris_fst2(hu,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $        'HU  ',1.0,     0.0,  Out_kind,F_nk+2, F_indo, F_nkot,nbit(pnhu) )
            endif
         endif

         if ( .not.(Lctl_step .eq. 0) .and. Schm_phyms_L
     $                 .and.  pnqc.ne.0 ) then
*            QC output for timestep 0 is done after physics have executed
             if (Out3_cliph_L) then
                do k= 1,F_nk+2
                 do i= 1, F_ninj
                    t8(i,k) = amax1( F_qct1(i,k), 0. )
                 enddo
                enddo
                call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $       'QC  ',1.0,      0.0,  Out_kind,F_nk+2, F_indo, F_nkot, nbit(pnqc) )
             else
                call ecris_fst2(F_qct1,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $       'QC  ',1.0,      0.0,  Out_kind,F_nk+2, F_indo, F_nkot, nbit(pnqc) )
             endif
         endif

         if ( pntt.ne.0 .or. pntd.ne.0 .or. pnhr.ne.0 ) then

*        Calculate TT (in tt)

           if (.not.V4dgconf_L .or. (V4dgconf_L .and. V4dg_di_L)) then
              
               call mfottv (tt,vt,hu, F_ninj,F_nk+2,F_ninj)               

           elseif (V4dgconf_L.and.V4dg_tl_L) then

              call gem_stop('out_thm : ajuster pour staggering',-1)

              call out_padbuf(F_vtm, l_minx,l_maxx,l_miny,l_maxy,F_nk+1)
              call out_padbuf(F_hum1,l_minx,l_maxx,l_miny,l_maxy,F_nk+1)
              call mfottv_tl (tt,vt,hu,F_vtm,F_hum1,F_ninj,F_nk+2,F_ninj)

           elseif (V4dgconf_L.and.V4dg_ad_L) then
*
              call gem_stop('out_thm : ajuster pour staggering',-1)

              call v4d_zerohalo (vt,    l_ni,l_nj,LDIST_DIM, F_nk+2)
              call v4d_zerohalo (F_hum1,l_ni,l_nj,LDIST_DIM, F_nk+1)
*
              do k=  1, F_nk+2
              do i=1,F_ninj
*                We calculate the pair (TT,HU), where TT is the true
*                temperature,
*                according to subroutine mfotvt_ad from the physics.
*                The pair (TPT1,HUT1), where TPT1 is the virtual
*                temperature,
*                is already taken care of.
*
                 tt(i,k) = dble(vt(i,k)) * 
     $                     (1.d0 + Dcst_delta_8*dble(hu(i,k)))
              enddo
              enddo
           endif

         endif

         if (pntt.ne.0)then            
            call ecris_fst2(tt,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $           'TT  ',1.0,pradd_pntt, Out_kind,F_nk+2, F_indo,F_nkot, nbit(pntt) )
         endif
         if (pnes.ne.0.or.pnpx.ne.0.or.pntw.ne.0.or.pntd.ne.0.or.pnhr.ne.0)then

*        Calculate PX (in px), thermo levels.
*        And output all the levels!
            call vsexp(px_ta,F_wlnph_ta,F_ninj*(F_nk+2))
            call out_padbuf(px_ta,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)
            px_ta(:,F_nk+2) = F_p0(:)

*        Calculate PX (in px), momentum levels.
            call vsexp(px_m,F_wlnph_m,F_ninj*(F_nk+1))
            call out_padbuf(px_m,l_minx,l_maxx,l_miny,l_maxy,F_nk+1)
            px_m(:,F_nk+1) = F_p0(:)
         endif
                     
         if (pnpx.ne.0)then
             do i=1,F_nk+2
                 pnindo(i)= i
             enddo
             call ecris_fst2(px_ta,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $        'PX  ',prmult_pnpx,0.0,Out_kind,F_nk+2,pnindo,F_nk+2,nbit(pnpx) )

             call ecris_fst2(px_m,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m,
     $        'PX  ',prmult_pnpx,0.0,Out_kind,F_nk+1,pnindo,F_nk,nbit(pnpx) )
         endif

         if (pntw.ne.0) then
*        Calculate THETAW TW (t8=TW) (px=PX)
             call mthtaw2 (t8,hu,vt, px_ta,px_ta,3, .false.,Out3_satues_L,
     $                     .true.,Dcst_trpl_8,F_ninj,F_nk+2,F_ninj)
             call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $        'TW  ',1.0,0.0, Out_kind,F_nk+2, F_indo, F_nkot, nbit(pntw) )
         endif

         if (pnes.ne.0 .or. pntd.ne.0) then
*        Calculate ES (t8=ES) (px=PX)
             call mhuaes(t8,hu,vt,px_ta,px_ta,3, .false., Out3_satues_L,
     $                      F_ninj,F_nk+2,F_ninj)

             if (Out3_cliph_L) then
                do k= 1,F_nk+2
                 do i= 1, F_ninj
                    t8(i,k) = amin1( t8(i,k), 30.)
                    t8(i,k) = amax1( t8(i,k), 0. )
                 enddo
                enddo
             endif

             if (pnes.ne.0)
     $       call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $        'ES  ',1.0,0.0, Out_kind,F_nk+2, F_indo, F_nkot, nbit(pnes) )

             if (pntd.ne.0) then
*            Calculate TD (tt=TT,t8=old ES, t8=TD=TT-ES)
                 do k= 1,F_nk+2
                 do i= 1, F_ninj
                    t8(i,k) = tt(i,k) - t8(i,k)
                 enddo
                 enddo
                 call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $           'TD  ',1.0,pradd_pntd,Out_kind,F_nk+2,F_indo,F_nkot,nbit(pntd) )
             endif
         endif

         if (pnhr.ne.0) then
*        Calculate HR (t8=HR,tt=TT,px=PX)
             if (Out3_satues_L) then
             call mfohr(t8,hu,tt,
     $                   px_ta,px_ta,3,F_ninj,F_nk+2,F_ninj)
             else
             call mfohra(t8,hu,tt,
     $                   px_ta,px_ta,3,F_ninj,F_nk+2,F_ninj)
             endif
             if ( Out3_cliph_L ) then
                do k= 1,F_nk+2
                  do i= 1, F_ninj
                     t8(i,k)=amin1( t8(i,k), 1.0 )
                     t8(i,k)=amax1( t8(i,k), 0.  )
                  enddo
                enddo
             endif
             call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $           'HR  ',1.0,0.0, Out_kind,F_nk+2, F_indo, F_nkot, nbit(pnhr) )
         endif

         if (pnww.ne.0) then
             call ecris_fst2(omega,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb_w,
     $           'WW  ',1.0,0.0, Out_kind,F_nk+2, F_indo, F_nkot, nbit(pnww) )
         endif

         if (pnzz.ne.0) then
            do k= 1,F_nk+1
               do i= 1, F_ninj
                  t8(i,k)=F_wt1(i,k)
               enddo
            enddo
*           Put nk value at special level like WE
            do i= 1, F_ninj
               t8(i,F_nk+2) = t8(i,F_nk+1)
               t8(i,F_nk+1) = t8(i,F_nk)
            enddo            
            call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb_w,
     $              'ZZ  ',1.0,0.0, Out_kind,F_nk+2, F_indo, F_nkot, nbit(pnzz) )
         endif
      else
*_______________________________________________________________________
*
*     5.0    Output 3-D Derived Variables on PRESSURE levels
*_______________________________________________________________________
*
        do i = 1, F_nko
           prprlvl(i) = F_rf(i) * 100.0
        enddo

*       Calculate vertical derivative of HUT1 with respect to F_wlnph_ta

        call verder(px_ta,hu,F_wlnph_ta,2.0,2.0,l_minx,l_maxx,l_miny,l_maxy,
     $                                       F_nk+2, 1,l_ni,1,l_nj)

*       Calculate HU (hu_pres=HU,px_ta=vert.der)
        call prgen(hu_pres,hu,px_ta,F_wlnph_ta,prprlvl,F_nko, 
     $                      Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)
        if ( Out3_cliph_L ) then
           do k= 1, F_nko
              do i= 1, F_ninj
                 hu_pres(i,k) = amax1( hu_pres(i,k), 0. )
              enddo
           enddo
        endif

*       Calculate GZ,VT (w5=GZ_pres, vt_pres=VT_pres)

        call prgzvta( w5, vt_pres, prprlvl, F_nko,
     %                gz_ta, vt, F_wlnph_ta, F_wlao,
     %                ttx, htx, Out3_nundr,Out3_cubzt_L, 
     %                Out3_linbot, l_minx,l_maxx,l_miny,l_maxy,F_nk+2)

        call out_padbuf(vt_pres,l_minx,l_maxx,l_miny,l_maxy,F_nko)
        call out_padbuf(hu_pres,l_minx,l_maxx,l_miny,l_maxy,F_nko)

        if (pngz.ne.0) then
            if (filt(pngz).gt.0)then
               call filter(w5,filt(pngz),coef(pngz),'G', .false.,
     $              l_minx,l_maxx,l_miny,l_maxy, F_nko)
            endif
            call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $        'GZ  ',prmult_pngz,0.0, Out_kind,F_nko,F_indo,F_nko,nbit(pngz) )
        endif

        if (pntt.ne.0.or.pntd.ne.0.or.pnhr.ne.0) then

*           Calculate TT (tt_pres=TT,vt_pres=VT,hu_pres=HU)
            call mfottv(tt_pres,vt_pres,hu_pres, F_ninj,F_nko,F_ninj)
            call out_padbuf(tt_pres,l_minx,l_maxx,l_miny,l_maxy,F_nko)
        endif

        if ( pnes.ne.0.or.pntw.ne.0.or.pntd.ne.0.or.pnhr.ne.0) then
*           Calculate PX for ES,TD,HR
            do k=1,F_nko
               do i= 1, F_ninj
                  px_pres(i,k) = prprlvl(k)
               enddo
            enddo
            call out_padbuf(px_pres,l_minx,l_maxx,l_miny,l_maxy,F_nko)
        endif

        if (pntw.ne.0) then
*           Calculate THETAW TW (w5=TW_pres) (px_pres=PX)
            call mthtaw2 (w5,hu_pres,vt_pres,
     $                     px_pres,px_pres,3,.false.,Out3_satues_L,
     $                     .true.,Dcst_trpl_8,F_ninj,F_nko,F_ninj)
            if (filt(pntw).gt.0)
     $          call filter(w5,filt(pntw),coef(pntw),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
            call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $          'TW  ',1.0,0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pntw) )
        endif
*
        if (pnes.ne.0.or.pntd.ne.0) then
*           Calculate ES (w5=ES_pres,hu_pres=HU,w2=VT,px_pres=PX)
            call mhuaes (w5, hu_pres, vt_pres,
     $                    px_pres,px_pres,3,.false.,Out3_satues_L,
     $                    F_ninj, F_nko, F_ninj)
            if ( Out3_cliph_L ) then
               do k=1,F_nko
                 do i= 1, F_ninj
                    w5(i,k) = amin1( w5(i,k), 30.)
                    w5(i,k) = amax1( w5(i,k), 0. )
                 enddo
               enddo
            endif

            if (pntd.ne.0) then
*           Calculate TD (tt_pres=TT,w5=ES, TD=TT-ES)
              do k=1,F_nko
                 do i= 1, F_ninj
                    td_pres(i,k) = tt_pres(i,k) - w5(i,k)
                 enddo
              enddo
              call filter(td_pres,filt(pntd),coef(pntd),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
              call ecris_fst2(td_pres,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $          'TD  ',1.0,pradd_pntd, Out_kind,F_nko,F_indo,F_nko,nbit(pntd) )
            endif

            if (pnes.ne.0) then
                if (filt(pnes).gt.0)
     $              call filter(w5,filt(pnes),coef(pnes),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
                call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $             'ES  ',1.0,0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnes) )
            endif
        endif

        if (pnhr.ne.0) then
*           Calculate HR (w5=HR_pres:hu_pres=HU,tt_pres=TT,px_pres=PX)
            if (Out3_satues_L) then
            call mfohr (w5,hu_pres,tt_pres,px_pres, 
     $                    px_pres,3,F_ninj,F_nko,F_ninj)
            else
            call mfohra (w5,hu_pres,tt_pres,px_pres, 
     $                    px_pres,3,F_ninj,F_nko,F_ninj)
            endif
            if ( Out3_cliph_L ) then
               do k=1,F_nko
                  do i= 1, F_ninj
                     w5(i,k) = amin1( w5(i,k), 1.0 )
                     w5(i,k) = amax1( w5(i,k), 0.  )
                  enddo
               enddo
            endif
            if (filt(pnhr).gt.0)
     $          call filter(w5,filt(pnhr),coef(pnhr),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
            call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $          'HR  ',1.0,0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnhr) )
        endif

        if (pnvt.ne.0) then
            if (filt(pnvt).gt.0)
     $          call filter(vt_pres,filt(pnvt),coef(pnvt),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
            call ecris_fst2(vt_pres,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $        'VT  ',1.0,pradd_pnvt, Out_kind,F_nko,F_indo, F_nko, nbit(pnvt) )
        endif

         if (pnth.ne.0) then
          call verder(px_ta,th,F_wlnph_ta,2.0,2.0,l_minx,l_maxx,l_miny,l_maxy,
     $                                       F_nk+2, 1,l_ni,1,l_nj)
          call prgen( th_pres, th, px_ta, F_wlnph_ta, prprlvl,F_nko,
     $                      Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)
            call ecris_fst2(th_pres,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $        'TH  ',1.0,      0.0,  Out_kind,F_nko, F_indo, F_nko, nbit(pnth) )
         endif

        if (pnhu.ne.0) then
            if (filt(pnhu).gt.0)
     $          call filter(hu_pres,filt(pnhu),coef(pnhu),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
            call ecris_fst2(hu_pres,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $        'HU  ',1.0,       0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnhu) )
        endif

        if (pntt.ne.0) then
            if (filt(pntt).gt.0)
     $          call filter(tt_pres,filt(pntt),coef(pntt),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
            call ecris_fst2(tt_pres,l_minx,l_maxx,l_miny,l_maxy,F_rf, 
     $        'TT  ',1.0,pradd_pntt, Out_kind,F_nko, F_indo, F_nko, nbit(pntt) )
        endif

        if ( .not.(Lctl_step .eq. 0) .and. Schm_phyms_L
     $                 .and.  pnqc.ne.0  ) then
*         QC output for timestep 0 is done after physics have executed
          call verder(px_ta,F_qct1,F_wlnph_ta,2.0,2.0,l_minx,l_maxx,l_miny,l_maxy,
     $                                        F_nk+2,1,l_ni,1,l_nj)
*         Calculate QC (qc_pres=w5,px=vert.der)
          call prgen( w5, F_qct1, px_ta, F_wlnph_ta, prprlvl,F_nko, 
     $                      Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy, F_nk+2)
          if ( Out3_cliph_L ) then
               do k= 1, F_nko
               do i= 1, F_ninj
                 w5(i,k) = amax1( w5(i,k), 0. )
               enddo
               enddo
          endif
          if (filt(pnqc).gt.0)
     $      call filter(w5,filt(pnqc),coef(pnqc),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
             call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $        'QC  ',1.0,       0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnqc) )
        endif

        if (pnww.ne.0) then
           call verder (w3,omega,F_wlnph_ta,2.0,2.0,l_minx,l_maxx,l_miny,l_maxy,
     $                 F_nk+2, 1,l_ni,1,l_nj)
            call prgen( w5,omega, w3, F_wlnph_ta, prprlvl,F_nko, 
     $                      Out3_cubww_L,l_minx,l_maxx,l_miny,l_maxy, F_nk+2)
            if (filt(pnww).gt.0)
     $          call filter(w5,filt(pnww),coef(pnww),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
             call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $           'WW  ',1.0,0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnww) )
        endif


      endif

      return
      end
