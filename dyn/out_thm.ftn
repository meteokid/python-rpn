**s/r out_thm - output  temperature, humidity and mass fields
*
#include <model_macros_f.h>
*
      subroutine out_thm(F_fiptx,F_tt1,F_st1,F_qct1,F_qh,F_hut1,
     %                   F_psdt1,F_wt1,F_zz1,F_ut1,F_vt1,F_csh,
     %                   F_vtm,F_hum1, F_st1m,F_piup,
     %                   F_wlnph_m,F_wlnph_ta,F_ptop,F_p0,F_wlao,F_topo,
     %                   F_tdia,F_hdia,F_posit,F_huv,
     %                   F_ninj,F_nk, F_levtyp_S,F_rf,F_rf_m,
     %                   F_indo,F_nko,F_indo_m,F_nko_m,F_set)
*
      implicit none
*
      character*1 F_levtyp_S
      integer F_nk,F_ninj,F_nko,F_indo(*),F_indo_m(*),F_set,F_nko_m

      real F_fiptx  (F_ninj,0:F_nk+1), F_tt1    (F_ninj,F_nk+1),
     %     F_qct1   (F_ninj,F_nk+1), F_qh     (F_ninj,F_nk+1),
     %     F_hut1   (F_ninj,F_nk+1), F_wt1    (F_ninj,F_nk+1),
     %     F_psdt1  (F_ninj,F_nk+1),
     %     F_zz1    (F_ninj,F_nk+1), F_csh    (F_ninj),
     %     F_ut1    (F_ninj,F_nk+1), F_vt1    (F_ninj,F_nk  ),
     %     F_vtm    (F_ninj,F_nk+1), F_piup   (F_ninj,F_nk+1),
     %     F_hum1   (F_ninj,F_nk+1), F_wlnph_m(F_ninj,F_nk+1),
     %     F_wlnph_ta(F_ninj,F_nk+2),
     %     F_posit  (F_ninj*(F_nk+1)*6),F_huv(F_ninj*(F_nk+2+4)*2),
     %     F_ptop(F_ninj),F_p0(F_ninj),F_st1(F_ninj),F_st1m(F_ninj),
     %     F_wlao(F_ninj),F_topo(F_ninj),F_rf(F_nko),
     %     F_rf_m(F_nko_m),F_tdia(F_ninj,3),F_hdia(F_ninj)
   
*
*author
*     james caveen/andre methot  - rpn june/nov 1995
*
*revision
* v2_00 - Lee V.            - initial MPI version (from blocthm v1_03)
* v2_11 - Desgagne M.       - ptop reproducubility
* v2_21 - Desgagne M.       - new calling sequence for glbdist + correct
* v2_21                       calling sequence mfohra
* v2_21 - J. P. Toviessi    - set dieze (#) slab output and rename
* v2_21                       truncate model output names to 4 characters
* v2_30 - Lee V.            - reorganize slab output to be more efficient
* v2_30 - Edouard S.        - adapt for vertical hybrid coordinate
* v2_30                     - change call to p0vt2gz_hyb
* v2_32 - Lee V.            - reduce dynamic allocation size, add HU,ME output
* v3_00 - Desgagne & Lee    - Lam configuration
* v3_01 - Lee V.            - Added output of ThetaW
* v3_01 - Morneau J.        - remove conversion to Celcius for TL or AD output
* v3_02 - Plante A.         - Water loading
* v3_02 - Lee V.            - LA and LO output (not physics), add QC output
* v3_03 - Lee V.            - correct bug for illegal access to all h2o tracers
* v3_03                       if Schm_phyms_L is false.
* v3_11   Tanguay M.        - Add TLM and ADJ increments TT and P0
*                           - Extend TRAJ for conversion for DYNOUT2
* v3_20   Lee V.            - Output in blocks, standard files
* v3_     Plante A.         - Adjuste and introduce output for staggering
*                           - Correct computation of theta
*
*object
*     See above id.
*
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_dostep     I    - array containing indices corresponding to the
*                     timestep sets that requires output at this time step.
* F_dostep_max I    - size of F_dostep array
*
c Index vectors for level indentifications
c ----------------------------------------
c 
c vector for the momentum level : ind_m.
c
c vector for the momentum-top-surface level int_ta
c    ind_ta : Thermo levels with special levels ("o" on figure below),

c                ind_m(1:G_nk) ind_ta(1:G_nk+2) 
c model top
c ===========1        -             X           

c - - - - - -3        X             -           
c
c ===========4        -             X           
c  
c    ...             ...           ...          
c
c
c ===========2*k      -             X           
c
c - - - - - -2*k+1    X             -           
c
c    ...             ...           ...          
c
c - - - - - -2*G_nk+1 X             -           
c o o o o o o2*G_nk+2 -             X           
c ===========2*G_nk+3 -             X           
c model surface
c
c----------------------------------------------------------------------
* 
*implicits

#include "glb_ld.cdk"
#include "dcst.cdk"
#include "dimout.cdk"
#include "geomn.cdk"
#include "schm.cdk"
#include "out.cdk"
#include "out3.cdk"
#include "grd.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "ptopo.cdk"
#include "v4dg.cdk"
#include "lctl.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
*
*modules
*
**
      type :: stg_i
         integer :: t,m,p
      end type stg_i

      real theta_p0

      parameter (theta_p0=100000.)

      integer i,j,k,kl,ii,my_nko
      real ind_ta(G_nk+2)
      real ind_m(G_nk)
      real wk1(G_ni,G_nj),wk2(G_ni,G_nj)
      real wk3(G_ni,G_nj+2),wk4(G_ni,G_nj+2)
      real w1(F_ninj), w2(F_ninj)
      real w3(F_ninj,F_nk+1)
      real px_pres(F_ninj,F_nko)
      real hu_pres(F_ninj,F_nko)
      real td_pres(F_ninj,F_nko)
      real th_pres(F_ninj,F_nko)
      real w5(F_ninj,F_nko)
      real prprlvl(F_nko)
      real tt_pres(F_ninj,F_nko)
      real vt_pres(F_ninj,F_nko)
      real htx(F_ninj,Out3_nundr)
      real ttx(F_ninj,Out3_nundr)
      real px_ta(F_ninj,F_nk+2),px_m(F_ninj,F_nk+1), th(F_ninj,F_nk+2)
      real tt(F_ninj,F_nk+2),hu(F_ninj,F_nk+2),t8(F_ninj,F_nk+2),
     $     vt(F_ninj,F_nk+2),gz(F_ninj,F_nk), omega(F_ninj,F_nk+2)
      real fbot(F_ninj),wlnph_top(F_ninj),wlnph_bot(F_ninj)
      real gz_ta(F_ninj,F_nk+2),tt_temp(F_ninj,F_nk+1)
      real ps_temp(F_ninj),gz_m_plus(F_ninj,0:F_nk+1)
      real w4(F_ninj,0:F_nk+1),pia_ta(F_nk+2),pib_ta(F_nk+2)
* ___________________________________________________________________
*
*     1.0     initialization of data
*_______________________________________________________________________
*
      type (stg_i)
     $        pngz,pnvt,pntt,pnes,pntd,
     $        pnhr,pnpx,pnhu,pntw,pnqc,
     $        pnww,pnwe,pnzz,pnth
      integer pnpn,psum,pnpt,pnp0,pnla,pnlo,pnme,pnmx

      integer nbit(0:Outd_var_max(F_set)+1),filt(0:Outd_var_max(F_set)+1)
      real    coef(0:Outd_var_max(F_set)+1)
      logical V4dgconf_L

*     initialize conversion of units

      real*8, parameter :: ZERO_8 = 0.0
      real    prmult_pngz, prmult_pnpx, prmult_pnme, prmult_pnwe
      real    pradd_pnvt,  pradd_pntt,  pradd_pntd,  pradd_pnwe

      prmult_pngz  = 0.1 / Dcst_grav_8
      prmult_pnpx  = 0.01
      prmult_pnme  = 1.0 / Dcst_grav_8
      prmult_pnwe  = 1.0 / (Ver_z_8%d(l_nk) - Ver_z_8%d(1))

      pradd_pnwe   = ZERO_8

      V4dgconf_L = V4dg_conf .ne. 0

      if (V4dgconf_L .and. (v4dg_tl_L .or. v4dg_ad_L)) then
        pradd_pnvt   = ZERO_8
        pradd_pntt   = ZERO_8
        pradd_pntd   = ZERO_8
      else
        pradd_pnvt   = -Dcst_tcdk_8
        pradd_pntt   = -Dcst_tcdk_8
        pradd_pntd   = -Dcst_tcdk_8
      endif

c     See figure above
      do ii=1,G_nk+2
         ind_ta(ii)=Ver_hyb_8%t(ii)
c         print*,'ii,ind_ta(ii)=',ii,ind_ta(ii)
         pia_ta(ii)=Ver_pia_spcl_8%t(ii)
         pib_ta(ii)=Ver_pibb_spcl_8%t(ii)*Cstv_pisrf_8
      enddo
      do ii=1,G_nk
         ind_m(ii)=Ver_hybm_8%m(ii)
      enddo

      pnpn=0
      pnpt=0
      pnp0=0
      pnla=0
      pnlo=0
      pnme=0
      pnmx=0

      pngz%t=0
      pnvt%t=0
      pntt%t=0
      pnes%t=0
      pntd%t=0
      pnhr%t=0
      pnpx%t=0
      pnhu%t=0
      pntw%t=0
      pnqc%t=0
      pnww%t=0
      pnwe%t=0
      pnzz%t=0
      pnth%t=0

      pngz%m=0
      pnvt%m=0
      pntt%m=0
      pnes%m=0
      pntd%m=0
      pnhr%m=0
      pnpx%m=0
      pnhu%m=0
      pntw%m=0
      pnqc%m=0
      pnww%m=0
      pnwe%m=0
      pnzz%m=0
      pnth%m=0

      pngz%p=0
      pnvt%p=0
      pntt%p=0
      pnes%p=0
      pntd%p=0
      pnhr%p=0
      pnpx%p=0
      pnhu%p=0
      pntw%p=0
      pnqc%p=0
      pnww%p=0
      pnwe%p=0
      pnzz%p=0
      pnth%p=0

      do ii=0,Outd_var_max(F_set)
         coef(ii)=0.0
         filt(ii)=0
         nbit(ii)=0
      enddo
      
      do ii=1,Outd_var_max(F_set)
        if (Outd_var_S(ii,F_set).eq.'PN') pnpn=ii
        if (Outd_var_S(ii,F_set).eq.'PT') pnpt=ii
        if (Outd_var_S(ii,F_set).eq.'P0') pnp0=ii
        if (Outd_var_S(ii,F_set).eq.'LA') pnla=ii
        if (Outd_var_S(ii,F_set).eq.'LO') pnlo=ii
        if (Outd_var_S(ii,F_set).eq.'ME') pnme=ii
        if (Outd_var_S(ii,F_set).eq.'MX') pnmx=ii
        nbit(ii)=Outd_nbit(ii,F_set)
        filt(ii)=Outd_filtpass(ii,F_set)
        coef(ii)=Outd_filtcoef(ii,F_set)
      enddo

      if (F_levtyp_S.eq.'M')then
         do ii=1,Outd_var_max(F_set)
            if (Outd_var_S(ii,F_set).eq.'GZ') pngz%t=ii
            if (Outd_var_S(ii,F_set).eq.'VT') pnvt%t=ii
            if (Outd_var_S(ii,F_set).eq.'TT') pntt%t=ii
            if (Outd_var_S(ii,F_set).eq.'ES') pnes%t=ii
c            if (Outd_var_S(ii,F_set).eq.'TD') pntd%t=ii
c            if (Outd_var_S(ii,F_set).eq.'HR') pnhr%t=ii
            if (Outd_var_S(ii,F_set).eq.'PX') pnpx%t=ii
c            if (Outd_var_S(ii,F_set).eq.'HU') pnhu%t=ii
c            if (Outd_var_S(ii,F_set).eq.'TW') pntw%t=ii
c            if (Outd_var_S(ii,F_set).eq.'QC') pnqc%t=ii
            if (Outd_var_S(ii,F_set).eq.'WW') pnww%t=ii
            if (Outd_var_S(ii,F_set).eq.'WE') pnwe%t=ii
c            if (Outd_var_S(ii,F_set).eq.'ZZ') pnzz%t=ii
c            if (Outd_var_S(ii,F_set).eq.'TH') pnth%t=ii
         enddo
      endif

c     Note : F_levtyp_S='N' for native model level (not implemented)
c      if (F_levtyp_S.eq.'N')then
c         do ii=1,Outd_var_max(F_set)
c            if (Outd_var_S(ii,F_set).eq.'GZ') pngz%m=ii
c            if (Outd_var_S(ii,F_set).eq.'VT') pnvt%t=ii
c            if (Outd_var_S(ii,F_set).eq.'TT') pntt%t=ii
c            if (Outd_var_S(ii,F_set).eq.'ES') pnes%t=ii
c            if (Outd_var_S(ii,F_set).eq.'TD') pntd%t=ii
c            if (Outd_var_S(ii,F_set).eq.'HR') pnhr%t=ii
c            if (Outd_var_S(ii,F_set).eq.'PX') pnpx%t=ii
c            if (Outd_var_S(ii,F_set).eq.'PX') pnpx%m=ii
c            if (Outd_var_S(ii,F_set).eq.'HU') pnhu%t=ii
c            if (Outd_var_S(ii,F_set).eq.'TW') pntw%t=ii
c            if (Outd_var_S(ii,F_set).eq.'QC') pnqc%t=ii
c            if (Outd_var_S(ii,F_set).eq.'WW') pnww%t=ii
c            if (Outd_var_S(ii,F_set).eq.'WE') pnwe%t=ii
c            if (Outd_var_S(ii,F_set).eq.'ZZ') pnzz%t=ii
c            if (Outd_var_S(ii,F_set).eq.'TH') pnth%t=ii
c         enddo
c      endif

      if (F_levtyp_S.eq.'P')then
         do ii=1,Outd_var_max(F_set)
            if (Outd_var_S(ii,F_set).eq.'GZ') pngz%p=ii
            if (Outd_var_S(ii,F_set).eq.'VT') pnvt%p=ii
            if (Outd_var_S(ii,F_set).eq.'TT') pntt%p=ii
            if (Outd_var_S(ii,F_set).eq.'ES') pnes%p=ii
c            if (Outd_var_S(ii,F_set).eq.'TD') pntd%p=ii
c            if (Outd_var_S(ii,F_set).eq.'HR') pnhr%p=ii
c            if (Outd_var_S(ii,F_set).eq.'HU') pnhu%p=ii
c            if (Outd_var_S(ii,F_set).eq.'TW') pntw%p=ii
c            if (Outd_var_S(ii,F_set).eq.'QC') pnqc%p=ii
c            if (Outd_var_S(ii,F_set).eq.'WW') pnww%p=ii
c            if (Outd_var_S(ii,F_set).eq.'WE') pnwe%p=ii
c            if (Outd_var_S(ii,F_set).eq.'ZZ') pnzz%p=ii
c            if (Outd_var_S(ii,F_set).eq.'TH') pnth%p=ii
         enddo
      endif

      if (pnpt.ne.0.and.Grd_rcoef.ne.1.0) pnpt=0

      psum=pnpn+pnpt+pnp0+pnla+pnlo+pnme+pnmx

      psum=psum + 
     $     pngz%t+pnvt%t+pntt%t+pnes%t+pntd%t+pnhr%t+pnpx%t+pnhu%t+
     $     pntw%t+pnqc%t+pnww%t+pnwe%t+pnzz%t+pnth%t

      psum=psum + 
     $     pngz%m+pnvt%m+pntt%m+pnes%m+pntd%m+pnhr%m+pnpx%m+pnhu%m+
     $     pntw%m+pnqc%m+pnww%m+pnwe%m+pnzz%m+pnth%m

      psum=psum + 
     $     pngz%p+pnvt%p+pntt%p+pnes%p+pntd%p+pnhr%p+pnpx%p+pnhu%p+
     $     pntw%p+pnqc%p+pnww%p+pnwe%p+pnzz%p+pnth%p


      if (psum.eq.0)return

      call out_padbuf(F_tt1,l_minx,l_maxx,l_miny,l_maxy,F_nk+1)

      call out_padbuf(F_fiptx,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)
      call out_padbuf(F_hut1,l_minx,l_maxx,l_miny,l_maxy,F_nk+1)
      call out_padbuf(F_qh,l_minx,l_maxx,l_miny,l_maxy,F_nk+1) 
      call out_padbuf(F_wlao,l_minx,l_maxx,l_miny,l_maxy,1) 
      if(.not.Schm_hydro_L)then
         call out_padbuf(F_wt1,l_minx,l_maxx,l_miny,l_maxy,F_nk+1)
      endif
*_______________________________________________________________________
*
*     Compute Virtual temperature
      if (.not.V4dgconf_L .or. (V4dgconf_L.and.V4dg_di_L)) then
*        With water loading
         call mfottvh (w3,F_tt1,F_hut1,F_qh,F_ninj,F_nk+1,F_ninj)
         do k=1,l_nk+1
            do i=1,F_ninj
               vt (i,k) = F_tt1(i,k) + w3(i,k) * F_qh(i,k)
               hu (i,k) = F_hut1(i,k)
            enddo
         enddo
      else
*        Without water loading
         do k=1,l_nk+1
            do i=1,F_ninj
               vt (i,k) = F_tt1(i,k)
               hu (i,k) = F_hut1(i,k)
            enddo
         enddo
      endif

*     Bring virtual temperature from top/surface to special levels
*     and add diagnostic temperature (2 m) at G_nk+2
*     Keep dynamic temperature at top
      if(Schm_phyms_L)then
         do i=1,F_ninj
            vt(i,G_nk+1)=F_tdia(i,2)
            vt(i,G_nk+2)=F_tdia(i,3)
            hu(i,G_nk+2)=F_hdia(i)
         enddo
      else
         do i=1,F_ninj
            vt(i,G_nk+2)=F_tt1(i,G_nk+1)
            hu(i,G_nk+2)=F_hut1(i,G_nk+1)
         enddo
      endif
         
      call out_padbuf(vt,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)
      call out_padbuf(hu,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)

*     Compute or store Geopotential Height (GZ)

      do k=1,l_nk
      do i=1,F_ninj
         gz (i,k) = F_fiptx(i,k)+Ver_fistr_8%m(k)
         gz_ta(i,G_nk+2)=F_topo(i)
      enddo
      enddo

      if ( Out3_vt2gz_L ) then
*          Compute hydrostatic GZ from P0 and VT
           call p0vt2gz_hyb (gz_ta,pia_ta,pib_ta,F_st1,
     $                          vt,F_ninj,G_nk+2,.true.,.false.)
      endif

*_________________________________________________________________
*
*     2.0    Output 2D variables 
*_________________________________________________________________
*
      if (pnme.ne.0)then
            call ecris_fst2(F_topo,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $        'ME  ',prmult_pnme,0.0,-1,1,1, 1, nbit(pnme) )
         endif
      if (pnmx.ne.0)then
            call ecris_fst2(F_topo,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $        'MX  ',1.0,0.0,-1,1,1, 1, nbit(pnmx) )
         endif
      if (pnpt.ne.0)
     $    call ecris_fst2(F_ptop,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $        'PT  ',.01,0.0,-1,1, 1, 1, nbit(pnpt) )
      if (pnla.ne.0)
     $    call ecris_fst2(Geomn_latrx,1,l_ni,1,l_nj,0.0,
     $        'LA  ',1.0,0.0,-1,1, 1, 1, nbit(pnla) )
      if (pnlo.ne.0)
     $    call ecris_fst2(Geomn_lonrx,1,l_ni,1,l_nj,0.0,
     $        'LO  ',1.0,0.0,-1,1, 1, 1, nbit(pnlo) )

*_______________________________________________________________________
*
*     3.0    Precomputations for output over pressure levels or PN or 
*            GZ on thermo levels
*
*        The underground extrapolation can use precalculated
*        temperatures over fictitious underground geopotential levels.
*        The number of fictitious levels is "Out3_nundr".
*        The levels in meters are stored in "Out3_zund(Out3_nundr)".
*        Both "Out3_nundr" and "Out3_zund" are user's given 
*        parameters.
*_______________________________________________________________________
*
      if ( ((Out3_nundr.gt.0).and.(F_levtyp_S.eq.'P'.or.pnpn.ne.0))
     $     .or.
     $     (pngz%t.ne.0) ) then

         if (.not.Out3_vt2gz_L) then
c            call gem_stop('out_thm : a faire GZ',-2)
c           Compute GZ on thermo levels in gz_ta
            do i= 1, F_ninj
               do k=1,l_nk
                  gz_m_plus(i,k)=gz(i,k)
               enddo
               gz_m_plus(i,l_nk+1)=F_topo(i)
               gz_m_plus(i,0)=.5*(F_fiptx(i,1)+F_fiptx(i,0))+
     $              Ver_fistr_8%t(1)
               gz_ta(i,l_nk+2)=F_topo(i)
            enddo
            call vertint3(gz_ta,gz_m_plus,F_posit,F_huv,F_ninj,G_nk+1,G_nk+2)
         endif

      endif

      if ( Out3_nundr.gt.0 .and. (F_levtyp_S.eq.'P'.or.pnpn.ne.0) ) then
         
       do 200 kl=1,Out3_nundr

         do 150 i=1,F_ninj

*        Store fictitious height level in htx

         htx(i,kl) = Out3_zund(kl) * Dcst_grav_8

*        Determine if fictitious level is above or below ground

         w1(i) = F_topo(i) - htx(i,kl)

         if ( w1(i) .gt. 0 ) then

*           fictitious level is under ground:
*           temperature is obtained by linear EXTrapolation
*           identify under ground grid point
* 
            if ( abs( F_wlao(i)*180./Dcst_pi_8 ) .ge. 49. ) then

                w1(i) = F_tt1(i,l_nk+1) +       .0005 * w1(i)
            else
                w1(i) = F_tt1(i,l_nk+1) + Dcst_stlo_8 * w1(i)
            endif

            w2(i) = 1.0

        else

*           fictitious level is above ground:
*           temperature is obtained by linear INTerpolation
*           identify above ground grid point

            do k=l_nk+2,-1
               w1(i) = gz_ta (i,k) - htx(i,kl)
               if ( w1(i) .gt. 0. ) goto 10
            enddo

 10         continue
            
            if(k.ge.l_nk+1)then
c              Temperature is constant between Special level and the surface.
               w1(i) = F_tt1 (i,l_nk)
            else
               w2(i)= - ( F_tt1 (i,k) - F_tt1 (i,k+1) ) /
     %              ( gz_ta (i,k) - gz_ta (i,k+1) )
               
               w1(i) = F_tt1 (i,k) + w2(i) * w1(i)
            endif
            
            w2(i) = 0.0

         endif

 150     continue

         call glbcolc (wk1,G_ni,G_nj,w1,l_minx,l_maxx,l_miny,l_maxy,1)
         call glbcolc (wk2,G_ni,G_nj,w2,l_minx,l_maxx,l_miny,l_maxy,1)

*        For all under ground grid points at level htx(i,kl)
*        recompute temperature by HORIZONTAL interpolation
*
         if (Ptopo_myproc.eq.0) 
     $        call liebman_2 (wk1,wk2,wk3,wk4,0.1,G_ni,G_nj)

         call glbdist (wk1,G_ni,G_nj,w1,l_minx,l_maxx,l_miny,l_maxy,
     $                         1,G_halox,G_haloy)

         do i=1,F_ninj
            ttx(i,kl) = w1(i)
         enddo

*        At this point:
*        temperature field is stored in ttx for future use
*        fictitious levels  are stored in htx for future use

 200   continue

      endif

      call out_padbuf(ttx,l_minx,l_maxx,l_miny,l_maxy,Out3_nundr) 
      call out_padbuf(htx,l_minx,l_maxx,l_miny,l_maxy,Out3_nundr) 

*     Calculate PN
      if (pnpn.ne.0) then
          call vslog(w2,F_p0,F_ninj)
          call pnm2(w1,F_tt1(1,F_nk+1),F_topo,w2,F_wlao,
     $         ttx,htx,Out3_nundr,l_minx,l_maxx,l_miny,l_maxy,1)
          if (filt(pnpn).gt.0)
     $      call filter(w1,filt(pnpn),coef(pnpn),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, 1)
          call ecris_fst2(w1,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $        'PN  ',.01,0.0,-1,1, 1, 1, nbit(pnpn) )
      endif

*     Calculate P0
      if (pnp0.ne.0) then

         if(.not.V4dgconf_L .or. (V4dgconf_L .and. V4dg_di_L)) then
             do i= 1, F_ninj
                w1(i) = F_p0(i)
             enddo

          elseif(V4dgconf_L .and. V4dg_tl_L) then
             print*,'Ajuster code pour sattgering'
             call gem_stop('out_thm',-2)
             do i= 1, F_ninj
                w1(i) =  Ver_z_8%t(F_nk+1) * exp(F_st1m(i)) * F_st1(i)
             enddo

          elseif(V4dgconf_L .and. V4dg_ad_L) then
             print*,'Ajuster code pour sattgering'
             call gem_stop('out_thm',-3)
             do i= 1, F_ninj
                w1(i) = F_st1(i)/(Ver_z_8%t(F_nk+1) * exp(F_st1m(i)))
             enddo
          endif

          if (filt(pnp0).gt.0)
     $       call filter(w1,filt(pnp0),coef(pnp0),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, 1)
          call ecris_fst2(w1,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $        'P0  ',.01,0.0,-1,1, 1, 1, nbit(pnp0) )

      endif

      if (pnww%t.ne.0.or.pnww%m.ne.0.or.pnww%p.ne.0)then
         call calomeg_adv (omega,F_st1,F_piup,LDIST_DIM,F_nk,.true.)
         do i= 1, F_ninj
            omega(i,F_nk+2)=omega(i,F_nk+1)
         enddo         
c         call calomeg(omega,F_psdt1,F_ut1,F_vt1,F_csh, 
c     $        l_minx,l_maxx,l_miny,l_maxy,G_nk,1,l_ni,1,l_nj)
      endif

      if (pnth%t.ne.0.or.pnth%p.ne.0) then
         call gem_stop('out_thm : tt() non dispo ici?',-1)
         do k= 1,F_nk+1
            do i= 1, F_ninj
               th(i,k)= tt(i,k)*(theta_p0/exp(F_wlnph_ta(i,k)))**Dcst_cappa_8
            enddo
         enddo
            do i= 1, F_ninj
               th(i,F_nk+2)= F_tdia(i,3)*(theta_p0/exp(F_wlnph_m(i,F_nk+1)))**Dcst_cappa_8
            enddo
      endif

      if (F_levtyp_S .eq. 'M'.or.F_levtyp_S .eq. 'T') then

*_______________________________________________________________________
*
*     4.0   Output 3-D Derived Variables on ETA levels
*_______________________________________________________________________
         
         if (pnwe%t.ne.0)then
            do k= 1,F_nk
            do i= 1, F_ninj
                  t8(i,k) = F_psdt1(i,k)
            enddo
            enddo
c           Put nk value at special level
            do i= 1, F_ninj
               t8(i,F_nk+1) = F_psdt1(i,F_nk)
               t8(i,F_nk+2) = F_psdt1(i,F_nk+1)
            enddo
            call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $           'WE  ',prmult_pnwe,0.0,Out_kind,F_nk+2, F_indo, F_nko, nbit(pnwe%t) )
         endif
         if (pngz%m.ne.0)then
            call ecris_fst2(gz,l_minx,l_maxx,l_miny,l_maxy,ind_m,
     $        'GZ  ',prmult_pngz,0.0,Out_kind,F_nk, F_indo_m, F_nko_m, nbit(pngz%m) )
         endif
         if (pngz%t.ne.0)then
            if (pngz%t.ne.0)then
               call ecris_fst2(gz_ta,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $           'GZ  ',prmult_pngz,0.0,Out_kind,F_nk+2, F_indo, F_nko, nbit(pngz%t))
            endif
         endif
         if (pnvt%t.ne.0)then
            call ecris_fst2(vt,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $           'VT  ',1.0,pradd_pnvt,Out_kind,F_nk+2, F_indo, F_nko, nbit(pnvt%t) )
         endif
         if (pnth%t.ne.0) then
            if(Schm_phyms_L)then
               call gem_stop('out_thm TH : ajuster pour niveaux quart',-6)
               call ecris_fst2(th,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $              'TH  ',1.0,0.0,Out_kind,F_nk+1,F_indo,F_nko,nbit(pnvt%t) )             
            else
               call ecris_fst2(th,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $              'TH  ',1.0,0.0,Out_kind,F_nk+1,F_indo,F_nko,nbit(pnvt%t) )               
            endif
         endif
         if (pnhu%t.ne.0) then
            if (Out3_cliph_L) then
                do k= 1,F_nk+2
                 do i= 1, F_ninj
                    t8(i,k) = amax1( hu(i,k), 0. )
                 enddo
                enddo
                call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $        'HU  ',1.0,      0.0,  Out_kind,F_nk+2, F_indo, F_nko, nbit(pnhu%t) )
            else
                call ecris_fst2(hu,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $        'HU  ',1.0,      0.0,  Out_kind,F_nk+2, F_indo, F_nko, nbit(pnhu%t) )
            endif
         endif

         if ( .not.(Lctl_step .eq. 0) .and. Schm_phyms_L
     $                 .and.  pnqc%t.ne.0  ) then
             call gem_stop('out_thm QC : ajuster pour niveaux quart',-8)
*            QC output for timestep 0 is done after physics have executed
             if (Out3_cliph_L) then
                do k= 1,F_nk+1
                 do i= 1, F_ninj
                    t8(i,k) = amax1( F_qct1(i,k), 0. )
                 enddo
                enddo
                call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $        'QC  ',1.0,      0.0,  Out_kind,F_nk+1, F_indo, F_nko, nbit(pnqc%t) )
             else
                call ecris_fst2(F_qct1,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $        'QC  ',1.0,      0.0,  Out_kind,F_nk+1, F_indo, F_nko, nbit(pnqc%t) )
             endif
         endif

         if ( pntt%t.ne.0 .or. pntd%t.ne.0 .or. pnhr%t.ne.0 ) then

*        Calculate TT (in tt)

           if (.not.V4dgconf_L .or. (V4dgconf_L .and. V4dg_di_L)) then
              
               call mfottv (tt,vt,hu, F_ninj,F_nk+2,F_ninj)               

           elseif (V4dgconf_L.and.V4dg_tl_L) then

              call gem_stop('out_thm : ajuster pour staggering',-1)

              call out_padbuf(F_vtm, l_minx,l_maxx,l_miny,l_maxy,F_nk+1)
              call out_padbuf(F_hum1,l_minx,l_maxx,l_miny,l_maxy,F_nk+1)
              call mfottv_tl (tt,vt,F_hut1,F_vtm,F_hum1,F_ninj,F_nk+2,F_ninj)

           elseif (V4dgconf_L.and.V4dg_ad_L) then
*
              call gem_stop('out_thm : ajuster pour staggering',-1)

              call v4d_zerohalo (vt,    l_ni,l_nj,LDIST_DIM, F_nk+2)
              call v4d_zerohalo (F_hum1,l_ni,l_nj,LDIST_DIM, F_nk+1)
*
              do k=  1, F_nk+2
              do i=1,F_ninj
                 tt(i,k) = dble(vt(i,k)) * 
     $                     (1.d0 + Dcst_delta_8*dble(hu(i,k)))
              enddo
              enddo
           endif

         endif

         if (pntt%t.ne.0)then            
            call ecris_fst2(tt,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $           'TT  ',1.0,pradd_pntt, Out_kind,F_nk+2, F_indo, F_nko, nbit(pntt%t) )
         endif
         if (pnes%t.ne.0.or.pnpx%t.ne.0.or.pntw%t.ne.0.or.pntd%t.ne.0.or.pnhr%t.ne.0)then
*        Calculate PX (in px), thermo levels.
            call vsexp(px_ta,F_wlnph_ta,F_ninj*(F_nk+2))
            call out_padbuf(px_ta,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)
         endif
         if (pnpx%m.ne.0)then
*        Calculate PX (in px), momentum levels.
            call vsexp(px_m,F_wlnph_m,F_ninj*F_nk)
            call out_padbuf(px_m,l_minx,l_maxx,l_miny,l_maxy,F_nk)
         endif
                     
         if (pnpx%t.ne.0)then
            call ecris_fst2(px_ta,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $           'PX  ',prmult_pnpx,0.0, Out_kind,F_nk+2, F_indo, F_nko, nbit(pnpx%t) )
         endif

         if (pnpx%m.ne.0)
     $       call ecris_fst2(px_m,l_minx,l_maxx,l_miny,l_maxy,ind_m,
     $        'PX  ',prmult_pnpx,0.0, Out_kind,F_nk, F_indo, F_nko_m, nbit(pnpx%m) )

         if (pntw%t.ne.0) then
            call gem_stop('out_thm TW : ajuster pour niveaux quart',-10)
*        Calculate THETAW TW (t8=TW) (px=PX)
             call mthtaw2 (t8,F_hut1,vt, px_ta,px_ta,3, .false., .false.,
     $                     .true.,Dcst_trpl_8,F_ninj,F_nk+2,F_ninj)
             call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $        'TW  ',1.0,0.0, Out_kind,F_nk+1, F_indo, F_nko, nbit(pntw%t) )
         endif

         if (pnes%t.ne.0 .or. pntd%t.ne.0) then
*        Calculate ES (t8=ES) (px=PX)
             call mhuaes(t8,hu,vt,px_ta,px_ta,3, .false., .false.,
     $                      F_ninj,F_nk+2,F_ninj)

             if (Out3_cliph_L) then
                do k= 1,F_nk+2
                 do i= 1, F_ninj
                    t8(i,k) = amin1( t8(i,k), 30.)
                    t8(i,k) = amax1( t8(i,k), 0. )
                 enddo
                enddo
             endif

             if (pnes%t.ne.0)
     $       call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $        'ES  ',1.0,0.0, Out_kind,F_nk+2, F_indo, F_nko, nbit(pnes%t) )

             if (pntd%t.ne.0) then
*            Calculate TD (tt=TT,t8=old ES, t8=TD=TT-ES)
                 do k= 1,F_nk+2
                 do i= 1, F_ninj
                    t8(i,k) = tt(i,k) - t8(i,k)
                 enddo
                 enddo
                 call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $           'TD  ',1.0,pradd_pntd,Out_kind,F_nk+2,F_indo,F_nko,nbit(pntd%t) )
             endif

         endif

         if (pnhr%t.ne.0) then
            call gem_stop('out_thm HR : ajuster pour niveaux quart',-13)
*        Calculate HR (t8=HR,tt=TT,px=PX)
             call mfohra(t8,F_hut1,tt,
     $                   px_ta,px_ta,3,F_ninj,F_nk+1,F_ninj)
             if ( Out3_cliph_L ) then
                do k= 1,F_nk+1
                  do i= 1, F_ninj
                     t8(i,k)=amin1( t8(i,k), 1.0 )
                     t8(i,k)=amax1( t8(i,k), 0.  )
                  enddo
                enddo
             endif
             call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $           'HR  ',1.0,0.0, Out_kind,F_nk, F_indo, F_nko, nbit(pnhr%t) )
         endif
         if (pnww%t.ne.0) then
             call ecris_fst2(omega,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $           'WW  ',1.0,0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnww%t) )
         endif
         if (pnzz%m.ne.0.or.pnzz%t.ne.0) then
            if(Schm_hydro_L)then
               call calzz  (t8, F_fiptx, F_zz1,
     $              l_minx,l_maxx,l_miny,l_maxy, G_nk)
            else
               do k= 1,F_nk+1
                  do i= 1, F_ninj
                     t8(i,k)=F_wt1(i,k)
                  enddo
               enddo
            endif
c           Put nk value at special level like WE
            do i= 1, F_ninj
               t8(i,F_nk+2) = t8(i,F_nk+1)
               t8(i,F_nk+1) = t8(i,F_nk)
            enddo            
            if (pnzz%t.ne.0)then
               call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $              'ZZ  ',1.0,0.0, Out_kind,F_nk+2, F_indo, F_nko, nbit(pnzz%t) )
            endif
            if (pnzz%m.ne.0)then
               call gem_stop('out_thm ZZ : interpoler',-14)
               do i= 1, F_ninj
                  do k=1,l_nk
                     w4(i,k)=t8(i,k)
                  enddo
*                 Velocity is zero at surface                  
                  w4(i,l_nk+1)=0.0
*                 Velocity is constant in layer near the top. 
*                 (It could be computed with fip at different step)
                  w4(i,0)=t8(i,1)
               enddo
*              Interpolation on the thermo level and on special levels
               call vertint3(t8,w4,F_posit,F_huv,F_ninj,G_nk+1,G_nk+2)
               do i= 1, F_ninj
*                 Force velocity to zero at surface
                  t8(i,l_nk+1)=0.0
               enddo
               call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,ind_ta,
     $              'ZZ  ',1.0,0.0, Out_kind,F_nk+1, F_indo, F_nko, nbit(pnzz%t) )


            endif

         endif
      else
*_______________________________________________________________________
*
*     5.0    Output 3-D Derived Variables on PRESSURE levels
*_______________________________________________________________________
*
        do i = 1, F_nko
           prprlvl(i) = F_rf(i) * 100.0
        enddo

*       Calculate vertical derivative of HUT1 with respect to F_wlnph_ta

        call verder(px_ta, F_hut1, F_wlnph_ta, 2.0,  2.0,l_minx,l_maxx,l_miny,l_maxy,
     $                                       F_nk+1, 1,l_ni,1,l_nj)

*       Calculate HU (hu_pres=HU,px_ta=vert.der)
        call prgen(hu_pres,hu,px_ta,F_wlnph_ta,prprlvl,F_nko, 
     $                      Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy,F_nk+2)
        if ( Out3_cliph_L ) then
           do k= 1, F_nko
              do i= 1, F_ninj
                 hu_pres(i,k) = amax1( hu_pres(i,k), 0. )
              enddo
           enddo
        endif

*       Calculate GZ,VT (w5=GZ_pres, vt_pres=VT_pres)

        call flush(6)
        call prgzvta( w5, vt_pres, prprlvl, F_nko,
     %                gz_ta, vt, F_wlnph_ta, F_wlao,
     %                ttx, htx, Out3_nundr,Out3_cubzt_L, 
     %                Out3_linbot, l_minx,l_maxx,l_miny,l_maxy,F_nk+1)
        call flush(6)

        call out_padbuf(vt_pres,l_minx,l_maxx,l_miny,l_maxy,F_nko)
        call out_padbuf(hu_pres,l_minx,l_maxx,l_miny,l_maxy,F_nko)

        if (pngz%p.ne.0) then
            if (filt(pngz%p).gt.0)then
               call filter(w5,filt(pngz%p),coef(pngz%p),'G', .false.,
     $              l_minx,l_maxx,l_miny,l_maxy, F_nko)
            endif
            call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $        'GZ  ',prmult_pngz,0.0, Out_kind,F_nko,F_indo,F_nko,nbit(pngz%p) )
        endif

        if (pntt%p.ne.0.or.pntd%p.ne.0.or.pnhr%p.ne.0) then

*           Calculate TT (tt_pres=TT,vt_pres=VT,hu_pres=HU)
            call mfottv(tt_pres,vt_pres,hu_pres, F_ninj,F_nko,F_ninj)
            call out_padbuf(tt_pres,l_minx,l_maxx,l_miny,l_maxy,F_nko)
        endif

        if ( pnes%p.ne.0.or.pntw%p.ne.0.or.pntd%p.ne.0.or.pnhr%p.ne.0) then
*           Calculate PX for ES,TD,HR
            do k=1,F_nko
               do i= 1, F_ninj
                  px_pres(i,k) = prprlvl(k)
               enddo
            enddo
            call out_padbuf(px_pres,l_minx,l_maxx,l_miny,l_maxy,F_nko)
        endif

        if (pntw%p.ne.0) then
*           Calculate THETAW TW (w5=TW_pres) (px_pres=PX)
            call mthtaw2 (w5,hu_pres,vt_pres,
     $                     px_pres,px_pres,3,.false.,.false.,
     $                     .true.,Dcst_trpl_8,F_ninj,F_nko,F_ninj)
            if (filt(pntw%p).gt.0)
     $          call filter(w5,filt(pntw%p),coef(pntw%p),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
            call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $          'TW  ',1.0,0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pntw%p) )
        endif
*
        if (pnes%p.ne.0.or.pntd%p.ne.0) then
*           Calculate ES (w5=ES_pres,hu_pres=HU,w2=VT,px_pres=PX)
            call mhuaes (w5, hu_pres, vt_pres,
     $                    px_pres,px_pres,3,.false.,.false.,
     $                    F_ninj, F_nko, F_ninj)
            if ( Out3_cliph_L ) then
               do k=1,F_nko
                 do i= 1, F_ninj
                    w5(i,k) = amin1( w5(i,k), 30.)
                    w5(i,k) = amax1( w5(i,k), 0. )
                 enddo
               enddo
            endif

            if (pntd%p.ne.0) then
*           Calculate TD (tt_pres=TT,w5=ES, TD=TT-ES)
              do k=1,F_nko
                 do i= 1, F_ninj
                    td_pres(i,k) = tt_pres(i,k) - w5(i,k)
                 enddo
              enddo
              call filter(td_pres,filt(pntd%p),coef(pntd%p),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
              call ecris_fst2(td_pres,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $          'TD  ',1.0,pradd_pntd, Out_kind,F_nko,F_indo,F_nko,nbit(pntd%p) )
            endif

            if (pnes%p.ne.0) then
                if (filt(pnes%p).gt.0)
     $              call filter(w5,filt(pnes%p),coef(pnes%p),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
                call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $             'ES  ',1.0,0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnes%p) )
            endif
        endif

        if (pnhr%p.ne.0) then
*           Calculate HR (w5=HR_pres:hu_pres=HU,tt_pres=TT,px_pres=PX)
            call mfohra (w5,hu_pres,tt_pres,px_pres, 
     $                    px_pres,3,F_ninj,F_nko,F_ninj)
            if ( Out3_cliph_L ) then
               do k=1,F_nko
                  do i= 1, F_ninj
                     w5(i,k) = amin1( w5(i,k), 1.0 )
                     w5(i,k) = amax1( w5(i,k), 0.  )
                  enddo
               enddo
            endif
            if (filt(pnhr%p).gt.0)
     $          call filter(w5,filt(pnhr%p),coef(pnhr%p),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
            call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $          'HR  ',1.0,0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnhr%p) )
        endif

        if (pnvt%p.ne.0) then
            if (filt(pnvt%p).gt.0)
     $          call filter(vt_pres,filt(pnvt%p),coef(pnvt%p),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
            call ecris_fst2(vt_pres,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $        'VT  ',1.0,pradd_pnvt, Out_kind,F_nko,F_indo, F_nko, nbit(pnvt%p) )
        endif

         if (pnth%p.ne.0) then
          call verder(px_ta, th, F_wlnph_ta, 2.0, 2.0, l_minx,l_maxx,l_miny,l_maxy,
     $                                       F_nk+1, 1,l_ni,1,l_nj)
          call prgen( th_pres, th, px_ta, F_wlnph_ta, prprlvl,F_nko,
     $                      Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy, F_nk+1)
            call ecris_fst2(th_pres,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $        'TH  ',1.0,      0.0,  Out_kind,F_nk, F_indo, F_nko, nbit(pnth%p) )
         endif

        if (pnhu%p.ne.0) then
            if (filt(pnhu%p).gt.0)
     $          call filter(hu_pres,filt(pnhu%p),coef(pnhu%p),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
            call ecris_fst2(hu_pres,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $        'HU  ',1.0,       0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnhu%p) )
        endif

        if (pntt%p.ne.0) then
            if (filt(pntt%p).gt.0)
     $          call filter(tt_pres,filt(pntt%p),coef(pntt%p),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
            call ecris_fst2(tt_pres,l_minx,l_maxx,l_miny,l_maxy,F_rf, 
     $        'TT  ',1.0,pradd_pntt, Out_kind,F_nko, F_indo, F_nko, nbit(pntt%p) )
        endif

        if ( .not.(Lctl_step .eq. 0) .and. Schm_phyms_L
     $                 .and.  pnqc%p.ne.0  ) then
*         QC output for timestep 0 is done after physics have executed
          call verder(px_ta, F_qct1, F_wlnph_ta, 2.0,2.0,l_minx,l_maxx,l_miny,l_maxy,
     $                                        F_nk+1,1,l_ni,1,l_nj)
*         Calculate QC (qc_pres=w5,px=vert.der)
          call prgen( w5, F_qct1, px_ta, F_wlnph_ta, prprlvl,F_nko, 
     $                      Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy, F_nk+1)
          if ( Out3_cliph_L ) then
               do k= 1, F_nko
               do i= 1, F_ninj
                 w5(i,k) = amax1( w5(i,k), 0. )
               enddo
               enddo
          endif
          if (filt(pnqc%p).gt.0)
     $      call filter(w5,filt(pnqc%p),coef(pnqc%p),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
             call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $        'QC  ',1.0,       0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnqc%p) )
        endif

        if (pnww%p.ne.0) then
            print*,'Ajuster code pour sattgering wlnph_?'
            call gem_stop('out_thm WW',-20)
            call verder (w3,omega,F_wlnph_ta,2.0,2.0,l_minx,l_maxx,l_miny,l_maxy,
     $                 G_nk, 1,l_ni,1,l_nj)
            call prgen( w5,omega, w3, F_wlnph_ta, prprlvl,F_nko, 
     $                      Out3_cubww_L,l_minx,l_maxx,l_miny,l_maxy, F_nk)
            if (filt(pnww%p).gt.0)
     $          call filter(w5,filt(pnww%p),coef(pnww%p),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, F_nko)
             call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,F_rf,
     $           'WW  ',1.0,0.0, Out_kind,F_nko, F_indo, F_nko, nbit(pnww%p) )
        endif


      endif

      return
      end
