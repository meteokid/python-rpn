***s/r ip1_param - to return A,B values given a liste of keys with sorted ip1
*
      integer function ip1_param(iun,ip1key,ip1,ip1_max,nlev,hyb_8,
     $                           presvar_8,presvar_S, presvar_max,
     $                           a_8,b_8,vcode_S,vcode,hybnorm_L)
*
      implicit none
*
      integer iun,ip1_max,nlev,presvar_max,vcode
      integer ip1(ip1_max),ip1key(ip1_max)
      real*8 presvar_8(presvar_max)
      real*8  hyb_8(ip1_max),hybm_8(ip1_max),a_8(ip1_max),b_8(ip1_max)
      character*6 presvar_S(presvar_max)
      logical hybnorm_L
      character*8 vcode_S

* ________________________________________________________________
*  Name        I/O      Description
* ----------------------------------------------------------------
* iun           I       unit number to input file
* ip1key        I/O     array of keys with different ip1
* ip1           O       ip1 list returned
* ip1_max       I       number of keys in ip1key given
* a_8           O       list of A coefficients for each level
* b_8           O       list of B coefficients for each level
* hybnorm_L     I       hyb_8 coded in ip1 is normalized or not?
* hyb_8         O       array of user-defined hybrid levels (0.0 to 1.0)
*                       corresponding to ip1 list returned
* nlev          O       number of levels (different ip1s found, sorted)
* vcode         O       code number for type of vertical coordinate
*                        0=pressure
*                        1=SIGMA 
*                        2=ETASEF (eta for spectral)
*                        3=SIGPT  (eta, rcoef=1.0)
*                        4=HYBLG  (hybrid Laprise/Girard)
*                        5=ECMWF  (ecmwf levels)
*                        6=HYBSTAG(staggered hybrid Girard)
* vcode_S       O       name of vertical coordinate found
* presvar_max   I       number of elements to return in presvar_8
* presvar_S     O       names of each presvar_8 variable
* presvar_8     O       array of values stored for the following variables:
*                       presvar_8(1)= pref (reference pressure in mb)
*                       presvar_8(2)= ptop  (mb)
*                       presvar_8(3)= etatop_8 (mb)
*                       presvar_8(4)= rcoef (coefficient btwn 1.0 to 2.0)
*                       presvar_8(5)= rcoef (coefficient btwn 1.0 to 2.0)
* ----------------------------------------------------------------
* the function will return 0 upon success, -1 if there is an error
**

      integer   fstinf, fstprm, fstlir, fstluk, fnom,
     $          read_decode_hyb,read_decode_bang
      external  fstinf, fstprm, fstlir, fstluk, fnom,
     $          read_decode_hyb,read_decode_bang
      integer  ni,nj,nk,ni1,nj1,nk1,i,j,k,n,m,ip1x,ip2x,ip3x
      integer  e1_key,hy_key,pt_key,p0_key,sf_key,xx_key,lookup_max
      integer  datev, dateo, deet, ipas, ip1a, ip2a, ip3a, 
     $         ig1a, ig2a, ig3a, ig4a, bit, datyp,
     $         swa, lng, dlf, ubc, ex1, ex2, ex3, kind, ip1mode
      real     rcoef(2),lev,ptop,pref,pr1
      real*8   x1_8,etatop_8,eta1_8,ptop_8,pref_8,pr1_8,rcoef_8(2)
      integer  prescode
      character*1   tva, grda, blk_S
      character*4   var
      character*12  etik_S

      integer,dimension(:), allocatable :: lookup_ip1
      real,   dimension(:,:),allocatable:: work
      real*8, dimension(:), allocatable :: lookup_a_8,lookup_b_8
      real*8, dimension(:,:),allocatable:: work_8

      ip1_param=0
      prescode=0
      rcoef(1)=0.0
      rcoef(2)=0.0
      pref=0.0
      ptop=0.0
      etatop_8=0.0d0
      ptop_8=0.0d0
      pref_8=0.0d0
      rcoef_8(1)=0.0d0
      rcoef_8(2)=0.0d0

      do k=1,ip1_max
         ip1_param = fstprm ( ip1key(k), dateo, deet, ipas, ni, nj, nk, 
     $     bit, datyp, ip1a,ip2a,ip3a, tva, var, etik_S, grda, 
     $     ig1a,ig2a,ig3a,ig4a, swa,lng, dlf, ubc, ex1, ex2, ex3 )
         if (ip1_param.lt.0) then
             print *,'ip1_param error: fstprm on key',ip1key(k)
             return
         endif
         call convip (ip1a, lev, kind,-1, blk_S, .false.)
         ip1(k)=ip1a
         hyb_8(k)=lev
      enddo
      call incdat(datev,dateo,ipas*deet/3600)

*     Sort levels in ascending order
      if (ip1_max.gt.1) then
         n = ip1_max
         do i = 1, n-1
            k = i
            do j = i+1, n
               if (hyb_8(k) .gt. hyb_8(j))  k=j
            enddo
            if (k .ne. i) then
               x1_8     = hyb_8(k)
               m      = ip1(k)
               hyb_8(k) = hyb_8(i)
               ip1(k)  = ip1(i)
               hyb_8(i) = x1_8
               ip1(i)  = m
            endif
         enddo
*   AND  Eliminate levels that are redundant in LISTE
         i = 1
         do j=2,n
            if (hyb_8(i) .ne. hyb_8(j)) then
                i = i+1
                if (i .ne. j) then
                    hyb_8(i) = hyb_8(j)
                     ip1(i) =  ip1(j)
                endif
            endif
         enddo
         nlev = i
      else
         nlev = 1 
      endif

      hy_key=fstinf (iun,ni,nj,nk,datev,etik_S,-1,  -1,  -1,' ','HY')
      pt_key=fstinf (iun,ni,nj,nk,datev,etik_S,-1,  -1,  -1,' ','PT')
      e1_key=fstinf (iun,ni,nj,nk,datev,etik_S,-1,  -1,  -1,' ','E1')
      if (kind.eq.1) then
          rcoef_8(1) = 1.0
          rcoef_8(2) = 1.0
          pref_8  = 800.0
          p0_key=fstinf (iun,ni,nj,nk,datev,etik_S,-1,ip2a,ip3a,' ','P0')
          if (p0_key.lt.0) then
                 print *,'ip1_param error: No p0 found, kind = 1'
                 ip1_param = -1
                 return
          endif
          if (hy_key.ge.0) then
              vcode_S='HYBLG'
              vcode = 4
              ip1_param=read_decode_hyb (iun,'HY',  -1,  -1,etik_S,
     $                                           datev,ptop,pref,rcoef(1))
              if (ip1_param.lt.0) then
                  print *,'ip1_param error: in read_decode_hyb'
                  return
              endif
              ptop_8=ptop
              pref_8=pref
              rcoef_8(1) = rcoef(1)
              rcoef_8(2) = rcoef(2)
          else if (pt_key.ge.0) then
               allocate (work(ni,nj))
               ip1_param = fstluk(work,pt_key,ni,nj,nk)
               if (ip1_param.lt.0) then
                   print *,'ip1_param error: in fstluk PT'
                   return
               endif
               ptop = work(1,1)
               ptop_8 = work(1,1)
               deallocate (work)
               if (e1_key.ge.0) then
                   allocate (work(ni,nj))
                   ip1_param = fstluk(work,e1_key,ni,nj,nk)
                   if (ip1_param.lt.0) then
                       print *,'ip1_param error: in fstluk E1'
                       return
                   endif
                   etatop_8 = work(1,1)
                   deallocate (work)
                   vcode_S='ETASEF'
                   vcode = 2
                   eta1_8=1.0d0 / (1.0d0 - etatop_8)
                   do i=1,nlev
                      b_8(i) = (hyb_8(i) - etatop_8)*eta1_8 
                      a_8(i) = ptop_8* (1.0d0 - b_8(i))
                   enddo
               else
                vcode_S='SIGPT' !pure ETA
                vcode = 3
               endif
          else 
               vcode_S='SIGMA'
               vcode = 1
               do i=1,nlev
                  a_8(i) = 0.0d0
                  b_8(i) = hyb_8(i) 
               enddo
          endif
      endif

      if (kind.eq.2) then
         vcode_S='PRESS'
         vcode = 0
         do i=1,nlev
            a_8(i) = hyb_8(i)
            b_8(i) = 0.0
         enddo
      endif
      if (kind.eq.5) then
         rcoef(1) = 1.0
         rcoef(2) = 1.0
         pref_8  = 800.0
         ptop_8=0.0
         xx_key=fstinf (iun,ni, nj, nk, datev,etik_S,ig1a,ig2a,-1 ,' ','!!  ')
         sf_key=fstinf (iun,ni1,nj1,nk1,datev,etik_S,-1,ip2a,ip3a,' ','!!SF')
         if (xx_key.ge.0.and.sf_key.ge.0) then
             lookup_max=nj 
             allocate (lookup_a_8(lookup_max))
             allocate (lookup_b_8(lookup_max))
             allocate (lookup_ip1(lookup_max))
             ip1_param = read_decode_bang (iun,ig1a,ig2a,datev,etik_S,
     $                   lookup_ip1,lookup_max,lookup_a_8,lookup_b_8,
     $                   prescode,presvar_8,presvar_S,presvar_max)
             if (ip1_param.lt.0) then
                 print *,'ip1_param error: in fstprm !!'
                 return
             endif
             vcode = prescode
             vcode_S='HYBSTAG'
             do i=1,nlev
             do j=1,lookup_max
                if (ip1(i).eq.lookup_ip1(j)) then
                    a_8(i)=lookup_a_8(j)
                    b_8(i)=lookup_b_8(j)
                endif
             enddo
             enddo
             pref_8=presvar_8(1)
             ptop_8=presvar_8(2)
             rcoef_8(1)=presvar_8(4)
             rcoef_8(2)=presvar_8(5)
             deallocate (lookup_a_8,lookup_b_8,lookup_ip1)
         else if (hy_key.ge.0) then
              p0_key=fstinf (iun,ni,nj,nk,datev,etik_S,-1,ip2a,ip3a,' ','P0')
              if (p0_key.lt.0) then
                 print *,'ip1_param error: HY found,No p0 found, kind = 5'
                 ip1_param = -1
                 return
              endif
              vcode_S='HYBLG'
              vcode = 4
              ip1_param=read_decode_hyb (iun,'HY',  -1,  -1,etik_S,
     $                                           datev,ptop,pref,rcoef(1))
              if (ip1_param.lt.0) then
                  print *,'ip1_param error: in read_decode_hyb'
                  return
              endif
              ptop_8=ptop
              pref_8=pref
              rcoef_8(1) = rcoef(1)
              rcoef_8(2) = rcoef(2)
         else
             print *,'ip1_param error: kind=5 but !! or !!sf  or HY NOT FOUND'
             ip1_param = -1
             return
         endif
      endif
      if ( vcode.eq.3.or.vcode.eq.4 ) then
           if (hyb_8(1).eq.0.0) then
               do i=1,nlev
                  hybm_8(i) = hyb_8(i) + (1.0d0 - hyb_8(i))*ptop_8/pref_8
               enddo
           else
               do i=1,nlev
                  hybm_8(i) = hyb_8(i)
               enddo
           endif
           pref_8 = 100.0d0 *ptop_8/hybm_8(1)
           pr1_8 = 1.0d0/(1.0d0 - hybm_8(1))
           do i=1,nlev
              b_8(i) = ( (hybm_8(i) - hybm_8(1)) * pr1_8)**rcoef_8(1)
              a_8(i) = pref_8 * (hybm_8(i) - b_8(i) )
           enddo
      endif
      presvar_8(1)=pref_8
      presvar_8(2)=ptop_8
      presvar_8(3)=etatop_8
      presvar_8(4)=rcoef_8(1)
      presvar_8(5)=rcoef_8(2)
      presvar_S(1)='pref'
      presvar_S(2)='ptop'
      presvar_S(3)='etatop'
      presvar_S(4)='rcoef1'
      presvar_S(5)='rcoef2'
      ip1_param = 0
      return
      end
