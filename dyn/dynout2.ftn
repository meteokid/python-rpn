***s/r dynout2 - perform dynamic output
*
#include <model_macros_f.h>
*
      subroutine dynout2 ()
*
*implicits
      use v4d_prof, only: Pr_nsim4d
*
#include "impnone.cdk"
*
*
*author 
*     J. Caveen - rpn - decembre 1994
*
*revision
* v2_00 - Lee V.            - initial MPI version (from dynout v1_03)
* v2_10 - Desgagne M.       - adapted from dynout; 4D-var controls,
* v2_10                       output file name convention to suite 
* v2_10                       assimilation cycle
* v2_11 - Desgagne M.       - ptop reproducibility
* v2_20 - Lee V.            - eliminate call to BLOCGEO (physics 3.66)
* v2_21 - J. P. Toviessi    - set diez (#) slab output,rename model varnames
* v2_30 - Lee V.            - setup ip2,ip3 here, grid output is assumed on
* v2_30                       PHI (scalar) unless specified elsewhere (BLOCUV),
* v2_30                       add control of filename extension here
* v2_31 - Lee V.            - introduce a call to bloctr
* v2_32 - Lee V.            - add "HY" record in dynamic slabs
* v3_01 - Tanguay M.        - Temporary patch for pressure levels when TLM,ADJ
* v3_02 - Lee V.            - delay closure of slab files at time 0 if 
* v3_02                       Schm_phyms_L in case QC is to be outputted later.
* v3_02 - Tanguay M.        - IP3 depend on # iterations when 4dvar_L
*
*object
*     Subroutine to control the production of
*     the output of the dynamic variables
*
*arguments
*  NONE
*
*implicits
#include "glb_ld.cdk"
#include "dimout.cdk"
#include "rstr.cdk"
#include "init.cdk"
#include "lun.cdk"
#include "cstv.cdk"
#include "lctl.cdk"
#include "vt1.cdk"
#include "p_geof.cdk"
#include "out2.cdk"
#include "geomg.cdk"
#include "schm.cdk"
#include "geomn.cdk"
#include "slab.cdk"
#include "dslab.cdk"
#include "v4dg.cdk"
*
**
      integer doout, fstouv, fstfrm, fnom, longueur,
     $        vmmlod, vmmuld, vmmget, vmmulk, getvndx
      external doout, fstouv, fstfrm, fnom, longueur,
     $         vmmlod, vmmuld, vmmget, vmmulk, getvndx
*
      integer err,nrec,dostep(MAXSET), dostep_max, step, key,
     $        i,j,k,pnindex
      real deg2rad
**
*
*     check if output is required and initialize control tables
*     ---------------------------------------------------------------
*
      dostep_max = doout(dostep,1)
      deg2rad    = acos( -1.0)/180.
*
      if ((dostep_max .gt. 0) .and. (V4dg_output_L)) then

         if (Lun_out.gt.0) write(Lun_out,7001) Lctl_step
         Dslab_fhand_p = -1
         Dslab_fhand_e = -1
         Dslab_slab_p = 0
         Dslab_slab_e = 0
      else
*
         if (Lun_out.gt.0) write(Lun_out,7002) Lctl_step
         return
*     
      endif
*
      call hpalloc (Out2_wlnph_ , LDIST_SIZ*G_nk, err,1)
      call hpalloc (Out2_ptop_  , LDIST_SIZ     , err,1)
      call hpalloc (Out2_wlao_  , LDIST_SIZ     , err,1)
*
*     obtain output grid
*     NOTE: all derived variables are output on the same grid
*           we may then only check the grid required for TT
*           for instance
*
      key = VMM_KEY(pipt1)
      err = vmmlod (key,1)
      err = VMM_GET_VAR(pipt1)
*
      if (V4dg_conf.eq.0.or.(V4dg_conf.ne.0.and.V4dg_di_L)) then
*
      do k=1,l_nk
      do j=1,l_nj
      do i=1,l_ni
         Out2_wlnph (i,j,k) = log ( geomg_z_8(k) + pipt1(i,j,k) )
      enddo
      enddo
      enddo
*
      else
*     <<<<<<<<<<<<<<<<<< CAUTION >>>>>>>>>>>>>>>>>>>>>>>>>>
*     Temporary patch for pressure levels when TLM,ADJ.
*     Correct evaluation should use TRAJECTORY when TLM,ADJ 
*     on pressure levels will be activated.
*     <<<<<<<<<<<<<<<<<< CAUTION >>>>>>>>>>>>>>>>>>>>>>>>>>
      do k=1,l_nk
      do j=1,l_nj
      do i=1,l_ni
         Out2_wlnph (i,j,k) = log ( geomg_z_8(k) )
      enddo
      enddo
      enddo
      endif
*
      do j=1,l_nj
      do i=1,l_ni
         Out2_ptop (i,j) = geomg_z_8(1) + pipt1(i,j,1)
         Out2_wlao (i,j) = Geomn_latrx(i,j) * deg2rad 
      end do
      end do
*
      err = vmmuld(key,1)
*
*     setup of ip2 and ip3
*
      Slab_ip2 = nint(float(Lctl_step)*Cstv_dt_8/3600.0)
      Slab_ip3 = 0
      if (V4dg_conf.ne.0) then
          if (.not.V4dg_4dvar_L) then
              Slab_ip3 = V4dg_status  
              if (V4dg_conf/100.eq.1.and.V4dg_ad_L)
     %        Slab_ip3 = 20 + V4dg_status
          else
              Slab_ip3 = V4dg_status  
              if(V4dg_tl_L) Slab_ip3 = 1000 + Pr_nsim4d
              if(V4dg_ad_L) Slab_ip3 = 2000 + Pr_nsim4d
          endif
      endif

*
*     setup of filename extension if needed
      Dslab_ext_S=""
      if ( ((Init_balgm_L).and.(.not.Rstri_idon_L)).and.
     $     ((Lctl_step.ge.(Init_dfnp-1)/2)) )
     $     Dslab_ext_S = '_dgf'
*
*     output of 3-D tracers
*
      call bloctr(dostep,dostep_max)
*
*     output of temperature, humidity and mass fields
*
      call blocthm(dostep,dostep_max)
*
*     output of winds
*
      call blocuv(dostep,dostep_max)
*
*     output of divergence and vorticity
*
      call blocdq(dostep,dostep_max)
*
*     output of omega
*
      call blomega(dostep,dostep_max)
*
*     output of all the other model variables not treated so far
*
      call blocavm(dostep,dostep_max)
*
      if ( Init_balgm_L .and. .not.Rstri_idon_L ) then
         call blocava(dostep,dostep_max)
      endif
*
*     Delay closure of files, de-allocation, wlog write out if...
      if ( .not. (Lctl_step .eq. 0 .and. Schm_phyms_L).or.V4dg_conf.ne.0) then
*
      call frmslabfhand(Dslab_fhand_p,Dslab_slab_p,.false.)
      call frmslabfhand(Dslab_fhand_e,Dslab_slab_e,.true.)
*
      call hpdeallc(Out2_wlnph_, err, 0)  
      call hpdeallc(Out2_wlao_ , err, 0) 
      call hpdeallc(Out2_ptop_ , err, 0) 
*
         if((Init_balgm_L) .and. (.not. Rstri_idon_L) ) then
             call wlog('IOUT')
         else
             call wlog('FOUT')
         endif
      endif
*
 7001 format(/,' DYNOUT - WRITING DYNAMIC SLABS FOR STEP (',I8,')')
 7002 format(/,' DYNOUT - NO DYNAMIC OUTPUT FOR STEP (',I8,')')
*
      return
      end

