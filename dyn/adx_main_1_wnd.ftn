! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r adx_main_1_wnd - process winds in preparation for advection
*
#include "model_macros_f.h"
*
      subroutine adx_main_1_wnd ( F_u, F_v, F_w, F_nit, F_njt, F_nk )
*
      implicit none
*
      integer F_nit, F_njt, F_nk
*
      real F_u(F_nit,F_njt,F_nk),
     %     F_v(F_nit,F_njt,F_nk),
     %     F_w(F_nit,F_njt,F_nk+1)
*
*author
*     alain patoine
*
*revision
* v2_31 - Desgagne M.       - removed stkmemw
* v3_00 - Desgagne & Lee    - Lam configuration
* v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
* v3_21 - Desgagne M.       - Revision OpenMP
*
*language
*     fortran 77
*
*object
*     see id section
*
*arguments
*______________________________________________________________________
*              |                                                 |     |
* NAME         | DESCRIPTION                                     | I/O |
*--------------|-------------------------------------------------|-----|
* F_u          | u components of winds on advection grid         |  o  |
* F_v          | v components of winds on advection grid         |  o  |
* F_w          | w components of winds on advection grid         |  o  |
*              |                                                 |     |
* F_nit        | \ total number of points in x,y direction in    |  i  |
* F_njt        | / advection grid (including halos)              |  i  |
*              |                                                 |     |
* F_nk         | number of levels                                |  i  |
*______________|_________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "type.cdk"
#include "adx.cdk"
#include "lun.cdk"
#include "inuvl.cdk"
#include "vthh.cdk"
*
*modules
      integer  vmmlod, vmmget, vmmuld
      external vmmlod, vmmget, vmmuld
************************************************************************
      integer pnerr, pnlkey1(30), pnlod
*
      integer i, j, k, i0, in, j0, jn, n, dest_ni
      real*8 ONE,sc
      parameter( ONE = 1.0 )
************************************************************************
      
      if (Lun_debug_L) write (Lun_out,1000)
      pnlkey1(1)  = VMM_KEY(uthh)
      pnlkey1(2)  = VMM_KEY(vthh)
      pnlkey1(3)  = VMM_KEY(zdthh)
*
      pnerr = vmmlod(pnlkey1,3)
*
      pnerr = VMM_GET_VAR(uthh)
      pnerr = VMM_GET_VAR(vthh)
      pnerr = VMM_GET_VAR(zdthh)
c     if (Acid_test_L)
c    %call glbstat (uthh,'Uthh',LDIST_DIM,G_nk,1+acid_i0,G_ni-acid_in-1,
c    %                                       1+acid_j0,G_nj-acid_jn,1,G_nk)
***********************************************************************
* Interpolate advection winds to geopotential grid
* F_u and F_v are used as work space
***********************************************************************
      call rpn_comm_xch_halo (uthh,LDIST_DIM,l_niu,l_nj, F_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
      call rpn_comm_xch_halo (vthh,LDIST_DIM,l_ni,l_njv,F_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
*
!$omp parallel private(i0,in,j0,jn,sc)
!$omp do
      do k=1,F_nk
*
         i0 = 1
         in = l_niu
         j0 = 1
         jn = l_nj
         if (G_lam) then
             if (l_west) i0 = 3
             if (l_east) in = l_niu - 1
         endif
         do j = j0, jn
         do i = i0, in
            F_u(i,j,k) = inuvl_wxux3_8(i,1) * uthh(i-2,j,k)
     %                 + inuvl_wxux3_8(i,2) * uthh(i-1,j,k)
     %                 + inuvl_wxux3_8(i,3) * uthh(i  ,j,k)
     %                 + inuvl_wxux3_8(i,4) * uthh(i+1,j,k)
         enddo
         enddo
*
         i0 = 1
         in = l_ni
         jn = l_njv
         if (l_south) j0 = 3
         if (l_north) jn = l_njv - 1
         do j = j0, jn
         do i = i0, in
            F_v(i,j,k) = inuvl_wyvy3_8(j,1) * vthh(i,j-2,k)
     %                 + inuvl_wyvy3_8(j,2) * vthh(i,j-1,k)
     %                 + inuvl_wyvy3_8(j,3) * vthh(i,j  ,k)
     %                 + inuvl_wyvy3_8(j,4) * vthh(i,j+1,k)
         enddo
         enddo
         if (.not.G_lam) then
         if (l_south) then
            do i = i0, in
            F_v(i,j0-2,k) = inuvl_wyvy3_8(j0-2,3) * vthh(i,j0-2,k)
     %                    + inuvl_wyvy3_8(j0-2,4) * vthh(i,j0-1,k)
            F_v(i,j0-1,k) = inuvl_wyvy3_8(j0-1,2) * vthh(i,j0-2,k)
     %                    + inuvl_wyvy3_8(j0-1,3) * vthh(i,j0-1,k)
     %                    + inuvl_wyvy3_8(j0-1,4) * vthh(i,j0,k  )
            enddo
         endif
         if (l_north) then
            do i = i0, in
            F_v(i,jn+2,k) = inuvl_wyvy3_8(jn+2,1) * vthh(i,jn  ,k)
     %                    + inuvl_wyvy3_8(jn+2,2) * vthh(i,jn+1,k)
            F_v(i,jn+1,k) = inuvl_wyvy3_8(jn+1,1) * vthh(i,jn-1,k)
     %                    + inuvl_wyvy3_8(jn+1,2) * vthh(i,jn  ,k)
     %                    + inuvl_wyvy3_8(jn+1,3) * vthh(i,jn+1,k)
            enddo
         endif
         endif
      enddo
!$omp enddo
***********************************************************************
* Image to component
***********************************************************************
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
             if (l_south) j0 = 3
             if (l_north) jn = l_njv - 1
      endif
!$omp do
      do k = 1,F_nk
      do j = j0,jn
*
      sc = ONE/adx_cy_8(j)
*
      do i = i0,in
*
      vthh(i,j,k) = sc * F_v(i,j,k)
*
      enddo
      enddo
      enddo
!$omp enddo
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
             if (l_west) i0 = 3
             if (l_east) in = l_niu - 1
      endif
!$omp do 
      do k = 1,F_nk
      do j = j0,jn
*
      sc = ONE/adx_cy_8(j)
*
      do i = i0,in
*
      uthh(i,j,k) = sc * F_u(i,j,k)
*
      enddo
      enddo
      enddo
!$omp enddo

***********************************************************************
* Adjust wind fields to advection grid
***********************************************************************
      if (G_lam) then
          n=0
          dest_ni=l_ni
      else
          n=999
          dest_ni=G_ni
      endif
*
c     if (Acid_test_L)
c     call glbstat (uthh,'Uthh',LDIST_DIM,G_nk,3+acid_i0,G_ni-acid_in-2,
c    %                                       1+acid_j0,G_nj-acid_jn,1,G_nk)
!$omp single
      call rpn_comm_xch_halox ( uthh, LDIST_DIM, l_ni, l_nj, F_nk, 
     %  adx_halox, adx_haloy, G_periodx, G_periody, F_u, 1-adx_halox, 
     %  adx_nic+adx_halox, 1-adx_haloy, adx_njc+adx_haloy, dest_ni, n)
*
      call rpn_comm_xch_halox ( vthh, LDIST_DIM, l_ni, l_nj, F_nk, 
     %  adx_halox, adx_haloy, G_periodx, G_periody, F_v, 1-adx_halox, 
     %  adx_nic+adx_halox, 1-adx_haloy, adx_njc+adx_haloy, dest_ni, n)
*
      call rpn_comm_xch_halox ( zdthh, LDIST_DIM, l_ni, l_nj, F_nk+1, 
     %  adx_halox, adx_haloy, G_periodx, G_periody, F_w, 1-adx_halox, 
     %  adx_nic+adx_halox, 1-adx_haloy, adx_njc+adx_haloy, dest_ni, n)
!$omp end single

*
      if (.not.G_lam) then
*
         if ( l_south ) then
*
            call adx_polw (F_u,F_v,adx_cx_8,adx_sx_8,adx_wx_8,
     %        adx_sy_8,0,adx_nic,adx_halox,adx_njc,adx_haloy,F_nk)
            call adx_pols (F_w,adx_wx_8,0,adx_nic,adx_halox,adx_njc,
     %        adx_haloy,F_nk+1)
         endif
*
         if ( l_north ) then
*
            call adx_polw (F_u,F_v,adx_cx_8,adx_sx_8,adx_wx_8,
     %        adx_sy_8,adx_njc+1,adx_nic,adx_halox,adx_njc,adx_haloy,F_nk)
            call adx_pols (F_w,adx_wx_8,adx_njc+1,adx_nic,adx_halox,
     %        adx_njc,adx_haloy,F_nk+1)
         endif

      endif
!$omp end parallel
*
 1000  format(3X,'PREPARE HORIZONTAL WINDS: (S/R ADX_MAIN_1_WND)')
      return
      end
