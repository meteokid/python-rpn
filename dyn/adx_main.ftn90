!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "stop_mpi.h"
#include "msg.h"

subroutine adx_main8()
   implicit none
   !---------------------------------------------------------------------
   call stop_mpi(STOP_ERROR,'adx_main8','called a stub')
   !---------------------------------------------------------------------
   return
end subroutine adx_main8


!/**
subroutine adx_main7(F_su, F_sv, F_sw, &
     F_fields_list, F_fields_type_L, F_nfields, &
     F_minx,F_maxx,F_miny,F_maxy,F_nks, F_nb_iter, F_doAdwStat_L)
   implicit none
   !@objective Perform advection
   !@arguments
   logical :: F_doAdwStat_L   !I, will compute stats if .true.
   integer :: F_nb_iter       !I, total number of iterations for trajectories
   integer :: F_minx,F_maxx,F_miny,F_maxy !I, bounds of model's wind arrays
   integer :: F_nks           !I, nb levels - super-set of m+l levels
   integer :: F_nfields       !I, nb of fields to advect
   logical, dimension(2, F_nfields) :: &
        F_fields_type_L       !I, fields type
   character(len=8),dimension(2, F_nfields) :: &
        F_fields_list         !I, list of gmm labels of fields to advect
   real, dimension(F_minx:F_maxx,F_miny:F_maxy, F_nks) :: &
        F_su, F_sv, F_sw      !I, real destag winds, super-set (mom+thermo)
   !@author  alain patoine
   !@revisions
   ! v3_00 - Desgagne & Lee    - Lam configuration
   ! v3_01 - Lee V.            - Initialize Lam truncated trajectory counters
   ! v3_20 - Tanguay M.        - Option of storing instead of redoing TRAJ 
   ! v4_04 - Tanguay M.        - Staggered version TL/AD 
   ! V4_10 - Plante A.         - Thermo upstream positions
   !@description
   !  adx_main_2_pos: Calculate upstream positions at th and t1
   !  adx_main_3_int: Interpolation of rhs
!**/
#include "gmm.hf"
#include "adx_gmm.cdk"
#include "adx_dims.cdk"
#include "adx_nml.cdk"
   include "v4dg.inc"

   logical, parameter :: IS_MOM_LEVEL = .true.
   logical, parameter :: POLE0_L = .false.
   logical, parameter :: EXTEND_L = .false.

   logical :: save_stats_L
   type(gmm_metadata) :: my_meta,my_meta_t,my_meta2
   integer :: i,istat,i0,in,j0,jn
   real, dimension(adx_mlni,adx_mlnj,adx_lnkm) :: &
        pxm,pym,pzm
   real, dimension(adx_mlni,adx_mlnj,adx_lnkt) :: &
        pxt,pyt,pzt,l_xct1, l_yct1, l_zct1
   real, dimension(adx_lminx:adx_lmaxx,adx_lminy:adx_lmaxy,F_nks) :: &
        a_su,a_sv,a_sw
   real :: dummy

   real, pointer, dimension(:) :: &
        xth, yth, zth, xcth, ycth, zcth, &
        xth_t, yth_t, zth_t, &
        xcth_t, ycth_t, zcth_t, &
        xct1, yct1, zct1
   !
   logical v4dstore_L

#define IS_SAME_BOUNDS(M1,M2) (M1%l(1)%low == M2%l(1)%low .and. M1%l(1)%high == M2%l(1)%high .and. M1%l(2)%low == M2%l(2)%low .and. M1%l(2)%high == M2%l(2)%high)
   !---------------------------------------------------------------------
   call msg(MSG_DEBUG,'adx_main')

   v4dstore_L = V4dg_conf.ne.0 .and. V4dg_oktr_L
   save_stats_L = adw_stats_L
   adw_stats_L = (F_doAdwStat_L .and. adw_stats_L)

   call adx_model2adx_grid_uv2(a_su,a_sv, F_su,F_sv, adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy,F_minx,F_maxx,F_miny,F_maxy, F_nks)
   call adx_model2adx_grid_scalar2(a_sw, F_sw, adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy,F_minx,F_maxx,F_miny,F_maxy, F_nks, POLE0_L, EXTEND_L)

   istat = GMM_OK
   istat = min(gmm_get(adx_xth_s,xth,my_meta),istat)
   istat = min(gmm_get(adx_yth_s,yth,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_zth_s,zth,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 

   istat = min(gmm_get(adx_xcth_s,xcth,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_ycth_s,ycth,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_zcth_s,zcth,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 

   istat = min(gmm_get(adx_xct1_s,xct1,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_yct1_s,yct1,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_zct1_s,zct1,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 

   istat = min(gmm_get(adx_xth_t_s,xth_t,my_meta_t),istat)
   istat = min(gmm_get(adx_yth_t_s,yth_t,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta_t,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_zth_t_s,zth_t,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta_t,my_meta2))) istat = -1 

   istat = min(gmm_get(adx_xcth_t_s,xcth_t,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta_t,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_ycth_t_s,ycth_t,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta_t,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_zcth_t_s,zcth_t,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta_t,my_meta2))) istat = -1 

   !TODO: check my_meta and my_meta_t compared to adx_mlnijk

   call handle_error(istat,'adx_main','gmm_get')

   call adx_main_2_pos3( &
        F_nb_iter, 'm', &
        pxm,  pym,  pzm , &
        a_su, a_sv, a_sw, &
        xth , yth , zth , &
        xcth, ycth, zcth, &
        xct1, yct1, zct1, &
        adx_lminx, adx_lmaxx, adx_lminy, adx_lmaxy, &
        adx_mlni, adx_mlnj, adx_lnkm, F_nks)

   call adx_main_2_pos3( &
        F_nb_iter, 't', &
        pxt,    pyt,    pzt, &
        a_su,   a_sv,   a_sw, &
        xth_t,  yth_t,  zth_t, &
        xcth_t, ycth_t, zcth_t, &
        l_xct1, l_yct1, l_zct1, &
        adx_lminx, adx_lmaxx, adx_lminy, adx_lmaxy, &
        adx_mlni, adx_mlnj, adx_lnkt,F_nks)

   call adx_main_2_pos_postfix2(pxt,pyt,pxm,pym,&
        adx_mlni,adx_mlnj,adx_lnkm,adx_lnkt)


   if (adw_stats_L) then
      call adx_get_ij0n(i0,in,j0,jn)
      call adx_main_2_pos_stats( &
           'm', &
           a_su  ,a_sv  ,a_sw  , &
           pxm,  pym,  pzm , &
           xth , yth , zth , &
           xcth, ycth, zcth, &
           xct1, yct1, zct1, &
           adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy,F_nks,&
           adx_mlni, adx_mlnj, adx_lnkm,adx_lnkm,i0,in,j0,jn)

      call adx_main_2_pos_stats(  &
           't', &
           a_su  ,a_sv  ,a_sw  , &
           pxt,    pyt,    pzt, &
           xth_t,  yth_t,  zth_t, &
           xcth_t, ycth_t, zcth_t, &
           l_xct1, l_yct1, l_zct1, &
           adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy,F_nks,&
           adx_mlni, adx_mlnj, adx_lnkm,adx_lnkt,i0,in,j0,jn)
   endif

!  Store TRAJ upstream positions
!  -----------------------------
   if ( v4dstore_L ) call v4d_rwtraj (5,pxm,pym,pzm,pxt,pyt,pzt,adx_mlni,adx_mlnj,adx_lnkm,adx_lnkt)
!
!  Store TRAJ RHS before interpolation
!  -----------------------------------
   if ( v4dstore_L ) call v4d_rwtraj (11)

   call adx_main_3_intlag6(pxm, pym, pzm, &
        F_fields_list, F_fields_type_L, F_nfields, &
        IS_MOM_LEVEL, F_doAdwStat_L, adx_mlni,adx_mlnj,adx_lnkm)
   call adx_main_3_intlag6(pxt, pyt, pzt, &
        F_fields_list, F_fields_type_L, F_nfields, &
        .not.IS_MOM_LEVEL, F_doAdwStat_L, adx_mlni,adx_mlnj,adx_lnkt)

!  Store TRAJ RHS interpolated
!  ---------------------------
   if ( v4dstore_L ) call v4d_rwtraj (6)

   adw_stats_L = save_stats_L
   call msg(MSG_DEBUG,'adx_main [end]')
   !---------------------------------------------------------------------
   return
end subroutine adx_main7

