! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r readdyn - read the dynamics fields from entrance programs
*
#include "model_macros_f.h"
*
      subroutine readdyn
      implicit none
*
*author 
*     Michel Roch - rpn - jan 1994
*
*revision
* v2_00 - Desgagne M.      - initial MPI version (from readdyn v1_03)
* V2_20 - Desgagne M.      - longitudes, latitudes and topography now
* v2_20                      read from gem_osdyn
* v2_21 - Desgagne M.      - new calling sequence to glbdist and
* v2_21                      rpn_comm stooge for MPI
* v2_21 - Lee V.           - modifications for LAM version
* v2_30 - Corbeil L.       - Added BMF stuff instead of rdfld, added 
* v2_30                      vertical interpolation
* v2_31 - Edouard/Lee      - proper treatment of hybrid coordinate 
* v2_31 - Desgagne         - clean up and introduce tracers
* v2_31 - Lee V.           - enable case for no interpolation
* v2_32 - Lee V.           - hybrid coordinate derives from "HY" record
* v2_32                    - if same grid and levels but the topography is
* v2_32                      different, vertical interpolation will be done
* v2_32                    - input winds are always UU,VV
* v3_00 - Lee V.           - re-arranged sequence to match new LAM entry
* v3_01 - Corbeil L.       - introduce interface acqui
* v3_10 - Lee V.           - added deallocate topu_temp,topv_temp,gzu_temp...
* v3_11 - Gravel S.        - provide for variable topography
* v3_11 - Lee V.           - correct vertical interp on tracers from pres anal
* v3_12 - Winger K.        - convert TD to HU with pressure level analysis
* v3_20 - Pellerin P.      - to run in off-line mode
* v3_20 - Gravel S.        - allow for initialization with ECMWF analyses
* v3_21 - Dugas B.         - replace TD by ES in pressure mode
* v3_30 - McTaggart-Cowan R. - update implementation of variable orography
*
*object
*	
*arguments
*	none
*
*interfaces
      INTERFACE
         subroutine acqui
#include "acq_int.cdk"
         end subroutine acqui
      END INTERFACE
*
*implicits
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "lun.cdk"
#include "bmf.cdk"
#include "ptopo.cdk"
#include "cstv.cdk" 
#include "geomg.cdk"
#include "grd.cdk"
#include "pres.cdk" 
#include "lctl.cdk"
#include "schm.cdk"
#include "out3.cdk"
#include "ind.cdk"
#include "acq.cdk"
#include "vtopo.cdk"
#include "anal.cdk"
#include "type.cdk"
#include "ver.cdk"
*
*modules
      integer  bmf_gobe,bmf_get
      external bmf_gobe,bmf_get
*
      integer nvar,i,j,k,err, nk_anal,nk_anal_t,presstype
      real, pointer, dimension(:  ) :: lna,rna,sdd
      real, pointer, dimension(:,:) :: psu_temp,psv_temp,
     $        apsu_temp,apsv_temp,topu_temp,topv_temp
      real, pointer, dimension(:,:,:) ::  u_temp,v_temp,
     $        hu_temp,tt_temp,gz_temp, 
     $        ttu_temp,ttv_temp,gzu_temp,gzv_temp
      real, allocatable, dimension(:  ) :: hyba,vlapse,aaa,bbb
      real*8, allocatable, dimension(:  ) :: aaa_8,bbb_8,
     $                                       aaa_t_8,bbb_t_8,hyba_8
      real, allocatable, dimension(:,:) ::zcol,tcol,vlna,pres
      real, allocatable, dimension(:,:,:) ::  u_temp2,v_temp2,
     $     xlnp, dz, dt, work, lnp_t,srclev,dstlev
      real, dimension(l_ni,l_nj) :: pps, ps , topo_temp
      real dummy, conv,
     $     psmin, psmax, psmin_glob, psmax_glob
      integer errprdf,prdfsum
      logical NESD

      real fact

**
*     ---------------------------------------------------------------
*
      presstype=6
*
      if (Ptopo_myproc.eq.0) write(lun_out,9000) bmf_time1,bmf_time2
*
* Lecture des donnees
*
      nullify(lna,rna,sdd ,psu_temp,psv_temp,
     $        apsu_temp,apsv_temp,topu_temp,topv_temp, u_temp,v_temp,
     $        hu_temp,tt_temp,gz_temp, 
     $        ttu_temp,ttv_temp,gzu_temp,gzv_temp)
*
      call acqui ( lna, rna, sdd, psu_temp, psv_temp, apsu_temp,
     $             apsv_temp, topu_temp,topv_temp, u_temp,v_temp,
     $             hu_temp,tt_temp, gz_temp, ttu_temp, ttv_temp, 
     $             gzu_temp, gzv_temp,ps, topo_temp)
*
      if (schm_offline_L) Acql_vertint=.false.
*
      if (Ptopo_myproc.eq.0) then
         write(lun_out,*)
     $      ' Acql_horzint=',Acql_horzint,' Acql_vertint=',Acql_vertint,
     $      ' Acql_etaanl=',Acql_etaanl,' Vtopo_L=',Vtopo_L
         write(lun_out,*)
     $      ' Acql_siganl =',Acql_siganl ,' Acql_hybanl =',Acql_hybanl,
     $      ' Acql_prsanl=',Acql_prsanl, ' Acql_ecmanl=',Acql_ecmanl
         write(lun_out,*)
     $      ' Acql_staganl =',Acql_staganl
*
      if ((schm_offline_L).and.(Acqi_vterplv.eq.1)) then
         write(lun_out,*) '  '
         write(lun_out,*) 'MEC: ARCHIVED DATA FOR:',  bmf_time1, bmf_time2
         write(lun_out,*) 'MEC: ONLY 1 LEVEL FOUND INITIALLY FOR TT HU UU VV P0'
         write(lun_out,*) 'MEC: THIS LAST WILL BE USED DIRECTLY'
      endif
      endif
*
      allocate(work(l_ni,l_nj,max(Acqi_nktmp,G_nk+2)))
*--------------------------------------------------------------------
*     NOTE: Acqi_vertlv, nk_anal, nk_anal_t 
*     includes the surface level at 12000, for vert. interp 
*--------------------------------------------------------------------

      if(.not. Acql_vertint) then
*---------------------------------------------------------------------
*     INTERPOLATION IS NOT REQUIRED
*---------------------------------------------------------------------
                  
       if (.not.schm_offline_L) then
         nk_anal = Acqi_vterplv
         nk_anal_t = nk_anal+1
         allocate( aaa_t_8(nk_anal_t),bbb_t_8(nk_anal_t) )
         do k=1,nk_anal_t
            aaa_t_8(k) = 1.0
            bbb_t_8(k) = 1.0
         enddo
         do k=1,g_nk+2
         do j=1,l_nj
         do i=1,l_ni
            Ind_t (i,j,k) = tt_temp(i,j,k) 
            work  (i,j,k) = hu_temp(i,j,k)
         end do
         end do
         end do
         do j=1,l_nj
         do i=1,l_ni
            pps   (i,j) =  ps(i,j)
            Ind_s (i,j) =  log(ps(i,j)/Cstv_pisrf_8)
         end do
         end do
       else
         print*,'Please review for Offline staggering'
         call flush(6)
         call gem_stop('readdyn',-1)
         do k=1,g_nk+2
         do j=1,l_nj
         do i=1,l_ni
            Ind_t (i,j,k) = tt_temp(i,j,1)
            work  (i,j,k) = hu_temp(i,j,1)
         end do
         end do
         end do
        endif
*
      else if(Acql_siganl.or.Acql_etaanl.or.Acql_hybanl.or.Acql_ecmanl) then
*---------------------------------------------------------------------
*     INTERPOLATION REQUIRED
*     ANALYSIS IS ON EITHER SIGMA or ETA, HYBRID or ECMWF COORDINATES
*     nk_anal,nk_anal_t includes surface level at 12000
*---------------------------------------------------------------------
*
         nk_anal = Acqi_vterplv
         if (Acql_ecmanl) nk_anal = Acqi_vterplv + 1
         nk_anal_t=nk_anal
         if (Acql_staganl) nk_anal_t = nk_anal+1
         
         allocate( aaa_8(nk_anal),bbb_8(nk_anal),hyba_8(nk_anal) )
         allocate ( aaa(nk_anal), bbb(nk_anal),hyba(nk_anal) )
         allocate( aaa_t_8(nk_anal_t),bbb_t_8(nk_anal_t) )

         if (Acql_siganl) then
            do k=1,Acqi_vterplv
               aaa_8(k) = rna(k)
               bbb_8(k)= 0.
               hyba(k)= 0.
               hyba_8(k)= 0.
            enddo
         else if (Acql_ecmanl) then

            call ecmwf_ab( aaa, bbb, nk_anal )

         else 
*  HYBRID analysis
            if (rna(1).eq.0.0.or.Acql_staganl) then
                do k=1,Acqi_vterplv
                   hyba_8(k) = rna(k) + (1.-rna(k))*Acqr_ptopa/Acqr_prefa
                enddo
            else 
                do k=1,Acqi_vterplv
                   hyba_8(k) = rna(k)
                enddo
            endif
            do k=1,Acqi_vterplv
               hyba(k) = hyba_8(k)
            enddo
            if (Acql_staganl) then
* HYB STAG
                call genab_8 (Acqi_kcode,aaa_8,bbb_8,aaa_t_8,bbb_t_8,hyba_8,
     $           100.0d0*Acqr_ptopa,100.0d0*Acqr_prefa,Acqr_rcoefa,Acqi_vterplv)
            else
* HYB NON STAG
                call genab ( aaa, bbb, hyba, Acqr_ptopa, Acqr_rcoefa,
     $                                               Acqi_vterplv )
                do k=1,Acqi_vterplv
                   aaa_8(k) = aaa(k)
                   bbb_8(k) = bbb(k) 
                   aaa_t_8(k) = aaa(k) 
                   bbb_t_8(k) = bbb(k) 
                enddo
            endif
         endif
*     
*        Compute pressure on model surface PPS
*
         allocate(pres(Acqi_nbpts,nk_anal_t))
         call get_press3d(pres,ps,Acqi_nbpts,aaa_t_8,
     $                      bbb_t_8,nk_anal_t,Acqi_datasp(2))
         call adj_ss2topo(pps, topo_temp,pres,gz_temp(1,1,nk_anal_t),
     $                     tt_temp,Acqi_nbpts,nk_anal_t)
*        Interpolate VT

         allocate(dstlev(l_ni,l_nj,G_nk+2))
         allocate (srclev(l_ni,l_nj,nk_anal_t))

         call get_lnpress3d(srclev,ps,l_ni*l_nj,aaa_t_8,bbb_t_8,
     $                      Cstv_pisrf_8,nk_anal_t,Acqi_datasp(2))
         call get_lnpress3d(dstlev,pps,l_ni*l_nj,Ver_a_spcl_8%t,Ver_b_spcl_8%t,
     $                      Cstv_pisrf_8,G_nk+2,6)
 
         call vte_intvertx(work,tt_temp,srclev,dstlev,Acqi_nbpts,
     $                     nk_anal_t,G_nk+2,'VT')
*
         do k=1,g_nk+2
         do j=1,l_nj
         do i=1,l_ni
            Ind_t(i,j,k)  = work(i,j,k) 
         end do
         end do
         end do
*
         if ( Schm_moist_L ) then
            call vte_intvertx(work,hu_temp,srclev,dstlev,Acqi_nbpts,
     $              nk_anal_t,G_nk+2,'HU')
            do k=1,G_nk+2
            do j=1,l_nj
            do i=1,l_ni
               work(i,j,k) = amax1(work(i,j,k),0.0)
            enddo
            enddo
            enddo
         else
            do k= 1, G_nk+2
            do j= 1, l_nj 
            do i= 1, l_ni 
               work(i,j,k)  = 0.0
            end do
            end do
            end do
         endif
*
         do j=1,l_nj
         do i=1,l_ni
            Ind_s(i,j) = log(pps(i,j)/Cstv_pisrf_8)
         enddo
         enddo
*
         deallocate(pres)
         allocate(pres(Acqi_niu*Acqi_nju,nk_anal_t))
         call get_press3d(pres,apsu_temp,Acqi_niu*Acqi_nju,aaa_t_8,
     $                      bbb_t_8,nk_anal_t,Acqi_datasp(2))
         call adj_ss2topo(psu_temp, topu_temp,pres,gzu_temp(1,1,nk_anal_t),
     $                     ttu_temp,Acqi_niu*Acqi_nju,nk_anal_t)
         deallocate(pres)
         allocate(pres(Acqi_niv*Acqi_njv,nk_anal_t))
         call get_press3d(pres,apsv_temp,Acqi_niv*Acqi_njv,aaa_t_8,
     $                      bbb_t_8,nk_anal_t,Acqi_datasp(2))
         call adj_ss2topo(psv_temp, topv_temp,pres,gzv_temp(1,1,nk_anal_t),
     $                     ttv_temp,Acqi_niv*Acqi_njv,nk_anal_t)
*
         deallocate(srclev,dstlev)
         allocate ( u_temp2(Acqi_niu,Acqi_nju,Acqi_nktmp),
     $              srclev (Acqi_niu,Acqi_nju,nk_anal),
     $              dstlev (Acqi_niu,Acqi_nju,G_nk+1) )
*
         call get_lnpress3d(srclev,apsu_temp,Acqi_niu*Acqi_nju,aaa_8,bbb_8,
     $                      Cstv_pisrf_8,nk_anal,Acqi_datasp(2))
         call get_lnpress3d(dstlev,psu_temp,Acqi_niu*Acqi_nju,
     $              Ver_a_spcl_8%m(1),Ver_b_spcl_8%m(1), Cstv_pisrf_8,G_nk+1,6)

*
         call vte_intvertx(u_temp2,u_temp,srclev,dstlev,Acqi_niu*Acqi_nju,
     $              nk_anal,G_nk+1,'UU')

         deallocate (srclev,dstlev)
         allocate ( v_temp2(Acqi_niv,Acqi_njv,Acqi_nktmp),
     $              srclev (Acqi_niv,Acqi_njv,nk_anal),
     $              dstlev (Acqi_niv,Acqi_njv,G_nk+1) )
*
         call get_lnpress3d(srclev,apsv_temp,Acqi_niv*Acqi_njv,aaa_8,bbb_8,
     $                      Cstv_pisrf_8,nk_anal,Acqi_datasp(2))
         call get_lnpress3d(dstlev,psv_temp,Acqi_niv*Acqi_njv,
     $               Ver_a_spcl_8%m(1),Ver_b_spcl_8%m(1), Cstv_pisrf_8,G_nk+1,6)
         call vte_intvertx(v_temp2,v_temp,srclev,dstlev,Acqi_niv*Acqi_njv,
     $              nk_anal,G_nk+1,'VV')
*
         do k=1,g_nk+1
            do j=1,Acqi_nju
            do i=1,Acqi_niu
               u_temp(i,j,k) = u_temp2(i,j,k)
            enddo
            enddo
            do j=1,Acqi_njv
            do i=1,Acqi_niv
               v_temp(i,j,k) = v_temp2(i,j,k)
            enddo
            enddo
         enddo
*
         deallocate ( u_temp2,v_temp2,apsu_temp,ttu_temp,ttv_temp,
     $                              apsv_temp,hyba )
*
      else
*
*---------------------------------------------------------------------
*     INTERPOLATION REQUIRED
*     ANALYSIS IS ON PRESSURE COORDINATES
*---------------------------------------------------------------------
*
         print*,'Review for staggering'
         call flush(6)
         call gem_stop('readdyn',-2)

         allocate ( aaa(Acqi_vterplv),
     $    zcol(Acqi_nim*Acqi_njm,Acqi_nktmp),vlapse(Acqi_nim*Acqi_njm),
     $    tcol(Acqi_nim*Acqi_njm,Acqi_nktmp),xlnp(l_ni,l_nj,Acqi_nktmp),
     $    vlna(Acqi_nim*Acqi_njm,Acqi_nktmp),  dz(l_ni,l_nj,Acqi_nktmp),
     $                                         dt(l_ni,l_nj,Acqi_nktmp))
         do k=1,Acqi_vterplv
            aaa(k) = lna(k)
         enddo
*
*        Compute PS,GZ,VT,ZCOL
*
         call gz2p0 ( ps, gz_temp, topo_temp, zcol,tcol, sdd, lna, 
     $                                   Acqi_nbpts, Acqi_vterplv )
*
*        Compute geopotential (GZ) and temperature (VT)
*
         do i=1,Acqi_nbpts
            vlapse(i)= (tcol(i,Acqi_vterplv)-tcol(i,Acqi_vterplv-1))
     $                    *sdd(Acqi_vterplv-1)
         enddo
*
         conv = log(100.)
         do k=1,g_nk
         do j=1,l_nj
         do i=1,l_ni
c    TO BE REVIEWED
c           xlnp(i,j,k) =  log( Ver_a_8%d(k)
c    %                   + Ver_b_8%d(k) * exp( ps(i,j) )) - conv
         enddo
         enddo
         enddo
         do k=1,Acqi_vterplv
         do i=1,Acqi_nbpts
            vlna(i,k)=lna(k)                
         enddo
         enddo
*
         call vterp2 ( dz, dt, xlnp, zcol, tcol, vlna, Acqi_nbpts, 
     $                     Acqi_nbpts, Acqi_vterplv, g_nk, vlapse )
*
         do k=1,g_nk
            do j=1,l_nj
            do i=1,l_ni
               Ind_t (i,j,k) = -dt(i,j,k)/Dcst_rgasd_8
            enddo
            enddo
         enddo
*
         call gz2p0 ( psu_temp,gzu_temp,topu_temp,zcol,tcol,
     $                          sdd,lna,Acqi_niu*Acqi_nju,Acqi_vterplv )
         call gz2p0 ( psv_temp,gzv_temp,topv_temp,zcol,tcol,
     $                          sdd,lna,Acqi_niv*Acqi_njv,Acqi_vterplv )
         call vte_vrtical ( u_temp, psu_temp, Acqi_niu*Acqi_nju, g_nk, 
     $                                       lna, Acqi_vterplv, .true. )
         call vte_vrtical ( v_temp, psv_temp, Acqi_niv*Acqi_njv, g_nk, 
     $                                       lna, Acqi_vterplv, .true. )
*
         if ( Schm_moist_L ) then
            call vte_vrtical ( hu_temp, ps, Acqi_nbpts, g_nk+2, lna, 
     $                                        Acqi_vterplv,.false. )
            do k= 1, G_nk+2
            do j= 1, l_nj 
            do i= 1, l_ni 
               dz(i,j,k) = exp(xlnp(i,j,k))*100.
               dt(i,j,k) = Ind_t(i,j,k) 
            end do
            end do
            end do
*
*           convert ES to HU
            call mesahu (work,hu_temp,dt,dummy,dz,
     $                   3,.false.,Anal_cond_L,Acqi_nbpts,g_nk+1,
     $                   Acqi_nbpts)
         else
            do k= 1, G_nk+2
            do j= 1, l_nj 
            do i= 1, l_ni 
               work(i,j,k)  = 0.0
            end do
            end do
            end do
         endif
*
         do j=1,l_nj
         do i=1,l_ni
            Ind_s(i,j) = exp(ps(i,j))
         enddo
         enddo
*
         deallocate (zcol,tcol,xlnp,vlna,dz,dt,vlapse)
*
      endif
*
*---------------------------------------------------------------------
*     INTERPOLATION OF TRACERS
*---------------------------------------------------------------------
*
      NESD = .false.
      if (Lctl_step.gt.0) NESD = .true.
      call tr_init ( work,Acqi_datasp,bmf_time1,bmf_time2,Acqi_nktmp,
     $               pps,aaa_t_8,bbb_t_8,ps,nk_anal_t,l_ni,l_nj,NESD )
*
*
*---------------------------------------------------------------------
*     FINAL TREATMENT OF WINDS
*---------------------------------------------------------------------
      if (Acql_horzint) 
     $     call vte_uv2img (u_temp, v_temp, Acqi_niu, Acqi_nju,
     $            Acqi_niv, Acqi_njv, g_nk+1, geomg_y_8(1), geomg_yv_8(1))

*     Convert wind from KNOTS TO M/S
      if ((.not.schm_offline_L).or.(Acqi_vterplv.gt.1)) then
         do k=1,g_nk+1
         do j=1,Acqi_nju
         do i=1,Acqi_niu
            Ind_u(i,j,k) = u_temp(i,j,k)*dcst_knams_8
         enddo
         enddo
         do j=1,Acqi_njv
         do i=1,Acqi_niv
            Ind_v(i,j,k) = v_temp(i,j,k)*dcst_knams_8
         enddo
         enddo
         enddo
      else
         do k=1,g_nk+1
         do j=1,Acqi_nju
         do i=1,Acqi_niu
            Ind_u(i,j,k) = u_temp(i,j,1)*dcst_knams_8
         enddo
         enddo
         do j=1,Acqi_njv
         do i=1,Acqi_niv
            Ind_v(i,j,k) = v_temp(i,j,1)*dcst_knams_8
         enddo
         enddo
         enddo
      endif

*     If required, copy difference between initial and target topography 
*     in Ind_dtopo and move analysis topography into Ind_topo
      if (Vtopo_L) then
        if (Lctl_step <= Vtopo_start) then
          Ind_dtopo(1:l_ni,1:l_nj) = Ind_topo(1:l_ni,1:l_nj) - topo_temp
        endif
        Ind_topo(1:l_ni,1:l_nj) = topo_temp
      endif
*
      deallocate ( u_temp,v_temp,gz_temp,tt_temp,hu_temp,work,lna,rna,
     $             sdd )
*
      if (Acql_vertint.or.Schm_offline_L) then
         deallocate (psu_temp,psv_temp,topu_temp,topv_temp,
     $               gzu_temp,gzv_temp)
          IF (Acql_vertint) THEN
              deallocate ( aaa )
              if (.not.Acql_prsanl) deallocate ( bbb )
          endif
      endif
*
      psmin = pps(1,1)
      psmax = pps(1,1)
      do j=1,l_nj
      do i=1,l_ni
         psmin = min( psmin, pps(i,j) )
         psmax = max( psmax, pps(i,j) )
c        NOTE : s wil be computed in predat
      enddo
      enddo
*     
      call rpn_comm_allreduce(psmin,psmin_glob,1,"MPI_REAL","MPI_MIN",
     $                                                     "grid",err)
      call rpn_comm_allreduce(psmax,psmax_glob,1,"MPI_REAL","MPI_MAX",
     $                                                     "grid",err)
      psmin=psmin_glob
      psmax=psmax_glob
*     
      if ( Ptopo_myproc.eq.0 .and. .not.NESD ) then
           write(lun_out,*)'PSMIN = ',PSMIN,' PSMAX = ',PSMAX,
     $                     ' PSMINMAX = ',0.5*(PSMIN+PSMAX),' (PASCAL)'
      endif
*
      Pres_surf = dble(0.5*(psmin+psmax))
      Pres_top  = dble(Pres_ptop*100.)
*     
      nullify ( lna,rna,sdd,psu_temp,psv_temp,apsu_temp,apsv_temp,
     $          topu_temp,topv_temp, u_temp,v_temp,hu_temp,tt_temp,
     $          gz_temp, ttu_temp,ttv_temp,gzu_temp,gzv_temp)
*
      call bmf_clear
*     
      call rpn_comm_xch_halo ( Ind_topo, LDIST_DIM,l_ni,l_nj,1,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
*
*     
 9000 format(/,' TREATING INPUT DATA VALID AT: ',i8.6,'.',i8.8,
     +       /,' ===============================================')
*
*     ---------------------------------------------------------------
*
      return
      end
