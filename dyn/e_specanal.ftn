! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r e_specanal - extraction of analysis levels
*
#include "model_macros_f.h"
*
      subroutine e_specanal
      implicit none
*
*author 
*    Michel Desgagne - RPN - May 2002 - new entry program  v3_00
*
*revision
* v3_01 - Lee V.            - new ip1 encoding (kind=5 -- unnormalized)
* v3_02 - Lee V.            - correction to storage of ip1 in NA, in-lined sort
* v3_12 - Winger K.         - add TD and HR as possible humidity variables
* v3_20 - Pellerin P.       - MEC option (off-line mode)
* v3_30 - Lee V.            - new LAM I/O  (BCS and 3DF pilot files)
* v3_31 - Lee V.            - eliminated using topoU, topoV, added press anal
*
#include "e_anal.cdk"
#include "e_fu.cdk"
#include "e_grids.cdk"
#include "e_topo.cdk"
#include "bmf.cdk"
#include "ptopo.cdk"
#include "e_cdate.cdk"
#include "e_schm.cdk"
#include "pilot.cdk"
#include "hgc.cdk"
#include "e_grdc.cdk"
*
      integer   fstinf, fstinl, fstprm, fstlir, fstluk, fnom, fstouv,
     $          read_decode_hyb, newdate, e_pilotf, 
     $          e_ac_posi, ezgdef_fmem, gdll,e_bmfrd,e_rdhint3
      external  fstinf, fstinl, fstprm, fstlir, fstluk, fnom, fstouv,
     $          read_decode_hyb, newdate, e_pilotf, 
     $          e_ac_posi, ezgdef_fmem, gdll,e_bmfrd,e_rdhint3
*
      integer  dte, det, ipas, p1, p2, p3, g1, g2, g3, g4, bit,
     $         dty, swa, lng, dlf, ubc, ex1, ex2, ex3, kind, err,ip1mode
      integer  ip1x,ip2x,ip3x,vcode
      character*1   typ, grd, blk_S
      character*4   var,varx,var_t
      character*12  lab
      character*15  datec,pdate
      real      x1,lev,difsig,dx,dy
      real coin_lat(4),coin_lon(4),difmin,c
      integer, dimension(:), allocatable :: lookup_ip1
      real, dimension(:,:), allocatable :: latd,lond,lats,lons
      real, dimension(:),   allocatable :: topp,xpx,xpxu,ypx,ypxv,levm
      real, dimension (:), allocatable:: wk2,p0
      real*8, dimension(:), allocatable :: lookup_a_8,lookup_b_8
      real*8, dimension(:,:), allocatable :: work_8
      real*8    xyz1(3),xyz2(3)
      real*8 Cstv_pref_8
      parameter (Cstv_pref_8=100000.0)
      parameter (difsig = 1.e-5)
      integer list(2000), i, j, k, l, m, n, ier,numi,numj,sgid,dgid
      integer list_t(2000),lookup_max
      integer is,js,jn,iw,ie,jw,njw,niw,nis,njs,dimgx,dimgy
      logical done,hollow
      data done,hollow /.false.,.true./
      save done,hollow
*
      real*8 ONE_8, CLXXX_8
      real*8 orr, deg2rad_8
      parameter( ONE_8   = 1.0 )
      parameter( CLXXX_8 = 180.0 )
      integer key,ni1,nj1,nk1,nka,yy,mo,dd,hh,mm,ss,dum,nvar
* ---------------------------------------------------------------------
*
*Notes for coding bmf_dtyp
* integer (i4) dtyp=40
* real*4  (r4) dtyp=41
* real*8  (r8) dtyp=81
*Notes for coding anal_hav
* anal_hav(2)
* 1 - hybrid
* 2 - eta
* 3 - sigma
* 4 - pressure
* 5 - ecmwf
* 6 - staggered hybrid
*
      write (6, 1001)
      deg2rad_8 = acos( -ONE_8 )/CLXXX_8
*
      if (LAM) then
         call datf2p (pdate,datev)
         ier = e_pilotf (datev,'UU',' ',' ',-1,-1,-1)
         if (ier.lt.0) ier = e_pilotf (datev,'UT1',' ',' ',-1,-1,-1)
         nvar=5
      else
         e_fu_anal = 0
         if (fnom (e_fu_anal ,'process/analysis','RND+OLD',0).lt.0) stop
         if (fstouv(e_fu_anal ,'RND').lt.0) stop
      endif
      ip1mode = +1
*
*                     Check moisture variable and find out if it is
*                     given by 'HU' (for sigma/eta/hybrid levels) or
*                     'ES', 'HR', 'HU' or 'TD' for pressure levels
*
      vh = 'HU'
      key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vh)
*
      if ( key .lt. 0 ) then
        vh = 'ES'
        key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vh)
*
        if ( key .lt. 0 ) then
          vh = 'TD'
          key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vh)
*
          if ( key .lt. 0 ) then
            vh = 'HR'
            key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vh)
*
            if ( key .lt. 0 ) then
              write(6,*) 'No moisture variables are found in analysis'
              write(6,*) 'Either ES, HR, HU or TD must be in the analysis file.'
              call e_arret('e_specanal')
            endif
*
          endif
        endif
      endif
*
*                      Check wind variable and find
*                      out if it is given by 'UU' or 'UT1'
      var = 'UU  '
      key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',var)
      print *,'key for UU found is ',key
*
      if ( key .lt. 0 ) then
         var = 'UT1'
         key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',var)
         if ( key .lt. 0 ) then
            write(6,*) 'No U variables are found in analysis'
            write(6,*) 'Either UU or UT1 must be in the analysis file.'
            call e_arret('e_specanal')
         endif
      endif
*
*     Get the information on the U field from the analysis
*     ig1a,ig2a,ig3a,ig4a are the grid descriptors for the UU/UT1 field
*
      err = fstprm ( key, dte, det, ipas, nia, nja, k, bit, dty, 
     $     ip1a,ip2a,ip3a, tva, var, labanl, grda, ig1a,ig2a,ig3a,ig4a,
     $     swa,lng, dlf, ubc, ex1, ex2, ex3 )
*
      call convip (ip1a, lev, kind,-1, blk_S, .false.)
*
      Anal_sigma_L   = .false.
      Anal_eta_L     = .false. 
      Anal_hyb_L     = .false.
      Anal_pres_L      = .false.
      Anal_ecmwf_L = .false.
*
      if (kind .eq. 3) then
         print*,' ===> Analysis on ECMWF coordinates... maybe.'
         Anal_ecmwf_L = .true.
         anal_hav(2) = 5
      endif
      if (kind .eq. 2) then
         print*,' ===> Analysis on PRESSURE vertical coordinates.'
         Anal_pres_L = .true.
         anal_hav(2) = 4
      endif
      if (kind .eq. 5) then
         ip1mode=2
         key = fstinf ( e_fu_anal, ni1,nj1,nk1,datev,' ',-1,-1,-1, 
     $                                                    ' ', '!!  ' )
         if (key.gt.0) then
*         Staggered Analysis
             ier = fstprm (key, dte, det, ipas, ni1, nj1, nk1, bit, dty,
     x              ip1x, ip2x, ip3x, typ, varx, labanl, grd, g1, g2, g3,
     x                           g4, swa, lng, dlf, ubc, ex1, ex2, ex3 )
             print *,'e_spec: g1,g2,g3,g4=',g1,g2,g3,g4
             vcode = g1
             ptopa = g2/100.
             prefa = 1000.0 ! fixed for STAG
             rcoefa(1)= g3/1000.0
             rcoefa(2)= g4/1000.0
             print *,'!!   found: ptopa=',ptopa,' rcoefa(1)=',rcoefa(1),' rcoefa(2)=',rcoefa(2)
             print*,' ===> Analysis on staggered HYBRID vertical coordinates.'
             anal_hav(2) = 6
             Anal_hyb_L = .true.
             allocate(work_8(ni1,nj1))
             err = fstlir (work_8,e_fu_anal,ni1,nj1,nk1,datev,
     $               ' ',ip1x,ip2x,ip3x,typ,'!!  ')
             allocate(lookup_a_8(nj1),lookup_b_8(nj1),lookup_ip1(nj1))
             do j=1,nj1
                lookup_ip1(j)=nint(work_8(1,j))
                lookup_a_8(j)=work_8(2,j)
                lookup_b_8(j)=work_8(3,j)
                print *,'lookup',j,lookup_ip1(j),lookup_a_8(j),lookup_b_8(j)
             enddo
             lookup_max=nj1
             key = fstinf ( e_fu_anal, ni1,nj1,nk1,datev,' ',-1,-1,-1, 
     $                                                    ' ', '!!SF' )
             if (key.lt.0) then
                 print *,'No !!SF found but !! is found'
                 stop
             endif
             print*,' ===> Analysis on STAGGERED HYBRID vertical coordinates.'
         else 
* Hybrid Analysis
             key = read_decode_hyb (e_fu_anal, 'HY', -1, -1, ' ',-1,
     $                  ptopa,prefa,rcoefa)
             if (key.lt.0) then 
                 print*,'No HY or +HY+ found , kind = 5'
                 stop
             else 
                 print *,'HY found: ptopa=',ptopa,' prefa=',prefa,' rcoefa=',rcoefa
                 Anal_hyb_L  = .true.
                 anal_hav(2) = 1
                 print*,' ===> Analysis on HYBRID vertical coordinates.'
             endif
         endif
      endif
      if (kind .eq. 1) then      
         key = fstinf ( e_fu_anal, ni1,nj1,nk1,datev,' ',-1,-1,-1,
     $                                                    ' ', 'HY' )
         if (key .lt. 0) then
            key = fstinf ( e_fu_anal, ni1,nj1,nk1,datev,' ',-1,-1,-1, 
     $                                                    ' ', 'PT' )
            if (key .ge. 0) then
               Anal_eta_L = .true.
               anal_hav(2) = 2
               rcoefa   = 1.0
               prefa    = 800.0
               allocate(topp(ni1*nj1))
               err = fstluk(topp, key, ni1,nj1,nk1)
               ptopa = topp(1)
               do i = 2, ni1*nj1
                  if (abs(topp(i)-ptopa).gt.difsig) then
                     write(6,900)
     $                    'ERROR: PT in ETA analysis is not uniform',
     $                    'ERROR: TOPP(',i,')=',topp(i),' ptopa=',ptopa
                     call e_arret('e_specanal')
                  endif
               end do
               deallocate (topp)
               print*,' ===> Analysis on ETA vertical coordinates.'
            else
               print*,' ===> Analysis on SIGMA vertical coordinates.'
               Anal_sigma_L = .true.
               anal_hav(2) = 3
            endif
         else
            key = read_decode_hyb (e_fu_anal, 'HY', -1, -1, ' ',-1,
     $                                          ptopa,prefa,rcoefa)
            if (key .lt. 0) stop
            print*,' ===> Analysis on HYBRID vertical coordinates.'
            Anal_hyb_L = .true.
            anal_hav(2) = 1
         endif
      endif
*
      if (( Anal_sigma_L.or.Anal_eta_L.or.Anal_hyb_L.or.Anal_ecmwf_L).and. 
     $     ( VH .ne. 'HU' )) then
         write(6,*) 'ERROR: Moisture variable(VH) must be HU '
         write(6,*) 'when analysis is on sigma/eta/hybrid.'
         call e_arret('e_specanal')
      endif
*
      print *,'Levels searched: fstinl on var=',var
*
      if (.not.e_Schm_offline_L) then
         if (Anal_ecmwf_L) then
            key  = fstinl ( e_fu_anal, ni1, nj1, nk1, datev, labanl,ip1a, 
     $                           ip2a, -1, tva, var, list, nka, lvmax)
         else
            key  = fstinl ( e_fu_anal, ni1, nj1, nk1, datev, labanl, -1, 
     $                           ip2a, ip3a, tva, var, list, nka, lvmax)
         endif
      else
         ip1a=11950
         key  = fstinl ( e_fu_anal, ni1, nj1, nk1, datev, labanl, ip1a,
     $                     ip2a, ip3a, tva, var, list, nka, lvmax)
         write (6,130)
         write (6,101) ip1a
         write (6,201) var
      endif
* (for UU)
      print *,'Found this many levels, nka=',nka,'for ',var
      LV = nka
      do k = 1, nka
         ier = fstprm (list(k), dte, det, ipas, ni1, nj1, nk1, bit, dty,
     x              ip1a, ip2a, ip3a, tva, var, labanl, grd, g1, g2, g3,
     x                           g4, swa, lng, dlf, ubc, ex1, ex2, ex3 )

         if (nia.ne.ni1 .or. nja.ne.nj1) then
            write(6,*)':  LEVEL ',ip1a,' DIMENSION MISMATCH',
     x                'nia,nja=',nia,nja,' ni1,nj1=', ni1,nj1
            call e_arret( 'e_specanal')
         elseif (grda.ne.grd .or. ig1a.ne.g1 .or. ig2a.ne.g2 .or.
     x         ig3a .ne.g3  .or. ig4a .ne.g4) then
            write(6,*)':  LEVEL ',ip1a,' GRID MISMATCH'
            call e_arret( 'e_specanal')
         endif
         call convip (ip1a, lev, kind, -1, blk_S, .false.)
         if ( (((Anal_sigma_L).or.(Anal_eta_L)).and. (kind.ne.1)) .or.
     $        (( Anal_ecmwf_L               ).and. (kind.ne.3)) .or.
     $        (( Anal_pres_L                ).and. (kind.ne.2)) .or.
     $        (( Anal_hyb_L                 ).and.((kind.ne.1)
     $                                      .and.(kind.ne.5)))) then
            write(6,*)':  LEVEL ',ip1a,' LEVEL INCONSISTENCY'
            call e_arret( 'e_specanal')
         elseif (Anal_ecmwf_L) then
            rna(k) = ip3a
            na(k)  = ip1a
         else
            rna(k) = lev
            na(k)  = ip1a
         endif
      enddo
*
*                      Check temperature variable and find
*                      out if it is given by 'TT' or 'VT'
      vt = 'VT'
      key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vt)
*
      if ( key .lt. 0 ) then
         vt = 'TT'
         key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vt)
         if ( key .lt. 0 ) then
            write(6,*) 'No temperature variables are found in analysis'
            write(6,*) 'Either TT or VT must be in the analysis file.'
            call e_arret('e_specanal')
         endif
      endif
*
*     Get the information on the temperature field from the analysis
*     ig1a,ig2a,ig3a,ig4a are the grid descriptors for the TT/VT field
*
      err = fstprm ( key, dte, det, ipas, nia, nja, k, bit, dty, 
     $     ip1a,ip2a,ip3a, tva, var, labanl, grda, ig1a,ig2a,ig3a,ig4a,
     $     swa,lng, dlf, ubc, ex1, ex2, ex3 )

      print *,'Levels searched: fstinl on var=',var
*
      if (.not.e_Schm_offline_L) then
         if (Anal_ecmwf_L) then
            key  = fstinl ( e_fu_anal, ni1, nj1, nk1, datev, labanl,ip1a, 
     $                           ip2a, -1, tva, var, list, nka, lvmax)
         else
            key  = fstinl ( e_fu_anal, ni1, nj1, nk1, datev, labanl, -1, 
     $                           ip2a, ip3a, tva, var, list, nka, lvmax)
         endif
      else
         ip1a=11950
         key  = fstinl ( e_fu_anal, ni1, nj1, nk1, datev, labanl, ip1a,
     $                     ip2a, ip3a, tva, var, list, nka, lvmax)
         write (6,130)
         write (6,101) ip1a
         write (6,201) var
      endif
*
      print *,'Found this many levels, nka=',nka,'for ',var
      LV_T = nka
      do k = 1, nka
         ier = fstprm (list(k), dte, det, ipas, ni1, nj1, nk1, bit, dty,
     x              ip1a, ip2a, ip3a, tva, var, labanl, grd, g1, g2, g3,
     x                           g4, swa, lng, dlf, ubc, ex1, ex2, ex3 )

         if (nia.ne.ni1 .or. nja.ne.nj1) then
            write(6,*)':  LEVEL ',ip1a,' DIMENSION MISMATCH',
     x                'nia,nja=',nia,nja,' ni1,nj1=', ni1,nj1
            call e_arret( 'e_specanal')
         elseif (grda.ne.grd .or. ig1a.ne.g1 .or. ig2a.ne.g2 .or.
     x         ig3a .ne.g3  .or. ig4a .ne.g4) then
            write(6,*)':  LEVEL ',ip1a,' GRID MISMATCH'
            call e_arret( 'e_specanal')
         endif
         call convip (ip1a, lev, kind, -1, blk_S, .false.)
         if ( (((Anal_sigma_L).or.(Anal_eta_L)).and. (kind.ne.1)) .or.
     $        (( Anal_ecmwf_L               ).and. (kind.ne.3)) .or.
     $        (( Anal_pres_L                ).and. (kind.ne.2)) .or.
     $        (( Anal_hyb_L                 ).and.((kind.ne.1)
     $                                      .and.(kind.ne.5)))) then
            write(6,*)':  LEVEL ',ip1a,' LEVEL INCONSISTENCY'
            call e_arret( 'e_specanal')
         elseif (Anal_ecmwf_L) then
            rna_t(k) = ip3a
            na_t(k)  = ip1a
         else
            rna_t(k) = lev
            na_t(k)  = ip1a
         endif
      enddo

*     Sort levels in ascending order for momentum levels
      call e_sortlev(rna,na,lv,m)
      LV=m
*     Sort levels in ascending order for thermo
      call e_sortlev(rna_t,na_t,lv_t,m)
      LV_T=m
*
      if (anal_hav(2).lt.6) then
          print *,'Check for non-staggered analysis:'
          if (lv.ne.lv_t) then
              print *,'Levels found for TT/VT is',LV_t,': should be ',LV
              call abort()
          endif
          do k=1,lv
             if (rna(k).ne.rna_t(k)) then
              print *,'Level',k,'for UU is',rna(k),' which is not the same for TT/VT ',rna_t(k)
              call abort()
             endif
          enddo
          print *,'Check is OK'
      endif

*     Find the A,B values corresponding to the IP1s
      if (anal_hav(2).eq.4) then
*     Pressure Analysis
          print*, ' UU ANALYSIS LEVELS FOUND ARE:'
          do k=1,lv
             write(6,801) rna(k),k,na(k)
          end do 
          do k=1,lv
             za_8(k)=rna(k)
             zb_8(k)=0.0
             zat_8(k)=rna(k)
             zbt_8(k)=0.0
          enddo 
          if ( (lv.lt.16) ) then
                write(6,*)': NEED 16 OR MORE PRESSURE LEVELS. ',
     x                        lv, ' levels found'
                call e_arret('e_specanal')
          endif
      else if (anal_hav(2).le.3.or.anal_hav(2).eq.5) then
*Eta/HYB/SIG/ECMWF
          print*, ' UU ANALYSIS LEVELS FOUND ARE:'
          do k=1,lv
             write(6,801) rna(k),k,na(k)
          end do 
          if (rna(lv).ne.1.0) then
              write(6,*)'**************************************'
              write(6,*)'rna(',lv,') is not equal to 1.0'
              write(6,*)'WARNING: NO topography level found!!!!'
              write(6,*)'**************************************'
          endif
          if (Anal_sigma_L) then
              do i=1,LV
                 za_8(i) = 0.0
                 zb_8(i) = rna(i)
                 zat_8(i) = 0.0
                 zbt_8(i) = rna(i)
              enddo
           else if (Anal_ecmwf_L) then
                call ecmwf_ab( pia, pibb, LV)
                do i=1,LV
                   za_8(i) = pia(i)
                   zb_8(i) = pibb(i)
                   zat_8(i) = pia(i)
                   zbt_8(i) = pibb(i)
                enddo
           else if (Anal_eta_L.or. Anal_hyb_L) then
                allocate(levm(lv))
                if (rna(1).eq.0.0) then
*  HYBRID analysis normalized
                   do k=1,lv
                      levm(k) = rna(k) + (1.-rna(k))*ptopa/prefa
                   enddo
                else
*  HYBRID analysis unnormalized
                   do k=1,lv
                      levm(k) = rna(k)
                   enddo
                endif 
                call genab ( pia, pibb, levm, ptopa, rcoefa(1), LV)
                do i=1,LV
                   za_8(i) = pia(i)
                   zb_8(i) = pibb(i)
                   zat_8(i) = pia(i)
                   zbt_8(i) = pibb(i)
                enddo
                deallocate(levm) 
           endif
      else if (anal_hav(2).eq.6) then
*STAGGERED
           print*, ' UU ANALYSIS LEVELS FOUND ARE:'
           do k=1,lv
           do i=1,lookup_max
              if (na(k).eq.lookup_ip1(i)) then 
                za_8(k)=lookup_a_8(i)
                zb_8(k)=lookup_b_8(i)
              endif
           enddo
           write(6,801) rna(k),k,na(k)
           end do 
           print*, ' TT ANALYSIS LEVELS FOUND ARE:'
           do k=1,lv_t
           do i=1,lookup_max
              if (na_t(k).eq.lookup_ip1(i)) then 
                zat_8(k)=lookup_a_8(i)
                zbt_8(k)=lookup_b_8(i)
              endif
           enddo
           write(6,801) rna_t(k),k,na_t(k)
           end do 
           deallocate(lookup_a_8,lookup_b_8,lookup_ip1)
      endif
* Construct A, B vectors with corresponding IP1 vectors

c     if ( .not. (Anal_hyb_L.or.Anal_eta_L) ) Pil_bmf_L = .true.
*
      write(6,*) 'nia     =',nia,'  nja =',nja
      write(6,*) 'Anal_hyb_L=', Anal_hyb_L
      write(6,*) 'Anal_eta_L=', Anal_eta_L
      write(6,*) 'Anal_sigma_L=', Anal_sigma_L
      write(6,*) 'Anal_ecmwf_L=', Anal_ecmwf_L
      write(6,*) 'Anal_pres_L=', Anal_pres_L
*
      if (LAM .and. (.not.Pil_bmf_L) .and. .not.done) then
          p1=ig1a
          p2=ig2a
          p3=ig3a
          key = fstinf(e_fu_anal,ni1,nj1,nk1,-1,' ',p1,p2,p3,' ','>>')
          if (key.lt.0) then
              write(6,4000) '>>'
              stop
          endif
          if (nia.ne.ni1) stop
          allocate(xpx(nia))
          ier = fstprm (key, dte, det, ipas, ni1, nj1, nk1, bit, dty,
     x              ip1x, ip2x, ip3x, typ, var, labanl, grd, g1, g2, g3,
     x                           g4, swa, lng, dlf, ubc, ex1, ex2, ex3 )
*         g1,g2,g3,g4 are the grid descriptors from the analysis file
          err = fstluk( xpx, key, ni1,nj1,nk1)
          key = fstinf(e_fu_anal,ni1,nj1,nk1,-1,' ',p1,p2,p3,' ','^^')
          if (key.lt.0) then
              write(6,4000) '^^'
              stop
          endif
          if (nja.ne.nj1) stop
          allocate(ypx(nja))
          err = fstluk( ypx, key, ni1,nj1,nk1)

* Check if the analysis grid is not global. 
* If LAM, create LAM grid with same resolution as the analysis grid on
* the same rotation as the target grid
*
*    xpx,ypx are in degrees from tic tacs.
          if ( (xpx(1)-(xpx(2)-xpx(1))*.6).gt.0.0 .or. 
     %         (xpx(nia)+(xpx(nia)-xpx(nia-1))*.6).lt.360. .or.
     %         (ypx(1)-(ypx(2)-ypx(1))*.6).gt.-90.0 .or. 
     %         (ypx(nja)+(ypx(nja)-ypx(nja-1))*.6).lt.90.) then
              if (Hgc_ig1ro.ne.g1.or.Hgc_ig2ro.ne.g2.or.
     %            Hgc_ig3ro.ne.g3.or.Hgc_ig4ro.ne.g4) then
                  sgid = ezgdef_fmem(nia,nja, 'Z','E',g1,g2,g3,g4,xpx,ypx)
                  allocate(lats(nia,nja),lons(nia,nja))
                  err = gdll (sgid,lats,lons)
                  print *,'Analysis is a LAM grid, rotation is different to model grid'
* Obtain grid rotation from analysis and calculate geographical lat lons
c                 call cigaxg ( 'E',xlat1,xlon1,xlat2,xlon2,g1,g2,g3,g4)
c                 call xllrot (xlat1,xlon1,xlat2,xlon2,rot_8)
c                 call llacar(cart,xpx,ypx,dimgx,dimgy)
c                 call mxma8(rot_8,1,3,cart,1,3,carot,1,3,3,3,dimgx*dimgy)
c                 call cartall(lons,lats,carot,dimgx*dimgy)
                  do j=1,nja
                  do i=1,nia
                     lons(i,j)=amod(lons(i,j) + 360.,360.0)
                  enddo
                  enddo
                  dimgx=nia
                  dimgy=nja
                  print *,'Recalc new xpx,ypx:'
* Create new xpx,ypx parameters in the same resolution as the analysis
* but on the target grid:
                  dx = xpx(2)-xpx(1)
                  nia = (xfi(nifi) - xfi(1))/dx + 9
                  dy = ypx(2)-ypx(1)
                  nja = (yfi(njfi) - yfi(1))/dy + 9
* Create new xpx
                  deallocate (xpx)
                  allocate(xpx(nia))
                  xpx(1)= xfi(1)- dx*4.0
                  do i=1,nia-1
                     xpx(i+1)= xpx(i) + dx
                  enddo
* Create new ypx
                  deallocate (ypx)
                  allocate(ypx(nja))
                  ypx(1)= yfi(1)-dy*4.0
                  do i=1,nja-1
                     ypx(i+1)= ypx(i) + dy
                  enddo
                  print *,'xpx(1),xpx(',nia,')=',xpx(1),xpx(nia)
                  print *,'ypx(1),ypx(',nja,')=',ypx(1),ypx(nja)
                  print *,'xfi(1),xfi(',nifi,')=',xfi(1),xfi(nifi)
                  print *,'yfi(1),yfi(',njfi,')=',yfi(1),yfi(njfi)
* Now check to see if the target domain is within the source domain
* by comparing geographical coordinates
                  dgid = ezgdef_fmem(nia,nja,'Z','E',Hgc_ig1ro,Hgc_ig2ro,
     $                   Hgc_ig3ro, Hgc_ig4ro,xpx,ypx)
                  allocate(latd(nia,nja),lond(nia,nja))
                  err  = gdll (dgid,latd,lond)
* Verify if the four corners of the destination grid is in the source grid
*
                  coin_lat(1)=latd(1,1)
                  coin_lon(1)=lond(1,1)
                  coin_lat(2)=latd(nia,1)
                  coin_lon(2)=lond(nia,1)
                  coin_lat(3)=latd(nia,nja)
                  coin_lon(3)=lond(nia,nja)
                  coin_lat(4)=latd(1,nja)
                  coin_lon(4)=lond(1,nja)
                  do k=1,4
                     coin_lon(k)=amod(coin_lon(k) + 360.,360.0)
                     call llacar(xyz1,coin_lon(k),coin_lat(k),1,1)
                     difmin=9999999.
                     numi=1
                     numj=1
                     do j=1,dimgy
                     do i=1,dimgx
                        call llacar (xyz2,lons(i,j),lats(i,j),1,1)
                        xyz2(1) = xyz1(1)-xyz2(1)
                        xyz2(2) = xyz1(2)-xyz2(2)
                        xyz2(3) = xyz1(3)-xyz2(3)
                        c = sqrt( xyz2(1)**2 + xyz2(2)**2 + xyz2(3)**2 )
                        if ( c .lt. difmin ) then
                             difmin= c
                             numi = i
                             numj = j
                        endif
                     enddo
                     enddo
                     if (numi.eq.1.or.numj.eq.1) then
                     write(6,*)'Abort: Insufficient coverage from LAM Analysis'
                        call e_arret('e_specanal')
                     else 
                        print *,'numi=',numi,' numj=',numj
                     endif
                  enddo
              endif
          endif
* create U,V target grid
          allocate(xpxu(nia-1))
          do i=1,nia-2
             xpxu(i)= 0.5 * ( xpx(i) + xpx(i+1) )
          enddo
          xpxu(nia-1) = ( xpx(nia-1) + xpx(nia) )
          allocate(ypxv(nja-1))
          do i=1,nja-2
             ypxv(i)= 0.5 * ( ypx(i) + ypx(i+1) )
          enddo
          ypxv(nja-1) = ( ypx(nja-1) + ypx(nja) )


          if (e_ac_posi(xpx,ypx,nia,nja,Pil_hblen+Pil_pil,hollow).eq.0) then

              call hpalloc(paygv_8   ,  (nja-1)*2, err,1)
              do j=1,nja-1
                 ygv_8(j)  = ypxv(j) * deg2rad_8
              enddo
              dstf_gid = ezgdef_fmem (e_grdc_ni, e_grdc_nj , 'Z', 'E', Hgc_ig1ro,
     $        Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xpx(e_grdc_gid), ypx(e_grdc_gjd) )
              dstu_gid = ezgdef_fmem (e_grdc_ni, e_grdc_nj , 'Z', 'E', Hgc_ig1ro,
     $        Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xpxu(e_grdc_gid), ypx(e_grdc_gjd) )
              dstv_gid = ezgdef_fmem (e_grdc_ni, e_grdc_nj , 'Z', 'E', Hgc_ig1ro,
     $        Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xpx(e_grdc_gid), ypxv(e_grdc_gjd) )
          else
            write(6,*)' Abort: Insufficient coverage in Analysis'
            call e_arret('e_specanal')
          endif
          deallocate(xpx)
          deallocate(ypx)
          done = .true.
      endif
      if (Pil_bcs_hollow_L) Pil_bcs_hollow_L = hollow
      if (Pil_bmf_L) then
         call bmf_splitstart (Ptopo_npex,Ptopo_npey,'./process/','BM',
     $                                Bmf_time1,Bmf_hh,Bmf_mm,Bmf_ss)
         call e_bmfsplitxy2 (topo ,nifi,njfi,'ME  ',1,1,pni ,0,0,0)
         call bmf_splitwrall ('RNA ',LV,1,1,Bmf_time1,Bmf_time2, 
     $                                    0,0,bmf_dtyp,0,RNA)
         call bmf_splitwrall ('ZA  ',LV,1,1,Bmf_time1,Bmf_time2, 
     $                                    0,0,81,0,ZA_8)
         call bmf_splitwrall ('ZB  ',LV,1,1,Bmf_time1,Bmf_time2, 
     $                                    0,0,81,0,ZB_8)
         call bmf_splitwrall ('ZAT ',LV_T,1,1,Bmf_time1,Bmf_time2, 
     $                                    0,0,81,0,ZAT_8)
         call bmf_splitwrall ('ZBT ',LV_T,1,1,Bmf_time1,Bmf_time2, 
     $                                    0,0,81,0,ZBT_8)
         if (anal_hav(2).eq.6) then
*        Read, interpolate, scale and write SurF
         allocate(p0(nifi*njfi)) 
         if (e_rdhint3 (p0,dstf_gid,nifi,njfi,'!!SF',-1,
     $         ip2a,ip3a,' ',tva,.true.,.false.,'CUBIC',e_fu_anal,6).lt.0)
     $         call e_arret('e_specanal')
         call e_bmfsplitxy2 (p0 ,nifi,njfi,'P0  ',1,1,pni ,0,0,0)
         deallocate(p0)
         else if (anal_hav(2).eq.5.or.anal_hav(2).le.3) then
*        Read, interpolate, scale and write P0.
              if (e_bmfrd (dstf_gid, nifi, njfi, 'P0  ',   0.,100., -1,
     $         1, .false.,.true.,'CUBIC').lt.0) call e_arret('e_specanal')
         endif

     
      else
*        Read and interpolate P0.
         nis=e_Grdc_ni
         njs=e_Grdc_nj
         allocate(wk2(nis*njs),p0(nis*njs)) 
         if (anal_hav(2).eq.6) then
*        Read, interpolate, scale and write SurF
           if (e_rdhint3 (p0,dstf_gid,nis,njs,'!!SF',-1,
     $         ip2a,ip3a,' ',tva,.true.,.false.,'CUBIC',e_fu_anal,6).lt.0)
     $         call e_arret('e_specanal')
         else if (anal_hav(2).eq.5.or.anal_hav(2).le.3) then
           if (e_rdhint3 (wk2,dstf_gid,nis,njs,'P0  ',-1,
     $         ip2a,ip3a,' ',tva,.true.,.false.,'CUBIC',e_fu_anal,6).lt.0)
     $         call e_arret('e_specanal')
*              Scale P0.
               p0 (:) = wk2(:)*100.
         endif 
         if (Pil_bcs_hollow_L) then
            call bcs_hollow(e_grdc_gid,e_grdc_gif,e_grdc_gjd,e_grdc_gjf,
     $          e_grdc_gjdi,e_grdc_hbsn,e_grdc_hbwe,is,nis,js,njs,
     $          jn,iw,niw,ie,jw,njw)
            call e_sfile_bcs (pdate,is,nis,js,jn,njs,
     $              iw,ie,niw,jw,njw,'DYNAMICS',nvar)
            call e_write_bcs (p0 ,nis,njs,
     $            e_grdc_is,e_grdc_nis,e_grdc_js,e_grdc_jn,e_grdc_njs,
     $            e_grdc_iw,e_grdc_ie,e_grdc_niw,e_grdc_jw,e_grdc_njw,
     $            1 , 'S   ',unf_casc)
         else
            call e_sfile_3df (pdate,'DYNAMICS',
     $             e_grdc_gid,e_grdc_gif,e_grdc_gjd,e_grdc_gjf, nvar)
            call e_write_3df ( p0 ,nis,njs,1 ,'S   ',unf_casc)
         endif
         deallocate(p0,wk2)
      endif
*
 101  format ('|',2x,'   Off-line Mode: Only One Level Used:',1x,I5,10x,'|')
 130  format ('|',9('-'),'+',5('-'),'+',8('-'),'+',8('-'),'+',5('-'),
     $        '+',5('-'),'+',10('-'),'|')
 201  format ('|',2x,'   Search First Infos on Variable:',1x,A3,16x,'|')
 801  format (' LEVEL anal = ',d15.8,2X,' k = ',i4,' IP1= ',I8)
 900  format (a/a,i5,a,e14.7,a,e14.7,a/'   >>>>> ABORT <<<<<')
 1001 format(/,'EXTRACTION OF ANALYSIS LEVELS (S/R E_SPECANAL)',/40('-'))
 1002 format(' DATE = ', 6i5 , 7a4 , i10 )
 4000 format(/,'CANNOT FIND TIC TACS in ANALYSIS (S/R E_SPECANAL)',/40('-'))
*
* ---------------------------------------------------------------------
*
      return
      end
