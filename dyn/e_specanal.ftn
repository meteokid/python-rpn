! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r e_specanal - extraction of analysis levels
*
#include "model_macros_f.h"
*
      subroutine e_specanal
      implicit none
*
*author 
*    Michel Desgagne - RPN - May 2002 - new entry program  v3_00
*
*revision
* v3_01 - Lee V.            - new ip1 encoding (kind=5 -- unnormalized)
* v3_02 - Lee V.            - correction to storage of ip1 in NA, in-lined sort
* v3_12 - Winger K.         - add TD and HR as possible humidity variables
* v3_20 - Pellerin P.       - MEC option (off-line mode)
* v3_30 - Lee V.            - new LAM I/O  (BCS and 3DF pilot files)
*
#include "e_anal.cdk"
#include "e_fu.cdk"
#include "e_option.cdk"
#include "e_grids.cdk"
#include "e_topo.cdk"
#include "bmf.cdk"
#include "ptopo.cdk"
#include "e_cdate.cdk"
#include "e_schm.cdk"
#include "pilot.cdk"
#include "hgc.cdk"
#include "e_grdc.cdk"
*
      integer   fstinf, fstinl, fstprm, fstlir, fstluk, fnom, fstouv,
     $          read_decode_hyb, newdate, e_pilotf, 
     $          e_ac_posi, ezgdef_fmem, gdll
      external  fstinf, fstinl, fstprm, fstlir, fstluk, fnom, fstouv,
     $          read_decode_hyb, newdate, e_pilotf, 
     $          e_ac_posi, ezgdef_fmem, gdll
*
      integer  dte, det, ipas, p1, p2, p3, g1, g2, g3, g4, bit,
     $         dty, swa, lng, dlf, ubc, ex1, ex2, ex3, kind, err,ip1mode
      integer  ip1x,ip2x,ip3x,kcode
      character*1   typ, grd, blk_S
      character*4   var,varx
      character*12  lab
      character*15  datec,pdate
      real      x1,lev,difsig,dx,dy
      real coin_lat(4),coin_lon(4),difmin,c
      real, dimension(:,:), allocatable :: latd,lond,lats,lons
      real, dimension(:),   allocatable :: topp,xpx,xpxu,ypx,ypxv,levm
      real*8, dimension(:), allocatable :: levm_8
      real*8    Cstv_pisrf_8, Cstv_tstr_8,xyz1(3),xyz2(3)
      parameter (difsig = 1.e-5)
      integer list(2000), i, j, k, l, m, n, ier,numi,numj,sgid,dgid
      integer is,js,jn,iw,ie,jw,njw,niw,nis,njs,dimgx,dimgy
      logical done,hollow
      data done,hollow /.false.,.true./
      save done,hollow
*
      real*8 ONE_8, CLXXX_8
      real*8 orr, deg2rad_8
      parameter( ONE_8   = 1.0 )
      parameter( CLXXX_8 = 180.0 )
      parameter(Cstv_pisrf_8=100000.0,Cstv_tstr_8=200.0)
      integer key,ni1,nj1,nk1,nka,yy,mo,dd,hh,mm,ss,dum,nvar
* ---------------------------------------------------------------------
*
*Notes for coding bmf_dtyp
* integer (i4) dtyp=40
* real*4  (r4) dtyp=41
* real*8  (r8) dtyp=81
*Notes for coding anal_hav
* anal_hav(2)
* 1 - hybrid
* 2 - eta
* 3 - sigma
* 4 - pressure
* 5 - ecmwf
* 6 - staggered hybrid
*
      write (6, 1001)
      deg2rad_8 = acos( -ONE_8 )/CLXXX_8
*
      if (LAM) then
         call datf2p (pdate,datev)
         ier = e_pilotf (datev,'UU',' ',' ',-1,-1,-1)
         if (ier.lt.0) ier = e_pilotf (datev,'UT1',' ',' ',-1,-1,-1)
         nvar=5
      else
         e_fu_anal = 0
         if (fnom (e_fu_anal ,'process/analysis','RND+OLD',0).lt.0) stop
         if (fstouv(e_fu_anal ,'RND').lt.0) stop
      endif
      ip1mode = +1
*
*                     Check moisture variable and find out if it is
*                     given by 'HU' (for sigma/eta/hybrid levels) or
*                     'ES', 'HR', 'HU' or 'TD' for pressure levels
*
      vh = 'HU'
      key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vh)
*
      if ( key .lt. 0 ) then
        vh = 'ES'
        key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vh)
*
        if ( key .lt. 0 ) then
          vh = 'TD'
          key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vh)
*
          if ( key .lt. 0 ) then
            vh = 'HR'
            key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vh)
*
            if ( key .lt. 0 ) then
              write(6,*) 'No moisture variables are found in analysis'
              write(6,*) 'Either ES, HR, HU or TD must be in the analysis file.'
              call e_arret('e_specanal')
            endif
*
          endif
        endif
      endif
*
*                      Check temperature variable and find
*                      out if it is given by 'TT' or 'VT'
      var = 'UU  '
      key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',var)
      print *,'key for UU found is ',key
*
      if ( key .lt. 0 ) then
         var = 'UT1'
         key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',var)
         if ( key .lt. 0 ) then
            write(6,*) 'No U variables are found in analysis'
            write(6,*) 'Either UU or UT1 must be in the analysis file.'
            call e_arret('e_specanal')
         endif
      endif
*
*     Get the information on the U field from the analysis
*     ig1a,ig2a,ig3a,ig4a are the grid descriptors for the UU/UT1 field
*
      err = fstprm ( key, dte, det, ipas, nia, nja, k, bit, dty, 
     $     ip1a,ip2a,ip3a, tva, var, labanl, grda, ig1a,ig2a,ig3a,ig4a,
     $     swa,lng, dlf, ubc, ex1, ex2, ex3 )
*
      call convip (ip1a, lev, kind,-1, blk_S, .false.)
*
      Anal_sigma_L   = .false.
      Anal_eta_L     = .false. 
      Anal_hyb_L     = .false.
      Anal_pres_L      = .false.
      Anal_ecmwf_L = .false.
*
      if (kind .eq. 3) then
         print*,' ===> Analysis on ECMWF coordinates... maybe.'
         Anal_ecmwf_L = .true.
         anal_hav(2) = 5
      endif
      if (kind .eq. 2) then
         print*,' ===> Analysis on PRESSURE vertical coordinates.'
         Anal_pres_L = .true.
         anal_hav(2) = 4
      endif
      if (kind .eq. 5) then
         ip1mode=2
         key = fstinf ( e_fu_anal, ni1,nj1,nk1,datev,' ',-1,-1,-1, 
     $                                                    ' ', '+HY+' )
         if (key.gt.0) then
             ier = fstprm (key, dte, det, ipas, ni1, nj1, nk1, bit, dty,
     x              ip1x, ip2x, ip3x, typ, varx, labanl, grd, g1, g2, g3,
     x                           g4, swa, lng, dlf, ubc, ex1, ex2, ex3 )
             kcode = g1
             ptopa = g2/100
             prefa = g3/100
             rcoefa= g4/1000.0
             print *,'+HY+ found: ptopa=',ptopa,' prefa=',prefa,' rcoefa=',rcoefa
             print*,' ===> Analysis on staggered HYBRID vertical coordinates.'
             anal_hav(2) = 6
             Anal_hyb_L = .true.
         else 
             key = read_decode_hyb (e_fu_anal, 'HY', -1, -1, ' ',-1,
     $                  ptopa,prefa,rcoefa)
             if (key.lt.0) then 
                 print*,'No HY or +HY+ found , kind = 5'
                 stop
             else 
                 print *,'HY found: ptopa=',ptopa,' prefa=',prefa,' rcoefa=',rcoefa
                 Anal_hyb_L  = .true.
                 anal_hav(2) = 1
                 print*,' ===> Analysis on HYBRID vertical coordinates.'
             endif
         endif
      endif
      if (kind .eq. 1) then      
         key = fstinf ( e_fu_anal, ni1,nj1,nk1,datev,' ',-1,-1,-1,
     $                                                    ' ', 'HY' )
         if (key .lt. 0) then
            key = fstinf ( e_fu_anal, ni1,nj1,nk1,datev,' ',-1,-1,-1, 
     $                                                    ' ', 'PT' )
            if (key .ge. 0) then
               Anal_eta_L = .true.
               anal_hav(2) = 2
               rcoefa   = 1.0
               prefa    = 800.0
               allocate(topp(ni1*nj1))
               err = fstluk(topp, key, ni1,nj1,nk1)
               ptopa = topp(1)
               do i = 2, ni1*nj1
                  if (abs(topp(i)-ptopa).gt.difsig) then
                     write(6,900)
     $                    'ERROR: PT in ETA analysis is not uniform',
     $                    'ERROR: TOPP(',i,')=',topp(i),' ptopa=',ptopa
                     call e_arret('e_specanal')
                  endif
               end do
               deallocate (topp)
               print*,' ===> Analysis on ETA vertical coordinates.'
            else
               print*,' ===> Analysis on SIGMA vertical coordinates.'
               Anal_sigma_L = .true.
               anal_hav(2) = 3
            endif
         else
            key = read_decode_hyb (e_fu_anal, 'HY', -1, -1, ' ',-1,
     $                                          ptopa,prefa,rcoefa)
            if (key .lt. 0) stop
            print*,' ===> Analysis on HYBRID vertical coordinates.'
            Anal_hyb_L = .true.
            anal_hav(2) = 1
         endif
      endif
*
      if (( Anal_sigma_L .or. Anal_eta_L .or. Anal_hyb_L .or. Anal_ecmwf_L) .and. 
     $     ( VH .ne. 'HU' )) then
         write(6,*) 'ERROR: Moisture variable(VH) must be HU '
         write(6,*) 'when analysis is on sigma/eta/hybrid.'
         call e_arret('e_specanal')
      endif
*

      if (.not.e_Schm_offline_L) then
         print *,'Levels searched: fstinl on var=',var
*
         if (Anal_ecmwf_L) then
            key  = fstinl ( e_fu_anal, ni1, nj1, nk1, datev, labanl,ip1a, 
     $                           ip2a, -1, tva, var, list, nka, lvmax)
         else
            key  = fstinl ( e_fu_anal, ni1, nj1, nk1, datev, labanl, -1, 
     $                           ip2a, ip3a, tva, var, list, nka, lvmax)
         endif
      else
         ip1a=11950
         key  = fstinl ( e_fu_anal, ni1, nj1, nk1, datev, labanl, ip1a,
     $                     ip2a, ip3a, tva, var, list, nka, lvmax)
         write (6,130)
         write (6,101) ip1a
         write (6,201) var
      endif
*
      print *,'Found this many levels, nka=',nka,'for ',var
      LV = nka
      do k = 1, nka
         ier = fstprm (list(k), dte, det, ipas, ni1, nj1, nk1, bit, dty,
     x              ip1a, ip2a, ip3a, tva, var, labanl, grd, g1, g2, g3,
     x                           g4, swa, lng, dlf, ubc, ex1, ex2, ex3 )

         if (nia.ne.ni1 .or. nja.ne.nj1) then
            write(6,*)':  LEVEL ',ip1a,' DIMENSION MISMATCH','nia,nja=',nia,nja,' ni1,nj1=', ni1,nj1
            call e_arret( 'e_specanal')
         elseif (grda.ne.grd .or. ig1a.ne.g1 .or. ig2a.ne.g2 .or.
     x         ig3a .ne.g3  .or. ig4a .ne.g4) then
            write(6,*)':  LEVEL ',ip1a,' GRID MISMATCH'
            call e_arret( 'e_specanal')
         endif
         call convip (ip1a, lev, kind, -1, blk_S, .false.)
         if ( (((Anal_sigma_L).or.(Anal_eta_L)).and. (kind.ne.1)) .or.
     $        (( Anal_ecmwf_L               ).and. (kind.ne.3)) .or.
     $        (( Anal_pres_L                ).and. (kind.ne.2)) .or.
     $        (( Anal_hyb_L                 ).and.((kind.ne.1)
     $                                      .and.(kind.ne.5)))) then
            write(6,*)':  LEVEL ',ip1a,' LEVEL INCONSISTENCY'
            call e_arret( 'e_specanal')
         elseif (Anal_ecmwf_L) then
            rna(k) = ip3a
            na(k)  = ip1a
         else
            rna(k) = lev
            na(k)  = ip1a
         endif
      enddo
*
*                      Check temperature variable and find
*                      out if it is given by 'TT' or 'VT'
      vt = 'VT'
      key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vt)
*
      if ( key .lt. 0 ) then
         vt = 'TT'
         key = fstinf (e_fu_anal,ni1,nj1,nk1,datev,' ',-1,-1,-1,' ',vt)
         if ( key .lt. 0 ) then
            write(6,*) 'No temperature variables are found in analysis'
            write(6,*) 'Either TT or VT must be in the analysis file.'
            call e_arret('e_specanal')
         endif
      endif
*
*     Get the information on the temperature field from the analysis
*     ig1a,ig2a,ig3a,ig4a are the grid descriptors for the TT/VT field
*
      err = fstprm ( key, dte, det, ipas, nia, nja, k, bit, dty, 
     $     ip1a,ip2a,ip3a, tva, var, labanl, grda, ig1a,ig2a,ig3a,ig4a,
     $     swa,lng, dlf, ubc, ex1, ex2, ex3 )

      if ( .not. (Anal_hyb_L.or.Anal_eta_L) ) Pil_bmf_L = .true.
*
      if (Pil_bmf_L) then
         call bmf_splitstart (Ptopo_npex,Ptopo_npey,'./process/','BM',
     $                                Bmf_time1,Bmf_hh,Bmf_mm,Bmf_ss)
         call e_bmfsplitxy2 (topo ,nifi,njfi,'ME  ',1,1,pni ,0,0,0)
         call e_bmfsplitxy2 (topou,niu ,nju ,'TOPU',1,1,pniu,0,0,0)
         call e_bmfsplitxy2 (topov,niv ,njv ,'TOPV',1,1,pni ,0,0,0)
      endif
*
      if ( (Anal_pres_L) ) then
           if ( (lv.lt.16) ) then
                 write(6,*)': NEED 16 OR MORE PRESSURE LEVELS. ',
     x                        lv, ' levels found'
                 call e_arret('e_specanal')
           endif
           if ( (lv.gt.35) ) then
                 write(6,*)': GREATER THAN 35 PRESSURE LEVELS: ',
     x                        lv, ' levels found'
                 write(6,*)': WARNING, TT on pressure levels are NOT USED '
                 write(6,*)': WARNING, TT on pressure levels are DERIVED  '
                 write(6,*)': and maybe WRONG if too many pressure levels '
           endif
      endif
*
*     Sort levels in ascending order (originally done in e_sortr)

      if (lv.ne.1) then
         n = lv
         do i = 1, n-1
         k = i
         do j = i+1, n
            if (rna(k) .gt. rna(j))  k=j
         enddo
         if (k .ne. i) then
            x1     = rna(k)
            m      = na(k)
            rna(k) = rna(i)
            na(k)  = na(i)
            rna(i) = x1
            na(i)  = m
         endif
         enddo

*        eliminate levels that are redundant in LISTE
         i = 1
         do j=2,n
            if (rna(i) .ne. rna(j)) then
                i = i+1
                if (i .ne. j) then
                    rna(i) = rna(j)
                     na(i) =  na(j)
                endif
            endif
         enddo
         lv = i

      endif
*
      print*, ' ANALYSIS LEVELS FOUND ARE:'
      do k=1,lv
         write(6,801) rna(k),k,na(k)
      end do 
      if (Anal_hyb_L.or.Anal_eta_L.or.Anal_sigma_L) then
          if (rna(lv).ne.1.0) then
              write(6,*)'**************************************'
              write(6,*)'WARNING: NO topography level found!!!!'
              write(6,*)'**************************************'
          endif
      endif
*
      write(6,*) 'nia     =',nia,'  nja =',nja
      write(6,*) 'Anal_hyb_L=', Anal_hyb_L
      write(6,*) 'Anal_eta_L=', Anal_eta_L
      write(6,*) 'Anal_sigma_L=', Anal_sigma_L
      write(6,*) 'Anal_ecmwf_L=', Anal_ecmwf_L
*
      if (Anal_hyb_L.or.Anal_eta_L.or.Anal_sigma_L) then
          if (rna(lv).ne.1.0) then
              write(6,*)'**************************************'
              write(6,*)'WARNING: NO topography level found!!!!'
              write(6,*)'**************************************'
          endif
      endif
*
      if (LAM .and. (.not.Pil_bmf_L) .and. .not.done) then
          p1=ig1a
          p2=ig2a
          p3=ig3a
          key = fstinf(e_fu_anal,ni1,nj1,nk1,-1,' ',p1,p2,p3,' ','>>')
          if (key.lt.0) then
              write(6,4000) '>>'
              stop
          endif
          if (nia.ne.ni1) stop
          allocate(xpx(nia))
          ier = fstprm (key, dte, det, ipas, ni1, nj1, nk1, bit, dty,
     x              ip1x, ip2x, ip3x, typ, var, labanl, grd, g1, g2, g3,
     x                           g4, swa, lng, dlf, ubc, ex1, ex2, ex3 )
*         g1,g2,g3,g4 are the grid descriptors from the analysis file
          err = fstluk( xpx, key, ni1,nj1,nk1)
          key = fstinf(e_fu_anal,ni1,nj1,nk1,-1,' ',p1,p2,p3,' ','^^')
          if (key.lt.0) then
              write(6,4000) '^^'
              stop
          endif
          if (nja.ne.nj1) stop
          allocate(ypx(nja))
          allocate(levm(nka))
          do k=1,nka
             levm(k) = rna(k) + (1.-rna(k))*ptopa/prefa
          enddo
          err = fstluk( ypx, key, ni1,nj1,nk1)

* Check if the analysis grid is not global. 
* If LAM, create LAM grid with same resolution as the analysis grid on
* the same rotation as the target grid
*
*    xpx,ypx are in degrees from tic tacs.
          if ( (xpx(1)-(xpx(2)-xpx(1))*.6).gt.0.0 .or. 
     %         (xpx(nia)+(xpx(nia)-xpx(nia-1))*.6).lt.360. .or.
     %         (ypx(1)-(ypx(2)-ypx(1))*.6).gt.-90.0 .or. 
     %         (ypx(nja)+(ypx(nja)-ypx(nja-1))*.6).lt.90.) then
              if (Hgc_ig1ro.ne.g1.or.Hgc_ig2ro.ne.g2.or.
     %            Hgc_ig3ro.ne.g3.or.Hgc_ig4ro.ne.g4) then
                  sgid = ezgdef_fmem(nia,nja, 'Z','E',g1,g2,g3,g4,xpx,ypx)
                  allocate(lats(nia,nja),lons(nia,nja))
                  err = gdll (sgid,lats,lons)
                  print *,'Analysis is a LAM grid, rotation is different to model grid'
* Obtain grid rotation from analysis and calculate geographical lat lons
c                 call cigaxg ( 'E',xlat1,xlon1,xlat2,xlon2,g1,g2,g3,g4)
c                 call xllrot (xlat1,xlon1,xlat2,xlon2,rot_8)
c                 call llacar(cart,xpx,ypx,dimgx,dimgy)
c                 call mxma8(rot_8,1,3,cart,1,3,carot,1,3,3,3,dimgx*dimgy)
c                 call cartall(lons,lats,carot,dimgx*dimgy)
                  do j=1,nja
                  do i=1,nia
                     lons(i,j)=amod(lons(i,j) + 360.,360.0)
                  enddo
                  enddo
                  dimgx=nia
                  dimgy=nja
                  print *,'Recalc new xpx,ypx:'
* Create new xpx,ypx parameters in the same resolution as the analysis
* but on the target grid:
                  dx = xpx(2)-xpx(1)
                  nia = (xfi(nifi) - xfi(1))/dx + 9
                  dy = ypx(2)-ypx(1)
                  nja = (yfi(njfi) - yfi(1))/dy + 9
* Create new xpx
                  deallocate (xpx)
                  allocate(xpx(nia))
                  xpx(1)= xfi(1)- dx*4.0
                  do i=1,nia-1
                     xpx(i+1)= xpx(i) + dx
                  enddo
* Create new ypx
                  deallocate (ypx)
                  allocate(ypx(nja))
                  ypx(1)= yfi(1)-dy*4.0
                  do i=1,nja-1
                     ypx(i+1)= ypx(i) + dy
                  enddo
                  print *,'xpx(1),xpx(',nia,')=',xpx(1),xpx(nia)
                  print *,'ypx(1),ypx(',nja,')=',ypx(1),ypx(nja)
                  print *,'xfi(1),xfi(',nifi,')=',xfi(1),xfi(nifi)
                  print *,'yfi(1),yfi(',njfi,')=',yfi(1),yfi(njfi)
* Now check to see if the target domain is within the source domain
* by comparing geographical coordinates
                  dgid = ezgdef_fmem(nia,nja,'Z','E',Hgc_ig1ro,Hgc_ig2ro,
     $                   Hgc_ig3ro, Hgc_ig4ro,xpx,ypx)
                  allocate(latd(nia,nja),lond(nia,nja))
                  err  = gdll (dgid,latd,lond)
* Verify if the four corners of the destination grid is in the source grid
*
                  coin_lat(1)=latd(1,1)
                  coin_lon(1)=lond(1,1)
                  coin_lat(2)=latd(nia,1)
                  coin_lon(2)=lond(nia,1)
                  coin_lat(3)=latd(nia,nja)
                  coin_lon(3)=lond(nia,nja)
                  coin_lat(4)=latd(1,nja)
                  coin_lon(4)=lond(1,nja)
                  do k=1,4
                     coin_lon(k)=amod(coin_lon(k) + 360.,360.0)
                     call llacar(xyz1,coin_lon(k),coin_lat(k),1,1)
                     difmin=9999999.
                     numi=1
                     numj=1
                     do j=1,dimgy
                     do i=1,dimgx
                        call llacar (xyz2,lons(i,j),lats(i,j),1,1)
                        xyz2(1) = xyz1(1)-xyz2(1)
                        xyz2(2) = xyz1(2)-xyz2(2)
                        xyz2(3) = xyz1(3)-xyz2(3)
                        c = sqrt( xyz2(1)**2 + xyz2(2)**2 + xyz2(3)**2 )
                        if ( c .lt. difmin ) then
                             difmin= c
                             numi = i
                             numj = j
                        endif
                     enddo
                     enddo
                     if (numi.eq.1.or.numj.eq.1) then
                     write(6,*)'Abort: Insufficient coverage from LAM Analysis'
                        call e_arret('e_specanal')
                     else 
                        print *,'numi=',numi,' numj=',numj
                     endif
                  enddo
              endif
          endif
* create U,V target grid
          allocate(xpxu(nia-1))
          do i=1,nia-2
             xpxu(i)= 0.5 * ( xpx(i) + xpx(i+1) )
          enddo
          xpxu(nia-1) = ( xpx(nia-1) + xpx(nia) )
          allocate(ypxv(nja-1))
          do i=1,nja-2
             ypxv(i)= 0.5 * ( ypx(i) + ypx(i+1) )
          enddo
          ypxv(nja-1) = ( ypx(nja-1) + ypx(nja) )


          if (e_ac_posi(xpx,ypx,nia,nja,Pil_hblen+Pil_pil,hollow).eq.0) then

              print *,'e_specanal: hpalloc nja=',nja,'lv=',lv
              call hpalloc(paygv_8   ,  (nja-1)*2, err,1)
              do j=1,nja-1
                 ygv_8(j)  = ypxv(j) * deg2rad_8
              enddo
              if (anal_hav(2).eq.1.or.anal_hav(2).eq.2) then 
                 print *,'cannot treat eta/hyb analysis for bcs'
                 stop
                 call genab ( pia, pibb, levm, ptopa, rcoefa, LV)
                 do i=1,LV
                    pib(i) = pibb(i)*Cstv_pisrf_8
                 enddo
              else if (anal_hav(2).eq.6) then
                   allocate(levm_8(lv))
                   do i=1,lv
                      levm_8(i) = levm(i) 
                   enddo
c
c       Get special levels for momentum, thermo
                   call genab_8 (kcode,za_8,zb_8,zat_8,zbt_8,levm_8,
     $                  100.0d0*ptopa, 100.0d0*prefa,rcoefa,lv)
c       Compute the real momentum and thermo levels
                   zat_8(1) = log(100.0d0*ptopa)
                   zbt_8(1) = 0.0d0
                   zat_8(lv+1) = 0.0d0
                   zbt_8(lv+1) = 1.0d0
                   deallocate(levm_8)
              endif
              dstf_gid = ezgdef_fmem (e_grdc_ni, e_grdc_nj , 'Z', 'E', Hgc_ig1ro,
     $        Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xpx(e_grdc_gid), ypx(e_grdc_gjd) )
              dstu_gid = ezgdef_fmem (e_grdc_ni, e_grdc_nj , 'Z', 'E', Hgc_ig1ro,
     $        Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xpxu(e_grdc_gid), ypx(e_grdc_gjd) )
              dstv_gid = ezgdef_fmem (e_grdc_ni, e_grdc_nj , 'Z', 'E', Hgc_ig1ro,
     $        Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xpx(e_grdc_gid), ypxv(e_grdc_gjd) )
          else
            write(6,*)' Abort: Insufficient coverage in Analysis'
            call e_arret('e_specanal')
          endif
          deallocate(levm)
          deallocate(xpx)
          deallocate(ypx)
          done = .true.
      endif
      if (Pil_bcs_hollow_L) Pil_bcs_hollow_L = hollow
      if (Pil_bmf_L) then
         call e_bmfsplitxy2 (topo ,nifi,njfi,'ME  ',1,1,pni ,0,0,0)
         call e_bmfsplitxy2 (topou,niu ,nju ,'TOPU',1,1,pniu,0,0,0)
         call e_bmfsplitxy2 (topov,niv ,njv ,'TOPV',1,1,pni ,0,0,0)
         call bmf_splitwrall ('RNA ',LV,1,1,Bmf_time1,Bmf_time2, 
     $                                    0,0,bmf_dtyp,0,RNA)
         if (Anal_hyb_L.or.Anal_eta_L) then
             call bmf_splitwrall ('PTOP',1,1,1,Bmf_time1,Bmf_time2
     $                                  ,0,0,bmf_dtyp,0,ptopa)
             call bmf_splitwrall ('PREF',1,1,1,Bmf_time1,Bmf_time2
     $                                  ,0,0,bmf_dtyp,0,prefa)
             call bmf_splitwrall ('RCOF',1,1,1,Bmf_time1,Bmf_time2
     $                                 ,0,0,bmf_dtyp,0,rcoefa)
             if (anal_hav(2).eq.6) 
     $       call bmf_splitwrall ('KCOD',1,1,1,Bmf_time1,Bmf_time2
     $                                  ,0,0,40,0,kcode)
         endif
      else
         if (Pil_bcs_hollow_L) then
            call bcs_hollow(e_grdc_gid,e_grdc_gif,e_grdc_gjd,e_grdc_gjf,
     $          e_grdc_gjdi,e_grdc_hbsn,e_grdc_hbwe,is,nis,js,njs,
     $          jn,iw,niw,ie,jw,njw)
            call e_sfile_bcs (pdate,is,nis,js,jn,njs,
     $              iw,ie,niw,jw,njw,'DYNAMICS',nvar)
         else
            call e_sfile_3df (pdate,'DYNAMICS',
     $             e_grdc_gid,e_grdc_gif,e_grdc_gjd,e_grdc_gjf, nvar)
         endif
      endif
*
 101  format ('|',2x,'   Off-line Mode: Only One Level Used:',1x,I5,10x,'|')
 130  format ('|',9('-'),'+',5('-'),'+',8('-'),'+',8('-'),'+',5('-'),
     $        '+',5('-'),'+',10('-'),'|')
 201  format ('|',2x,'   Search First Infos on Variable:',1x,A3,16x,'|')
 801  format (' LEVEL anal = ',d15.8,2X,' k = ',i4,' IP1= ',I8)
 900  format (a/a,i5,a,e14.7,a,e14.7,a/'   >>>>> ABORT <<<<<')
 1001 format(/,'EXTRACTION OF ANALYSIS LEVELS (S/R E_SPECANAL)',/40('-'))
 1002 format(' DATE = ', 6i5 , 7a4 , i10 )
 4000 format(/,'CANNOT FIND TIC TACS in ANALYSIS (S/R E_SPECANAL)',/40('-'))
*
* ---------------------------------------------------------------------
*
      return
      end
