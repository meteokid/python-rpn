!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/r adw_main_3_intlag - Interpolation of rhs
*
#include "model_macros_f.h"
#include "msg.h"
*
      subroutine adw_main_3_intlag2(F_u, F_v, F_w, F_isStatStep)
*
      implicit none
      real F_u(*), F_v(*), F_w(*)
      logical F_isStatStep
*
*author
*     alain patoine
*
*revision
* v2_31 - Desgagne & Tanguay  - removed stkmemw, introduce tracers
* v2_31                       - tracers not monotone if V4dg_conf.ne.0
* v2_31 - R.Moffet            - do precalc (zz1) for ZZ in blomega
* v3_00 - Desgagne & Lee      - Lam configuration
* v3_02 - Tanguay             - Restore tracers monotone if V4dg_conf.ne.0 
* v3_02 - Lee V.              - revert adw_exch_1 for GLB only, 
* v3_02                         added adw_ckbd_lam,adw_cfl_lam for LAM only
* v3_03 - Tanguay M.          - stop if adw_exch_1 is activated when 4D-Var
* v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
* v3_11 - Gravel S.           - introduce key Adw_mono_L 
* v3_20 - Gravel & Valin & Tanguay - Lagrange 3D
* v3_20 - Tanguay M.          - Improve alarm when points outside advection grid
* v3_20 - Dugas B.            - correct calculation for LAM when Glb_pil gt 7
* v3_21 - Desgagne M.         - if  Lagrange 3D, call adw_main_3_intlag
* v4_04 - Tanguay M.          - Staggered version TL/AD
* v4_05 - Lepine M.           - VMM replacement with GMM
*
*language
*     fortran 77
*
*object
*     see id section
*
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
*        |                                                       |     |
*        |                                                       |     |
* F_u,F_v| 3 components of upstream positions at t1 at input     |  iw |
* F_w    | used as work field afterward                          |     |
*________|_______________________________________________________|_____|
*
*implicits
#include "gmm.hf"
#include "var_gmm.cdk"
!      type(gmm_metadata) :: meta3d
!      integer :: gmmstat
#include "glb_ld.cdk"
!      logical G_lam
!      logical l_north, l_south, l_east, l_west
!      integer l_ni, l_nj, l_nk, l_niu, l_njv
!      integer l_minx, l_maxx, l_miny, l_maxy
!      integer pil_n,pil_s,pil_w,pil_e
#include "orh.cdk"
!      logical Orh_crank_L
!      integer Orh_icn
!      real, pointer, dimension (:,:,:) :: orhst,orhsc,orhsw,orhsf
!      character(len=8) :: gmmk_orhst_s,gmmk_orhsc_s,gmmk_orhsw_s,gmmk_orhsf_s
#include "schm.cdk"
!      logical Schm_zdotlag_L,Schm_zdotMid_L,Schm_hydro_L
!      integer Schm_itcn
#include "cstv.cdk"
!      real*8    Cstv_tau_8
#include "rhsc.cdk"
!      real, pointer, dimension (:,:,:) :: ruw1,rvw1,ruw2,rvw2
!      real, pointer, dimension (:,:,:) :: rhst,rhsc,rhsw,rhsf
!      character(len=8) :: gmmk_rhst_s,gmmk_rhsc_s
!      character(len=8) :: gmmk_rhsw_s,gmmk_rhsf_s
!      character(len=8) :: gmmk_ruw1_s,gmmk_rvw1_s,gmmk_ruw2_s,gmmk_rvw2_s
#include "v4dg.cdk"
!      integer V4dg_conf
#include "adw.cdk"
c$$$      logical Adw_mono_L,Adw_ckbd_L
c$$$      integer            Adw_nit, Adw_njt
c$$$      integer            Adw_for_n, Adw_for_s, Adw_for_a
c$$$      integer            Adw_fro_n, Adw_fro_s, Adw_fro_a
c$$$      integer            Adw_trunc(4)
c$$$      DCL_DYNVAR(Adw,  capx1,    real   , (*))
c$$$      DCL_DYNVAR(Adw,  capy1,    real   , (*))
c$$$      DCL_DYNVAR(Adw,  capz1,    real   , (*))
c$$$      DCL_DYNVAR(Adw,  capx2,    real   , (*))
c$$$      DCL_DYNVAR(Adw,  capy2,    real   , (*))
c$$$      DCL_DYNVAR(Adw,  capz2,    real   , (*))
c$$$      DCL_DYNVAR(Adw,     n1,    real   , (*))
c$$$      DCL_DYNVAR(Adw,     n2,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   xdd1,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   ydd1,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   xgg1,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   ygg1,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   xdd2,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   ydd2,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   xgg2,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   ygg2,    real   , (*))
c$$$      DCL_DYNVAR(Adw,    cz1,    real   , (*))
c$$$      DCL_DYNVAR(Adw,    cz2,    real   , (*))
c$$$      DCL_DYNVAR(Adw,     c1,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   wrka,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   wrkb,    real   , (*))
c$$$      DCL_DYNVAR(Adw,   wrkc,    real   , (*))
#include "tr3d.cdk"
!      integer MAXTR3D
!      parameter ( MAXTR3D = 250 )
!      character*4 Tr3d_name_S(MAXTR3D)
!      integer Tr3d_ntr
#include "vt1.cdk"
!      real, pointer, dimension (:,:,:) :: wt1,zdt1,zz1,wup,zdup,fipt1
!      character(len=8) :: gmmk_wt1_s,gmmk_zdt1_s,gmmk_zz1_s,gmmk_wup_s,gmmk_zdup_s,gmmk_fipt1_s
#include "ver.cdk"
!      #include "type.cdk"
!      type (vertical_8) Ver_idz_8  
!      type (vertical_8) Ver_wp_8
!      type (vertical_8) Ver_wm_8
c$$$#include "acid.cdk"
!      logical acid_test_l
*
*modules
************************************************************************
*
      integer ier,longueur
      integer n, nij, nijkt, nijkm, nijkad, cnt, unf
      integer i,j,k, n1,n2,np,i0,j0,in,jn,dim,err
*
      real*8 aaa
      real, allocatable, dimension(:) :: pos_x, pos_y, pos_z
      real, pointer    , dimension(:,:,:) :: tr0,tr1
*
      call msg(MSG_DEBUG,
     $     'ADVECT THE RIGHT-HAND-SIDES: (S/R ADW_MAIN_3_INTLAG)')
      nij    = l_ni   *l_nj
      nijkt  = l_ni   *l_nj   *(l_nk+1)
      nijkm  = l_ni   *l_nj   * l_nk
      nijkad = Adw_nit*Adw_njt*(l_nk+1)
      call hpalloc(Adw_capx1_   ,nijkt,      err,1)
      call hpalloc(Adw_capy1_   ,nijkt,      err,1)
      call hpalloc(Adw_capz1_   ,nijkt,      err,1)
      call hpalloc(Adw_n1_      ,nijkt,      err,1)
      call hpalloc(Adw_xdd1_    ,nijkt,      err,1)
      call hpalloc(Adw_xgg1_    ,nijkt,      err,1)
      call hpalloc(Adw_ydd1_    ,nijkt,      err,1)
      call hpalloc(Adw_ygg1_    ,nijkt,      err,1)
      call hpalloc(Adw_cz1_     ,nijkt,      err,1)
      call hpalloc(Adw_c1_      ,nijkt,      err,1)
      call hpalloc(Adw_wrkb_    ,nijkt,      err,1)
      call hpalloc(Adw_wrkc_    ,nijkt,      err,1)
*
      allocate ( pos_x(nijkad) )
      allocate ( pos_y(nijkad) )
      allocate ( pos_z(nijkad) )
*
************************************************************************

      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west)  i0=pil_w
          if (l_east)  in=l_niu - pil_e + 2
          if (l_south) j0=pil_s
          if (l_north) jn=l_njv - pil_n + 2
      endif

***********************************************************************
* Prepare for advection on momentum levels
***********************************************************************
!
!$omp parallel do private(n)
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         pos_x(n) =  F_u(n)
         pos_y(n) =  F_v(n)
         pos_z(n) =  F_w(n)
      enddo
      enddo
      enddo
!$omp end parallel do

      if (G_lam) then
*
          if (((.not.Orh_crank_L) .or. Orh_icn.eq.Schm_itcn) .and. F_isStatStep)
     $         call adw_cfl_lam ( pos_x, pos_y, pos_z, 
     $                            i0, in, j0, jn, l_nk,'m' )
          call adw_cliptraj( pos_x, pos_y, i0, in, j0, jn, l_nk, 'INTERP MT')
          if (V4dg_conf .ne. 0.) then
              err = 0
              if ((Adw_trunc(1) + Adw_trunc(2) +
     $             Adw_trunc(3) + Adw_trunc(4)) > 0) err = -1
              call handle_error(err,'adw_main_3_intlag','TLM-ADJ NOT done: INCREASE HALO')
          endif
      endif
*
      if (.not.G_lam) then
      call adw_exch_1 ( Adw_n1, Adw_xgg1, Adw_xdd1, Adw_c1,
     $                  pos_x, pos_y, pos_z, l_nk )
*
          if (V4dg_conf .ne. 0.) then
              err = 0
              if (Adw_fro_a > 0) err = -1
              call handle_error(err,'adw_main_3_intlag','TLM-ADJ NOT done: INCREASE HALO')
          endif
*
      dim = max(1,Adw_fro_a)
      call hpalloc(Adw_capx2_   ,dim,      err,1)
      call hpalloc(Adw_capy2_   ,dim,      err,1)
      call hpalloc(Adw_capz2_   ,dim,      err,1)
      call hpalloc(Adw_n2_      ,dim,      err,1)
      call hpalloc(Adw_xdd2_    ,dim,      err,1)
      call hpalloc(Adw_xgg2_    ,dim,      err,1)
      call hpalloc(Adw_ydd2_    ,dim,      err,1)
      call hpalloc(Adw_ygg2_    ,dim,      err,1)
      call hpalloc(Adw_cz2_     ,dim,      err,1)
      call hpalloc(Adw_wrka_    ,dim,      err,1)
*
      call adw_exch_2 ( Adw_capx2, Adw_capy2, Adw_capz2,
     %                  Adw_n1, Adw_xgg1, Adw_xdd1,
     %                  Adw_fro_n, Adw_fro_s, Adw_fro_a,
     %                  Adw_for_n, Adw_for_s, Adw_for_a, 3 )
*
*
      if ( Adw_fro_a .gt. 0 .and. Adw_ckbd_L ) 
     %                            call adw_ckbd ( Adw_capy2 )
 
*  
      endif
*
***********************************************************************
* Perform interpolation on momentum levels
***********************************************************************
      gmmstat = gmm_get(gmmk_ruw1_s,ruw1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(ruw1)'
      gmmstat = gmm_get(gmmk_rvw1_s,rvw1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(rvw1)'
      gmmstat = gmm_get(gmmk_ruw2_s,ruw2,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(ruw2)'
      gmmstat = gmm_get(gmmk_rvw2_s,rvw2,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(rvw2)'
      gmmstat = gmm_get(gmmk_rhsc_s,rhsc,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(rhsc)'
      gmmstat = gmm_get(gmmk_wup_s,wup,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(wup)'
      gmmstat = gmm_get(gmmk_wt1_s,wt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(wt1)'
      gmmstat = gmm_get(gmmk_zdup_s,zdup,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(zdup)'
      gmmstat = gmm_get(gmmk_zdt1_s,zdt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(zdt1)'
      gmmstat = gmm_get(gmmk_zz1_s,zz1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(zz1)'
      gmmstat = gmm_get(gmmk_fipt1_s,fipt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(fipt1)'
      gmmstat = gmm_get(gmmk_orhsc_s,orhsc,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(orhsc)'

*     ----------------------------
*     Keep positions in CAP fields
*     ----------------------------
*
c$$$      if (Acid_test_L)call acid_stat_adw_main_3_intlag(ruw1,ruw2,rvw2,1)
*
!$omp parallel private(n)
!$omp do
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         Adw_capx1(n) = pos_x(n)
         Adw_capy1(n) = pos_y(n)
         Adw_capz1(n) = pos_z(n)
      end do
      end do
      end do
!$omp enddo
*
      call adw_interp2 (ruw2, ruw1, pos_x, pos_y,
     %                 .true., .false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
      call adw_interp2 (rvw2, rvw1, pos_x, pos_y,
     %                 .true., .false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
      call adw_interp2 (rhsc , orhsc , pos_x, pos_y,
     %                 .false.,.false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
c$$$      if (Acid_test_L)call acid_stat_adw_main_3_intlag(ruw1,ruw2,rvw2,2)
*
      if(Schm_zdotlag_L) then
!$omp do
         do k=1,l_nk+1
            do j=1,l_nj
            do i=1,l_ni
               zz1(i,j,k)=.5d0*(fipt1(i,j,k)+fipt1(i,j,k-1))
            enddo
            enddo
         enddo
!$omp enddo
*
*     Note : optimizing on j due to dependency on k
!$omp do
         do j=1,l_nj
            do k=1,l_nk
            do i=1,l_ni
               zz1(i,j,k)=(zz1(i,j,k+1)-zz1(i,j,k))*Ver_idz_8%m(k)
            end do
            end do
         end do
!$omp enddo
*
*        applying the standard averaging
!$omp do
         do k=1,l_nk
            do j=1,l_nj
            do i=1,l_ni
               wup(i,j,k) = Ver_wp_8%m(k) * wt1(i,j,k+1)
     %                     +Ver_wm_8%m(k) * wt1(i,j,k)
            enddo
            enddo
         enddo
!$omp enddo
*
         call adw_interp2 (wup,wup, pos_x, pos_y, 
     %        .false.,.false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')         
*
         call adw_interp2 (zz1,zz1, pos_x, pos_y, 
     %        .false.,.false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')         
*
      else if(Schm_zdotmid_L) then
*
!$omp do
         do k=1,l_nk
            do j=1,l_nj
            do i=1,l_ni
               zdup(i,j,k) = Ver_wp_8%m(k)*zdt1(i,j,k+1)
     %                      +Ver_wm_8%m(k)*zdt1(i,j,k)
               enddo
            enddo
         enddo
!$omp enddo
*
         call adw_interp2 (zdup,zdup, pos_x, pos_y, 
     %        .false.,.false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')         
*
      endif
*
!$omp end parallel

      if (.not.G_lam) then
      call hpdeallc(Adw_capx2_   ,err,1)
      call hpdeallc(Adw_capy2_   ,err,1)
      call hpdeallc(Adw_capz2_   ,err,1)
      call hpdeallc(Adw_n2_      ,err,1)
      call hpdeallc(Adw_xdd2_    ,err,1)
      call hpdeallc(Adw_xgg2_    ,err,1)
      call hpdeallc(Adw_ydd2_    ,err,1)
      call hpdeallc(Adw_ygg2_    ,err,1)
      call hpdeallc(Adw_cz2_     ,err,1)
      call hpdeallc(Adw_wrka_    ,err,1)
      endif
*
***********************************************************************
* Prepare for advection on thermodynamic levels
***********************************************************************
!     from upstream position for momentum levels to upstream
!     position for thermodynamic levels
!
      call adw_meanpos(pos_x, pos_y, pos_z, F_u, F_v, F_w, i0,in,j0,jn)

      if (G_lam) then
          if (((.not.Orh_crank_L) .or. Orh_icn.eq.Schm_itcn) .and. F_isStatStep)
     $         call adw_cfl_lam ( pos_x, pos_y, pos_z, 
     $                            i0, in, j0, jn, l_nk+1, 't')
          call adw_cliptraj( pos_x, pos_y, i0, in, j0, jn, l_nk+1, 'INTERP TH')
*
      endif
*
      if (.not.G_lam) then
         call adw_exch_1 ( Adw_n1, Adw_xgg1, Adw_xdd1, Adw_c1,
     $                  pos_x, pos_y, pos_z, l_nk+1 )
*
         if (V4dg_conf .ne. 0.) then
             err = 0
             if (Adw_fro_a > 0) err = -1
             call handle_error(err,'adw_main_3_intlag','TLM-ADJ NOT done: INCREASE HALO')
         endif
*
         dim = max(1,Adw_fro_a)
         call hpalloc(Adw_capx2_   ,dim,      err,1)
         call hpalloc(Adw_capy2_   ,dim,      err,1)
         call hpalloc(Adw_capz2_   ,dim,      err,1)
         call hpalloc(Adw_n2_      ,dim,      err,1)
         call hpalloc(Adw_xdd2_    ,dim,      err,1)
         call hpalloc(Adw_xgg2_    ,dim,      err,1)
         call hpalloc(Adw_ydd2_    ,dim,      err,1)
         call hpalloc(Adw_ygg2_    ,dim,      err,1)
         call hpalloc(Adw_cz2_     ,dim,      err,1)
         call hpalloc(Adw_wrka_    ,dim,      err,1)

         call adw_exch_2 ( Adw_capx2, Adw_capy2, Adw_capz2,
     %                     Adw_n1, Adw_xgg1, Adw_xdd1,
     %                     Adw_fro_n, Adw_fro_s, Adw_fro_a,
     %                     Adw_for_n, Adw_for_s, Adw_for_a, 3 )
*
         if ( Adw_fro_a .gt. 0 .and. Adw_ckbd_L ) call adw_ckbd ( Adw_capy2 )
*
      endif
*
***********************************************************************
* Perform interpolation for equations on thermodynamic levels
***********************************************************************
      gmmstat = gmm_get(gmmk_rhst_s,rhst,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(rhst)'
      gmmstat = gmm_get(gmmk_rhsf_s,rhsf,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(rhsf)'
      gmmstat = gmm_get(gmmk_orhst_s,orhst,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(orhst)'
      gmmstat = gmm_get(gmmk_orhsf_s,orhsf,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(orhsf)'
      if (.not. Schm_hydro_L) then
         gmmstat = gmm_get(gmmk_rhsw_s,rhsw,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(rhsw)'
         gmmstat = gmm_get(gmmk_orhsw_s,orhsw,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_intlag ERROR at gmm_get(orhsw)'
      endif
*
*     ----------------------------
*     Keep positions in CAP fields
*     ----------------------------
!$omp parallel private(n)
!$omp do
      do k=1,l_nk+1
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         Adw_capx1(n) = pos_x(n)
         Adw_capy1(n) = pos_y(n)
         Adw_capz1(n) = pos_z(n)
      end do
      end do
      end do
!$omp enddo
*
      call adw_interp2 (rhst, orhst, pos_x, pos_y, 
     %                 .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
      call adw_interp2 (rhsf, orhsf, pos_x, pos_y, 
     %                 .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
      if (.not. Schm_hydro_L) then
         call adw_interp2 (rhsw, orhsw, pos_x, pos_y, 
     %                 .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
      endif
*
cap      if(.not.G_lam)then
cap         if(Orh_icn.eq.Schm_itcn)then
cap*
cap!$omp do
cap            do k=1,l_nk+1
cap               do j=j0,jn
cap               do i=i0,in
cap                  piup(i,j,k)=exp(Ver_z_8%t(k) + Ver_b_8%t(k)*st1(i,j))
cap               enddo
cap               enddo
cap            enddo
cap!$omp enddo
cap*
cap            call adw_interp2 (piup,piup, pos_x, pos_y, 
cap     %           .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')         
cap*
cap         endif
cap      endif
cap*
!$omp end parallel
*
      if ( (Orh_icn .eq. Schm_itcn) ) then
*
* tr3d advection,
*
*
         aaa = -1.d0 / Cstv_tau_8
*
         do n=1,Tr3d_ntr
            nullify (tr0,tr1)
	    gmmstat = gmm_get('TR/'//trim(Tr3d_name_S(n))//':M',tr0,meta3d)
	    gmmstat = gmm_get('TR/'//trim(Tr3d_name_S(n))//':P',tr1,meta3d)

!$omp parallel
!$omp do
            do k=1,l_nk+1
            do j=1,l_nj
            do i=1,l_ni
               tr0(i,j,k) = - aaa*tr1(i,j,k)
            end do
            end do
            end do
!$omp enddo
            call adw_interp2 ( tr0, tr0, pos_x, pos_y,
     %               .false. , Adw_mono_L, LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
!$omp do
            do k=1,l_nk+1
            do j=1,l_nj
            do i=1,l_ni
               tr0(i,j,k) = Cstv_tau_8*tr0(i,j,k)
            end do
            end do
            end do
!$omp enddo
!$omp end parallel

         end do
*
      endif

***********************************************************************
* Deallocate
***********************************************************************
      call hpdeallc(Adw_capx1_   ,err,1)
      call hpdeallc(Adw_capy1_   ,err,1)
      call hpdeallc(Adw_capz1_   ,err,1)
      call hpdeallc(Adw_n1_      ,err,1)
      call hpdeallc(Adw_xdd1_    ,err,1)
      call hpdeallc(Adw_xgg1_    ,err,1)
      call hpdeallc(Adw_ydd1_    ,err,1)
      call hpdeallc(Adw_ygg1_    ,err,1)
      call hpdeallc(Adw_cz1_     ,err,1)
      call hpdeallc(Adw_c1_      ,err,1)
      call hpdeallc(Adw_wrkb_    ,err,1)
      call hpdeallc(Adw_wrkc_    ,err,1)
      if (.not.G_lam) then
      call hpdeallc(Adw_capx2_   ,err,1)
      call hpdeallc(Adw_capy2_   ,err,1)
      call hpdeallc(Adw_capz2_   ,err,1)
      call hpdeallc(Adw_n2_      ,err,1)
      call hpdeallc(Adw_xdd2_    ,err,1)
      call hpdeallc(Adw_xgg2_    ,err,1)
      call hpdeallc(Adw_ydd2_    ,err,1)
      call hpdeallc(Adw_ygg2_    ,err,1)
      call hpdeallc(Adw_cz2_     ,err,1)
      call hpdeallc(Adw_wrka_    ,err,1)
      endif
*
      deallocate (pos_x,pos_y,pos_z)
*
      return
      end
