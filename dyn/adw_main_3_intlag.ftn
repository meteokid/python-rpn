***s/r adw_main_3_intlag - Interpolation of rhs
*
#include "model_macros_f.h"
*
      subroutine adw_main_3_intlag ( F_u, F_v, F_w )
*
      implicit none
      real F_u(*), F_v(*), F_w(*)
*
*author
*     alain patoine
*
*revision
* v2_31 - Desgagne & Tanguay  - removed stkmemw, introduce tracers
* v2_31                       - tracers not monotone if V4dg_conf.ne.0
* v2_31 - R.Moffet            - do precalc (zz1) for ZZ in blomega
* v3_00 - Desgagne & Lee      - Lam configuration
* v3_02 - Tanguay             - Restore tracers monotone if V4dg_conf.ne.0 
* v3_02 - Lee V.              - revert adw_exch_1 for GLB only, 
* v3_02                         added adw_ckbd_lam,adw_cfl_lam for LAM only
* v3_03 - Tanguay M.          - stop if adw_exch_1 is activated when 4D-Var
* v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
* v3_11 - Gravel S.           - introduce key Adw_mono_L 
* v3_20 - Gravel & Valin & Tanguay - Lagrange 3D
* v3_20 - Tanguay M.          - Improve alarm when points outside advection grid
* v3_20 - Dugas B.            - correct calculation for LAM when Glb_pil gt 7
* v3_21 - Desgagne M.         - if  Lagrange 3D, call adw_main_3_intlag
*
*language
*     fortran 77
*
*object
*     see id section
*
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
*        |                                                       |     |
*        |                                                       |     |
* F_u,F_v| 3 components of upstream positions at t1 at input     |  iw |
* F_w    | used as work field afterward                          |     |
*________|_______________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "ptopo.cdk"
#include "geomg.cdk"
#include "orh.cdk"
#include "lctl.cdk"
#include "step.cdk"
#include "lun.cdk"
#include "schm.cdk"
#include "offc.cdk"
#include "cstv.cdk"
#include "rhsc.cdk"
#include "v4dg.cdk"
#include "type.cdk"
#include "adw.cdk"
#include "tr3d.cdk"
#include "vt1.cdk"
#include "vt0.cdk"
#include "vtx.cdk"
#include "ver.cdk"
#include "matlab.cdk"
*
*modules
      integer  vmmlod, vmmget, vmmuld
      external vmmlod, vmmget, vmmuld
************************************************************************
      integer i0,in,j0,jn
      integer pnerr, pnlkey1(30), key1(Tr3d_ntr), key0(Tr3d_ntr), 
     $        key1_, key0_, pnlod, err, dim
*
      integer outside,sum_outside,ier,longueur
*
      integer n, nij, nijkt, nijkm, nijkad, cnt, unf
      integer i,j,k, n1,n2,np 
      integer*8 pnt_trt1(Tr3d_ntr),pnt_trt0(Tr3d_ntr)
*      integer m, ntr2do, j2do
      integer DIST_DIM
*
      real*8 aaa
      real tr,tr0,buf(l_ni,G_nk+1), half
      real work(LDIST_SHAPE,G_nk+1),work2(LDIST_SHAPE,G_nk+1)
      real ytmp(LDIST_SHAPE),xtmp(LDIST_SHAPE)
      parameter( half = 0.5 )
      pointer (patr, tr(LDIST_SHAPE,*)),(patr0, tr0(LDIST_SHAPE,*))
      real, allocatable, dimension(:) :: pos_x, pos_y, pos_z
*
      if (Lun_debug_L) write (Lun_out,1000)
      nij    = l_ni   *l_nj
      nijkt  = l_ni   *l_nj   *(l_nk+1)
      nijkm  = l_ni   *l_nj   * l_nk
      nijkad = Adw_nit*Adw_njt*(l_nk+1)
      call hpalloc(Adw_capx1_   ,nijkt,      err,1)
      call hpalloc(Adw_capy1_   ,nijkt,      err,1)
      call hpalloc(Adw_capz1_   ,nijkt,      err,1)
      call hpalloc(Adw_n1_      ,nijkt,      err,1)
      call hpalloc(Adw_xdd1_    ,nijkt,      err,1)
      call hpalloc(Adw_xgg1_    ,nijkt,      err,1)
      call hpalloc(Adw_ydd1_    ,nijkt,      err,1)
      call hpalloc(Adw_ygg1_    ,nijkt,      err,1)
      call hpalloc(Adw_cz1_     ,nijkt,      err,1)
      call hpalloc(Adw_c1_      ,nijkt,      err,1)
      call hpalloc(Adw_wrkb_    ,nijkt,      err,1)
      call hpalloc(Adw_wrkc_    ,nijkt,      err,1)
*
      allocate ( pos_x(nijkad) )
      allocate ( pos_y(nijkad) )
      allocate ( pos_z(nijkad) )
*
************************************************************************

      if(matlab_write_L.and.Ptopo_myproc.eq.0)then
         open(unit=62,file=
     $        matlab_dir_S(1:longueur(matlab_dir_S))//'from_fortran_adw_main_3_int.bin',
     $        status='replace',form='unformatted')
         write(62)G_ni-lam_pil_w-lam_pil_e
         write(62)G_nk
      endif

      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west)  i0=4       + (Glb_pil_w - 7)
          if (l_east)  in=l_niu-2 - (Glb_pil_e - 7)
          if (l_south) j0=4       + (Glb_pil_s - 7)
          if (l_north) jn=l_njv-2 - (Glb_pil_n - 7)
      endif

***********************************************************************
* Prepare for advection on momentum levels
***********************************************************************
!
!$omp parallel do private(n)
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         pos_x(n) =  F_u(n)
         pos_y(n) =  F_v(n)
         pos_z(n) =  F_w(n)
      enddo
      enddo
      enddo
!$omp end parallel do

      if (G_lam) then
          if ( ((.not.Orh_crank_L).or.(Orh_icn.eq.Schm_itcn)) .and.
     $         (mod(Lctl_step,Step_gstat).eq.0) )
     $         call adw_cfl_lam ( pos_x, pos_y, pos_z, 
     $                            i0, in, j0, jn, l_nk,'m' )
          call adw_ckbd_lam( pos_x, pos_y, pos_z, i0, in, j0, jn, l_nk )
          if ( V4dg_conf.ne.0.0 ) then
             call gem_stop('adw_main_3_intlag : ajouter code')            
          endif
      endif
*
      if (.not.G_lam) then
      call adw_exch_1 ( Adw_n1, Adw_xgg1, Adw_xdd1, Adw_c1,
     $                  pos_x, pos_y, pos_z, l_nk )
*
          if ( V4dg_conf.ne.0.0 ) then
*
               outside = 0
*
               if ( Adw_fro_a .gt. 0 ) outside = 1
*
               sum_outside = 0
               call rpn_comm_Allreduce(outside,sum_outside,1,"MPI_INTEGER",
     $                                 "MPI_SUM","grid",ier)
*
               if(sum_outside.ne.0) call gem_stop ('ADW_MAIN_3_INT: TLM-ADJ NOT done: INCREASE HALO',-1)
*
          endif
*
      dim = max(1,Adw_fro_a)
      call hpalloc(Adw_capx2_   ,dim,      err,1)
      call hpalloc(Adw_capy2_   ,dim,      err,1)
      call hpalloc(Adw_capz2_   ,dim,      err,1)
      call hpalloc(Adw_n2_      ,dim,      err,1)
      call hpalloc(Adw_xdd2_    ,dim,      err,1)
      call hpalloc(Adw_xgg2_    ,dim,      err,1)
      call hpalloc(Adw_ydd2_    ,dim,      err,1)
      call hpalloc(Adw_ygg2_    ,dim,      err,1)
      call hpalloc(Adw_cz2_     ,dim,      err,1)
      call hpalloc(Adw_wrka_    ,dim,      err,1)
*
      call adw_exch_2 ( Adw_capx2, Adw_capy2, Adw_capz2,
     %                  Adw_n1, Adw_xgg1, Adw_xdd1,
     %                  Adw_fro_n, Adw_fro_s, Adw_fro_a,
     %                  Adw_for_n, Adw_for_s, Adw_for_a, 3 )
*
*
      if ( Adw_fro_a .gt. 0 .and. Adw_ckbd_L ) 
     %                            call adw_ckbd ( Adw_capy2 )
 
*  
      endif
*
***********************************************************************
* Perform interpolation
***********************************************************************
      pnlkey1(1) = VMM_KEY(ruw1)
      pnlkey1(2) = VMM_KEY(rvw1)
      pnlkey1(3) = VMM_KEY(ruw2)
      pnlkey1(4) = VMM_KEY(rvw2)
      pnlkey1(5) = VMM_KEY(rcn)
      pnlkey1(6) = VMM_KEY(fiptx)
      pnlkey1(7) = VMM_KEY(zz1)
      pnlkey1(8) = VMM_KEY(piup)
      pnlkey1(9) = VMM_KEY(st1)
      pnlod = 9
*
      pnerr = vmmlod(pnlkey1,pnlod)
*
      pnerr =  VMM_GET_VAR(ruw1)
      pnerr =  VMM_GET_VAR(rvw1)
      pnerr =  VMM_GET_VAR(ruw2)
      pnerr =  VMM_GET_VAR(rvw2)
      pnerr =  VMM_GET_VAR(rcn)
      pnerr =  VMM_GET_VAR(fiptx)
      pnerr =  VMM_GET_VAR(zz1)
      pnerr =  VMM_GET_VAR(piup)
      pnerr =  VMM_GET_VAR(st1)
*     ----------------------------
*     Keep positions in CAP fields
*     ----------------------------
!$omp parallel private(n)
!$omp do
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         Adw_capx1(n) = pos_x(n)
         Adw_capy1(n) = pos_y(n)
         Adw_capz1(n) = pos_z(n)
      end do
      end do
      end do
!$omp enddo
*
      call adw_interp2 (ruw2, ruw1, pos_x, pos_y,
     %                 .true., .false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
 
*
      call adw_interp2 (rvw2, rvw1, pos_x, pos_y,
     %                 .true., .false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
      call adw_interp2 (rcn , rcn , pos_x, pos_y,
     %                 .false.,.false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
!$omp end parallel

      if (.not.G_lam) then
      call hpdeallc(Adw_capx2_   ,err)
      call hpdeallc(Adw_capy2_   ,err)
      call hpdeallc(Adw_capz2_   ,err)
      call hpdeallc(Adw_n2_      ,err)
      call hpdeallc(Adw_xdd2_    ,err)
      call hpdeallc(Adw_xgg2_    ,err)
      call hpdeallc(Adw_ydd2_    ,err)
      call hpdeallc(Adw_ygg2_    ,err)
      call hpdeallc(Adw_cz2_     ,err)
      call hpdeallc(Adw_wrka_    ,err)
      endif
*
***********************************************************************
* Prepare for advection on thermodynamic levels
***********************************************************************
!     from upstream position for momentum levels to upstream
!     position for thermodynamic levels
!
      call adw_meanpos(pos_x, pos_y, pos_z, F_u, F_v, F_w, i0,in,j0,jn)

      if (G_lam) then
          if ( ((.not.Orh_crank_L).or.(Orh_icn.eq.Schm_itcn)) .and.
     $         (mod(Lctl_step,Step_gstat).eq.0) )
     $         call adw_cfl_lam ( pos_x, pos_y, pos_z, 
     $                            i0, in, j0, jn, l_nk+1, 't')
          call adw_ckbd_lam( pos_x, pos_y, pos_z, i0, in, j0, jn, l_nk+1 )

*
      endif
*
      if (.not.G_lam) then
         call adw_exch_1 ( Adw_n1, Adw_xgg1, Adw_xdd1, Adw_c1,
     $                  pos_x, pos_y, pos_z, l_nk+1 )
*
         if ( V4dg_conf.ne.0.0 ) then
*
               outside = 0
*
            if ( Adw_fro_a .gt. 0 ) outside = 1
*
            sum_outside = 0
            call rpn_comm_Allreduce(outside,sum_outside,1,"MPI_INTEGER",
     $                              "MPI_SUM","grid",ier)
*
            if(sum_outside.ne.0) call gem_stop ('ADW_MAIN_3_INT: TLM-ADJ NOT done: INCREASE HALO',-1)
*
         endif
*
         dim = max(1,Adw_fro_a)
         call hpalloc(Adw_capx2_   ,dim,      err,1)
         call hpalloc(Adw_capy2_   ,dim,      err,1)
         call hpalloc(Adw_capz2_   ,dim,      err,1)
         call hpalloc(Adw_n2_      ,dim,      err,1)
         call hpalloc(Adw_xdd2_    ,dim,      err,1)
         call hpalloc(Adw_xgg2_    ,dim,      err,1)
         call hpalloc(Adw_ydd2_    ,dim,      err,1)
         call hpalloc(Adw_ygg2_    ,dim,      err,1)
         call hpalloc(Adw_cz2_     ,dim,      err,1)
         call hpalloc(Adw_wrka_    ,dim,      err,1)

         call adw_exch_2 ( Adw_capx2, Adw_capy2, Adw_capz2,
     %                     Adw_n1, Adw_xgg1, Adw_xdd1,
     %                     Adw_fro_n, Adw_fro_s, Adw_fro_a,
     %                     Adw_for_n, Adw_for_s, Adw_for_a, 3 )
*

         if ( Adw_fro_a .gt. 0 .and. Adw_ckbd_L ) call adw_ckbd ( Adw_capy2 )
*
      endif
*
***********************************************************************
* Perform interpolation for equations on thermodynamic levels
***********************************************************************
      pnlkey1(1) = VMM_KEY(rth)
      pnlod = 1
*
      if (.not. Schm_hydro_L) then
         pnlkey1(2) = VMM_KEY(rw)
         pnlkey1(3) = VMM_KEY(rvv)
         pnlod = 3 
      endif
*
      pnerr = vmmlod(pnlkey1,pnlod)
*
      pnerr =  VMM_GET_VAR(rth)
*
      if (.not. Schm_hydro_L) then
         pnerr = VMM_GET_VAR(rw)
         pnerr = VMM_GET_VAR(rvv)
      endif
*
      if (Tr3d_ntr.gt.0) then
         key1_ = VMM_KEY (trt1)
         key0_ = VMM_KEY (trt0)
         do n=1,Tr3d_ntr
            key1(n) = key1_ + n
            key0(n) = key0_ + n
         end do
         err = vmmlod(key1,Tr3d_ntr)
         err = vmmlod(key0,Tr3d_ntr)
         do n=1,Tr3d_ntr
            err = vmmget(key1(n),patr,tr)
            pnt_trt1(n) = patr
            err = vmmget(key0(n),patr0,tr0)
            pnt_trt0(n) = patr0
         end do
      endif
*
*     ----------------------------
*     Keep positions in CAP fields
*     ----------------------------
!$omp parallel private(n)
!$omp do
      do k=1,l_nk+1
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         Adw_capx1(n) = pos_x(n)
         Adw_capy1(n) = pos_y(n)
         Adw_capz1(n) = pos_z(n)
      end do
      end do
      end do
!$omp enddo
      call adw_interp2 (rth, rth, pos_x, pos_y, 
     %                 .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')

      if (.not. Schm_hydro_L) then
          call adw_interp2 (rw, rw, pos_x, pos_y, 
     %                 .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
          call adw_interp2 (rvv, rvv, pos_x, pos_y, 
     %                 .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
      else         
         if(Orh_icn.eq.Schm_itcn)then

!$omp parallel do
            do j=l_miny,l_maxy
            do i=l_minx,l_maxx
               xtmp(i,j)=st1(i,j)
            end do
            end do
!$omp end parallel do
            call vsexp (ytmp,xtmp,(l_maxx-l_minx+1)*(l_maxy-l_miny+1))
!$omp parallel do
            do k=1,l_nk+1
               do j=j0,jn
               do i=i0,in
                  work(i,j,k)=.5d0*(fiptx(i,j,k)+fiptx(i,j,k-1))
     $                 +Ver_fistr_8%t(k)
                  work2(i,j,k)=Ver_pia_8%t(k) + Ver_pib_8%t(k)*ytmp(i,j)
               enddo
               enddo
            enddo
!$omp end parallel do
            call adw_interp2 (zz1, work, pos_x, pos_y, 
     %           .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')         
            call adw_interp2 (piup,work2, pos_x, pos_y, 
     %           .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')         
         endif
      endif
*
      if ( (Orh_icn .eq. Schm_itcn) .and. (Tr3d_ntr.gt.0) ) then
*
* tr3d advection
*
*
         aaa = ( Offc_a1_8 / Offc_b0_8 )/ Cstv_dt_8 
*
         do n=1,Tr3d_ntr
            patr = pnt_trt1(n)
            patr0= pnt_trt0(n)
!$omp do
            do k=1,l_nk+1
            do j=1,l_nj
            do i=1,l_ni
               tr0(i,j,k) = - aaa*tr(i,j,k)
            end do
            end do
            end do
!$omp enddo
            call adw_interp2 ( tr0, tr0, pos_x, pos_y,
     %               .false. , Adw_mono_L, LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
!$omp do
            do k=1,l_nk+1
            do j=1,l_nj
            do i=1,l_ni
               tr0(i,j,k) = Cstv_tau_8*tr0(i,j,k)
            end do
            end do
            end do
!$omp enddo
         end do
*
      endif
!$omp end parallel
      if(matlab_write_L)then      
         call write_matlab_3d(62,ruw1)
         call write_matlab_3d(62,ruw2)
         call write_matlab_3d(62,rcn)
         call write_matlab_3d_th(62,rth)
         if (.not. Schm_hydro_L) then 
            call write_matlab_3d_th(62,rw)
            call write_matlab_3d_th(62,rvv)
         endif
         if(Ptopo_myproc.eq.0)close(62)
      endif

***********************************************************************
* Deallocate
***********************************************************************
      call hpdeallc(Adw_capx1_   ,err,1)
      call hpdeallc(Adw_capy1_   ,err,1)
      call hpdeallc(Adw_capz1_   ,err,1)
      call hpdeallc(Adw_n1_      ,err,1)
      call hpdeallc(Adw_xdd1_    ,err,1)
      call hpdeallc(Adw_xgg1_    ,err,1)
      call hpdeallc(Adw_ydd1_    ,err,1)
      call hpdeallc(Adw_ygg1_    ,err,1)
      call hpdeallc(Adw_cz1_     ,err,1)
      call hpdeallc(Adw_c1_      ,err,1)
      call hpdeallc(Adw_wrkb_    ,err,1)
      call hpdeallc(Adw_wrkc_    ,err,1)
      if (.not.G_lam) then
      call hpdeallc(Adw_capx2_   ,err,1)
      call hpdeallc(Adw_capy2_   ,err,1)
      call hpdeallc(Adw_capz2_   ,err,1)
      call hpdeallc(Adw_n2_      ,err,1)
      call hpdeallc(Adw_xdd2_    ,err,1)
      call hpdeallc(Adw_xgg2_    ,err,1)
      call hpdeallc(Adw_ydd2_    ,err,1)
      call hpdeallc(Adw_ygg2_    ,err,1)
      call hpdeallc(Adw_cz2_     ,err,1)
      call hpdeallc(Adw_wrka_    ,err,1)
      endif
*
      deallocate (pos_x,pos_y,pos_z)
*
 1000  format(3X,'ADVECT THE RIGHT-HAND-SIDES: (S/R ADW_MAIN_3_INTLAG)')
*
      return
      end
