!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***   s/r adw_main_2_pos - calculate upstream positions at th and t1
*
#include "model_macros_f.h"
#include "constants.h"
#include "msg.h"
*
      subroutine adw_main_2_pos ( F_it, F_u, F_v, F_w )
*
      implicit none
*
      integer F_it
      real F_u(*),F_v(*),F_w(*)
*
*author
*     alain patoine
*
*revision
* v2_31 - Desgagne M.    - removed stkmemw
* v2_31 - Tanguay M.     - gem_stop if Adw_fro_a.gt.0.and.V4dg_conf.ne.0
* v3_00 - Desgagne & Lee - Lam configuration
* v3_02 - Lee V.         - revert adw_exch_1 for GLB only, added adw_ckbd_lam
* v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
* v3_20 - Valin & Tanguay - Optimized SETINT/TRILIN 
* v3_20 - Gravel S.       - Change test a lower and upper boundaries
* v3_20 - Tanguay M.      - Improve alarm when points outside advection grid
* v3_20 - Dugas B.        - correct calculation for LAM when Glb_pil gt 7
* v3_21 - Lee V.          - bug correction, yth should not be modified.
* v4_05 - Lepine M.       - VMM replacement with GMM
*
*language
*     fortran 77
*
*object
*     see id section
*
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
* F_it   | total number of iterations for trajectory             |  i  |
*        |                                                       |     |
* F_u,F_v| input:  3 components of wind on advection grid        |  io |
* F_w    | output: 3 upstream positions valid at t1              |     |
*________|_______________________________________________________|_____|
*
*implicits
#include "gmm.hf"
#include "var_gmm.cdk"
!      type(gmm_metadata) :: meta3d, tmp_meta1d
!      integer :: gmmstat
#include "glb_ld.cdk"
!      logical G_lam
!      integer G_nk
!      logical l_north, l_south, l_east, l_west
!      integer l_ni, l_nj, l_nk, l_niu, l_njv
!      integer l_minx, l_maxx, l_miny, l_maxy
!      integer pil_n,pil_s,pil_w,pil_e
#include "adw.cdk"
!      logical Adw_ckbd_L
!      logical Adw_hor_L,Adw_ver_L
!      integer            Adw_for_n, Adw_for_s, Adw_for_a
!      integer            Adw_fro_n, Adw_fro_s, Adw_fro_a
!      integer Adw_fn_I(*)
#include "cstv.cdk"
!      real*8    Cstv_dt_8
#include "vth.cdk"
!      real, pointer, dimension (:) :: xth,yth,zth
!      real, pointer, dimension (:) :: xcth,ycth,zcth
!      character(len=8) :: gmmk_xth_s, gmmk_yth_s, gmmk_zth_s
!      character(len=8) :: gmmk_xcth_s, gmmk_ycth_s, gmmk_zcth_s
#include "vt1.cdk"
!      real, pointer, dimension (:)     :: xct1,yct1,zct1
!      character(len=8) :: gmmk_xct1_s, gmmk_yct1_s, gmmk_zct1_s
#include "v4dg.cdk"
!      integer V4dg_conf
#include "ver.cdk"
!      #include "type.cdk"
!      type (vertical_8) Ver_z_8  
#include "geomg.cdk"
!      real*8 geomg_x_8(XDIST_SHAPE)
!      real*8 geomg_y_8(YDIST_SHAPE)
#include "schm.cdk"
!      logical schm_zdotmid_l
c$$$#include "acid.cdk"
!      logical acid_test_l
*
      integer i, j, k, n, ij, ijk, nij, nijk, it, kmin, kmax
      integer i1,j1,k1,nn,ier,i0,in,j0,jn
*
      integer, dimension(l_ni*l_nj*l_nk) :: n1
      real,    dimension(l_ni*l_nj*l_nk) :: capx1,capy1,capz1
      real,    dimension(l_ni*l_nj*l_nk) :: wrkx1,wrky1,wrkz1,wrkc1,wrk_yth
      integer, dimension(:), allocatable :: n2
      real,    dimension(:), allocatable :: capx2,capy2,capz2
      real,    dimension(:), allocatable :: xpos2,ypos2,zpos2
      real,    dimension(l_ni*l_nj*l_nk) :: xgrid,ygrid,zgrid
*
      real dummy, dth
      real*8 r2pi_8,two,half,pdp,pdm
      parameter (two = 2.0,half=0.5)
*
*     ---------------------------------------------------------------
*
      call msg(MSG_DEBUG,'CALC UPSTREAM POSITIONS: (S/R ADW_MAIN_2_POS)')
      nij    = l_ni   *l_nj
      nijk   = l_ni   *l_nj   *l_nk
*
      r2pi_8 = two * CONST_PI_8
      dth    = Cstv_dt_8/2.
      pdp    = 1.d0 + 1.d-6
      pdm    = 1.d0 - 1.d-6

      kmin=2
      kmax=l_nk-1
*
      gmmstat = gmm_get(gmmk_xth_s,xth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos ERROR at gmm_get(xth)'
      gmmstat = gmm_get(gmmk_yth_s,yth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos ERROR at gmm_get(yth)'
      gmmstat = gmm_get(gmmk_zth_s,zth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos ERROR at gmm_get(zth)'

      gmmstat = gmm_get(gmmk_xcth_s,xcth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos ERROR at gmm_get(xcth)'
      gmmstat = gmm_get(gmmk_ycth_s,ycth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos ERROR at gmm_get(ycth)'
      gmmstat = gmm_get(gmmk_zcth_s,zcth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos ERROR at gmm_get(zcth)'

      gmmstat = gmm_get(gmmk_xct1_s,xct1,tmp_meta1d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos ERROR at gmm_get(xct1)'
      gmmstat = gmm_get(gmmk_yct1_s,yct1,tmp_meta1d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos ERROR at gmm_get(yct1)'
      gmmstat = gmm_get(gmmk_zct1_s,zct1,tmp_meta1d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos ERROR at gmm_get(zct1)'

      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west)  i0=pil_w
          if (l_east)  in=l_niu - pil_e + 2
          if (l_south) j0=pil_s
          if (l_north) jn=l_njv - pil_n + 2
      endif
*
c$$$      if (Acid_test_L)
c$$$     $     call acid_stat_adw_main_2_pos(xth,xcth,wrkx1,i0,in,j0,jn,1)
*
************************************************************************
      do it=1,F_it ! begin iterations loop
************************************************************************
c
c        ==================================================================
c        3d interpolation of u and v winds
c        ==================================================================
c
      do n = 1,nijk
      wrk_yth(n) = yth(n)
      enddo

      if (G_lam) then
*
          call adw_cliptraj ( xth, wrk_yth, i0, in, j0, jn, G_nk, '')          
*
      else
*
          call adw_exch_1 ( wrkx1, wrky1, wrkz1, wrkc1,xth,wrk_yth,zth,G_nk )
*
          if (V4dg_conf .ne. 0.) then
              ier = 0
              if (Adw_fro_a > 0) ier = -1
              call handle_error(ier,'adw_main_2_pos','TLM-ADJ NOT done: INCREASE HALO')
          endif
*
          allocate(capx2(max(1,Adw_fro_a)),
     %             capy2(max(1,Adw_fro_a)),
     %             capz2(max(1,Adw_fro_a)),
     %             xpos2 (max(1,Adw_fro_a)),
     %             ypos2 (max(1,Adw_fro_a)),
     %             zpos2 (max(1,Adw_fro_a)),
     %             n2 (max(1,Adw_fro_a)) )
          call adw_exch_2 ( xpos2, ypos2, zpos2,
     %                  wrkx1, wrky1, wrkz1,
     %                  Adw_fro_n, Adw_fro_s, Adw_fro_a,
     %                  Adw_for_n, Adw_for_s, Adw_for_a, 3 )
*
      endif
*      
      if( .not. Adw_nosetint_L ) then
*
         call adw_setint ( n1, capx1, dummy, dummy, capy1, dummy,
     %                     dummy, capz1, dummy, xth, wrk_yth, zth,
     %                    .true., .true., .true.,nijk,i0,in,j0,jn,l_nk,'m')
*
      
         call adw_trilin (wrkx1,F_u,1.0,n1,capx1,capy1,capz1,nijk,i0,in,j0,jn,l_nk)
         call adw_trilin (wrky1,F_v,1.0,n1,capx1,capy1,capz1,nijk,i0,in,j0,jn,l_nk)
*
      else
*
         Adw_hor_L = .true.
         Adw_ver_L = .true. 

         call adw_trilin_turbo (wrkx1,F_u,1.0,xth,wrk_yth,zth,capz1,
     %                          Adw_Fn_I,nijk,i0,in,j0,jn,l_nk,'m')
         call adw_trilin_turbo (wrky1,F_v,1.0,xth,wrk_yth,zth,capz1,
     %                          Adw_Fn_I,nijk,i0,in,j0,jn,l_nk,'m')
*
      endif
*
c$$$      if (Acid_test_L)
c$$$     $     call acid_stat_adw_main_2_pos(xth,xcth,wrkx1,i0,in,j0,jn,2)
*
c        ==================================================================
c        Compute new upstream postions along x and y
c        ==================================================================
c
      if (.not.G_lam) then

         if ( Adw_fro_a .gt. 0 ) then
*
*
              if ( Adw_ckbd_L ) call adw_ckbd ( ypos2 )
*
              call adw_setint ( n2, capx2, dummy, dummy, capy2, dummy,
     %                     dummy, capz2, dummy, xpos2, ypos2, zpos2,
     %                    .true., .true., .true., Adw_fro_a,1,Adw_fro_a,
     %                    1,1,1,'m')
*
              call adw_trilin ( xpos2, F_u, 1.0, n2, capx2, capy2, capz2,
     %                     Adw_fro_a,1,Adw_fro_a,1,1,1)
              call adw_trilin ( ypos2, F_v, 1.0, n2, capx2, capy2, capz2,
     %                     Adw_fro_a,1,Adw_fro_a,1,1,1)
*
         endif
*
         call adw_exch_2 ( wrkz1, wrk_yth, dummy,
     %                  xpos2, ypos2, dummy,
     %                  Adw_for_n, Adw_for_s, Adw_for_a,
     %                  Adw_fro_n, Adw_fro_s, Adw_fro_a, 2)
*
         if ( Adw_for_a .gt. 0 )
     %         call adw_exch_3 ( wrkx1, wrky1, wrkz1, wrk_yth, wrkc1, 2 )
*
         deallocate(capx2,capy2,capz2,xpos2,ypos2,zpos2,n2)
      endif
************************************************************************
      call adw_trajsp ( xth, yth, xcth, ycth, zcth, wrkx1, wrky1, dth,
     %                  i0,in,j0,jn)
************************************************************************
c     
c        ==================================================================
c        3D interpolation of zeta dot
c        ==================================================================
c
      do n = 1,nijk
      wrk_yth(n) = yth(n)
      enddo
*
c$$$      if (Acid_test_L)
c$$$     $     call acid_stat_adw_main_2_pos(xth,xcth,wrkx1,i0,in,j0,jn,3)
*     
      if(Schm_zdotMid_L)then
         do k = 1, l_nk
         do j = 1, l_nj 
         do i = 1, l_ni
            ijk=(k-1)*nij+(j-1)*l_ni+i
            xgrid(ijk)  = Geomg_x_8(i)
            ygrid(ijk)  = Geomg_y_8(j)
            zgrid(ijk)  = Ver_z_8%m(k)
         enddo         
         enddo         
         enddo         
      endif

      if (G_lam) then
*
          if(.not.Schm_zdotMid_L)call adw_cliptraj ( xth, wrk_yth, i0, in, j0, jn, G_nk, '')
*
      else
*
         if(Schm_zdotMid_L)then
            call adw_exch_1 ( wrkx1, wrky1, wrkz1, wrkc1,xgrid,ygrid,zgrid,G_nk )
         else
            call adw_exch_1 ( wrkx1, wrky1, wrkz1, wrkc1,xth,wrk_yth,zth,G_nk )
         endif
*
          allocate(capx2(max(1,Adw_fro_a)),
     %             capy2(max(1,Adw_fro_a)),
     %             capz2(max(1,Adw_fro_a)),
     %             xpos2 (max(1,Adw_fro_a)),
     %             ypos2 (max(1,Adw_fro_a)),
     %             zpos2 (max(1,Adw_fro_a)),
     %             n2 (max(1,Adw_fro_a)) )
*
          call adw_exch_2 ( xpos2, ypos2, zpos2,
     %                  wrkx1, wrky1, wrkz1,
     %                  Adw_fro_n, Adw_fro_s, Adw_fro_a,
     %                  Adw_for_n, Adw_for_s, Adw_for_a, 3 )
*
      endif
*
      if( .not. Adw_nosetint_L ) then
*
         if(Schm_zdotMid_L)then
            call adw_setint ( n1, capx1, dummy, dummy, capy1, dummy,
     %           dummy, capz1, dummy, xgrid, ygrid, zgrid,
     %           .true., .true., .true., nijk,i0,in,j0,jn,l_nk,'m')
         else
            call adw_setint ( n1, capx1, dummy, dummy, capy1, dummy,
     %           dummy, capz1, dummy, xth, wrk_yth, zth,
     %           .true., .true., .true., nijk,i0,in,j0,jn,l_nk,'t')
         endif

         call adw_trilin (wrkx1,F_w,-dth,n1,capx1,capy1,capz1,nijk,i0,in,j0,jn,l_nk)
*     
c$$$         if (Acid_test_L)
c$$$     $        call acid_stat_adw_main_2_pos(xth,xcth,wrkx1,i0,in,j0,jn,4)

      else
*         
         Adw_hor_L = .true. 
         Adw_ver_L = .true. 
         if(Schm_zdotMid_L)then
            call adw_trilin_turbo (wrkx1,F_w,-dth,xgrid,ygrid,zgrid,capz1,
     %           Adw_Fn_I,nijk,i0,in,j0,jn,l_nk,'m')
*
         else      
            call adw_trilin_turbo (wrkx1,F_w,-dth,xth,wrk_yth,zth,capz1,
     %           Adw_Fn_I,nijk,i0,in,j0,jn,l_nk,'t')
*
         endif
*
      endif
*
      if (.not.G_lam) then

         if (Adw_fro_a > 0 .and. Schm_zdotMid_L) then
            call handle_error(-1,'adw_main_2_pos','The code should not pass in this branch.\n Please report the problem to the developer (zdotMid_L)')
         endif

         if ( Adw_fro_a .gt. 0 ) then
*     
              if ( Adw_ckbd_L ) call adw_ckbd ( ypos2 )
*     
              call adw_setint ( n2, capx2, dummy, dummy, capy2, dummy,
     %           dummy, capz2, dummy, xpos2, ypos2, zpos2,
     %           .true., .true., .true., Adw_fro_a,1,Adw_fro_a,
     %           1,1,1,'t')
*     
              call adw_trilin ( xpos2, F_w, -dth, n2, capx2,capy2,capz2,
     %           Adw_fro_a,1,Adw_fro_a,1,1,1)
*
         endif
*
         call adw_exch_2 ( wrkz1, dummy, dummy,
     %                  xpos2, dummy, dummy,
     %                  Adw_for_n, Adw_for_s, Adw_for_a,
     %                  Adw_fro_n, Adw_fro_s, Adw_fro_a, 1)
*
         if ( Adw_for_a .gt. 0 )
     %        call adw_exch_3 ( wrkx1, dummy, wrkz1, dummy, wrkc1, 1 )
*
         deallocate(capx2,capy2,capz2,xpos2,ypos2,zpos2,n2)
      endif

************************************************************************
c
c        ==================================================================
c        Compute new upstream position along zeta
c        ==================================================================
c
!$omp parallel private(n)
!$omp do
      do k = kmin,kmax
      do j = j0,jn
      do i = i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         zth(n) = Ver_z_8%m(k) + two*wrkx1(n)
c        Make sure zth is below Ver_z_8%m(1) and above Ver_z_8%m(l_nk)
         zth(n) = min( pdm*Ver_z_8%m(l_nk), 
     %                max( 1.0d0*zth(n), pdp*Ver_z_8%m(1) ) )
         zth(n) = half*(zth(n) + Ver_z_8%m(k))
      enddo
      enddo
      enddo
!$omp enddo
!$omp end parallel
************************************************************************
      enddo ! end of iterations loop
************************************************************************
      call adw_trajex (F_u, F_v, xct1, yct1, zct1, xcth, ycth, zcth,
     %                  i0,in,j0,jn)
*
!$omp parallel private(n)
!$omp do
         do j = j0,jn
         do i = i0,in
            n = ((j-1)*l_ni) + i   !for k=1
            F_w(n) = Ver_z_8%m(1)
            n = (l_nk-1)*nij+((j-1)*l_ni) + i !for k=l_nk
            F_w(n) = Ver_z_8%m(l_nk)
         enddo
         enddo
!$omp enddo

!$omp do
      do k = kmin,kmax
         do j = j0,jn
         do i = i0,in
            n=(k-1)*nij+((j-1)*l_ni) + i
            F_w(n) = zth(n) - Ver_z_8%m(k)
            F_w(n) = Ver_z_8%m(k) + 2.0 * F_w(n)
         enddo
         enddo
      enddo
!$omp enddo
!$omp end parallel
*
*     ---------------------------------------------------------------
*
      return
      end
