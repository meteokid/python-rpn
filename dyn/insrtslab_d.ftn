***s/p - insrtslab_d - insert data into slab work space
*
#include <model_macros_f.h>
      subroutine insrtslab_d(F_field,F_work1,DIST_DIM,F_nk,F_k,
     $         F_sets,F_mult,F_add, F_index,F_level_ip1,F_mtout,F_var_S,
     $         F_typvar_S,F_ip1,F_bit,F_mtval,NN,MXOUT,MXGRD)
*
#include "impnone.cdk"
      integer DIST_DIM,F_Nk,F_index,F_k,F_sets,NN,MXOUT,MXGRD
      real F_field(DIST_SHAPE,F_Nk)
      real F_work1(DIST_SHAPE)
      real F_mult,F_add,F_mtval(NN*MXOUT,MXGRD)
      integer F_level_ip1
      character*1 F_typvar_S(MXOUT,MXGRD)
      character*4 F_var_S(MXOUT,MXGRD)
      integer F_mtout(MXGRD),F_ip1(MXOUT,MXGRD),F_bit(MXOUT,MXGRD)
*
*author 
*     J-P. Toviessi - CMC (insrtslabd)
*
*revision
* v2_30 - Lee V.       - removed calculation of extraction limits and
* v2_30                - also calculations of the slab grids. Fill variables
* v2_30                  locally allocated in "BLOC??" here.
* v3_00 - Desgagne & Lee    - Lam configuration
* v3_02 - Lee V.       - filter only on 2D or pressure output if requested
* v3_02 - Lee V.       - special typvar for V4d adj/tlm
*
*object
*     see above id
*
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_field       I           field to be written to output file
* F_work1       I           work field for converting units with extra column
* F_nk          I           the number of levels in the input field
* F_k           I           the "K" level to be outputted
* F_mult        I           factor by which to multiply the field
* F_add         I           bias to add to the output field
* F_index       I           index pointing to global tables for the variable
* F_level_ip1   I           IP1 value corresponding to the "F_k" level
* F_mtout       I/O         accumulater of number of records in the slab
* F_var_S       O           array of variable names for each record to output
* F_typvar_S    O           array of TYPVAR values for each record to output
* F_ip1         O           array of IP1 values for each record to output
* F_bit         O           array of bit compaction values for each record 
* F_mtval       O           the slab workspace to be filled by each record
*----------------------------------------------------------------
*
*implicits
#include "glb_ld.cdk"
#include "dimout.cdk"
#include "outd.cdk"
#include "setsor.cdk"
#include "dslab.cdk"
#include "v4dg.cdk"
*
**
*NOTE: Every dynamic variable is output using PHi grid descriptors.
*
      character*1 blk_S
      real wk1(LDIST_SHAPE,1)
      real wk2(LDIST_SHAPE,1),lev
*
      integer i,j,ii,jj,i1,j1,idx,ij,nnio,gridset,kind
*
      gridset=Outd_grid(F_sets)
*     convert to proper units
      do j = 1, l_nj
         do i = 1, l_ni
            F_work1(i,j) = (F_field(i,j,F_k) + F_add) * F_mult
         enddo
      enddo
*
      if (Setsor_filtpass(F_index).gt.0) then
*         Filter output variable only if in pressure units
          call convip(F_level_ip1, lev, kind, -1, blk_S, .false.)
          if (kind.eq.2)
     $        call filter(F_work1, wk1,wk2, Setsor_filtpass(F_index),
     $             Setsor_filtcoef(F_index), 'G', .false., LDIST_DIM, 1)
      endif

**____________________________________________________________________
*
*____ fill info into header of slab

      F_mtout(gridset)=F_mtout(gridset)+1
      idx = F_mtout(gridset)
      F_var_S(idx,gridset)= Setsor_name_S(F_index)(1:4)
      F_typvar_S(idx,gridset)=Outd_typvar_S(F_sets)
*     Special coding of typvar for V4d TLM and V4d ADJ only
      if (V4dg_tl_L) F_typvar_S(idx,gridset) = 'R'
      if (V4dg_ad_L) F_typvar_S(idx,gridset) = 'G'
      F_ip1(idx,gridset)= F_level_ip1
      F_bit(idx,gridset)= Setsor_xnbits(F_index)
*
* ____ insert data into mtval
*
       do j = Dslab_ymin(gridset), Dslab_ymax(gridset)
          do i = Dslab_xmin(gridset), Dslab_xmax(gridset)
             ij = 1+i-Dslab_xmin(gridset)+
     %                (j-Dslab_ymin(gridset))*Dslab_niout(gridset)
             F_mtval(Dslab_nnio(gridset)*(idx-1)+ij,gridset)=
     %               F_work1(i,j)
          enddo
       enddo
*
      return
      end
