***s/r  sol_mxma8_2 - parallel direct solution of horizontal Helmholtz
*       problem. With  mxma8 and using Opr_opsxp2_8 eigenvector's parity
*                     
*
#include <model_macros_f.h>
      subroutine  sol_parite_2 ( Sol, Rhs, evxevec,oddxevec,
     $                          Minx, Maxx, Miny, Maxy, njl,
     $                          Minz, Maxz, Nk, Nkl, 
     $                          Gni, Gnj, Minij, Maxij, L_nij,
     $                          minx1, maxx1, minx2, maxx2,nx3,
     $                          F_npex1, F_npey1, ai, bi, ci,
     $                          fdg1,fdg2,fdwfft,fdg12,NSTOR,nev)
*
#include "impnone.cdk"
#include "ptopo.cdk"
*
*author    Abdessamad Qaddouri
*
*revision
* v3_01 - Qaddouri A.          - initial version
*
*arguments
*   o      - Sol      - result
*   i      - Rhs      - r.h.s. of elliptic equation
*   i      - ev-Xevec - Even eigenvectors
*   i      - odd-Xevec- Odd eigenvectors
*   i      - Gni      - number of points in x-direction
*   i      - Gnj      - number of points in y-direction
*
      integer  F_npex1 , F_npey1
      integer  minx1, maxx1, minx2, maxx2,nx3
      integer  jk

      Real*8   ai(minx1:maxx1,minx2:maxx2,nx3),
     $         bi(minx1:maxx1,minx2:maxx2,nx3),
     $         ci(minx1:maxx1,minx2:maxx2,nx3)



      integer  Minx, Maxx, Miny, Maxy, njl,
     $         Minz, Maxz, Nk  , Nkl ,
     $         Gni , Gnj , Minij, Maxij, L_nij,NSTOR,nev
      real*8   Rhs(Minx:Maxx,Miny:Maxy,Nk), Sol(Minx:Maxx,Miny:Maxy,Nk)
      real*8   evxevec(NSTOR*NSTOR),oddxevec(NSTOR*NSTOR)

      real*8   fdwfft(Miny:Maxy,Minz:Maxz,Gni)
      real*8   fdg1(Miny:Maxy,Minz:Maxz,Gni+F_npex1)
      real*8   fdg2(Minz:Maxz,Minij:Maxij,Gnj+F_npey1)
      real*8   fdg12(Miny:Maxy,Minz:Maxz,Gni)
*
      integer  j, jr, err, ki,dim
      real*8   zero, one
      parameter( zero = 0.0 )
      parameter( one  = 1.0 )

*
      integer i,  k, nevi,gnii
*
*
 
*PDIR SERIAL
      call rpn_comm_transpose( Rhs, Minx, Maxx, Gni, (Maxy-Miny+1),
     %                                   Minz, Maxz, Nk, fdg1, 1,2 )


          do k= Minz,Maxz
            do j= njl+1,Maxy
               do i= 1,Gni
                  fdg1(j,k,i)=zero
                  fdg12(j,k,i)=zero
               enddo
            enddo
         enddo


         do k= Nkl+1,Maxz
            do j= Miny,Maxy
               do i= 1,Gni
                  fdwfft(j,k,i)=zero
               enddo
            enddo
         enddo
*PDIR ENDSERIAL
*  even  part of rhs

          do k=1,Nkl
            do j=1,njl
              fdg12(j,k,1)=fdg1(j,k,1)
            enddo
          enddo
           
          do k=1,Nkl
            do j=1,njl
              do i= 2,(Gni+1)/2
                fdg12(j,k,i)=fdg1(j,k,i)+fdg1(j,k,Gni+2-i)
              enddo
            enddo
          enddo

         if(Gni.eq.(2*(Gni/2)) ) then
          do k=1,Nkl
            do j=1,njl
               fdg12(j,k,nev)=fdg1(j,k,nev)
            enddo
          enddo
         endif

*  odd part of rhs             
          do k=1,Nkl
            do j=1,njl
             do i=1,Gni-nev
              fdg12(j,k,i+nev)=fdg1(j,k,i+1)-fdg1(j,k,Gni+1-i)
             enddo
            enddo
          enddo


*     projection ( wfft = x transposed * g )

c*PDIR PARDO FOR=Ptopo_npeOpenMP

      call mxma8( evxevec,          NSTOR    , 1,
     %            fdg12(1,1,1),   (Maxy-Miny+1) * (Maxz-Minz+1), 1,
     %            fdwfft(1,1,1), (Maxy-Miny+1) * (Maxz-Minz+1), 1,
     %                     nev, nev, (Maxy-Miny+1) * Nkl )

      call mxma8( oddxevec,          NSTOR, 1,
     %            fdg12(1,1,nev+1),   (Maxy-Miny+1) * (Maxz-Minz+1), 1,
     %            fdwfft(1,1,nev+1),(Maxy-Miny+1) * (Maxz-Minz+1), 1,
     %                     Gni-nev, Gni-nev, (Maxy-Miny+1) * Nkl )

*

*PDIR SERIAL
      call rpn_comm_transpose
     $     ( fdwfft, Miny, Maxy, Gnj, (Maxz-Minz+1),
     $                         Minij, Maxij, Gni, fdg2, 2, 2 )

*
       j =1
       do ki= 1, (Maxz-Minz+1) *L_nij
          fdg2(ki,1,j) = bi(ki,1,j)*fdg2(ki,1,j)
       enddo

      do j =2, Gnj
            jr =  j - 1
            do ki= 1, (Maxz-Minz+1)*L_nij
               fdg2(ki,1,j) = bi(ki,1,j)*fdg2(ki,1,j) - ai(ki,1,j)
     $                                          * fdg2(ki,1,jr)
            enddo
      enddo

         do j = Gnj-1, 1, -1
            jr =  j + 1
            do ki= 1, (Maxz-Minz+1)*L_nij
              fdg2(ki,1,j) = fdg2(ki,1,j) - ci(ki,1,j) * fdg2(ki,1,jr)
            enddo
         enddo

*
      call rpn_comm_transpose
     $     ( fdwfft, Miny, Maxy, Gnj, (Maxz-Minz+1),
     $                        Minij, Maxij, Gni, fdg2,- 2, 2 )
*PDIR ENDSERIAL

*     inverse projection ( r = x * w )

      

c*PDIR PARDO FOR=Ptopo_npeOpenMP

      call mxma8( evxevec,                1, NSTOR,
     %            fdwfft(1,1,1), (Maxy-Miny+1) * (Maxz-Minz+1),   1,
     %            fdg12(1,1,1),   (Maxy-Miny+1) * (Maxz-Minz+1),   1,
     %                         nev, nev, (Maxy-Miny+1) * Nkl )

      call mxma8( oddxevec,                 1,NSTOR,
     %            fdwfft(1,1,nev+1),(Maxy-Miny+1) * (Maxz-Minz+1),   1,
     %            fdg12(1,1,nev+1), (Maxy-Miny+1) * (Maxz-Minz+1),   1,
     %                        Gni-nev, Gni-nev, (Maxy-Miny+1) * Nkl )

*
* combine even and odd parts

*VDIR NODEP
      do k= 1,Nkl
        do j= 1,njl
          fdg1(j,k,1) = fdg12(j,k,1)  
        enddo
      enddo

      do k= 1,Nkl
        do j= 1,njl
*VDIR NODEP
          do i= 2,(Gni+1)/2 
           gnii=Gni+2-i
           nevi=nev-1+i
           fdg1(j,k,i)       = fdg12(j,k,i)+fdg12(j,k,nevi)
           fdg1(j,k,gnii)    = fdg12(j,k,i)-fdg12(j,k,nevi)
          enddo
        enddo
      enddo

      if( Gni.eq.(2*(Gni/2)) ) then
      do k= 1,Nkl
        do j= 1,njl
           fdg1(j,k,nev)=fdg12(j,k,nev)
        enddo
      enddo
      endif

*
*PDIR SERIAL
      call rpn_comm_transpose( Sol, Minx, Maxx, Gni, (Maxy-Miny+1),
     %                             Minz, Maxz, Nk, fdg1, -1, 2)
 
*PDIR ENDSERIAL

      return
      end
