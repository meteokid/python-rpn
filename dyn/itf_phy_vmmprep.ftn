!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/r itf_phy_vmmprep - load all fields required by the physics
*
#include "model_macros_f.h"
*
      subroutine itf_phy_vmmprep(F_pvptr,NPTR, F_trp, F_trm, 
     $                           F_tp, F_vtm, DIST_DIM,nkphy )
      implicit none
*
      integer,   INTENT(IN) :: NPTR, DIST_DIM, nkphy
      integer*8, INTENT(OUT):: F_pvptr(NPTR)
      real, INTENT(OUT),dimension(DIST_SHAPE,nkphy,*) :: F_trp, F_trm
      real, INTENT(OUT),dimension(DIST_SHAPE,nkphy)   :: F_tp,  F_vtm
*
*author
*     Michel Roch - rpn - april 1994
*
*revision
* v2_00 - Desgagne M.       - initial MPI version
* v2_31 - Desgagne          - clean up and introduce h2o tracers
* v3_00 - Laroche S.        - adaptation for v4d
* v3_12 - Leduc A-M.        - Add arguments gzm and topo
* v3_20 - Lee V.            - Corrected loop i=1,p_nj to i-1,p_ni
* v3_21 - Dugas B.          - Add F_busdyn(p_phis) = topo
* v3_30 - Tanguay M.        - adapt TL/AD to pvptr
* v3_30 - Lee V.            - removed clipping from tracers
* v4_03 - Spacek L.         - Staggered version
* v4_05 - McTaggart-Cowan R.- Add log(surface pressure)-zeta0 stplus for profiles
* v4_05 - Lee V.            - correct loop for h2o_ntr (hucond)
*
*object
*----------------------------------------------------------------
*   Copy variables at time t- and t* in workfields              *
*                                                               *
*     Physics is called for nkphy levels, where nkphy= G_nk+2   *
*     Level are staggered (see drawing below)                   *
*                                                               *
*     The following figure explains how the variables are       *
*     treated. T -> temperature                                 *
*              H -> tracers                                     *
*              U -> winds                                       *
*                                                               *
*----------------------------------------------------------------
*                                |                              |
*       PHYSICS                  |            DYNAMIC           |
*                                |                              |
*--------------------------------|------------------------------|
*                                |                              |
* TOP  k=1                       |   TOP                        |
* =====T,H(1): copied from k=1   |   =====T(1),H(1)             |
*      U(1): copy of DYN U(1)    |                              |
*                                |                              |
*                                |                              |
*                                |                              |
*                                |                              |
* - - -U(2): copy of DYN(1)      |   - - -U(1)                  |
*                                |                              |
*                                |                              |
*                                |                              |
*   ...                          |   ...                        |
*                                |                              |
*                                |                              |
*                                |                              |
*      k=2..G_nk+1               |                              |
* =====T,H(k) : copied from k    |   =====T(k),H(k)             |
*                                |                              |
*                                |                              |
*                                |                              |
*      k=2..G_nk+1               |                              |
* - - -U(k): copied form k-1     |   - - -U(k-1)                |
*                                |                              |
*                                |                              |
*                                |                              |
*   ...                          |   ...                        |
*                                |                              |
*                                |                              |
*       k=G_nk+2                 |                              |
*  =====T,H,U : diagnostics      |   =====T,H(G_nk+1),U(G_nk)   |
*----------------------------------------------------------------
*
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
*     TODO: Document
* F_pvptr     O
* NPTR        I    ?number of VMM p_  pointers?
* F_trp       O
* F_trm       O
* F_tp        O
* F_vtm       O
* DIST_DIM    I
* nkphy       I    number of phys level, p_nk=G_nk+2
*----------------------------------------------------------------
*
*implicits
#include "glb_ld.cdk"
#include "geomg.cdk"
#include "cstv.cdk"
#include "lun.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "itf_phy_config.cdk"
#include "itf_phy_buses.cdk"
#include "inuvl.cdk"
#include "vt1.cdk"
#include "vt0.cdk"
#include "vtx.cdk"
#include "itf_phy_busind.cdk"
#include "p_geof.cdk"
#include "itf_phy_vmm.cdk"
#include "ver.cdk"
#include "itf_vmm.cdk"
#include "tr3d.cdk"
#include "v4dg.cdk"

**
*
      integer err, key(14), i, j, k, n, i0, j0, in, jn, nksurf,
     $        keyd(18), keyp(phyt_ntr), keym(phyt_ntr), keyp_, keym_
      integer pnlod, nik, nikp, km1
      real dt, dzsedi, dzmin, dzmin_, sigsfc, trp, trm, con(l_nj)
      real xtmp(l_ni,nkphy)
      real wtmp(l_ni,nkphy-1),wtmp2(l_ni,nkphy-1),ztmp(l_ni,l_nj)
      real*8 r0
      real, dimension(LDIST_SHAPE,nkphy) :: summqj, sumpqj, vmm   
      pointer (patrp, trp(LDIST_SHAPE,*)),(patrm, trm(LDIST_SHAPE,*))
      pointer (pavmm, vmm)
*
*     ________________________________________________________________
*
      key( 1) = VMM_KEY(ut0)
      key( 2) = VMM_KEY(vt0)
      key( 3) = VMM_KEY(tt0)
      key( 4) = VMM_KEY(st0)
      key( 5) = VMM_KEY(ut1)
      key( 6) = VMM_KEY(vt1)
      key( 7) = VMM_KEY(tt1)
      key( 8) = VMM_KEY(st1)
      key( 9) = VMM_KEY(fiptx)
      key(10) = VMM_KEY(topo)
cap      if(G_lam)then
         key(11) = VMM_KEY(wt1)
cap      else
cap         key(11) = VMM_KEY(piup)
cap      endif         
      pnlod = 11
      if (.not. Schm_hydro_L ) then
        key(12) = VMM_KEY(qt1)
        pnlod = 12
      endif

      err = vmmlod(key,pnlod)
      err = VMM_GET_VAR(ut0)
      err = VMM_GET_VAR(vt0)
      err = VMM_GET_VAR(tt0)
      err = VMM_GET_VAR(st0)
      err = VMM_GET_VAR(ut1)
      err = VMM_GET_VAR(vt1)
      err = VMM_GET_VAR(tt1)
      err = VMM_GET_VAR(st1)
      err = VMM_GET_VAR(fiptx)
      err = VMM_GET_VAR(topo)
cap      if(G_lam)then
         err = VMM_GET_VAR(wt1)
cap      else
cap         err = VMM_GET_VAR(piup)
cap      endif
      if (.not. Schm_hydro_L ) then
         err = VMM_GET_VAR(qt1)
      endif
*
      keyd(1) = VMM_KEY(p_uplus)
      keyd(2) = VMM_KEY(p_vplus)
      keyd(3) = VMM_KEY(p_tplus)
      keyd(4) = VMM_KEY(p_umoins)
      keyd(5) = VMM_KEY(p_vmoins)
      keyd(6) = VMM_KEY(p_tmoins)
      keyd(7) = VMM_KEY(p_gzplus)
      keyd(8) = VMM_KEY(p_omegap)
      keyd(9) = VMM_KEY(p_sigm_m)
      keyd(10) = VMM_KEY(p_sigm_t)
      keyd(11) = VMM_KEY(p_phis)
      keyd(12) = VMM_KEY(p_pplus)
      keyd(13) = VMM_KEY(p_pmoins)
      keyd(14) = VMM_KEY(p_dxdy)
      keyd(15) = VMM_KEY(p_eponmod)
      keyd(16) = VMM_KEY(p_fcpf)
      keyd(17) = VMM_KEY(p_fcpw)
      keyd(18) = VMM_KEY(p_stplus)
      err = vmmlod(keyd,18)
      err = VMM_GET_VAR(p_uplus)
      err = VMM_GET_VAR(p_vplus)
      err = VMM_GET_VAR(p_tplus)
      err = VMM_GET_VAR(p_umoins)
      err = VMM_GET_VAR(p_vmoins)
      err = VMM_GET_VAR(p_tmoins)
      err = VMM_GET_VAR(p_gzplus)
      err = VMM_GET_VAR(p_omegap)
      err = VMM_GET_VAR(p_sigm_m)
      err = VMM_GET_VAR(p_sigm_t)
      err = VMM_GET_VAR(p_phis)
      err = VMM_GET_VAR(p_pplus)
      err = VMM_GET_VAR(p_pmoins)
      err = VMM_GET_VAR(p_dxdy)
      err = VMM_GET_VAR(p_eponmod)
      err = VMM_GET_VAR(p_fcpf)
      err = VMM_GET_VAR(p_fcpw)
      err = VMM_GET_VAR(p_stplus)

      nik  = l_ni*(nkphy-1)
      nikp = l_ni*(nkphy)
*
*   Copy variables at time t- and t* in workfields *
*   AND stagger the winds for the physics
*     --------------------------------------------
*
      do k=1,l_nk+2
      km1=max(k-1,1)
      do j= 1, l_nj
      do i= 1, l_ni 
         p_umoins  (i,j,k) =  ut0 (i,j,km1)
         p_vmoins  (i,j,k) =  vt0 (i,j,km1)
         F_vtm     (i,j,k) =  tt0 (i,j,k)
         p_uplus   (i,j,k) =  ut1 (i,j,km1)
         p_vplus   (i,j,k) =  vt1 (i,j,km1)
         F_tp      (i,j,k) =  tt1 (i,j,k)
      end do
      end do
      end do

*
*     Computing pressure.
*     -----------------------

c$$$ p_sigm_* are used as tmp var for the pressure on t/m levels until sigm is computed at the end

      do j=1,l_nj
         do i=1,l_ni
            p_sigm_m(i,j,1) = Cstv_ptop_8
         enddo
      enddo
*
      do k=1,nkphy-1
         do j=1,l_nj
         do i=1,l_ni
            p_sigm_m(i,j,k+1) = exp( Ver_a_8%m(k) 
     $                             + Ver_b_8%m(k)*st1(i,j) )
            p_sigm_t(i,j,k)  = sqrt(p_sigm_m(i,j,k+1)*p_sigm_m(i,j,k))
         enddo
         enddo
      enddo         
*
      do j=1,l_nj
         do i=1,l_ni
            p_pplus(i,j) = p_sigm_m(i,j,nkphy)
            p_sigm_t(i,j,nkphy) = p_sigm_m(i,j,nkphy)
         end do
      end do
*
*     compute log(surface pressure) - zeta0
*     -------------------------------------
*
      do j=1,l_nj
         do i=1,l_ni
            p_stplus(i,j) = st1(i,j)
         enddo
      enddo
*
*     compute vertical omega
*     -----------------------
*
cap      if(G_lam)then
         call calomeg_w (p_omegap,st1,wt1,tt1,LDIST_DIM,l_nk)            
cap      else
cap         call calomeg_adv (p_omegap,st1,piup,LDIST_DIM,l_nk,.false.)
cap      endif
!     calomeg_adv compute p_omegap up to nkphy-2+1 
!     p_omegap(nkphy)=p_omegap(nkphy-1)  below

*
*     correct for vertical motion at bottom
*     Interpolat gz from momentum to thermo levels in ln(p)
*     -----------------------------------------------------------------
*
      do j=1,l_nj

         call vsexp (ztmp(1,j),st0(1,j),l_ni)
*
         do i= 1, l_ni
            xtmp(i,1)     = log(p_sigm_t(i,j,1))
            xtmp(i,nkphy) = st1(i,j)+Cstv_Zsrf_8
            wtmp2(i,1)      = p_sigm_t(i,j,1)
            p_gzplus(i,j,1) = fiptx(i,j,0)+Ver_fistr_8%m(0)
            p_gzplus(i,j,nkphy) =  topo(i,j)
         enddo
         do k= 2, nkphy-1
         do i= 1, l_ni
            xtmp(i,k) = Ver_a_8%m(k-1) + 
     $                  Ver_b_8%m(k-1)*st1(i,j)
            wtmp2(i,k) = p_sigm_t(i,j,k)
            p_gzplus(i,j,k) = fiptx(i,j,k-1)+Ver_fistr_8%m(k-1)
         enddo
         enddo
*
         call vslog(wtmp,wtmp2,nik)
*
         do k= 1, nkphy-1
         do i= 1, l_ni
            wtmp2(i,k) = xtmp(i,k+1)-xtmp(i,k)
            xtmp(i,k)  = xtmp(i,k+1)-wtmp(i,k)
         enddo
         enddo
         call vsrec(wtmp,wtmp2,nik)
*
         do k= 1, nkphy-1
         do i= 1, l_ni
            r0 = wtmp(i,k)*xtmp(i,k)
            p_gzplus(i,j,k) = r0*p_gzplus(i,j,k) 
     $                          + (1.D0-r0)*p_gzplus(i,j,k+1)
     $                          - topo(i,j)
         end do
         end do
*
*        put information in surface level (only pressure is relevant
*        other values will be ignored by the physics
*        -----------------------------------------------------------
         do i= 1, l_ni
c$$$ TODO: recheck p_pmoins [i.e. ztmp]
            p_pmoins(i,j)        = ztmp(i,j)*Cstv_pref_8
c           p_umoins(i,j,nkphy)  = p_umoins(i,j,nkphy-1) 
c           p_vmoins(i,j,nkphy)  = p_vmoins(i,j,nkphy-1) 
            p_gzplus(i,j,nkphy)= 0.
c$$$ p_vmmphy:  p_gzplus(i,j,nkphy)= topo(i,j) 
c$$$ p_fillbus: F_busdyn(gzmoins6+indx)= F_gzm(ii,F_jdo,k) - F_topo(ii,F_jdo)
c           p_uplus(i,j,nkphy)   = p_uplus(i,j,nkphy-1) 
c           p_vplus(i,j,nkphy)   = p_vplus(i,j,nkphy-1) 
            p_omegap(i,j,nkphy)  = p_omegap(i,j,nkphy-1) 
         end do
      end do !do j=
*    
*     TODO: Document
*     -----------------------------------------
*
      keyp_ = VMM_KEY (trt1)
      keym_ = VMM_KEY (trt0)
      if (phyt_ntr.gt.0) then
         do n=1,phyt_ntr
            keyp(n) = keyp_ + n
            keym(n) = keym_ + n
         end do
         err = vmmlod(keyp,phyt_ntr)  
         err = vmmlod(keym,phyt_ntr)  
*No Clipping for tracers, it will be done in the PHYSICS

         do n=1,phyt_ntr
            err = vmmget(keyp(n),patrp,trp)
            err = vmmget(keym(n),patrm,trm)
            do k=1,l_nk+2
            do j= 1, l_nj
            do i= 1, l_ni
               F_trp(i,j,k,n) =  trp(i,j,k)
               F_trm(i,j,k,n) =  trm(i,j,k)
            end do
            end do
            enddo
*For HU, take NK+2 level for diagnostics, for others,copy NK+1 to Nk+2
*Note that hucond not equal to 1 always, use hucond for HU reference in F_trt1
            if (n.ne.hucond) then
            do j= 1, l_nj
            do i= 1, l_ni
               F_trp(i,j,l_nk+2,n) =  trp(i,j,l_nk+1)
               F_trm(i,j,l_nk+2,n) =  trm(i,j,l_nk+1)
            end do
            end do
            endif
         enddo
         err = vmmuln(keyp,phyt_ntr)
         err = vmmuln(keym,phyt_ntr)
      endif


*
*     dzmin determines the micro-physical timestep for sedimentation
*     --------------------------------------------
*
*     dzsedi is the minimal thickness of the sedimentation layer.
*     Get default value from the physics package.
*
      call phy_optr('DZSEDI',dzsedi,1,'GET',Lun_out.gt.0,err )
*
*     The mixed-phase microphysics scheme combines the lower model
*     layers (excluding the lowest) to compute a sedimentation 
*     timestep that is not too short in order to save on computing 
*     time. In order to do that, the dynamics must compute NKSURF
*     (the index of the eta level just below dzsedi) and DZMIN (the
*     minimal thickness in the domain, taking into account the 
*     combined levels).
*
      dt = Cstv_dt_8
      sigsfc=1.-(min(dt,dzsedi))/10000.

      do k=G_nk+1,1,-1     
         if (exp(Ver_z_8%t(k))/100000.0.lt.sigsfc) go to 100
      end do
 100  nksurf = min(G_nk+1,k+1)
*
      dzmin_=1.e+5
      if ( nksurf .eq. G_nk+1 ) then
*C                                     The sedimentation is made
*C                                     over all model levels
        do j= 1, l_nj
        do i= 1, l_ni 
c$$$ TODO: optimize with vslog
         dzmin_= min(1.0d0*(dzmin_),
     $   Dcst_rgasd_8*(0.5d0*(F_tp(i,j,G_nk+1)+ F_tp(i,j,G_nk)))/
     $   Dcst_grav_8*(Ver_z_8%t(G_nk+1)-Ver_z_8%t(G_nk)))
        end do
        end do
*
      else  
*C                                     The sedimentation is made
*C                                     over a reduced set of levels
        do j= 1, l_nj 
        do i= 1, l_ni
c$$$ TODO: optimize with vslog
         dzmin_= min(1.0d0*(dzmin_),
     $      Dcst_rgasd_8*(0.5d0*(F_tp(i,j,nksurf-1)+F_tp(i,j,nksurf-2)))/
     $      Dcst_grav_8*(Ver_z_8%t(nksurf-1)-Ver_z_8%t(nksurf-2)))
c$$$ TODO: optimize with vslog
         dzmin_= min(1.0d0*(dzmin_),
     $      Dcst_rgasd_8*(0.5d0*(F_tp(i,j,G_nk+1)+F_tp(i,j,nksurf-1)))/
     $      Dcst_grav_8*(Ver_z_8%t(G_nk+1)-Ver_z_8%t(nksurf-1)))
        end do
        end do
*
      endif
*
      call rpn_comm_ALLREDUCE (dzmin_,dzmin,1,"MPI_REAL",
     $                         "MPI_MIN","grid",err)
*

*     send dzmin and nksurf to the physics
      call phycom ('dzmin' ,dzmin ,1,'set')
      call phycom ('nksurf',nksurf,1,'set')

*     interpolate wind images at time t1 and t2
*     -----------------------------------------
*
      call itf_phy_uvgridscal (p_uplus ,p_vplus ,LDIST_DIM,nkphy,.true.)
      call itf_phy_uvgridscal (p_umoins,p_vmoins,LDIST_DIM,nkphy,.true.)

*
*     TODO: Document, this was done in p_fillbus
*     --------------------------------------------
*
      do j=1,l_nj
         con(j) = ( 1.0/cos(geomg_y_8(j))) * Dcst_rayt_8
      enddo
      do k=1,nkphy
      do j= 1, l_nj
      do i= 1, l_ni 
         p_uplus(i,j,k) = p_uplus(i,j,k)*con(j)
         p_umoins(i,j,k) = p_umoins(i,j,k)*con(j)
         p_vplus(i,j,k) = p_vplus(i,j,k)*con(j)
         p_vmoins(i,j,k) = p_vmoins(i,j,k)*con(j)
      enddo
      enddo
      enddo

*
*     Compute temperature from virtual temperature
*     --------------------------------------------
*
      call itf_phy_padbuf(F_tp,l_minx,l_maxx,l_miny,l_maxy,nkphy)
      call itf_phy_padbuf(F_trp,l_minx,l_maxx,l_miny,l_maxy,nkphy)
      call itf_phy_padbuf(F_trm,l_minx,l_maxx,l_miny,l_maxy,nkphy)
      call itf_phy_padbuf(F_vtm,l_minx,l_maxx,l_miny,l_maxy,nkphy)
*
      if(Schm_wload_L)then
*
         summqj = 0.
         sumpqj = 0.
*        Sum over Hydrometeors, note: 'HU' is not always in position 1
         do n = hucond+1, h2o_ntr+(hucond-1)
         do k = 1, nkphy
         do j= 1, l_nj
         do i = 1, l_ni
            summqj(i,j,k)=summqj(i,j,k)+F_trm(i,j,k,n)
            sumpqj(i,j,k)=sumpqj(i,j,k)+F_trp(i,j,k,n)
         end do
         end do
         end do
         end do
         call itf_phy_padbuf(summqj,l_minx,l_maxx,l_miny,l_maxy,nkphy)
         call itf_phy_padbuf(sumpqj,l_minx,l_maxx,l_miny,l_maxy,nkphy)
c$$$ TODO: check if mfottvh can take nkphy
         call mfottvh ( p_tplus ,F_tp,
     $            F_trp(l_minx,l_miny,1,hucond),sumpqj,
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1),nkphy,
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1) )
         call mfottvh ( p_tmoins,F_vtm,
     $            F_trm(l_minx,l_miny,1,hucond),summqj,
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1),nkphy,
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1) )
*
      else
*
c$$$ TODO: check if mfottv can take nkphy
         call mfottv ( p_tplus ,F_tp,
     $            F_trp(l_minx,l_miny,1,hucond),
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1),nkphy,
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1) )
         call mfottv ( p_tmoins,F_vtm,
     $            F_trm(l_minx,l_miny,1,hucond),
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1),nkphy,
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1) )

      endif

*
*      The following hardcoding of fcpf, fcpw and eponmod will be
*      a source of difference for future acide test with physics
*     --------------------------------------------
*
      do j=1,l_nj
      do i=1,l_ni
         p_phis(i,j)= topo(i,j)
         p_dxdy(i,j)= geomg_hxu_8(i-1)*geomg_hyv_8(j-1)*
     $                Dcst_rayt_8*Dcst_rayt_8*geomg_cy_8(j)
             p_fcpf(i,j) = 2.
             p_fcpw(i,j) = 1.
             p_eponmod(i,j) = 1.
      enddo
      enddo
*
      if (.not. G_lam) then
          do j=1,l_nj
          do i=1,l_ni
             p_fcpf   (i,j) = P_fcpkuo_fcpf(i,j)
             p_fcpw   (i,j) = P_fcpkuo_fcpw(i,j)
             p_eponmod(i,j) = P_lmvd_vlsp  (i,j)
          enddo
          enddo
      endif
*
*     compute thermo and momentum sigma levels
*     -------------------------------------
*
      do k=1,nkphy
         do j=1,l_nj
         do i=1,l_ni 
            p_sigm_t(i,j,k) = p_sigm_t(i,j,k)/p_pplus(i,j)
            p_sigm_m(i,j,k) = p_sigm_m(i,j,k)/p_pplus(i,j)
         end do
         end do
      end do
*
*   Surface fields:
*   pointers are stored the same order as the common block p_phy
*     inside F_pvptr
*     --------------------------------------------
      do i=1,COMMON_SIZE(p_phy)
         keyd(i) = p_phy_first(i)
         err = vmmget(keyd(i),pavmm,vmm)
         F_pvptr(i) = pavmm
      enddo
*
*     Store TRAJ for the simplified physics
*     -------------------------------------
      if ( V4dg_conf.ne.0 .and. V4dg_oktr_L) then
*
         call v4d_rwtraj (23)
         call v4d_rwtraj (21, F_tp, F_trp, F_vtm, F_trm)
         call v4d_rwtraj (26, st1)
*
      endif
*
c$$$
c         call statfld3d(p_uplus  ,'p_up',LDIST_DIM,G_ni-1,G_nj,nkphy)
c         call statfld3d(p_vplus  ,'p_vp',LDIST_DIM,G_ni,G_nj-1,nkphy)
c         call statfld3d(p_tplus  ,'p_tp',LDIST_DIM,G_ni,G_nj,nkphy)
c         call statfld3d(p_umoins ,'p_um',LDIST_DIM,G_ni-1,G_nj,nkphy)
c         call statfld3d(st1 ,'st1 ',LDIST_DIM,G_ni,G_nj,1)
c         call statfld3d(wt1 ,'wt1 ',LDIST_DIM,G_ni,G_nj,G_nk+1)
c         call statfld3d(p_vmoins ,'p_vm',LDIST_DIM,G_ni,G_nj-1,nkphy)
c         call statfld3d(p_tmoins ,'p_tm',LDIST_DIM,G_ni,G_nj,nkphy)
c         call statfld3d(p_gzplus ,'p_gz',LDIST_DIM,G_ni,G_nj,nkphy)
c         call statfld3d(p_omegap ,'p_om',LDIST_DIM,G_ni,G_nj,nkphy)
c         call statfld3d(p_sigm_t ,'p_st',LDIST_DIM,G_ni,G_nj,nkphy)
c         call statfld3d(p_sigm_m ,'p_sm',LDIST_DIM,G_ni,G_nj,nkphy)
c         call statfld3d(p_phis ,'p_ph',LDIST_DIM,G_ni,G_nj,1)
c         call statfld3d(p_pplus ,'p_pp',LDIST_DIM,G_ni,G_nj,1)
c         call statfld3d(p_pmoins ,'p_pm',LDIST_DIM,G_ni,G_nj,1)
c         call statfld3d(p_dxdy ,'p_dx',LDIST_DIM,G_ni,G_nj,1)
c         call statfld3d(p_eponmod ,'p_ep',LDIST_DIM,G_ni,G_nj,1)
c$$$      call statfld3d(p_fcpf ,'p_ff',LDIST_DIM,G_ni,G_nj,1)
c$$$      call statfld3d(p_fcpw ,'p_fw',LDIST_DIM,G_ni,G_nj,1)
c         call statfld3d(F_tp ,'F_tp',LDIST_DIM,G_ni,G_nj,nkphy)
c         call statfld3d(F_vtm ,'F_vtm',LDIST_DIM,G_ni,G_nj,nkphy)
c$$$
*
*     ________________________________________________________________
*
      return
      end

      subroutine statfld3d(fld,name,DIST_DIM,ni,nj,nk)
      implicit none
      integer, INTENT(IN) :: DIST_DIM, ni,nj,nk
      character*(*) name
      real, INTENT(IN),dimension(DIST_SHAPE,nk) :: fld
      
#include "glb_ld.cdk"
#include "lctl.cdk"
#include "schm.cdk"

      integer :: i0,in,j0,jn,inn

      i0 = 1
      in = ni
      j0 = 1
      jn = nj
      call glbstat (fld,name,LDIST_DIM,nk,i0,in,j0,jn ,nk,nk)

      end
