! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r hzd_exhrdif - applies horizontal explicit diffusion
*
#include "model_macros_f.h"
      subroutine hzd_exhrdif ( F_u, F_v, F_w, F_t, F_s, DIST_DIM, Nk )
*
      implicit none
*
      integer DIST_DIM, Nk
*
      real     F_u(DIST_SHAPE,Nk)  , F_v(DIST_SHAPE,Nk),
     $         F_w(DIST_SHAPE,Nk+1), F_t(DIST_SHAPE,Nk+1),
     $         F_s(DIST_SHAPE)
*
*AUTHORs    C. Girard & M. Desgagne
*
*revision
* v3_21 - Desgagne M. - initial MPI version
* v3_30 - Desgagne M. - openMP precision in shared variables
*
*arguments
*  Name        I/O        Description
*----------------------------------------------------------------
*----------------------------------------------------------------
* 
*implicits
#include "glb_ld.cdk"
#include "hzd.cdk"
#include "schm.cdk"
#include "ver.cdk"
#include "dcst.cdk"
*
      integer i,j,k, nn, mm, nij,i0,in,j0,jn
      real*8 pt25,nu_dif,epsilon,khdim,lnr,visco
      parameter (epsilon = 1.0d-12, pt25=0.25d0)
      real smu(LDIST_SHAPE,Nk)  ,smv(LDIST_SHAPE,Nk),
     $     smw(LDIST_SHAPE,Nk+1),smt(LDIST_SHAPE,Nk+1)
      real*8 exner_8(DIST_SHAPE,Nk+1),wkx_8(DIST_SHAPE),wky_8(DIST_SHAPE)
      logical diff_theta
      diff_theta=.false.
**
*     __________________________________________________________________
*
      nu_dif = 0.d0
      lnr    = 1.0d0 - exp(Hzd_lnr)
      if (Hzd_pwr.gt.0) nu_dif = pt25*lnr**(2.d0/Hzd_pwr)
      nu_dif = min(nu_dif,pt25-epsilon)
      if (nu_dif.lt.1.0e-10) return
      i0=Minx
      in=Maxx
      j0=Miny
      jn=Maxy
      nij=(in-i0+1)*(jn-j0+1)
*
      visco = min ( nu_dif, pt25 )
*
      call rpn_comm_xch_halo ( F_u  , LDIST_DIM, l_ni,l_nj,G_nk,
     $               G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo ( F_v  , LDIST_DIM, l_ni,l_nj,G_nk,
     $               G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo ( F_w  , LDIST_DIM, l_ni,l_nj,G_nk+1,
     $               G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
*
      if(diff_theta) then

         if(.not.Schm_theoc_L)then
            call gem_stop('hzd_exhrdif : Code a revoir',-1)
         endif

         call rpn_comm_xch_halo ( F_t  , LDIST_DIM, l_ni,l_nj,G_nk+1,
     $               G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
         call rpn_comm_xch_halo ( F_s  , LDIST_DIM, l_ni,l_nj,     1,
     $               G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      endif

      nn=Hzd_pwr/2
*
!$omp parallel shared( visco,nn) private(wkx_8,wky_8)
*
      if(diff_theta) then
*
*        theta = T * exp(-cappa*(zeta+Bs))
*    
!$omp do
         do k=1,l_nk+1
            do j=j0,jn
            do i=i0,jn
               wkx_8(i,j)=Dcst_cappa_8*(Ver_z_8%t(k)+Ver_b_8%t(k)*F_s(i,j))
            enddo
            enddo
            call vexp(wky_8,wkx_8,nij)
            call vrec(wkx_8,wky_8,nij)
            do j=j0,jn
            do i=i0,jn
               exner_8(i,j,k)=wky_8(i,j)
               F_t(i,j,k)=F_t(i,j,k)*wkx_8(i,j)
            enddo
            enddo
         enddo
!$omp enddo
      endif
*
      do mm=1,nn
*
         call hzd_nudeln (F_u  ,smu  ,LDIST_DIM,Nk  ,visco,1,0,mm,nn)
         call hzd_nudeln (F_v  ,smv  ,LDIST_DIM,Nk  ,visco,0,1,mm,nn)
         call hzd_nudeln (F_w  ,smw,  LDIST_DIM,Nk+1,visco,0,0,mm,nn)
*
         if(diff_theta)then
            call hzd_nudeln (F_t  ,smt,  LDIST_DIM,Nk+1,visco,0,0,mm,nn)
         endif
*
         if(mm.ne.nn) then
!$omp single
            call rpn_comm_xch_halo( smu  , LDIST_DIM, l_ni,l_nj,G_nk,
     $           G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
            call rpn_comm_xch_halo( smv  , LDIST_DIM, l_ni,l_nj,G_nk,
     $           G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
            call rpn_comm_xch_halo( smw  , LDIST_DIM, l_ni,l_nj,G_nk+1,
     $           G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
*     
            if(diff_theta) then
               call rpn_comm_xch_halo( smt  , LDIST_DIM, l_ni,l_nj,G_nk+1,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
            endif
!$omp end single
         endif
*
      end do
*
      if(diff_theta) then
!$omp do
        do k=1,l_nk+1
        do j=j0,jn
        do i=i0,jn
          F_t(i,j,k)=F_t(i,j,k)*exner_8(i,j,k)
        enddo
        enddo
        enddo
!$omp enddo
      endif
!$omp end parallel
*     __________________________________________________________________
*
      return
      end
