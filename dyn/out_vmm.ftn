!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/r out_vmm - output VMM fields
*
#include "model_macros_f.h"
*
      subroutine out_vmm (F_ip3,F_etikadd_S,F_ext_S,
     $     minx,maxx, miny,maxy,F_nk,F_rf,F_indo,F_nko,F_nkot,F_set)
*
      implicit none
*
      character*6 F_etikadd_S
      character*4 F_ext_S
      integer F_nk,minx,maxx,miny,maxy,F_nko,F_nkot,F_set,F_ip3
      integer F_indo(*)
      real F_rf(*)
*
*author
*     Lee V.                    - rpn July 2004
*
*revision
* v3_20 - Lee V.            - initial MPI version
* v3_30 - McTaggart-Cowan R.- allow for user-defined domain tag extensions
* v3_31 - Lee V.            - kind is set to 2 (press) for 2D fields, not -1
* v4_03 - Lee V.            - modification of Out_etik_S in out_sgrid only
*
*object
*     output all the VMM fields
*	
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_dostep     I    - array containing indices corresponding to the
*                     timestep sets that requires output at this time step.
* F_dostep_max I    - size of F_dostep array
*
*
c Index vectors for level indentifications
c ----------------------------------------
c 
c There is one vector for the momentum level : Ver_hyb%m.
c
c There are 1 vector for the thermo levels :
c    Ver_hyb%t : Thermo levels without special levels but top and surface.
C
c                Ver_hyb%m(1:G_nk)                 Ver_hyb%t(1:G_nk+1)
c model top
c ===========1        -                              X
c o o o o o o2        -                              -
c - - - - - -3        X                              -
c
c ===========4        -                              X
c  
c    ...             ...                            ...
c
c
c ===========2*k      -                              X
c
c - - - - - -2*k+1    X                              -
c
c    ...             ...                            ...
c
c - - - - - -2*G_nk+1 X                              -
c o o o o o o2*G_nk+2 -                              -
c ===========2*G_nk+3 -                              X
c model surface
c
c----------------------------------------------------------------------
*implicits
#include "glb_ld.cdk"
#include "lun.cdk"
#include "out3.cdk"
#include "out.cdk"
#include "cube.cdk"
#include "outd.cdk"
#include "geomn.cdk"
#include "rhsc.cdk"
#include "init.cdk"
#include "rstr.cdk"
#include "vt0.cdk"
#include "vth.cdk"
#include "vt1.cdk"
#include "vt2.cdk"
#include "vta.cdk"
#include "vtx.cdk"
#include "orh.cdk"
#include "p_geof.cdk"
#include "lctl.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
*
*
**
      integer vmmget,vmmlod,vmmuln,vmmatt
      external vmmget,vmmlod,vmmuln,vmmatt
      integer i,j,k, ii, pnerr, gridset, levset
      integer i0,in,j0,jn
      integer sorkey(400),soridx,sorbit(400)
      integer sortype(400),sornk(400)
      integer sor_lpiece(5)
*     sortype =1: 2d with halo l_minx:l_maxx,l_miny:l_maxy
*     so_lpiece
*     sortype =2: 3d with halo l_minx:l_maxx,l_miny:l_maxy,l_nk
*     sortype =3: 3d with halo l_minx:l_maxx,l_miny:l_maxy,l_nk+1
*     sortype =4: 3d with halo l_minx:l_maxx,l_miny:l_maxy,l_nk+2
*     sortype =5: 3d with no halo l_ni,l_nj,l_nk
      character*8 sorname_S(400)
      character*40 attrib
      integer lpiece,npiece,ierr,indo(F_nkot),nko,nkot,nks,nkst
      logical next_L,periodx_L,uvgrid_L
*
*
      real prprlvl(F_nko)
      real w4(minx:maxx,miny:maxy,F_nko) 
      real t4(minx:maxx,miny:maxy,F_nk+2) 
      real t3(minx:maxx,miny:maxy,F_nk+2) 
      real tr,wk
      pointer (patr, tr(LDIST_SHAPE,*))
      pointer (pawk, wk(l_ni,l_nj,*))
*
*_______________________________________________________________________
*
      soridx = 0
      periodx_L = .false.
      uvgrid_L=.false.
      gridset = Outd_grid(F_set)
      levset = Outd_lev(F_set)

      if (.not.G_lam .and. (Grid_x1(gridset)-
     %      Grid_x0(gridset)+1).eq. G_ni ) periodx_L=.true.
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj

      sorkey(1) = VMM_KEY(st1)
      sorkey(2) = VMM_KEY(wup)
      sorkey(3) = VMM_KEY(ut1)
      sorkey(4) = VMM_KEY(tt1)
      sorkey(5) = VMM_KEY(xct1)

*     2D variables
      ierr = vmmatt('ST1',lpiece,npiece,attrib)
      sor_lpiece(1) = lpiece
c     print *,'ST1',lpiece,npiece

*     Momentum levels (WUP)
      ierr = vmmatt('WUP',lpiece,npiece,attrib)
      sor_lpiece(2) = lpiece
c     print *,'WUP',lpiece,npiece

*     Momentum with special levels (ut1)
      ierr = vmmatt('UT1',lpiece,npiece,attrib)
      sor_lpiece(3) = lpiece
c     print *,'UT1',lpiece,npiece

*     Thermodynamic with special levels (TT,tracers)
      ierr = vmmatt('TT1',lpiece,npiece,attrib)
      sor_lpiece(4) = lpiece
c     print *,'TT1',lpiece,npiece

*     non-halo variables
      ierr = vmmatt('XCT1',lpiece,npiece,attrib)
      sor_lpiece(5) = lpiece
c     print *,'XCT1',lpiece,npiece


      do 100 ii=1,Outd_var_max(F_set)
         next_L = .true.
         if (vt0_first(1).ge.0.and.next_L) then
            do i=1,COMMON_SIZE(vt0)
               if (Outd_var_S(ii,F_set).eq.vt0_n_first(i)(1:4)) then
                       soridx = soridx + 1
                       sorkey(soridx) = vt0_first(i)
                       sorname_S(soridx) = vt0_n_first(i)
                       next_L = .false.
               endif
            enddo
         endif
         if (vth_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(vth)
                if (Outd_var_S(ii,F_set).eq.vth_n_first(i)(1:4)) then
                       soridx = soridx + 1
                       sorkey(soridx) = vth_first(i)
                       sorname_S(soridx) = vth_n_first(i)
                       next_L = .false.
                endif
             enddo
         endif
         if (vt1_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(vt1)
                if (Outd_var_S(ii,F_set).eq.vt1_n_first(i)(1:4)) then
                       soridx = soridx + 1
                       sorkey(soridx) = vt1_first(i)
                       sorname_S(soridx) = vt1_n_first(i)
                       next_L = .false.
                endif
             enddo
         endif
         if (vtx_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(vtx)
                if (Outd_var_S(ii,F_set).eq.vtx_n_first(i)(1:4)) then
                    soridx = soridx + 1
                    sorkey(soridx) = vtx_first(i)
                    sorname_S(soridx) = vtx_n_first(i)
                    next_L = .false.
                endif
             enddo
         endif
         if ( Init_balgm_L .and. .not.Rstri_idon_L ) then
             if (vta_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(vta)
                if (Outd_var_S(ii,F_set).eq.vta_n_first(i)(1:4)) then
                    soridx = soridx + 1
                    sorkey(soridx) = vta_first(i)
                    sorname_S(soridx) = vta_n_first(i)
                    next_L = .false.
                endif
             enddo
             endif
         endif
         if (rhsc_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(rhsc)
                if (Outd_var_S(ii,F_set).eq.rhsc_n_first(i)(1:4)) then
                    soridx = soridx + 1
                    sorkey(soridx) = rhsc_first(i)
                    sorname_S(soridx) = rhsc_n_first(i)
                    next_L = .false.
                endif
             enddo
         endif
         if (orh_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(orh)
                if (Outd_var_S(ii,F_set).eq.orh_n_first(i)(1:4)) then
                    soridx = soridx + 1
                    sorkey(soridx) = orh_first(i)
                    sorname_S(soridx) = orh_n_first(i)
                    next_L = .false.
                endif
             enddo
         endif
         if (geof_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(geof)
                if (Outd_var_S(ii,F_set).eq.geof_n_first(i)(1:4)) then
                    soridx = soridx + 1
                    sorkey(soridx) = geof_first(i)
                    sorname_S(soridx) = geof_n_first(i)
                    next_L = .false.
                endif
             enddo
         endif
         if (.not.next_L) then
             if ( sorname_S(soridx)(1:4).eq.Outd_var_S(ii,F_set) ) then
                if ( sorkey(soridx).ge.0 ) then
                  ierr = vmmatt(sorname_S(soridx),lpiece,npiece,attrib)
                  sortype(soridx) = 0
                  do j=1,5
                     if (lpiece.eq.sor_lpiece(j) ) then
                        sortype(soridx) = j
                        sorbit(soridx) = Outd_nbit(ii,F_set)
                     endif
                  enddo
                  if ( sortype(soridx).lt.1 ) then
                       soridx = soridx - 1
                       print *,'Warning: No output for ',sorname_S(soridx)(1:4),'lpiece=',lpiece
                  endif
                else
                  soridx = soridx - 1
                endif
             endif
         endif
 100  continue

      if (soridx.gt.0) then
         pnerr = vmmlod(sorkey(1),soridx)
      else
         return
      endif

*     sortype =1: 2d with halo l_minx:l_maxx,l_miny:l_maxy
*     sortype =2: 3d with halo l_minx:l_maxx,l_miny:l_maxy,l_nk
*     sortype =3: 3d with halo l_minx:l_maxx,l_miny:l_maxy,l_nk+1
*     sortype =4: 3d with halo l_minx:l_maxx,l_miny:l_maxy,l_nk+2
*     sortype =5: 3d with no halo l_ni,l_nj,l_nk
*
      nko=F_nko
      nkot=F_nkot
      nks=nko
      nkst=nkot
      if (F_indo(F_nkot).eq.F_nk+2) nkst=nkot-1
      if (.not. Schm_phyms_L) then
          if (F_indo(F_nko).eq.F_nk+1) nko = nko-1
          if (F_indo(F_nkot).eq.F_nk+2) nkot=nkot-1
      endif
      do 200 ii=1,soridx
         if (uvgrid_L) then
             uvgrid_L=.false.
             call out_sgrid(
     $           Grid_x0(gridset),Grid_x1(gridset),
     $           Grid_y0(gridset),Grid_y1(gridset),
     $           periodx_L, Grid_stride(gridset),
     $           Grid_etikext_s(gridset),F_etikadd_S )
             call out_href(Cube_ig1(gridset,levset),
     $            Cube_ig2(gridset,levset),Geomn_longs,Geomn_latgs)
         endif
         if ( sortype(ii).eq.1 ) then
*            2D field with halo
             pnerr = vmmget(sorkey(ii),patr,tr)
             call ecris_fst2(tr,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $             sorname_S(ii)(1:4),1.0,0.0,  2, 1, 1, 1, 
     $             sorbit(ii) )
*            3D field but NK levels with halo
         else if ( sortype(ii).eq.2 ) then
             pnerr = vmmget(sorkey(ii),patr,tr)
             call ecris_fst2(tr,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m,
     $             sorname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk, F_indo, nko, 
     $             sorbit(ii) )
*            3D field but NK+1 levels with halo
         else if ( sortype(ii).eq.3 ) then
            pnerr = vmmget(sorkey(ii),patr,tr)
            if (sorname_S(ii)(1:1).eq.'U') then
                 call out_sgrid(
     $           Grid_x0(gridset),min(Grid_x1(gridset),G_niu),
     $           Grid_y0(gridset),Grid_y1(gridset),
     $           periodx_L, Grid_stride(gridset),
     $           Grid_etikext_s(gridset),F_etikadd_S )
                 call out_href(Cube_ig1(gridset,levset),
     $                Cube_ig2(gridset,levset)+1,Geomn_longu,Geomn_latgs)
                 uvgrid_L=.true.
            endif
            if (sorname_S(ii)(1:1).eq.'V') then
                 call out_sgrid(
     $           Grid_x0(gridset),Grid_x1(gridset),
     $           Grid_y0(gridset),min(Grid_y1(gridset),G_njv),
     $           periodx_L, Grid_stride(gridset),
     $           Grid_etikext_s(gridset),F_etikadd_S )
                 call out_href(Cube_ig1(gridset,levset),
     $                Cube_ig2(gridset,levset)+2, Geomn_longs,Geomn_latgv)
                 uvgrid_L=.true.
            endif
            if (sorname_S(ii)(1:2).eq.'ZD'.or.sorname_S(ii)(1:2).eq.'WT') then
                 call ecris_fst2(tr,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $             sorname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk+1, F_indo, nkst,
     $             sorbit(ii) )
            else
                 call ecris_fst2(tr,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m,
     $             sorname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk+1, F_indo, nko, 
     $             sorbit(ii) )
            endif
*            3D field but NK+2 levels with halo
         else if ( sortype(ii).eq.4 ) then
             pnerr = vmmget(sorkey(ii),patr,tr)
            if (sorname_S(ii)(1:1).eq.'Q'.or.sorname_S(ii)(1:3).eq.'FIP') then
                 call ecris_fst2(tr(l_minx,l_miny,2),
     $                              l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m,
     $             sorname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk+1, F_indo, nks,
     $             sorbit(ii) )
            else
             call ecris_fst2(tr,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $             sorname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk+2, F_indo, nkot, 
     $             sorbit(ii) )
            endif
*            3D field but NK levels with no halo
         else if ( sortype(ii).eq.5 ) then
             pnerr = vmmget(sorkey(ii),pawk,wk)
             call ecris_fst2(wk,1,l_ni,1,l_nj,Ver_hyb%m,
     $             sorname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk, F_indo, nko, 
     $             sorbit(ii) )
         endif

 200  continue
      pnerr = vmmuln(sorkey,soridx)

* ___________________________________________________________________
      return
      end
