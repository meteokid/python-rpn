! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r out_vmm - output VMM fields
*
#include "model_macros_f.h"
*
      subroutine out_vmm (F_ip3,F_etikadd_S,F_ext_S,
     $     minx,maxx, miny,maxy,F_nk,F_rf,F_indo,F_nko,F_nkot,F_set)
*
      implicit none
*
      character*6 F_etikadd_S
      character*4 F_ext_S
      integer F_nk,minx,maxx,miny,maxy,F_nko,F_nkot,F_set,F_ip3
      integer F_indo(*)
      real F_rf(*)
*
*author
*     Lee V.                    - rpn July 2004
*
*revision
* v3_20 - Lee V.            - initial MPI version
* v3_30 - McTaggart-Cowan R.- allow for user-defined domain tag extensions
* v3_31 - Lee V.            - kind is set to 2 (press) for 2D fields, not -1
* v4_03 - Lee V.            - modification of Out_etik_S in out_sgrid only
*
*object
*     output all the VMM fields
*	
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_dostep     I    - array containing indices corresponding to the
*                     timestep sets that requires output at this time step.
* F_dostep_max I    - size of F_dostep array
*
*
c Index vectors for level indentifications
c ----------------------------------------
c 
c There is one vector for the momentum level : Ver_hyb%m.
c
c There are 1 vector for the thermo levels :
c    Ver_hyb%t : Thermo levels without special levels but top and surface.
C
c                Ver_hyb%m(1:G_nk)                 Ver_hyb%t(1:G_nk+1)
c model top
c ===========1        -                              X
c o o o o o o2        -                              -
c - - - - - -3        X                              -
c
c ===========4        -                              X
c  
c    ...             ...                            ...
c
c
c ===========2*k      -                              X
c
c - - - - - -2*k+1    X                              -
c
c    ...             ...                            ...
c
c - - - - - -2*G_nk+1 X                              -
c o o o o o o2*G_nk+2 -                              -
c ===========2*G_nk+3 -                              X
c model surface
c
c----------------------------------------------------------------------
*implicits
#include "glb_ld.cdk"
#include "lun.cdk"
#include "out3.cdk"
#include "out.cdk"
#include "grid.cdk"
#include "outd.cdk"
#include "geomn.cdk"
#include "rhsc.cdk"
#include "init.cdk"
#include "rstr.cdk"
#include "vt0.cdk"
#include "vth.cdk"
#include "vt1.cdk"
#include "vt2.cdk"
#include "vta.cdk"
#include "vtx.cdk"
#include "orh.cdk"
#include "p_geof.cdk"
#include "lctl.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
*
*
**
      integer vmmget,vmmlod,vmmuln,vmmatt
      external vmmget,vmmlod,vmmuln,vmmatt
      integer i,j,k, ii, pnerr
      integer i0,in,j0,jn
      integer sorkey(400),soridx,sorbit(400),sorfilt(400)
      integer windkey(12),windidx,windbit(12),windfilt(12)
      integer sordim(400)
      integer sorlen(5)
*     sordim =1: 3d with halo l_minx:l_maxx,l_miny:l_maxy,l_nk
*     sordim =2: 2d with halo l_minx:l_maxx,l_miny:l_maxy
*     sordim =3: 3d with no halo l_ni,l_nj,l_nk
      character*8 sorname_S(400),windname_S(12)
      character*40 attrib
      integer lpiece,npiece,ierr,indo(F_nkot),nko,nkot
      logical next_L,periodx_L,uvgrid_L
*
*
      real prprlvl(F_nko)
      real w4(minx:maxx,miny:maxy,F_nko) 
      real t4(minx:maxx,miny:maxy,F_nk+2) 
      real t3(minx:maxx,miny:maxy,F_nk+2) 
      real tr,wk,sorcoef(400),windcoef(12)
      pointer (patr, tr(LDIST_SHAPE,*))
      pointer (pawk, wk(l_ni,l_nj,*))
*
*_______________________________________________________________________
*
      soridx = 0
      windidx = 0
      periodx_L = .false.

      if (.not.G_lam .and. (Grid_x1(Outd_grid(F_set))-
     %      Grid_x0(Outd_grid(F_set))+1).eq. G_ni ) periodx_L=.true.
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj

      sorkey(1) = VMM_KEY(ut1)
      sorkey(2) = VMM_KEY(st1)
      sorkey(3) = VMM_KEY(xct1)
      sorkey(4) = VMM_KEY(tt1)
      sorkey(5) = VMM_KEY(fiptx)

c     Thermodynamic levels (ZD,W)
      ierr = vmmatt('WT1',lpiece,npiece,attrib)
      sorlen(1) = lpiece

c     2D variables
      ierr = vmmatt('ST1',lpiece,npiece,attrib)
      sorlen(2) = lpiece

c     non-halo variables
      ierr = vmmatt('XCT1',lpiece,npiece,attrib)
      sorlen(3) = lpiece

c     Thermodynamic with special levels (TT,tracers)
      ierr = vmmatt('TT1',lpiece,npiece,attrib)
      sorlen(4) = lpiece

      do 100 ii=1,Outd_var_max(F_set)
         next_L = .true.
         if (vt0_first(1).ge.0.and.next_L) then
            do i=1,COMMON_SIZE(vt0)
               if (Outd_var_S(ii,F_set).eq.vt0_n_first(i)(1:4)) then
                   if (Outd_var_S(ii,F_set).eq.'UT0'.or.
     %                 Outd_var_S(ii,F_set).eq.'VT0') then
                       windidx=windidx+1
                       windkey(windidx) = vt0_first(i)
                       windname_S(windidx) = vt0_n_first(i)
                       next_L = .false.
                   else 
                       soridx = soridx + 1
                       sorkey(soridx) = vt0_first(i)
                       sorname_S(soridx) = vt0_n_first(i)
                       next_L = .false.
                   endif
               endif
            enddo
         endif
         if (vth_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(vth)
                if (Outd_var_S(ii,F_set).eq.vth_n_first(i)(1:4)) then
                   if (Outd_var_S(ii,F_set).eq.'UTH'.or.
     %                 Outd_var_S(ii,F_set).eq.'VTH') then
                       windidx=windidx+1
                       windkey(windidx) = vth_first(i)
                       windname_S(windidx) = vth_n_first(i)
                       next_L = .false.
                   else 
                       soridx = soridx + 1
                       sorkey(soridx) = vth_first(i)
                       sorname_S(soridx) = vth_n_first(i)
                       next_L = .false.
                   endif
                endif
             enddo
         endif
         if (vt1_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(vt1)
                if (Outd_var_S(ii,F_set).eq.vt1_n_first(i)(1:4)) then
                   if (Outd_var_S(ii,F_set).eq.'UT1'.or.
     %                 Outd_var_S(ii,F_set).eq.'VT1') then
                       windidx=windidx+1
                       windkey(windidx) = vt1_first(i)
                       windname_S(windidx) = vt1_n_first(i)
                       next_L = .false.
                   else 
                       soridx = soridx + 1
                       sorkey(soridx) = vt1_first(i)
                       sorname_S(soridx) = vt1_n_first(i)
                       next_L = .false.
                   endif
                endif
             enddo
         endif
         if (vtx_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(vtx)
                if (Outd_var_S(ii,F_set).eq.vtx_n_first(i)(1:4)) then
                    soridx = soridx + 1
                    sorkey(soridx) = vtx_first(i)
                    sorname_S(soridx) = vtx_n_first(i)
                    next_L = .false.
                endif
             enddo
         endif
         if ( Init_balgm_L .and. .not.Rstri_idon_L ) then
             if (vta_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(vta)
                if (Outd_var_S(ii,F_set).eq.vta_n_first(i)(1:4)) then
                    soridx = soridx + 1
                    sorkey(soridx) = vta_first(i)
                    sorname_S(soridx) = vta_n_first(i)
                    next_L = .false.
                endif
             enddo
             endif
         endif
         if (rhsc_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(rhsc)
                if (Outd_var_S(ii,F_set).eq.rhsc_n_first(i)(1:4)) then
                    soridx = soridx + 1
                    sorkey(soridx) = rhsc_first(i)
                    sorname_S(soridx) = rhsc_n_first(i)
                    next_L = .false.
                endif
             enddo
         endif
         if (orh_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(orh)
                if (Outd_var_S(ii,F_set).eq.orh_n_first(i)(1:4)) then
                    soridx = soridx + 1
                    sorkey(soridx) = orh_first(i)
                    sorname_S(soridx) = orh_n_first(i)
                    next_L = .false.
                endif
             enddo
         endif
         if (geof_first(1).ge.0.and.next_L) then
             do i=1,COMMON_SIZE(geof)
                if (Outd_var_S(ii,F_set).eq.geof_n_first(i)(1:4)) then
                    soridx = soridx + 1
                    sorkey(soridx) = geof_first(i)
                    sorname_S(soridx) = geof_n_first(i)
                    next_L = .false.
                endif
             enddo
         endif
         if (.not.next_L) then
             if ( sorname_S(soridx)(1:4).eq.Outd_var_S(ii,F_set) ) then
                if ( sorkey(soridx).ge.0 ) then
                  ierr = vmmatt(sorname_S(soridx),lpiece,npiece,attrib)
                  sordim(soridx) = lpiece
                  sorbit(soridx) = Outd_nbit(ii,F_set)
                  sorfilt(soridx) = Outd_filtpass(ii,F_set)
                  sorcoef(soridx) = Outd_filtcoef(ii,F_set)
                else
                  soridx = soridx - 1
                endif
             else if ( windkey(windidx).ge.0 ) then
                windbit(windidx) = Outd_nbit(ii,F_set)
                windfilt(windidx) = Outd_filtpass(ii,F_set)
                windcoef(windidx) = Outd_filtcoef(ii,F_set)
             else
                  windidx = windidx - 1
             endif
         endif
 100  continue

      if (soridx+windidx.eq.0) return

      if (soridx.gt.0) then
         pnerr = vmmlod(sorkey(1),soridx)
      endif
      if (windidx.gt.0) then
         pnerr = vmmlod(windkey(1),windidx)
      endif

*__________________________________________
*     1.0    Output of VMM 2-D variables
*
*__________________________________________

      do ii=1,soridx
         if (sordim(ii).eq.sorlen(2)) then
             pnerr = vmmget(sorkey(ii),patr,tr)
             if (sorfilt(ii).gt.0) then
                 do j=1,l_nj
                 do i=1,l_ni
                    w4(i,j,1)=tr(i,j,1)
                 enddo
                 enddo
                 call filter(w4,sorfilt(ii),sorcoef(ii),'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, 1)
                 call ecris_fst2(w4,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $             sorname_S(ii)(1:4),1.0,0.0,  2, 1, 1, 1, 
     $             sorbit(ii) )
             else
                 call ecris_fst2(tr,l_minx,l_maxx,l_miny,l_maxy,0.0,
     $             sorname_S(ii)(1:4),1.0,0.0,  2, 1, 1, 1, 
     $             sorbit(ii) )
             endif
         endif
      enddo

*_______________________________________________________________________
*
*     2.0    Output of VMM variables on ETA levels
*_______________________________________________________________________

*     No output at surface level except tt,tracers and wind
      nko=F_nko
      nkot=F_nkot
      if (F_indo(F_nko).eq.F_nk+1) nko = nko-1
      if (F_indo(F_nkot).eq.F_nk+2) nkot=nkot-1
*
         do ii=1,soridx

            if (sordim(ii).eq.sorlen(1)) then
c               Thermo levels
               pnerr = vmmget(sorkey(ii),patr,tr)
                call ecris_fst2(tr,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $             sorname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk+2, F_indo, nkot, 
     $             sorbit(ii) )
             else if (sordim(ii).eq.sorlen(3)) then
                pnerr = vmmget(sorkey(ii),pawk,wk)
                call ecris_fst2(wk,1,l_ni,1,l_nj,Ver_hyb%m,
     $             sorname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk, F_indo, nko, 
     $             sorbit(ii) )
             else if (sordim(ii).eq.sorlen(4)) then
c               Thermodynamic levels TT,tracers,qt1,fipt1
                pnerr = vmmget(sorkey(ii),patr,tr)
                if (sorname_S(ii)(1:3).eq.'FIP'
     $              .or.sorname_S(ii)(1:2).eq.'QT' ) then
                    call ecris_fst2(tr(l_minx,l_miny,2),
     $             l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m,
     $             sorname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk, F_indo, nkot, 
     $             sorbit(ii) )                                
                else
                   call ecris_fst2(tr,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t,
     $             sorname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk+2, F_indo, F_nkot, 
     $             sorbit(ii) )                                
                endif
             endif
          enddo

      pnerr = vmmuln(sorkey,soridx)
      if (windidx.eq.0) return
*_______________________________________________________________________
*
*     4.0    Output of VMM WIND variables on ETA levels     
*_______________________________________________________________________
*
*        Output on U  grid
         uvgrid_L = .false.
         do ii=1,windidx
            pnerr = vmmget(windkey(ii),patr,tr)
            if (windname_S(ii)(1:1).eq.'U') then
               if (.not.uvgrid_L) then
                 call out_sgrid(
     $           Grid_x0(outd_grid(F_set)),min(Grid_x1(outd_grid(F_set)),G_niu),
     $           Grid_y0(outd_grid(F_set)),Grid_y1(outd_grid(F_set)),
     $           periodx_L, Grid_stride(outd_grid(F_set)),
     $           Grid_etikext_s(outd_grid(F_set)),F_etikadd_S )
                 call out_href(Grid_ig1(outd_grid(F_set)),
     $                Grid_ig2(outd_grid(F_set))+1,Geomn_longu,Geomn_latgs)
               endif
               uvgrid_L = .true.
               call ecris_fst2(tr,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m,
     $             windname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk+1, F_indo, F_nko, 
     $             windbit(ii) )
            endif
         enddo
*        Output on V  grid
         uvgrid_L = .false.
         do ii=1,windidx
            pnerr = vmmget(windkey(ii),patr,tr)
            if (windname_S(ii)(1:1).eq.'V') then
               if (.not.uvgrid_L) then
                 call out_sgrid(
     $           Grid_x0(outd_grid(F_set)),Grid_x1(outd_grid(F_set)),
     $           Grid_y0(outd_grid(F_set)),min(Grid_y1(outd_grid(F_set)),G_njv),
     $           periodx_L, Grid_stride(outd_grid(F_set)),
     $           Grid_etikext_s(outd_grid(F_set)),F_etikadd_S )
                 call out_href(Grid_ig1(outd_grid(F_set)),
     $                Grid_ig2(outd_grid(F_set))+2, Geomn_longs,Geomn_latgv)
               endif
               uvgrid_L = .true.
               call ecris_fst2(tr,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m,
     $             windname_S(ii)(1:4),1.0,0.0,Out_kind,F_nk+1, F_indo, F_nko, 
     $             windbit(ii) )
            endif
         enddo

      pnerr = vmmuln(windkey,windidx)

* ___________________________________________________________________
      return
      end
