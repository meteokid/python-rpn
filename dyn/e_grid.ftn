***s/r e_grid - compute the grid of the model
#include <model_macros_f.h>
*
      subroutine e_grid 
      implicit none
*
*author  unknown
*
*revision
* v2_30 - Dugas B.          - use real*8 rotation matrices and 
* v2_30                       cartesian coordinates
* v3_00 - Desgagne & Lee    - Lam configuration
*
*implicits
#include "e_grids.cdk"
#include "hgc.cdk"
#include "grd.cdk"
*
      integer  stretch_axis2, ezgdef_fmem
      external stretch_axis2, ezgdef_fmem
*
      integer i,j,nleft,nbelo,nimax,njmax,ier,ni,nila,ng
      real*8 y_8(Grd_nj+2),pt5,x2_8(2000),y2_8(2000),
     $       a_8,b_8,c_8,d_8,xyz1_8(3),xyz2_8(3)
      real*8, dimension (:), allocatable :: x_8
      parameter (pt5 = 0.5)
      real r1,s1,x0,y0,xl,yl
*
*----------------------------------------------------------------------
*
      call hpalloc (paxfi, nifi, ier, 1)
      call hpalloc (payfi, njfi, ier, 1)
      call hpalloc (paxu , niu , ier, 1)
      call hpalloc (payv , njv , ier, 1)
*
      ni   = Grd_ni
      nila = Grd_nila
      if (.not.lam) then
          ni=ni+1
          if ( ni .eq. nila+1) nila=nila+1
      endif
*
      allocate (x_8(ni+2))
      Hgc_gxtyp_s = 'E'
      write(6,1001)
*
*     reset Grd_xlon1, Grd_xlat1, Grd_xlon2, Grd_xlat2 
*     if grid is not rotated
*
      if (.not. Grd_roule) then
         Grd_xlon1=180.
         Grd_xlat1=0.
         Grd_xlon2=270.
         Grd_xlat2=0.
      endif
*      
      LAM = .false.
      if (abs(1.0-abs(Grd_xl-Grd_x0)/360.).gt.1.0e-5) LAM = .true.
      if (abs(1.0-abs(Grd_yl-Grd_y0)/180.).gt.1.0e-5) LAM = .true.
*
*     compute RPN/FST grid descriptors
*
      call cxgaig ( Hgc_gxtyp_S,Hgc_ig1ro,Hgc_ig2ro,Hgc_ig3ro,Hgc_ig4ro,
     $                        Grd_xlat1,Grd_xlon1,Grd_xlat2,Grd_xlon2 )
      call cigaxg ( Hgc_gxtyp_S,Grd_xlat1,Grd_xlon1,Grd_xlat2,Grd_xlon2,
     $                        Hgc_ig1ro,Hgc_ig2ro,Hgc_ig3ro,Hgc_ig4ro )
*
      write(6,1005) Grd_xlat1,Grd_xlon1,Grd_xlat2,Grd_xlon2
*
*     compute x and y positions of the PHI grid
*
      ier=stretch_axis2 ( x_8, Grd_dx, Grd_x0, Grd_xl, nleft, ni, nila,
     $                    r1, .false., .false., Grd_dxmax, nimax )
*
      if (ier.ne.0) then
          write(6,*)'ERROR in generating X axis!!! ABORT!!!!'
          call e_arret('e_gridgef')
      endif
*
      if (LAM) then
         ier=stretch_axis2 ( y_8, Grd_dy, Grd_y0, Grd_yl, nbelo, Grd_nj,
     $                   Grd_njla, s1, .false.,.false.,Grd_dymax,njmax )
      else
         ier=stretch_axis2 ( y_8, Grd_dy, Grd_y0, Grd_yl, nbelo, Grd_nj,
     $                   Grd_njla, s1, .true. ,.false.,Grd_dymax,njmax )
      endif 
*
      if (ier.ne.0) then
          write(6,*)'ERROR in generating Y axis!!! ABORT!!!!'
          call e_arret('e_gridgef')
      endif
*
*     compute the staggered positions for U and V grids
*
      do i=1,ni-2
         xu(i) = pt5 * ( x_8(i) + x_8(i+1) )
      enddo
      if (.not.LAM) then
         xu(ni-1) = pt5 * ( x_8(ni-1) + x_8(1) + 360. )
         xu(ni  ) = pt5 * ( x_8   (1) + x_8(2) ) + 360. 
      else
         xu(ni-1) = pt5 * ( x_8(ni-1) + x_8(ni))
      endif
      do i=1,Grd_nj-1
         yv(i) = pt5 * ( y_8(i) + y_8(i+1) )
      enddo
*
*     convert to real*4 
*
      do i=1,ni
         xfi(i)=x_8(i)
      enddo
      do j=1,Grd_nj
         yfi(j)=y_8(j)
      enddo
*
      deallocate (x_8)
*
*     adjust grid coverage parameters
*
      x0 = xfi(1)
      y0 = yfi(1)
      xl = xfi(ni)
      yl = yfi(Grd_nj)
*
      write(6,1020) ni,x0,xl,Grd_nj,y0,yl,
     $                   Grd_xlon1,Grd_xlat1
      write(6,1025) nila,Grd_dx,1+nleft,1+nleft+nila-1,
     $                   Grd_njla,Grd_dy,1+nbelo,1+nbelo+Grd_njla-1
      i = ni-nila-nleft
      j = Grd_nj-Grd_njla-nbelo
      write(6,1030) nleft,i,r1,xfi(2)-xfi(1),
     $                   nbelo,j,s1,yfi(2)-yfi(1)
*
      if ( nimax .gt. 0 ) write(6,1035) Grd_dxmax, nimax, 'X','X'
      if ( njmax .gt. 0 ) write(6,1035) Grd_dymax, njmax, 'Y','Y'
      write(6,1031)
*
*     Compute rotated coordinates if Grd_roule = .true.
*
      if (Grd_roule) then
*
*     Compute the rotation matrix (r_8) that allows transformation
*     from the none-rotated to the rotated spherical coordinate system.
*
*     Compute transform matrices xyz1_8 and xyz2_8
*
         call llacar ( xyz1_8, Grd_xlon1, Grd_xlat1, 1, 1 )
         call llacar ( xyz2_8, Grd_xlon2, Grd_xlat2, 1, 1 )
*
*     Compute a = cos(alpha) & b = sin(alpha)
*
         a_8 = (xyz1_8(1)*xyz2_8(1)) + (xyz1_8(2)*xyz2_8(2)) 
     $                               + (xyz1_8(3)*xyz2_8(3))
         b_8 = sqrt (((xyz1_8(2)*xyz2_8(3)) - (xyz2_8(2)*xyz1_8(3)))**2
     $            +  ((xyz2_8(1)*xyz1_8(3)) - (xyz1_8(1)*xyz2_8(3)))**2 
     $            +  ((xyz1_8(1)*xyz2_8(2)) - (xyz2_8(1)*xyz1_8(2)))**2)
*
*     Compute c = norm(-r1) & d = norm(r4)
*
         c_8 = sqrt ( xyz1_8(1)**2 + xyz1_8(2)**2 + xyz1_8(3)**2 )
         d_8 = sqrt ( ( ( (a_8*xyz1_8(1)) - xyz2_8(1) ) / b_8 )**2 +
     $                ( ( (a_8*xyz1_8(2)) - xyz2_8(2) ) / b_8 )**2 +
     $                ( ( (a_8*xyz1_8(3)) - xyz2_8(3) ) / b_8 )**2  )
*
         Grd_rot_8(1,1)=  -xyz1_8(1)/c_8
         Grd_rot_8(1,2)=  -xyz1_8(2)/c_8
         Grd_rot_8(1,3)=  -xyz1_8(3)/c_8
         Grd_rot_8(2,1)=  ( ((a_8*xyz1_8(1)) - xyz2_8(1)) / b_8)/d_8
         Grd_rot_8(2,2)=  ( ((a_8*xyz1_8(2)) - xyz2_8(2)) / b_8)/d_8
         Grd_rot_8(2,3)=  ( ((a_8*xyz1_8(3)) - xyz2_8(3)) / b_8)/d_8
         Grd_rot_8(3,1)=  
     $        ( (xyz1_8(2)*xyz2_8(3)) - (xyz2_8(2)*xyz1_8(3)))/b_8
         Grd_rot_8(3,2)=  
     $        ( (xyz2_8(1)*xyz1_8(3)) - (xyz1_8(1)*xyz2_8(3)))/b_8
         Grd_rot_8(3,3)=  
     $        ( (xyz1_8(1)*xyz2_8(2)) - (xyz2_8(1)*xyz1_8(2)))/b_8
*
      else
*
         do j=1,3
         do i=1,3
            Grd_rot_8(i,j) = 0.0
         enddo
         enddo
         Grd_rot_8(1,1) = 1.
         Grd_rot_8(2,2) = 1.
         Grd_rot_8(3,3) = 1.
*
      endif
*
      dstf_gid = ezgdef_fmem (ni , Grd_nj , 'Z', 'E', Hgc_ig1ro,
     $               Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
      dstu_gid = ezgdef_fmem (niu, Grd_nj , 'Z', 'E', Hgc_ig1ro,
     $               Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xu  , yfi )
      dstv_gid = ezgdef_fmem (ni , njv    , 'Z', 'E', Hgc_ig1ro,
     $               Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yv  )
*
 1001 format (/1x,'COMPUTE MODEL GRID (S/R E_GRIDGEF)',
     $        /1x,34('='))
 1005 format (/1x,'AJUSTED RPN/FST grid descriptors Grd_xlat1,',
     $            'Grd_xlon1,Grd_xlat2,Grd_xlon2:'
     $        /4f12.6/1x,73('='))
 1020 FORMAT (/1X,'FINAL HORIZONTAL GRID CONFIGURATION:'
     $  /1X,' NI=',I4,' FROM Grd_x0=',F9.3,' TO Grd_xl=',F9.3,' DEGREES'
     $  /1X,' NJ=',I4,' FROM Grd_y0=',F9.3,' TO Grd_yl=',F9.3,' DEGREES'
     $  /1X,' CENTRAL POINT OF THE GRID  Grd_xlon1,Grd_xlat1=',
     $  2F9.3,' DEGREES'/1x,74('='))
 1025  FORMAT(/1X,'THE CONSTANT RESOLUTION AREA HAS:'
     $        /1X,' NILA=',I4,' OF GRID-LENGTH=',F9.4,' DEGREES'
     $         1x,'(',i4,',',i4,' )',
     $        /1X,' NJLA=',I4,' OF GRID-LENGTH=',F9.4,' DEGREES'
     $         1x,'(',i4,',',i4,' )',
     $        /1x,56('='))
 1030  FORMAT(/1X,'THE VARIABLE RESOLUTION AREA HAS:'
     $      /1X,i3,' POINTS TO THE WEST  AND ',i3,' POINTS TO THE EAST'
     $      /2x,'WITH STRETCHING FACTOR=',F8.4,
     $      ' AND MINIMUM RESOLUTION=',F8.4,
     $      /1X,i3,' POINTS ON THE SOUTH AND ',i3,' POINTS ON THE NORTH'
     $      /2x,'WITH STRETCHING FACTOR=',F8.4,
     $      ' AND MINIMUM RESOLUTION=',F8.4)
 1031  FORMAT(1x,64('='))
 1035  FORMAT(2x,'RESOLUTION IS LIMITED TO ',F9.4,1x,
     $           'DEGREES OVER LAST',I4,' DELTA-',a1,' AT ',
     $           'EACH ENDS OF THE ',a1,' AXIS.')
*
*----------------------------------------------------------------------
*
      return
      end
