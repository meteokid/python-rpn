!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
copyright (C) 2001  MSC-RPN COMM  %%%MC2%%%
***s/r casc_bcs - For reading cascade 3DF pilot files where
*                 3DF01 files were written after advection,
*                 3DF02 files were written after Physics
*                 This one is used for after the initialization of LAM
*                 See casc_3df_dynp.ftn.
*
#include "model_macros_f.h"
*
      integer function casc_bcs ( datev, unf, wowp, errp )
      implicit none
*
      character*15 datev
      integer unf,wowp,errp
*
*author
*     M. Desgagne  April 2006 (MC2 casc_bcs)
*
*revision
* v3_30 - Lee V.         - initial version for GEMDM
* v4_03 - Lee/Desgagne   - ISST
* v4_05 - Plante A.      - top nesting
*
*
#include "glb_ld.cdk"
#include "bcsdim.cdk"
#include "bcsgrds.cdk"
#include "bcsmem.cdk"
#include "ptopo.cdk"
#include "ifd.cdk"
#include "schm.cdk"
#include "tr3d.cdk"
#include "lun.cdk"
#include "lctl.cdk"
#include "ind.cdk"
#include "nest.cdk"
#include "acid.cdk"
#include "path.cdk"
*
*        presstype
*            0 => p =    A                         (B=0),  prs-anal
*            1 => p =    A+B*   ps       , F_p0=ps (A=0),  sig-anal
*            2 => p =    A+B*   ps       , F_p0=ps      ,  etasef-anal
*            3 => p =    A+B*   ps       , F_p0=ps      ,  eta-anal
*            4 => p =    A+B*   ps       , F_p0=ps      ,  hyb-anal
*         ?  5 => p =    A+B*   ps       , F_p0=ps      ,  ecm-anal
*            6 => p =exp(A+B*ln(ps/pref)), F_p0=ps      ,  stg-anal

      integer  vmmlod,vmmget,vmmuld,longueur,sid3df
      external vmmlod,vmmget,vmmuld,longueur,sid3df
      character*2 md
      character*4 nomvar
      character*8 dynophy
      character*8, dimension (:), pointer :: trname_a
      character*256 fn
      logical done,data2treat
      real trp
      pointer (patrp, trp(LDIST_SHAPE,*))
      real, dimension (:,:,:), pointer :: trn
      integer i,j,k,ntra,n,err,ngd,nga,errop,ofi,ofj,mode,ioerr,
     $   errdyn,cumerr,cnt,nit,njt,d1,ni1,nj1,nk1,nbits,id,nvar,
     $   nka_m,nka_t,presstype
      integer key1(17),keyp_,keyp(Tr3d_ntr)
      real*8  , dimension (:  ), pointer :: xpaq,ypaq,xpau,ypav
      real, dimension (:,:), pointer :: 
     $       uun,vvn,zdn,ttn,meqn,ssqn,qqn,wwn
      real topo_s(minxs:maxxs+1,minys:maxys+1)
      real topo_n(minxn:maxxn+1,minyn:maxyn+1)
      real topo_w(minxw:maxxw+1,minyw:maxyw+1)
      real topo_e(minxe:maxxe+1,minye:maxye+1)
*-----------------------------------------------------------------------
*
      if (Lun_debug_L) write (Lun_out,1000) Lctl_step,wowp
*

      casc_bcs = -1
      nullify(xpaq,ypaq,xpau,ypav,
     $        uun,vvn,zdn,ttn,meqn,ssqn,qqn,wwn,trn,trname_a)
*
      data2treat = l_south.or.l_north.or.l_west.or.l_east
*
      if (data2treat) then
*

      nga  = bcs_nia * bcs_nja
      nka_m=0
      nka_t=0
      ntra = 0
      err  = 0
      done = .false.
      write (md,'(i2.2)') wowp
*
* Read all needed files and construct the source domain for
* the horozontal interpolation
*
      do 50 n=1,ifd_nf
      if (ifd_needit(n)) then
         errdyn = -1
         fn= trim(Path_ind_S)//'/3df'//md//'_'//datev//'_'//ifd_fnext(n)
         open (unf,file=fn(1:longueur(fn)),access='SEQUENTIAL',
     $            form='UNFORMATTED',status='OLD',iostat=errop)
c        print *,'opening ',fn(1:longueur(fn)),'errop=',errop
         if (errop.ne.0) goto 33
*
* Use first file to establish 3D grid dimensions and geo-references
* of all input stagerred grids (xpaq, ypaq, xpau and ypva).
*
         if (.not.done) allocate (xpaq(bcs_nia), ypaq(bcs_nja), 
     $                            xpau(bcs_nia), ypav(bcs_nja))
         err = sid3df (xpaq,ypaq,xpau,ypav,unf,done,
     $                 bcs_nia,bcs_nja,nka_m,nka_t,presstype)
         read (unf,end=33) dynophy,mode,nvar,ntra
*
         if (.not.done) then
            allocate (uun(nga,nka_m),vvn(nga,nka_m),
     $                zdn(nga,nka_t-1),ttn(nga,nka_t),
     $                ssqn(nga,1),
     $                qqn(nga,nka_m+1), wwn(nga,nka_t-1),
     $                trn(nga,nka_t,ntra),
     $                trname_a(ntra) )
            if (presstype.eq.0) then ! if in pressure levels
                allocate (meqn(nga,nka_m))
            else
                allocate (meqn(nga,1))
            endif
	    uun=0.; vvn=0.; zdn=0.; ttn=0.; ssqn=0.; trn=0.; 
            wwn=0.; qqn=0.; meqn=0.;
         endif
         ofi = ifd_minx(n)-1
         ofj = ifd_miny(n)-1
         cumerr=0
         call read_3df(unf,uun,vvn,zdn,ttn,ssqn,meqn,qqn,wwn,trn,
     $             trname_a,nvar,ntra,nga,nka_m,nka_t,ofi,ofj,cumerr)
         errdyn = cumerr
 33      continue
*
*        finish filmup for dynamic variables
         err = err + errdyn
         if (err.lt.0) then
            if (Ptopo_myproc.eq.0) write (6,203) fn(1:longueur(fn))
            goto 999
         endif
         done = .true.
         close (unf)
      endif
  50  continue
      casc_bcs = 0
 999  continue
*
      else
         casc_bcs = 0
      endif
*
*
* topo is inflated!
      call rpn_comm_xch_halo ( Ind_topo, LDIST_DIM,l_ni,l_nj,1,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
       call trnes1(Ind_topo,topo_s,topo_n,topo_w,topo_e,
     $         LDIST_DIM,
     $         minxs,maxxs+1-(east*1),minys,maxys+1,
     $         minxn,maxxn+1-(east*1),minyn,maxyn+1-(north*1),
     $         minxw,maxxw+1,minyw,maxyw+1,
     $         minxe,maxxe+1-(east*1),minye,maxye+1,
     $         1)

      if (.not.data2treat .or. casc_bcs.lt.0) return

* Perform horizontal and vertical interpolations for South boundary
      
      if (l_south) 
     $call casc_hvi (trname_a,
     $  xps,yps,xpus,ypvs,xpaq,ypaq,xpau,ypav,
     $  bcs_uf,bcs_vf, bcs_tf,bcs_zdf,
     $  bcs_sf,bcs_qf, bcs_wf,bcs_trf,
     $  bcs_is-1, bcs_sz, topo_s,
     $  uun,vvn,ttn,zdn,meqn,ssqn,qqn,wwn,trn,
     $  minxs,maxxs,minys,maxys,maxxs+1-(east*1),maxys+1, G_nk, 
     $  bcs_nia,bcs_nja,nka_m,nka_t,presstype,ntra)

* Perform horizontal and vertical interpolations for North boundary
c     print *,Ptopo_myproc,'casc_hvi N:',minxn,maxxn,minyn,maxyn
      if (l_north) 
     $call casc_hvi (trname_a,
     $  xpn,ypn,xpun,ypvn,xpaq,ypaq,xpau,ypav,
     $  bcs_uf(bcs_in),bcs_vf(bcs_in), bcs_tf(bcs_in),bcs_zdf(bcs_in),
     $  bcs_sf(bcs_in),bcs_qf(bcs_in),bcs_wf(bcs_in),bcs_trf,
     $  bcs_in-1, bcs_sz, topo_n,
     $  uun,vvn,ttn,zdn,meqn,ssqn,qqn,wwn,trn,
     $  minxn,maxxn,minyn,maxyn,maxxn+1-(east*1),maxyn+1-(north*1), G_nk,
     $  bcs_nia,bcs_nja,nka_m,nka_t,presstype,ntra)

* Perform horizontal and vertical interpolations for West boundary
c     print *,Ptopo_myproc,'casc_hvi W:'
      if (l_west) 
     $call casc_hvi (trname_a,
     $  xpw,ypw,xpuw,ypvw,xpaq,ypaq,xpau,ypav,
     $  bcs_uf(bcs_iw),bcs_vf(bcs_iw), bcs_tf(bcs_iw),bcs_zdf(bcs_iw),
     $  bcs_sf(bcs_iw),bcs_qf(bcs_iw),bcs_wf(bcs_iw),bcs_trf,
     $  bcs_iw-1, bcs_sz, topo_w,
     $  uun,vvn,ttn,zdn,meqn,ssqn,qqn,wwn,trn,
     $  minxw,maxxw,minyw,maxyw,maxxw+1,maxyw+1, G_nk,
     $  bcs_nia,bcs_nja,nka_m,nka_t,presstype,ntra)

* Perform horizontal and vertical interpolations for East boundary
c     print *,Ptopo_myproc,'casc_hvi E:'
      if (l_east) 
     $call casc_hvi (trname_a, 
     $  xpe,ype,xpue,ypve,xpaq,ypaq,xpau,ypav,
     $  bcs_uf(bcs_ie),bcs_vf(bcs_ie), bcs_tf(bcs_ie),bcs_zdf(bcs_ie),
     $  bcs_sf(bcs_ie),bcs_qf(bcs_ie),bcs_wf(bcs_ie),bcs_trf,
     $  bcs_ie-1, bcs_sz, topo_e,
     $  uun,vvn,ttn,zdn,meqn,ssqn,qqn,wwn,trn,
     $  minxe,maxxe,minye,maxye,maxxe+1-(east*1),maxye+1, G_nk,
     $  bcs_nia,bcs_nja,nka_m,nka_t,presstype,ntra)
*
      if (associated(xpaq)) deallocate (xpaq)
         if (associated(ypaq)) deallocate (ypaq)
         if (associated(xpau)) deallocate (xpau)
         if (associated(ypav)) deallocate (ypav)
         if (associated(uun)) deallocate (uun)
         if (associated(vvn)) deallocate (vvn)
         if (associated(zdn)) deallocate (zdn)
         if (associated(ttn)) deallocate (ttn)
         if (associated(meqn)) deallocate (meqn)
         if (associated(ssqn)) deallocate (ssqn)
         if (associated(trn)) deallocate (trn)
         if (associated(trname_a)) deallocate (trname_a)
*
      if (Ptopo_myproc.eq.0) then
         write(6,100)
         write(6,101) datev,wowp
         write(6,100)
      endif
*
      if ( data2treat.and. (wowp.eq.1.or.errp.lt.0) ) then
*
c        print *,'CASC_BCS wowp=',wowp, ' copying bcs_uf to Ind_u'
         call trnes (Ind_u,bcs_uf(bcs_is),bcs_uf(bcs_in),
     $       bcs_uf(bcs_iw),bcs_uf(bcs_ie),bcs_uf(bcs_it),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,l_ni,l_nj,G_nk+1,1)
         call trnes (Ind_v,bcs_vf(bcs_is),bcs_vf(bcs_in),
     $       bcs_vf(bcs_iw),bcs_vf(bcs_ie),bcs_vf(bcs_it),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,l_ni,l_nj,G_nk+1,1)
         call trnes (Ind_t,bcs_tf(bcs_is),bcs_tf(bcs_in),
     $       bcs_tf(bcs_iw),bcs_tf(bcs_ie),bcs_tf(bcs_it),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,l_ni,l_nj,G_nk+2,1)
         call trnes (Ind_s,bcs_sf(bcs_is),bcs_sf(bcs_in),
     $       bcs_sf(bcs_iw),bcs_sf(bcs_ie),bcs_sf(bcs_it),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,l_ni,l_nj,1,1)
         call trnes (Ind_zd,bcs_zdf(bcs_is),bcs_zdf(bcs_in),
     $       bcs_zdf(bcs_iw),bcs_zdf(bcs_ie),bcs_zdf(bcs_it),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,l_ni,l_nj,G_nk+1,1)
         call trnes (Ind_w,bcs_wf(bcs_is),bcs_wf(bcs_in),
     $       bcs_wf(bcs_iw),bcs_wf(bcs_ie),bcs_wf(bcs_it),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,l_ni,l_nj,G_nk+1,1)
         if (.not.Schm_hydro_L) then
            call trnes (Ind_q,bcs_qf(bcs_is),bcs_qf(bcs_in),
     $       bcs_qf(bcs_iw),bcs_qf(bcs_ie),bcs_qf(bcs_it),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,l_ni,l_nj,G_nk+2,1)
         endif
         keyp_ = VMM_KEY (nest_trf)
         do n=1,Tr3d_ntr
            keyp(n) = keyp_ + n
         end do
         err = vmmlod(keyp,Tr3d_ntr)
         do n = 1, Tr3d_ntr
            err = vmmget(keyp(n),patrp,trp)
            id = (n-1)*bcs_sz+1
            call trnes(trp,bcs_trf(id),
     $                 bcs_trf(id+bcs_in-1),bcs_trf(id+bcs_iw-1),
     $                 bcs_trf(id+bcs_ie-1),bcs_trf(id+bcs_it-1),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,l_ni,l_nj,G_nk+2,1)
         end do
         err = vmmuld(keyp,Tr3d_ntr)
      endif
*
*
 100  format (' ',60('*'))
 101  format (' (CASC_BCS) JUST READ LBCS DATA FOR DATE: ',a15,x,i3)
 203  format (' FILE: ',a,' NOT AVAILABLE')
 1000 format (/' CASC_BCS AT TIMESTEP', I8,' WOWP=',I3)
*-----------------------------------------------------------------------
      return
      end
*
