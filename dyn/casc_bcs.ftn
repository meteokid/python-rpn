copyright (C) 2001  MSC-RPN COMM  %%%MC2%%%
***s/r casc_bcs - For reading cascade 3DF pilot files where
*                 3DF01 files were written after advection,
*                 3DF02 files were written after Physics
*                 This one is used for after the initialization of LAM
*                 See casc_3df_dynp.ftn.
*
#include "model_macros_f.h"
*
      integer function casc_bcs ( datev, unf, wowp, errp )
      implicit none
*
      character*15 datev
      integer unf,wowp,errp
*
*author
*     M. Desgagne  April 2006 (MC2 casc_bcs)
*
*revision
* v3_30 - Lee V.         - initial version for GEMDM
*
*
#include "glb_ld.cdk"
#include "bcsdim.cdk"
#include "bcsgrds.cdk"
#include "bcsmem.cdk"
#include "ptopo.cdk"
#include "ifd.cdk"
#include "schm.cdk"
#include "tr3d.cdk"
#include "lun.cdk"
#include "lctl.cdk"
#include "ind.cdk"
#include "nest.cdk"
#include "acid.cdk"
*
      integer  vmmlod,vmmget,vmmuld,longueur,sid3df
      external vmmlod,vmmget,vmmuld,longueur,sid3df
      character*2 md
      character*4 nomvar
      character*8 dynophy
      character*8, dimension (:), pointer :: trname_a
      character*256 fn
      logical done,data2treat
      real trp
      pointer (patrp, trp(LDIST_SHAPE,*))
      real, dimension (:,:,:), pointer :: trn
      integer i,j,k,nka,ntra,n,err,ngd,nga,errop,ofi,ofj,mode,ioerr,
     $   errdyn,cumerr,cnt,nit,njt,d1,ni1,nj1,nk1,nbits,id,nvar
      integer key1(17),keyp_,keyp(Tr3d_ntr)
      real*8  , dimension (:  ), pointer :: xpaq,ypaq,xpau,ypav
      real, dimension (:,:), pointer :: 
     $       uun,vvn,psdn,ttn,ssn,wwn,qsecn,p0n,fisn
      real topo(bcs_sz),topu(bcs_sz),topv(bcs_sz)
*-----------------------------------------------------------------------
*
      if (Lun_debug_L) write (Lun_out,1000) Lctl_step,wowp
*

      casc_bcs = -1
      nullify(xpaq,ypaq,xpau,ypav,
     $     uun,vvn,psdn,ttn,ssn,wwn,qsecn,p0n,fisn,trn,trname_a)
*
      data2treat = l_south.or.l_north.or.l_west.or.l_east
*
      if (data2treat) then
*

      nga  = bcs_nia * bcs_nja
      nka  = 0
      ntra = 0
      err  = 0
      done = .false.
      write (md,'(i2.2)') wowp
*
* Read all needed files and construct the source domain for
* the horozontal interpolation
*
      do 50 n=1,ifd_nf
      if (ifd_needit(n)) then
         errdyn = -1
         fn ='../casc/3df'//md//'_'//datev//'_'//ifd_fnext(n)
         open (unf,file=fn(1:longueur(fn)),access='SEQUENTIAL',
     $            form='UNFORMATTED',status='OLD',iostat=errop)
         if (Lun_debug_L) write(Lun_out,*)'opening ',fn(1:longueur(fn)),'errop=',errop
         if (errop.ne.0) goto 33
*
* Use first file to establish 3D grid dimensions and geo-references
* of all input stagerred grids (xpaq, ypaq, xpau and ypva).
*
         if (.not.done) allocate (xpaq(bcs_nia), ypaq(bcs_nja), 
     $                            xpau(bcs_nia), ypav(bcs_nja))
         err = sid3df (xpaq,ypaq,xpau,ypav,unf,done,
     $                     bcs_nia,bcs_nja,nka,nvar,ntra)
c        print*,'casc_bcs: nia,nja=',bcs_nia,bcs_nja,'nvar,ntra=',nvar,ntra
         read (unf,end=33) dynophy,cnt,mode
*
         if (.not.done) then
            allocate (uun(nga,nka),vvn(nga,nka),psdn(nga,nka),
     $           ttn(nga,nka),ssn(nga,1),wwn(nga,nka),qsecn(nga,nka),
     $           p0n(nga,1),fisn(nga,1),trn(nga,nka,ntra),
     $           trname_a(ntra) )
	    uun=0.  ; vvn=0.; psdn=0. ; ttn=0.; ssn=0.; wwn=0.;
            qsecn=0.; p0n=0.; fisn=0. ; trn=0.
         endif
         ofi = ifd_minx(n)-1
         ofj = ifd_miny(n)-1
         cumerr=0

*        filling uun buffer by reading from unit unf
              
              if (nvar.eq.5) then
                  call filmup ( ttn,ifd_niad,ifd_niaf,ifd_njad,
     $                              ifd_njaf, nka,unf,ofi,ofj,cumerr )
                  call filmup ( p0n,ifd_niad,ifd_niaf,ifd_njad,
     $                              ifd_njaf,   1,unf,ofi,ofj,cumerr )
                  call filmup (fisn,ifd_niad,ifd_niaf,ifd_njad,
     $                              ifd_njaf,   1,unf,ofi,ofj,cumerr )
              else
                 call gem_stop("casc_bcs : a revoir",-1)
                  call filmup ( ttn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                   nka,unf,ofi,ofj,cumerr )
                  call filmup ( ssn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                   1      ,unf,ofi,ofj,cumerr )
                  call filmup (psdn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                   nka,unf,ofi,ofj,cumerr )
                  if (nvar.gt.11) then
                     call filmup ( wwn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                   nka,unf,ofi,ofj,cumerr )
                     call filmup ( qsecn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                   nka,unf,ofi,ofj,cumerr )
                  endif
              endif
              if (ntra.gt.0) then
                  call filuptr ( trn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,nka,
     $              unf,ofi,ofj,Tr3d_name_S,Tr3d_ntr,trname_a,ntra,cumerr )
              endif
              call filmup ( uun,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                   nka,unf,ofi,ofj,cumerr )
              call filmup ( vvn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                   nka,unf,ofi,ofj,cumerr )
         errdyn = cumerr
 33      continue
*
*        finish filmup for dynamic variables
         err = err + errdyn
         if (err.lt.0) then
            if (Ptopo_myproc.eq.0) write (6,203) fn(1:longueur(fn))
            goto 999
         endif
         done = .true.
         close (unf)
      endif
  50  continue
      casc_bcs = 0
 999  continue
*
      else
         casc_bcs = 0
      endif
*
      if (.not.data2treat .or. casc_bcs.lt.0) return
*
* Perform horizontal and vertical interpolations for S-N 
* and W-E boundaries
*
      nit = max(dimxs,dimxn)
      njt = 0
      if (l_south) njt = njt + dimys
      if (l_north) njt = njt + dimyn
      d1  = dimys*north
      ngd = nit * njt
*
c     print *,'CASC_BCS: call casc_hvi NS - put data into bcs_uf'
      if (data2treat) then
      call trnes (Ind_topo,topo(bcs_is),topo(bcs_in),topo(bcs_iw),
     $            topo(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,1,0)
      call trnes (Ind_topu,topu(bcs_is),topu(bcs_in),topu(bcs_iw),
     $            topu(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,1,0)
      call trnes (Ind_topv,topv(bcs_is),topv(bcs_in),topv(bcs_iw),
     $            topv(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,1,0)
      endif
      if (data2treat) then

c      call glbstat (uun ,'uun' ,1,nga,1,1,nka,1,nga,1,1,1,nka)
c      call glbstat (p0n ,'p0n' ,1,nga,1,1,  1,1,nga,1,1,1,  1)
c      call glbstat (fisn,'fisn',1,nga,1,1,  1,1,nga,1,1,1,  1)

      call casc_hvi (trname_a,
     $  xpn,ypn,xpun,ypvn,xpaq,ypaq,xpau,ypav,
     $  bcs_uf,bcs_uf(bcs_in),bcs_vf,bcs_vf(bcs_in),
     $  bcs_tf,bcs_tf(bcs_in),bcs_psdf,bcs_psdf(bcs_in),
     $  bcs_trf,bcs_wf,bcs_wf(bcs_in),
     $  bcs_qsecf,bcs_qsecf(bcs_in),bcs_sf,bcs_sf(bcs_in),
     $  bcs_is-1,bcs_in-1,
     $  topo,topo(bcs_in),topu,topu(bcs_in),topv,topv(bcs_in),
     $  uun,vvn,psdn,ttn,fisn,p0n,ssn,wwn,qsecn,trn,
     $               minxs,maxxs,minys,maxys,0,d1,G_nk,nit,njt,
     $               bcs_nia,bcs_nja,nka,nvar,ntra,l_south,l_north)
        endif
*
      nit = 0
      njt = max(dimyw,dimye)
      if (l_west) nit = nit + dimxw
      if (l_east) nit = nit + dimxe
      d1  = dimxw*east
      ngd = nit * njt
*
c     print *,'CASC_BCS: call casc_hvi WE - put data into bcs_uf'
      if ( data2treat ) then
      call casc_hvi (trname_a, 
     $               xpw,ypw,xpuw,ypvw,xpaq,ypaq,xpau,ypav,
     $  bcs_uf(bcs_iw),bcs_uf(bcs_ie),bcs_vf(bcs_iw),bcs_vf(bcs_ie),
     $  bcs_tf(bcs_iw),bcs_tf(bcs_ie),bcs_psdf(bcs_iw),bcs_psdf(bcs_ie),
     $  bcs_trf,bcs_wf(bcs_iw),bcs_wf(bcs_ie),
     $  bcs_qsecf(bcs_iw),bcs_qsecf(bcs_ie),bcs_sf(bcs_iw),bcs_sf(bcs_ie),
     $  bcs_iw-1,bcs_ie-1,
     $  topo(bcs_iw),topo(bcs_ie),topu(bcs_iw),topu(bcs_ie),topv(bcs_iw),topv(bcs_ie),
     $  uun,vvn,psdn,ttn,fisn,p0n,ssn,wwn,qsecn,trn,
     $               minxw,maxxw,minyw,maxyw,d1,0,G_nk,nit,njt,
     $               bcs_nia,bcs_nja,nka,nvar,ntra,l_west,l_east)
      endif
*
         if (associated(xpaq)) deallocate (xpaq)
         if (associated(ypaq)) deallocate (ypaq)
         if (associated(xpau)) deallocate (xpau)
         if (associated(ypav)) deallocate (ypav)
         if (associated(uun)) deallocate (uun)
         if (associated(vvn)) deallocate (vvn)
         if (associated(psdn)) deallocate (psdn)
         if (associated(ttn)) deallocate (ttn)
         if (associated(ssn)) deallocate (ssn)
         if (associated(wwn)) deallocate (wwn)
         if (associated(qsecn))deallocate (qsecn)
         if (associated(p0n))  deallocate (p0n)
         if (associated(fisn)) deallocate (fisn)
         if (associated(trn)) deallocate (trn)
         if (associated(trname_a)) deallocate (trname_a)
*
      if (Ptopo_myproc.eq.0) then
         write(6,100)
         write(6,101) datev,wowp
         write(6,100)
      endif
*
      if ( data2treat.and. (wowp.eq.1.or.errp.lt.0) ) then
*
c        print *,'CASC_BCS wowp=',wowp, ' copying bcs_uf to Ind_u'
         call trnes (Ind_u,bcs_uf(bcs_is),bcs_uf(bcs_in),
     $       bcs_uf(bcs_iw),bcs_uf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk,1)
         call trnes (Ind_v,bcs_vf(bcs_is),bcs_vf(bcs_in),
     $       bcs_vf(bcs_iw),bcs_vf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk,1)
         call trnes (Ind_t,bcs_tf(bcs_is),bcs_tf(bcs_in),
     $       bcs_tf(bcs_iw),bcs_tf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,1)
         call trnes (Ind_s,bcs_sf(bcs_is),bcs_sf(bcs_in),
     $       bcs_sf(bcs_iw),bcs_sf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,1,1)
         if (Acid_test_L) then
             call trnes (Ind_psd,bcs_psdf(bcs_is),bcs_psdf(bcs_in),
     $         bcs_psdf(bcs_iw),bcs_psdf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,1)
             if (.not.Schm_hydro_L) then
             call trnes (Ind_w,bcs_wf(bcs_is),bcs_wf(bcs_in),
     $          bcs_wf(bcs_iw),bcs_wf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $          minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,1)
             call trnes (Ind_qsec,bcs_qsecf(bcs_is),bcs_qsecf(bcs_in),
     $          bcs_qsecf(bcs_iw),bcs_qsecf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $          minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+2,1)
             endif
         endif
         keyp_ = VMM_KEY (nest_trf)
         do n=1,Tr3d_ntr
            keyp(n) = keyp_ + n
         end do
         err = vmmlod(keyp,Tr3d_ntr)
         do n = 1, Tr3d_ntr
            err = vmmget(keyp(n),patrp,trp)
            id = (n-1)*bcs_sz+1
            call trnes(trp,bcs_trf(id),
     $                 bcs_trf(id+bcs_in-1),bcs_trf(id+bcs_iw-1),
     $                 bcs_trf(id+bcs_ie-1),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk,1)
         end do
         err = vmmuld(keyp,Tr3d_ntr)
      endif

*
*
 100  format (' ',60('*'))
 101  format (' (CASC_BCS) JUST READ LBCS DATA FOR DATE: ',a15,x,i3)
 203  format (' FILE: ',a,' NOT AVAILABLE')
 1000 format (/' CASC_BCS AT TIMESTEP', I8,' WOWP=',I3)
*-----------------------------------------------------------------------
      return
      end
*
