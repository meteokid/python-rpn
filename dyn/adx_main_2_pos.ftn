!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/r adx_main_2_pos - calculate upstream positions at thh and t1
*
#include "model_macros_f.h"
*
      subroutine adx_main_2_pos ( F_it, F_u, F_v, F_w )
*
      implicit none
*
      integer F_it
      real F_u(*),F_v(*),F_w(*)
*
*author
*     alain patoine
*
*revision
* v2_31 - Desgagne M.    - removed stkmemw
* v2_31 - Tanguay M.     - gem_stop if adx_fro_a.gt.0.and.V4dg_conf.ne.0
* v3_00 - Desgagne & Lee - Lam configuration
* v3_02 - Lee V.         - revert adx_exch_1 for GLB only, added adx_ckbd_lam
* v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
* v3_20 - Valin & Tanguay - Optimized SETINT/TRILIN 
* v3_20 - Gravel S.       - Change test a lower and upper boundaries
* v3_20 - Tanguay M.      - Improve alarm when points outside advection grid
* v3_20 - Dugas B.        - correct calculation for LAM when Glb_pil gt 7
* v3_21 - Lee V.          - bug correction, ythh should not be modified.
*
*language
*     fortran 77
*
*object
*     see id section
*
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
* F_it   | total number of iterations for trajectory             |  i  |
*        |                                                       |     |
* F_u,F_v| input:  3 components of wind on advection grid        |  io |
* F_w    | output: 3 upstream positions valid at t1              |     |
*________|_______________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "lun.cdk"
#include "type.cdk"
#include "adx.cdk"
#include "dcst.cdk"
#include "cstv.cdk"
#include "vthh.cdk"
#include "vt1.cdk"
#include "v4dg.cdk"
#include "lctl.cdk"
#include "ver.cdk"
#include "geomg.cdk"
c#include "ptopo.cdk"
*
*modules
      integer  vmmlod, vmmget, vmmuld
      external vmmlod, vmmget, vmmuld
************************************************************************
*
      integer pnerr, pnlkey1(30), pnlod
*
      integer i, j, k, n, ij, ijk, nij, nijk, it
      integer i1,j1,k1,nn
*
      integer outside,sum_outside,ier
*
      integer, dimension(l_ni*l_nj*l_nk) :: n1
      real,    dimension(l_ni*l_nj*l_nk) :: capx1,capy1,capz1
      real,    dimension(l_ni*l_nj*l_nk) :: wrkx1,wrky1,wrkz1,wrkc1,wrk_ythh
      integer, dimension(:), allocatable :: n2
      real,    dimension(:), allocatable :: capx2,capy2,capz2
      real,    dimension(:), allocatable :: xpos2,ypos2,zpos2
*
      real dummy, dthh
      real*8 r2pi_8,two,half,pdp,pdm
      parameter (two = 2.0,half=0.5)

      integer i0,in,j0,jn, longueur
*
      if (Lun_debug_L) write (Lun_out,1000)
      nij    = l_ni   *l_nj
      nijk   = l_ni   *l_nj   *l_nk
*
      r2pi_8 = two * Dcst_pi_8
      dthh    = Cstv_dt_8/2.
      pdp    = 1.d0 + 1.d-6
      pdm    = 1.d0 - 1.d-6

************************************************************************
*
      pnlkey1(1) = VMM_KEY(xthh)
      pnlkey1(2) = VMM_KEY(ythh)
      pnlkey1(3) = VMM_KEY(zthh)
      pnlkey1(4) = VMM_KEY(xcthh)
      pnlkey1(5) = VMM_KEY(ycthh)
      pnlkey1(6) = VMM_KEY(zcthh)
      pnlkey1(7) = VMM_KEY(xct1)
      pnlkey1(8) = VMM_KEY(yct1)
      pnlkey1(9) = VMM_KEY(zct1)
*
      pnerr = vmmlod(pnlkey1,9)
*
      pnerr = VMM_GET_VAR(xthh)
      pnerr = VMM_GET_VAR(ythh)
      pnerr = VMM_GET_VAR(zthh)
      pnerr = VMM_GET_VAR(xcthh)
      pnerr = VMM_GET_VAR(ycthh)
      pnerr = VMM_GET_VAR(zcthh)
      pnerr = VMM_GET_VAR(xct1)
      pnerr = VMM_GET_VAR(yct1)
      pnerr = VMM_GET_VAR(zct1)
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west) i0=4       + (Glb_pil_w - 7)
          if (l_east) in=l_niu-2 - (Glb_pil_e - 7)
          if (l_south) j0=4      + (Glb_pil_s - 7)
          if (l_north) jn=l_njv-2- (Glb_pil_n - 7)
      endif
c     if (Acid_test_L)
c    %    call glbstat (xthh,'Xthh',1,l_ni,1,l_nj,G_nk,4+acid_i0,G_ni-3-acid_in,
c    %                                            4+acid_j0,G_nj-3-acid_jn,1,1)
c         call glbstat (xcthh,'Xcthh',1,l_ni,1,l_nj,G_nk,5+acid_i0,G_ni-4-acid_in,
c    %                                           5+acid_j0,G_nj-4-acid_jn,1,1)
c     endif
************************************************************************
      do it=1,F_it
************************************************************************
*
      do n = 1,nijk
      wrk_ythh(n) = ythh(n)
      enddo

      if (G_lam) then
*
          call adx_ckbd_lam ( xthh, wrk_ythh, zthh, i0, in, j0, jn, G_nk )
*
      else
*
          call adx_exch_1 ( wrkx1, wrky1, wrkz1, wrkc1,xthh,wrk_ythh,zthh,G_nk )
*
          if ( V4dg_conf.ne.0.0 ) then
*
               outside = 0
*
               if ( adx_fro_a .gt. 0 ) outside = 1
*
               sum_outside = 0
               call rpn_comm_Allreduce(outside,sum_outside,1,"MPI_INTEGER",
     $                                 "MPI_SUM","grid",ier)
*
               if(sum_outside.ne.0) call gem_stop ('adx_MAIN_2_POS: TLM-ADJ NOT done: INCREASE HALO',-1)
*
          endif
*
          allocate(capx2(max(1,adx_fro_a)),
     %             capy2(max(1,adx_fro_a)),
     %             capz2(max(1,adx_fro_a)),
     %             xpos2 (max(1,adx_fro_a)),
     %             ypos2 (max(1,adx_fro_a)),
     %             zpos2 (max(1,adx_fro_a)),
     %             n2 (max(1,adx_fro_a)) )
          call adx_exch_2 ( xpos2, ypos2, zpos2,
     %                  wrkx1, wrky1, wrkz1,
     %                  adx_fro_n, adx_fro_s, adx_fro_a,
     %                  adx_for_n, adx_for_s, adx_for_a, 3 )
*
      endif
*
      if( .not. adx_nosetint_L ) then
*
      call adx_setint ( n1, capx1, dummy, dummy, capy1, dummy,
     %                  dummy, capz1, dummy, xthh, wrk_ythh, zthh,
     %                 .true., .true., .true.,nijk,i0,in,j0,jn,l_nk,'m')
*
      
      call adx_trilin (wrkx1,F_u,1.0,n1,capx1,capy1,capz1,nijk,i0,in,j0,jn,l_nk)
      call adx_trilin (wrky1,F_v,1.0,n1,capx1,capy1,capz1,nijk,i0,in,j0,jn,l_nk)
*
      else
*
      adx_hor_L = .true.
      adx_ver_L = .true. 
      call adx_trilin_turbo (wrkx1,F_u,1.0,xthh,wrk_ythh,zthh,capz1,
     %                       adx_Fn_I,nijk,i0,in,j0,jn,l_nk,'m')
      call adx_trilin_turbo (wrky1,F_v,1.0,xthh,wrk_ythh,zthh,capz1,
     %                       adx_Fn_I,nijk,i0,in,j0,jn,l_nk,'m')
*
      endif
c     if (Acid_test_L)
c    %call glbstat (wrkx1,'wrkX',1,l_ni,1,l_nj,G_nk,4+acid_i0,G_ni-3-acid_in,
c    %                                    4+acid_j0,G_nj-3-acid_jn,1,G_nk)
*
      if (.not.G_lam) then

         if ( adx_fro_a .gt. 0 ) then
*
*
              if ( adx_ckbd_L ) call adx_ckbd ( ypos2 )
*
              call adx_setint ( n2, capx2, dummy, dummy, capy2, dummy,
     %                     dummy, capz2, dummy, xpos2, ypos2, zpos2,
     %                    .true., .true., .true., adx_fro_a,1,adx_fro_a,
     %                    1,1,1,'m')
*
              call adx_trilin ( xpos2, F_u, 1.0, n2, capx2, capy2, capz2,
     %                     adx_fro_a,1,adx_fro_a,1,1,1)
              call adx_trilin ( ypos2, F_v, 1.0, n2, capx2, capy2, capz2,
     %                     adx_fro_a,1,adx_fro_a,1,1,1)
*
         endif
*
         call adx_exch_2 ( wrkz1, wrk_ythh, dummy,
     %                  xpos2, ypos2, dummy,
     %                  adx_for_n, adx_for_s, adx_for_a,
     %                  adx_fro_n, adx_fro_s, adx_fro_a, 2)
*
         if ( adx_for_a .gt. 0 )
     %         call adx_exch_3 ( wrkx1, wrky1, wrkz1, wrk_ythh, wrkc1, 2 )
*
         deallocate(capx2,capy2,capz2,xpos2,ypos2,zpos2,n2)
      endif
************************************************************************
      call adx_trajsp ( xthh, ythh, xcthh, ycthh, zcthh, wrkx1, wrky1, dthh,
     %                  i0,in,j0,jn)
************************************************************************
      do n = 1,nijk
      wrk_ythh(n) = ythh(n)
      enddo
c     if (Acid_test_L)
c     call glbstat (xthh,'Xthh',1,l_ni,1,l_nj,G_nk,4+acid_i0,G_ni-3-acid_in,
c    %                                           4+acid_in,G_nj-3-acid_jn,1,1)
c     call glbstat (xcthh,'Xcthh',1,l_ni,1,l_nj,G_nk,5+acid_i0,G_ni-4-acid_in,
c    %                                           5+acid_in,G_nj-4-acid_jn,1,1)
*
      if (G_lam) then
*
          call adx_ckbd_lam ( xthh, wrk_ythh, zthh, i0, in, j0, jn, G_nk )
*
      else
*
          call adx_exch_1 ( wrkx1, wrky1, wrkz1, wrkc1,xthh,wrk_ythh,zthh,G_nk )
*
          allocate(capx2(max(1,adx_fro_a)),
     %             capy2(max(1,adx_fro_a)),
     %             capz2(max(1,adx_fro_a)),
     %             xpos2 (max(1,adx_fro_a)),
     %             ypos2 (max(1,adx_fro_a)),
     %             zpos2 (max(1,adx_fro_a)),
     %             n2 (max(1,adx_fro_a)) )
*
          call adx_exch_2 ( xpos2, ypos2, zpos2,
     %                  wrkx1, wrky1, wrkz1,
     %                  adx_fro_n, adx_fro_s, adx_fro_a,
     %                  adx_for_n, adx_for_s, adx_for_a, 3 )
*
      endif
*
      if( .not. adx_nosetint_L ) then

*
      call adx_setint ( n1, capx1, dummy, dummy, capy1, dummy,
     %                  dummy, capz1, dummy, xthh, wrk_ythh, zthh,
     %                 .true., .true., .true., nijk,i0,in,j0,jn,l_nk,'t')
*
      call adx_trilin (wrkx1,F_w,-dthh,n1,capx1,capy1,capz1,nijk,i0,in,j0,jn,l_nk)
*
      else
*
      adx_hor_L = .true. 
      adx_ver_L = .true. 
      call adx_trilin_turbo (wrkx1,F_w,-dthh,xthh,wrk_ythh,zthh,capz1,
     %                       adx_Fn_I,nijk,i0,in,j0,jn,l_nk,'t')
*
      endif
*
      if (.not.G_lam) then
         if ( adx_fro_a .gt. 0 ) then
*
              if ( adx_ckbd_L ) call adx_ckbd ( ypos2 )
*
              call adx_setint ( n2, capx2, dummy, dummy, capy2, dummy,
     %                     dummy, capz2, dummy, xpos2, ypos2, zpos2,
     %                    .true., .true., .true., adx_fro_a,1,adx_fro_a,
     %                    1,1,1,'t')
*
              call adx_trilin ( xpos2, F_w, -dthh, n2, capx2,capy2,capz2,
     %                     adx_fro_a,1,adx_fro_a,1,1,1)
*
         endif
*
         call adx_exch_2 ( wrkz1, dummy, dummy,
     %                  xpos2, dummy, dummy,
     %                  adx_for_n, adx_for_s, adx_for_a,
     %                  adx_fro_n, adx_fro_s, adx_fro_a, 1)
*
         if ( adx_for_a .gt. 0 )
     %        call adx_exch_3 ( wrkx1, dummy, wrkz1, dummy, wrkc1, 1 )
*
         deallocate(capx2,capy2,capz2,xpos2,ypos2,zpos2,n2)
      endif

************************************************************************
!$omp parallel private(n)
!$omp do
      do k = 2,l_nk-1
      do j = j0,jn
      do i = i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         zthh(n) = Ver_z_8%m(k) + two*wrkx1(n)
         zthh(n) = min( pdm*Ver_z_8%m(l_nk), 
     %                max( 1.0d0*zthh(n), pdp*Ver_z_8%m(1) ) )
         zthh(n) = half*(zthh(n) + Ver_z_8%m(k))
      enddo
      enddo
      enddo      
!$omp enddo
!$omp end parallel

************************************************************************
      enddo ! end of iterations loop
************************************************************************
      call adx_trajex (F_u, F_v, xct1, yct1, zct1, xcthh, ycthh, zcthh,
     %                  i0,in,j0,jn)
*
!$omp parallel private(n)
!$omp do
      do j = j0,jn
      do i = i0,in
         n = ((j-1)*l_ni) + i   !for k=1
         F_w(n) = Ver_z_8%m(1)
         n = (l_nk-1)*nij+((j-1)*l_ni) + i !for k=l_nk
         F_w(n) = Ver_z_8%m(l_nk)
      enddo
      enddo
!$omp enddo

!$omp do
      do k = 2,l_nk-1
         do j = j0,jn
         do i = i0,in
            n=(k-1)*nij+((j-1)*l_ni) + i
            F_w(n) = zthh(n) - adx_bsz_8%m(k-1)
            F_w(n) = Ver_z_8%m(k) + 2.0 * F_w(n)
         enddo
         enddo
      enddo
!$omp enddo
!$omp end parallel
*
      pnerr = vmmuld(-1,0)
*
 1000  format(3X,'CALC HORIZONTAL UPSTREAM POSITIONS: (S/R ADX_MAIN_2_POS)')
      return
      end
