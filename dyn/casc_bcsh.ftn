! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
copyright (C) 2001  MSC-RPN COMM  %%%MC2%%%
***s/r casc_bcsh - For reading cascade BCS pilot files where
*                 BCS01 files were written after advection and
*                 BCS02 files were written after physics
#include "model_macros_f.h"
*
      integer function casc_bcsh ( datev, unf, wowp, errp )
      implicit none
*
      character*15 datev
      integer unf,wowp,errp
*
*author
*     M. Desgagne  April 2006 (MC2 casc_bcsh)
*
*revision
* v3_30 - Lee V.         - initial version for GEMDM
*
*
#include "glb_ld.cdk"
#include "bcsdim.cdk"
#include "bcsmem.cdk"
#include "bcsgrds.cdk"
#include "ptopo.cdk"
#include "schm.cdk"
#include "tr3d.cdk"
#include "nest.cdk"
#include "lun.cdk"
#include "lctl.cdk"
#include "ind.cdk"
#include "acid.cdk"
*
      integer  vmmlod,vmmget,vmmuld,longueur
      external vmmlod,vmmget,vmmuld,longueur
      character*2 md
      character*4 nomvar
      character*8 dynophy
      character*8, dimension (:), pointer :: trname_a
      real, dimension (:,:,:), pointer :: trns,trnw
      character*256 fn
      logical fb_w,fb_e,fb_s,fb_n,data2treat
      logical s_L,gz_L,tt_L,uu_L,vv_L,w_L,zd_L,q_L
      integer i,j,k,ntra,n,err,ngas,ngaw,ofi,ofj,id,
     $   mode,nit,njt,d1,nis,njs,niw,njw,iscal(2),errcode,takeit
      integer ni1,nj1,ni2,nj2,nk1,nka_m,nka_s,nka_t,ntr,presstype,cumerr,nbits
      real htop
      real*8 epsilon
      parameter (epsilon=1.0e-6)
      real trp
      pointer (patrp,trp(LDIST_SHAPE,*))
      integer key1(17),keyp_,keyp(Tr3d_ntr),nvar,hycode
      real*8, dimension (:  ), pointer :: xpsn,ypsn,xpwe,ypwe,
     $        xpaqs,ypaqs,xpaus,ypavs,xpaqw,ypaqw,xpauw,ypavw
      real  , dimension (:,:), pointer :: 
     $ uuns,vvns,zdns,ttns,meqns,ssns,wwns,qqns,
     $ uunw,vvnw,zdnw,ttnw,meqnw,ssnw,wwnw,qqnw

      real topo_s(minxs:maxxs+1,minys:maxys+1)
      real topo_n(minxn:maxxn+1,minyn:maxyn+1)
      real topo_w(minxw:maxxw+1,minyw:maxyw+1)
      real topo_e(minxe:maxxe+1,minye:maxye+1)
*-----------------------------------------------------------------------
*
*
      if (Lun_debug_L) write(Lun_out,3000) Lctl_step,wowp
*
*
      nullify ( xpsn,ypsn,xpwe,ypwe,xpaqs,ypaqs,xpaus,ypavs,xpaqw,ypaqw,
     $     xpauw,ypavw,uuns,vvns,zdns,ttns,meqns,ssns,qqns,wwns,
     $     uunw,vvnw,zdnw,ttnw,meqnw,ssnw,qqnw,wwnw,trns,trnw,trname_a )
*
      casc_bcsh = -1
*
      data2treat = (l_south.or.l_north.or.l_west.or.l_east)
*
      s_L=.false.
      gz_L=.false.
      tt_L=.false.
      uu_L=.false.
      vv_L=.false.
      w_L=.false.
      zd_L=.false.
      q_L=.false.
      ana_zdw_L=.false.
      ana_q_L=.false.
*
      if (data2treat) then
*
         write (md,'(i2.2)') wowp
         fn = '../casc/bcs'//md//'_'//datev
         open (unf,file=fn,access='SEQUENTIAL',status='OLD',
     $                        iostat=err,form='UNFORMATTED')
c        print *,'opening ',fn(1:longueur(fn)),'err=',err
*
         if (err.ne.0) goto 33
*
         read (unf,end=33) dynophy,mode
c        print *,'casc_bcsh',dynophy,mode
         read (unf,end=33) nomvar,nis,njs,niw,njw,
     $                     nka_m,nka_s,nka_t,presstype,nvar,ntra
         if (ntra.le.0) then
             if (Lun_out.gt.0) write(Lun_out,*)'No tracers are available including HU'
             call gem_stop('casc_bcsh',-1)
         endif
c        print *,'casc_bcsh: ',nomvar,nis,njs,niw,njw,
c    $                     nka_m,nka_s,nka_t,presstype,nvar,ntra
         allocate (xpsn (nis),ypsn (njs*2),xpwe (niw*2),ypwe (njw))
         read (unf,end=33) xpsn,ypsn,xpwe,ypwe
         nis = nis - 1 
         njs = njs - 1 
         niw = niw - 1
         njw = njw - 1
         allocate (xpaqs(nis),ypaqs(njs*2),xpaus(nis),ypavs(njs*2),
     $             xpaqw(niw*2),ypaqw(njw),xpauw(niw*2),ypavw(njw))
*
         if (associated(ana_am_8)) deallocate(ana_am_8)
         if (associated(ana_bm_8)) deallocate(ana_bm_8)
         if (associated(ana_at_8)) deallocate(ana_at_8)
         if (associated(ana_bt_8)) deallocate(ana_bt_8)
*
         allocate(ana_am_8(nka_m), ana_bm_8(nka_m),
     $            ana_at_8(nka_t), ana_bt_8(nka_t),
     $            ana_as_8(nka_s), ana_bs_8(nka_s) )

         read (unf,end=33,err=33) 
     $         ana_am_8,ana_bm_8,ana_as_8,ana_bs_8,ana_at_8,ana_bt_8
         if (Lun_debug_L) then
             write(Lun_out,*)'sid3df:'
             write(Lun_out,*)'ana_am_8=',ana_am_8
             write(Lun_out,*)'ana_bm_8=',ana_bm_8
             write(Lun_out,*)'ana_as_8=',ana_as_8
             write(Lun_out,*)'ana_bs_8=',ana_bs_8
             write(Lun_out,*)'ana_at_8=',ana_at_8
             write(Lun_out,*)'ana_bt_8=',ana_bt_8
         endif
*
         do i=1,nis
            xpaqs(i) = xpsn(i)
            xpaus(i) = 0.5 * (xpsn(i) + xpsn(i+1))
         end do
         do j=1,njs
            ypaqs(j) = ypsn(j)
            ypavs(j) = 0.5 * (ypsn(j) + ypsn(j+1))
         end do
         do j=njs+1,njs*2
            ypaqs(j) = ypsn(j+1)
            ypavs(j) = 0.5 * (ypsn(j+1) + ypsn(j+2))
         end do
*     
         do i=1,niw
            xpaqw(i) = xpwe(i)
            xpauw(i) = 0.5 * (xpwe(i) + xpwe(i+1))
         end do
         do i=niw+1,niw*2
            xpaqw(i) = xpwe(i+1)
            xpauw(i) = 0.5 * (xpwe(i+1) + xpwe(i+2))
         end do
         do j=1,njw
            ypaqw(j) = ypwe(j)
            ypavw(j) = 0.5 * (ypwe(j) + ypwe(j+1))
         end do
*
         ngas = nis*njs*2
         ngaw = niw*njw*2


         allocate (uuns(ngas,nka_m),vvns(ngas,nka_m),zdns(ngas,nka_t),
     $             ttns(ngas,nka_s),ssns(ngas,1),
     $             wwns(ngas,nka_t),qqns(ngas,nka_m+1),trns(ngas,nka_s,ntra),
     $             uunw(ngaw,nka_m),vvnw(ngaw,nka_m),zdnw(ngaw,nka_t),
     $             ttnw(ngaw,nka_s),ssnw(ngaw,1),
     $             wwnw(ngaw,nka_t),qqnw(ngaw,nka_m+1),trnw(ngaw,nka_s,ntra),
     $             trname_a(ntra) )
            if (presstype.eq.4) then
                allocate (meqns(ngas,nka_m),meqnw(ngaw,nka_m))
            else
                allocate (meqns(ngas,1),meqnw(ngaw,1))
            endif
*
         cumerr=0
         uuns = 0.0; uunw = 0.0
         vvns = 0.0; vvnw = 0.0
         zdns = 0.0; zdnw = 0.0
         ttns = 0.0; ttnw = 0.0
         ssns = 0.0; ssnw = 0.0
         qqns = 0.0; qqnw = 0.0
         wwns = 0.0; wwnw = 0.0
         trns = 0.0; trnw = 0.0
         meqns= 0.0; meqnw= 0.0
         ntr=0
c        print *,'read_bcs ntra=',ntra, 'nvar=',nvar
c        print *,'read_bcs nis,njs,niw,njw=',nis,njs,niw,njw

* read tt1,st1, ME(GZ)
         do 30 k=1,nvar+ntra
            read (unf) nomvar,ni1,nj1,ni2,nj2,nk1,nbits
            if (Lun_debug_L) write(Lun_out,1000) nomvar,ni1,nj1,ni2,nj2,nk1,nbits
            if ((ni1.ne.nis).or.(nj1.ne.njs).or.
     $          (ni2.ne.niw).or.(nj2.ne.njw) ) then
                 write (6,1001) nomvar,ni1,nj1,ni2,nj2,nis,njs,niw,njw
                 stop
            endif
            if (nomvar.eq.'S   ') then
                 s_L = .true.
                 call rdbcs ( ssns, ssnw, nis,njs,niw,njw,nk1,unf,nbits)
            endif
            if (nomvar.eq.'UU  ') then
                 uu_L = .true.
                 call rdbcs ( uuns, uunw, nis,njs,niw,njw,nk1,unf,nbits)
            endif
            if (nomvar.eq.'VV  ') then
                 vv_L = .true.
                 call rdbcs ( vvns, vvnw, nis,njs,niw,njw,nk1,unf,nbits)
            endif
            if (nomvar.eq.'TT  ') then
                 tt_L = .true.
                 call rdbcs ( ttns, ttnw, nis,njs,niw,njw,nk1,unf,nbits)
            endif
            if (nomvar.eq.'GZ  ') then
                 gz_L = .true.
                 call rdbcs ( meqns, meqnw, nis,njs,niw,njw,nk1,unf,nbits)
            endif
            if (nomvar.eq.'W   ') then
                 w_L = .true.
                 call rdbcs ( wwns, wwnw, nis,njs,niw,njw,nk1,unf,nbits)
            endif
            if (nomvar.eq.'ZD  ') then
                 zd_L = .true.
                 call rdbcs ( zdns, zdnw, nis,njs,niw,njw,nk1, unf,nbits)
            endif
            if (nomvar.eq.'Q   ') then
                 q_L = .true.
                 call rdbcs ( qqns, qqnw, nis,njs,niw,njw,nk1,unf,nbits)
            endif
   
            if (ntra.gt.0) then
* check for tracers
                 takeit=-1
                 do n=1,Tr3d_ntr
                    if (nomvar.eq.Tr3d_name_S(n)) takeit=n
                 enddo
                 if (takeit.gt.0) then
                     ntr=ntr+1
                     trname_a(ntr)=Tr3d_name_S(takeit)
                     call rdbcs ( trns(1,1,ntr), trnw(1,1,ntr), nis,njs,niw,njw,nk1,unf,nbits)
                 endif
             endif
 30      continue
         if (.not.(s_L.and.tt_L.and.uu_L.and.vv_L.and.gz_L)) then
             if (Lun_out.gt.0) then
                 write(Lun_out,*) 'ESSENTIAL variables are missing in BCS file:'
                 write(Lun_out,*) 'S =',s_L
                 write(Lun_out,*) 'TT=',tt_L
                 write(Lun_out,*) 'UU=',uu_L
                 write(Lun_out,*) 'VV=',vv_L
                 write(Lun_out,*) 'GZ=',GZ_L
             endif
             call gem_stop('casc_bcsh',-1)
         endif
         ana_zdw_L = (zd_L.and.w_L)
         ana_q_L   =  q_L

         casc_bcsh = 0

      else

         casc_bcsh = 0
      endif
*
 33   data2treat = data2treat .and. (casc_bcsh.eq.0)
c     print *,'casc_bcsh:33',data2treat
*
* Perform horizontal and vertical interpolations for S,N,W and E boundaries
*
      if ( data2treat .and. (dimxs*dimys.gt.0) ) then
           errcode = -1
           fb_w = (xps  (1).gt.xpaqs    (2)-epsilon)
           fb_e = (xps(dimxs+1-(east*1)).lt.xpaqs(nis-1)+epsilon)
           fb_s = (yps  (1).gt.ypaqs    (2)-epsilon)
           fb_n = (yps(dimys+1).lt.ypaqs(njs-1)+epsilon)
           if ( .not.fb_w ) write (6,*) 'xps(1)<xpaqs(2)',
     $                      xps(1), xpaqs(2)
           if ( .not.fb_e ) write (6,*) 'xps(dimxs+1-(east*1))<xpaqs(nis-1)',
     $                      xps(dimxs+1-(east*1)), xpaqs(nis-1)
           if ( .not.fb_s ) write (6 ,*) 'yps(1)<ypaqs(2)',
     $                      yps(1), ypaqs(2)
           if ( .not.fb_n ) write (6 ,*) 'yps(dimys+1)<ypaqs(njs-1)',
     $                      yps(dimys+1), ypaqs(njs-1)
      if ( fb_w .and. fb_e .and. fb_s .and. fb_n ) errcode = 0
      call gem_stop('CASC_BCSH:dimxs*dimys',errcode)
      endif

      if ( data2treat .and. (dimxn*dimyn.gt.0) ) then
c          print *,'north:',dimxn,dimyn,xpn(1)
           errcode = -1
           fb_w = (xpn  (1).gt.xpaqs    (2)-epsilon)
           fb_e = (xpn(dimxn+1-(east*1)).lt.xpaqs(nis-1)+epsilon)
           fb_s = (ypn  (1).gt.ypaqs    (njs+2)-epsilon)
           fb_n = (ypn(dimyn+1-(north*1)).lt.ypaqs(2*njs-1)+epsilon)
           if ( .not.fb_w ) write (6,*) 'xpn(1)<xpaqs(2)',
     $                                  xpn(1), xpaqs(2)
           if ( .not.fb_e ) write (6,*) 'xpn(dimxn+1-(east*1))<xpaqs(nis-1)',
     $                                  xpn(dimxn+1-(east*1)), xpaqs(nis-1)
           if ( .not.fb_s ) write (6,*) 'ypn(1)<ypaqs(njs+2)',
     $                                  ypn(1), ypaqs(njs+2)
           if ( .not.fb_n ) write (6 ,*) 'ypn(dimyn+1-(north*1))<ypaqs(2*njs-1)',
     $                            ypn(dimyn+1-(north*1)),ypaqs(2*njs-1)
      if ( fb_w .and. fb_e .and. fb_s .and. fb_n ) errcode = 0
      call gem_stop('CASC_BCSH:dimxn*dimyn',errcode)
      endif

      if ( data2treat .and. (dimxw*dimyw.gt.0) ) then
           errcode = -1
           fb_w = (xpw  (1).gt.xpaqw    (2)-epsilon)
           fb_e = (xpw(dimxw+1).lt.xpaqw(niw-1)+epsilon)
           fb_s = (ypw  (1).gt.ypaqw    (2)-epsilon)
           fb_n = (ypw(dimyw+1).lt.ypaqw(njw-1)+epsilon)
           if ( .not.fb_w ) write (6,*) 'xpw(1)<xpaqw(2)',
     $                                   xpw(1),xpaqw(2)
           if ( .not.fb_e ) write (6,*) 'xpw(dimxw+1)<xpaqw(niw-1)',
     $                                   xpw(dimxw+1),xpaqw(niw-1)
           if ( .not.fb_s ) write (6 ,*) 'ypw(1)<ypaqw(2)',
     $                                    ypw(1),ypaqw(2)
           if ( .not.fb_n ) write (6 ,*) 'ypw(dimyw+1)<ypaqw(njw-1)',
     $                                    ypw(dimyw+1),ypaqw(njw-1)
      if ( fb_w .and. fb_e .and. fb_s .and. fb_n ) errcode = 0
      call gem_stop('CASC_BCSH:dimxw*dimyw',errcode)
      endif

      if ( data2treat .and. (dimxe*dimye.gt.0) ) then
           errcode = -1
           fb_w = (xpe  (1).gt.xpaqw    (niw+2)-epsilon)
           fb_e = (xpe(dimxe+1-(east*1)).lt.xpaqw(2*niw-1)+epsilon)
           fb_s = (ype  (1).gt.ypaqw    (2)-epsilon)
           fb_n = (ype(dimye+1).lt.ypaqw(njw-1)+epsilon)
           if ( .not.fb_w ) write (6,*) 'xpe(1)<xpaqw(niw+2)',
     $                                   xpe(1),xpaqw(niw+2)
           if ( .not.fb_e ) write (6,*) 'xpe(dimxe+1-(east*1)))<xpaqw(2*niw-1)',
     $                                   xpe(dimxe+1-(east*1)),xpaqw(2*niw-1)
           if ( .not.fb_s ) write (6,*) 'ype(1)<ypaqw(2)',
     $                                   ype(1),ypaqw(2)
           if ( .not.fb_n )write (6 ,*) 'ype(dimye+1)<ypaqw(njw-1)',
     $                                   ype(dimye+1),ypaqw(njw-1)
      if ( fb_w .and. fb_e .and. fb_s .and. fb_n ) errcode = 0
      call gem_stop('CASC_BCSH:dimxe*dimye',errcode)
      endif
*
      if (data2treat)then
* topo is inflated!
          call rpn_comm_xch_halo ( Ind_topo, LDIST_DIM,l_ni,l_nj,1,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
          call trnes1(Ind_topo,topo_s,topo_n,topo_w,topo_e,
     $         LDIST_DIM,
     $         minxs,maxxs+1-(east*1),minys,maxys+1,
     $         minxn,maxxn+1-(east*1),minyn,maxyn+1-(north*1),
     $         minxw,maxxw+1,minyw,maxyw+1,
     $         minxe,maxxe+1-(east*1),minye,maxye+1,
     $         1)

*       PUT DATA into BCS_UF
* Perform horizontal and vertical interpolations for South boundary
c      print *,'casc_bcsh:south hvi'
      if (l_south)
     $call casc_hvi (trname_a,
     $  xps,yps,xpus,ypvs,xpaqs,ypaqs,xpaus,ypavs,
     $  bcs_uf,bcs_vf, bcs_tf,bcs_zdf,
     $  bcs_sf,bcs_qf, bcs_wf,bcs_trf,
     $  bcs_is-1, topo_s,
     $  uuns,vvns,ttns,zdns,meqns,ssns,qqns,wwns,trns,
     $  minxs,maxxs,minys,maxys,maxxs+1-(east*1),maxys+1, G_nk,
     $  nis,njs*2,nka_m,nka_s,nka_t,presstype,ntra)

* Perform horizontal and vertical interpolations for North boundary
      if (l_north)
     $call casc_hvi (trname_a,
     $  xpn,ypn,xpun,ypvn,xpaqs,ypaqs,xpaus,ypavs,
     $  bcs_uf(bcs_in),bcs_vf(bcs_in), bcs_tf(bcs_in),bcs_zdf(bcs_in),
     $  bcs_sf(bcs_in),bcs_qf(bcs_in),bcs_wf(bcs_in),bcs_trf,
     $  bcs_in-1, topo_n,
     $  uuns,vvns,ttns,zdns,meqns,ssns,qqns,wwns,trns,
     $  minxn,maxxn,minyn,maxyn,maxxn+1-(east*1),maxyn+1-(north*1),G_nk,
     $  nis,njs*2,nka_m,nka_s,nka_t,presstype,ntra)

* Perform horizontal and vertical interpolations for West boundary
      if (l_west)
     $call casc_hvi (trname_a,
     $  xpw,ypw,xpuw,ypvw,xpaqw,ypaqw,xpauw,ypavw,
     $  bcs_uf(bcs_iw),bcs_vf(bcs_iw), bcs_tf(bcs_iw),bcs_zdf(bcs_iw),
     $  bcs_sf(bcs_iw),bcs_qf(bcs_iw),bcs_wf(bcs_iw),bcs_trf,
     $  bcs_iw-1, topo_w,
     $  uunw,vvnw,ttnw,zdnw,meqnw,ssnw,qqnw,wwnw,trnw,
     $  minxw,maxxw,minyw,maxyw,maxxw+1,maxyw+1, G_nk,
     $  niw*2,njw,nka_m,nka_s,nka_t,presstype,ntra)

* Perform horizontal and vertical interpolations for East boundary
      if (l_east)
     $call casc_hvi (trname_a,
     $  xpe,ype,xpue,ypve,xpaqw,ypaqw,xpauw,ypavw,
     $  bcs_uf(bcs_ie),bcs_vf(bcs_ie), bcs_tf(bcs_ie),bcs_zdf(bcs_ie),
     $  bcs_sf(bcs_ie),bcs_qf(bcs_ie),bcs_wf(bcs_ie),bcs_trf,
     $  bcs_ie-1, topo_e,
     $  uunw,vvnw,ttnw,zdnw,meqnw,ssnw,qqnw,wwnw,trnw,
     $  minxe,maxxe,minye,maxye,maxxe+1-(east*1),maxye+1, G_nk,
     $  niw*2,njw,nka_m,nka_s,nka_t,presstype,ntra)
*
      endif
      if (associated(xpsn)) deallocate(xpsn)
      if (associated(ypsn)) deallocate(ypsn)
      if (associated(xpwe)) deallocate(xpwe)
      if (associated(ypwe)) deallocate(ypwe)
*
      if (associated(xpaqs)) deallocate(xpaqs)
      if (associated(ypaqs)) deallocate(ypaqs)
      if (associated(xpaus)) deallocate(xpaus)
      if (associated(ypavs)) deallocate(ypavs)
      if (associated(xpaqw)) deallocate(xpaqw)
      if (associated(ypaqw)) deallocate(ypaqw)
      if (associated(xpauw)) deallocate(xpauw)
      if (associated(ypavw)) deallocate(ypavw)
      if (associated(trname_a)) deallocate(trname_a)
*
      if (associated(uuns)) deallocate(uuns)
      if (associated(vvns))  deallocate(vvns)
      if (associated(zdns)) deallocate(zdns)
      if (associated(ttns)) deallocate(ttns)
      if (associated(meqns)) deallocate(meqns)
      if (associated(ssns)) deallocate(ssns)
      if (associated(qqns)) deallocate(qqns)
      if (associated(wwns)) deallocate(wwns)
*
      if (associated(uunw)) deallocate(uunw)
      if (associated(vvnw))  deallocate(vvnw)
      if (associated(zdnw)) deallocate(zdnw)
      if (associated(ttnw)) deallocate(ttnw)
      if (associated(meqnw)) deallocate(meqnw)
      if (associated(ssnw)) deallocate(ssnw)
      if (associated(qqnw)) deallocate(qqnw)
      if (associated(wwnw)) deallocate(wwnw)

      if (Ptopo_myproc.eq.0) then
         write(6,100)
         write(6,101) datev,wowp
         write(6,100)
      endif
*
      if ( data2treat .and. (wowp.eq.1.or.errp.lt.0) ) then
*
*        transfer data from bcs_uf to Ind_u
         call trnes (Ind_u,bcs_uf(bcs_is),bcs_uf(bcs_in),
     $       bcs_uf(bcs_iw),bcs_uf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,1)
         call trnes (Ind_v,bcs_vf(bcs_is),bcs_vf(bcs_in),
     $       bcs_vf(bcs_iw),bcs_vf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,1)
         call trnes (Ind_t,bcs_tf(bcs_is),bcs_tf(bcs_in),
     $       bcs_tf(bcs_iw),bcs_tf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+2,1)
         call trnes (Ind_s,bcs_sf(bcs_is),bcs_sf(bcs_in),
     $       bcs_sf(bcs_iw),bcs_sf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,1,1)
         call trnes (Ind_zd,bcs_zdf(bcs_is),bcs_zdf(bcs_in),
     $       bcs_zdf(bcs_iw),bcs_zdf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,1)
         call trnes (Ind_w,bcs_wf(bcs_is),bcs_wf(bcs_in),
     $       bcs_wf(bcs_iw),bcs_wf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,1)
         if (.not. Schm_hydro_L) then
             call trnes (Ind_q,bcs_qf(bcs_is),bcs_qf(bcs_in),
     $         bcs_qf(bcs_iw),bcs_qf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,
     $         minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+2,1)
         endif
         keyp_ = VMM_KEY (nest_trf)
         do n=1,Tr3d_ntr
            keyp(n) = keyp_ + n
         end do
         err = vmmlod(keyp,Tr3d_ntr)
         do n = 1, Tr3d_ntr
            err = vmmget(keyp(n),patrp,trp)
            id = (n-1)*bcs_sz+1
            call trnes(trp,bcs_trf(id),
     $                 bcs_trf(id+bcs_in-1),bcs_trf(id+bcs_iw-1),
     $                 bcs_trf(id+bcs_ie-1),l_minx,l_maxx,l_miny,l_maxy,
     $       minxs,maxxs,minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+2,1)
         end do
      endif
*
*
 100  format (' ',61('*'))
 101  format (' (CASC_BCSH) JUST READ LBCS DATA FOR DATE: ',a15,x,i3)
 201  format (' Insufficient input data coverage ',a1,' in ',a2,
     $        ' interpolation (casc_bcsh) - ABORT - myproc=',i4)
 1000 format (/' RDBCS read: ',a4,6i6)
 1001 format (/' PROBLEM WITH DIMENSIONS IN CASC_BCSH: ',a4,10i6)
 3000 format (/' CASC_BCSH AT TIMESTEP', I8,' WOWP=',I3)
*-----------------------------------------------------------------------
      return
      end
