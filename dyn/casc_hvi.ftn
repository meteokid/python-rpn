! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
*** casc_hvi - take incoming lo-res data, interpolate to hi-res data
*              and place into the pieces of the BCS target grid as
*              described in bcs_did
*
#include "model_macros_f.h"
*
* xpn=> xpq1
* ypn=> ypq1
* xpun = > xpu1
* ypvn = > ypv1
      subroutine casc_hvi (trname_a,   
     $       xpq1,ypq1,xpu1,ypv1,xpaq1,ypaq1,xpau1,ypav1,
     $       uu1,vv1,tt1,zd1,ssq1,qq1,ww1,tr1,ib1,
     $       topo1,
     $       uun,vvn,ttn,zdn,meqn,ssqn,qqn,wwn,trn,
     $       n1,n2,n3,n4,n21,n41,lnk,
     $       nis,njs,nka,nvar,ntra)
      implicit none
*
      character*8 trname_a(ntra)
      logical b1,b2
      integer n1,n2,n3,n4,d1,d2,d11,d21,lnk,nis,njs,nka
      integer ii,jj,jjj,kk,ntra,ib1,nvar,presstype
      real*8 xpq1(*),ypq1(*),xpu1(*),ypv1(*)
      real*8 xpaq1(*),ypaq1(*),xpau1(*),ypav1(*)
      real uun(*),vvn(*),ttn(*),zdn(*),meqn(*),ssqn(*),
     $     qqn(*),wwn(*),trn(*),
     $     uu1(n1:n2,n3:n4,*),
     $     vv1(n1:n2,n3:n4,*),
     $     tt1(n1:n2,n3:n4,*),
     $     zd1(n1:n2,n3:n4,*),
     $     qq1(n1:n2,n3:n4,*),
     $     ww1(n1:n2,n3:n4,*),
     $    ssq1(n1:n2,n3:n4),
     $     tr1(*),
     $     topo1(n1:n21,n3:n41)
         
*
*author    M. Desgagne  2001 (MC2)
*
*revision
* v3_30 - Lee V.       - initial version for GEMLAM


#include "glb_ld.cdk"
#include "bcsdim.cdk"
#include "bcsgrds.cdk"
#include "bcsmem.cdk"
#include "lam.cdk"
#include "geomg.cdk"
#include "schm.cdk"
#include "pres.cdk"
#include "tr3d.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
#include "itf_phy_busind.cdk"
#include "ptopo.cdk"
*
      integer i,j,k,n,nga,err,cnt,tr1_id
      integer n21,n41,nid,njd,nid1,njd1,ngd,ngd1,nidu,njdv
      logical Vertint_L
      integer, dimension (:), allocatable :: idx,idu,idy
      real  tr3 (n1:n2,n3:n4,G_nk+2)
      real, dimension (:,:), allocatable :: uur,vvr,ttr,zdr,ssqr,qqr,wwr
      real, dimension (:,:), allocatable :: ssur,ssvr,ssu0,ssv0
      real, dimension (:,:), allocatable :: ssq0x,topo_temp,ttx,ssq0,pres
      real, dimension (:,:,:), allocatable :: trr,dstlev,srclev
      real, dimension (:), allocatable :: ssqx,meqx
      real*8, dimension (:  ), allocatable ::
     $              cxa,cxb,cxc,cxd,cua,cub,cuc,cud,cya,cyb,cyc,cyd
      real*8 lnpis_8,lnpref_8
*
*-----------------------------------------------------------------------
*
c     dpis_8 = log(Pres_pref*100.)
c     spis_8 = log(Acqr_ptopa*100.)
c     print *,'Pres_pref=',Pres_pref,' Acqr_ptopa=',Acqr_ptopa,' Cstv_pisrf=',Cstv_pisrf_8

      lnpref_8 = log(Cstv_pisrf_8)
      nga = nis * njs
      nid = n2-n1+1
      njd = n4-n3+1
      ngd = nid*njd
      nid1 = n21-n1+1
      njd1 = n41-n3+1
      ngd1 = nid1 * njd1
      if (ngd.le.0) return
*
      allocate ( idx(nid1), idy(njd1), idu(max(nid,njd)) )
      allocate ( cxa(nid1),cxb(nid1),cxc(nid1),cxd(nid1),
     $           cua(max(nid1,njd1)),cub(max(nid1,njd1)),
     $           cuc(max(nid1,njd1)),cud(max(nid1,njd1)),
     $           cya(njd1),cyb(njd1),cyc(njd1),cyd(njd1))
*
*
      allocate (uur(ngd,nka+1),vvr(ngd,nka+1),zdr(ngd,nka+1),
     $          ssur(nid,njd),ssvr(nid,njd),
     $          ttr(ngd,nka+2),ssqr(nid,njd),
     $          qqr(ngd,nka+2),wwr(ngd,nka+1),
     $          ttx(ngd1,nka+2),ssqx(ngd1),meqx(ngd1),
     $          trr(ngd,nka+2,ntra))
*
* Perform horizontal interpolations for inflated BCS boxes
*
      call grid_to_grid_coef(xpq1,nid1,xpaq1,nis,idx,cxa,cxb,cxc,cxd,
     $                                                  Lam_hint_S)
      call grid_to_grid_coef(ypq1,njd1,ypaq1,njs,idy,cya,cyb,cyc,cyd,
     $                                                  Lam_hint_S)

      call hinterpo ( ttx,nid1,njd1, ttn,nis,njs,nka+2,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      call hinterpo ( ssqx,nid1,njd1, ssqn,nis,njs,   1,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      call hinterpo ( meqx,nid1,njd1, meqn,nis,njs,   1,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)

*
* Perform horizontal interpolations for BCS boxes
*
      call grid_to_grid_coef(xpq1,nid,xpaq1,nis,idx,cxa,cxb,cxc,cxd,
     $                                                  Lam_hint_S)
      call grid_to_grid_coef(ypq1,njd,ypaq1,njs,idy,cya,cyb,cyc,cyd,
     $                                                  Lam_hint_S)
      if (.not.Schm_hydro_L.and.nvar.eq.8) then
      call hinterpo ( qqr,nid,njd, qqn,nis,njs,nka+2,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      endif
      if (nvar.gt.5) then
      call hinterpo ( wwr,nid,njd, wwn,nis,njs,nka+1,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      call hinterpo ( zdr,nid,njd, zdn,nis,njs,nka+1,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      endif
      do k=1,ntra
         if (trname_a(k).ne.'!@@NOT@@') 
     $   call hinterpo (trr(1,1,k),nid,njd,trn((k-1)*nga*(nka+2)+1),nis,njs,
     $           nka+2,idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      end do

* Horizontal interpolation ===> U point (xpu1,ypq1)
* unn=>uur (xpau1,ypaq1) ===> (xpu1,ypq1)
      call grid_to_grid_coef (xpu1,nid,xpau1,nis,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
      call hinterpo  (uur,nid,njd,uun,nis,njs,nka+1,
     $               idu,idy,cua,cub,cuc,cud,cya,cyb,cyc,cyd,Lam_hint_S)

* ssqn=>ssur (xpaq1,ypaq1) ===> (xpu1,ypq1)
      call grid_to_grid_coef (xpu1,nid,xpaq1,nis,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
      call hinterpo (ssur,nid,njd,ssqn,nis,njs,1,
     $               idu,idy,cua,cub,cuc,cud,cya,cyb,cyc,cyd,Lam_hint_S)

* Horizontal interpolation ===> V point (xpq1,ypv1)
* vvn=>vvr (xpaq1,ypav1) ===> (xpq1,ypv1)
      call grid_to_grid_coef (ypv1,njd,ypav1,njs,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
      call hinterpo (vvr,nid,njd,vvn,nis,njs,nka+1,
     $               idx,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,Lam_hint_S)

      call grid_to_grid_coef (ypv1,njd,ypaq1,njs,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
* ssqn=>ssvr (xpaq1,ypaq1) ===> (xpq1,ypv1)
      call hinterpo (ssvr,nid,njd,ssqn,nis,njs,1,
     $               idx,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,Lam_hint_S)

      deallocate (idx,idy,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,
     $                                        cya,cyb,cyc,cyd)
      allocate  (topo_temp(nid1,njd1),
     $           ssq0x(nid1,njd1),
     $           ssq0(nid,njd),
     $           ssu0(nid,njd),
     $           ssv0(nid,njd),pres(ngd1,nka+2)  )
      do j=1,njd1
      do i=1,nid1
         topo_temp(i,j) = topo1(n1+i-1,n3+j-1)
      enddo
      enddo


      presstype=0
      call get_lnpress3d(pres,ssqx,ngd1,ana_as_8,ana_bs_8,
     $                   Cstv_pisrf_8,nka+2,presstype)
      do k=1,nka+2
      do i=1,ngd1
         pres(i,k) = exp(pres(i,k))
      enddo
      enddo
      call adj_ss2topo(ssq0x, topo_temp,pres,meqx,ttx,ngd1,nka+2)
      deallocate(pres)

      do j=1,njd1
      do i=1,nid1
         ssq0x(i,j) = log(ssq0x(i,j)/Cstv_pisrf_8)
      enddo
      enddo

      do k=1,nka+2
            do j=1,njd
            do i=1,nid
               ttr((j-1)*nid+i,k) = ttx((j-1)*nid1+i,k)
            enddo
            enddo
      enddo

      do j=1,njd
      do i=1,nid
*Calc for st1
         ssq0(i,j)=  ssq0x(i,j)
         ssqr(i,j) = ssqx((j-1)*nid1+i)
         ssq1(n1+i-1,n3+j-1)= ssq0(i,j)
      enddo
      enddo

*Calc for ssu0,ssv0
      nidu=nid
      njdv=njd
      if (l_east) nidu=nid-1
      if (l_north)njdv=njd-1
         do j=1,njd
         do i=1,nidu
            ssu0(i,j)= (ssq0x(i,j)+ssq0x(i+1,j  ))*.5
         enddo
         enddo
      if (l_east) then
          do j=1,njd
             ssu0(nid,j)= ssq0x(nid,j)
          enddo 
      endif
 
         do j=1,njdv
         do i=1,nid
            ssv0(i,j)= (ssq0x(i,j)+ssq0x(i  ,j+1))*.5
         enddo
         enddo
      if (l_north) then
          do i=1,nid
             ssv0(i,njd)= ssq0x(i,njd)
          enddo 
      endif
      deallocate(ssq0x,ssqx,ttx,meqx)

* Vertical interpolation (in log(pressure))
      allocate (dstlev(nid,njd,G_nk+2),srclev(nid,njd,nka+2) )
*     Interpolate ZD,W 
*
      call get_lnpress3d(srclev,ssqr,ngd,ana_at_8,ana_bt_8,
     $                   Cstv_pisrf_8,nka+1,presstype)
      call get_lnpress3d(dstlev,ssq0,ngd,Ver_a_8%t,Ver_b_8%t,
     $                   Cstv_pisrf_8,G_nk+1,presstype)
*
      if (nvar.gt.5) then
         call vte_intvertx(ww1,wwr,srclev,dstlev, ngd, nka+1,G_nk+1,'WW') 
         call vte_intvertx(zd1,zdr,srclev,dstlev, ngd, nka+1,G_nk+1,'ZD') 
      else
         do k=1,G_nk+1
            do j=n3,n4
            do i=n1,n2
               ww1(i,j,k)=0.
               zd1(i,j,k)=0.
            enddo
            enddo
         enddo
      endif
      deallocate (wwr,zdr)
*
*     Interpolate TT,Tracers
*
      call get_lnpress3d(srclev,ssqr,ngd,ana_as_8,ana_bs_8,
     $                   Cstv_pisrf_8,nka+2,presstype)
      call get_lnpress3d(dstlev,ssq0,ngd,Ver_a_spcl_8%t,Ver_b_spcl_8%t,
     $                   Cstv_pisrf_8,G_nk+2,presstype)
      call vte_intvertx(tt1,ttr,srclev,dstlev, ngd, nka+2,G_nk+2,'VT') 
      deallocate (ttr)
* Interpolate Tracers and place in bcs space
      do 100 n=1,Tr3d_ntr
         tr1_id = (n-1)*ngd*(G_nk+2)
         jj=-1
         do k=1,ntra
            if (Tr3d_name_S(n).eq.trname_a(k)(1:4)) jj=k
         end do
* If data found for this tracer
         if (jj.gt.0) then
             call vte_intvertx(tr3,trr(1,1,jj),srclev,dstlev,ngd,nka+2,G_nk+2,'HU') 
* ALWAYS clip tracers to zero after vertical interpolation (Desgagne)
            do k=1,G_nk+2
            do j=n3,n4
            do i=n1,n2
               tr3(i,j,k)=max(tr3(i,j,k),0.0)
            enddo
            enddo
            enddo
         endif
         if (.not.Schm_moist_L) then
            jjj=-1
* See if it is a humid tracer
            do kk = 1,h2o_ntr
               if (trname_a(jj)(1:2).eq.h2o_name_S(kk)(1:2)) jjj=kk
            enddo
            if (jjj.gt.0) then
* If no moist scheme, put humid tracers to zero
                do k=1,G_nk+2
                do j=n2,n4
                do i=n1,n3
                   tr3(i,j,k)=0.0
                enddo
                enddo
                enddo
            endif
         endif
* Fill the BCS area
             cnt=0
             do k=1,G_nk+2
             do j=n3,n4
             do i=n1,n2
                cnt=cnt+1
                tr1(cnt+tr1_id+ib1) = tr3(i,j,k)
             end do
             end do
             end do
 100  continue
      deallocate (trr)
*
      if (.not.Schm_hydro_L) then
          if(nvar.eq.8) then
             call get_lnpress3d(dstlev,ssq0,ngd,Ver_a_8%m(1),Ver_b_8%m(1),
     $                   Cstv_pisrf_8,G_nk,presstype)
             do j=1,njd
             do i=1,nid
                lnpis_8 = ssq0(i,j) + lnpref_8
                dstlev(i,j,G_nk+1) = lnpis_8
             enddo
             enddo
             call get_lnpress3d(srclev(1,1,2),ssqr,ngd,ana_am_8,ana_bm_8,
     $                   Cstv_pisrf_8,nka,presstype)
             do j=1,njd
             do i=1,nid
                 lnpis_8 = ssqr(i,j) + lnpref_8
                 srclev(i,j,1) = ana_at_8(1)
                 srclev(i,j,nka+2) = lnpis_8
                 qqr((j-1)*nid+i,nka+2) = 
     $               (qqr((j-1)*nid+i,nka)+qqr((j-1)*nid+i,nka+1) ) *0.5
             enddo
             enddo
             qqr(:,1)=0.

             call vte_intvertx(qq1(n1,n3,2),qqr,srclev,dstlev, ngd, nka+2,G_nk+1,'QQ') 
             do j=1,njd
             do i=1,nid
                qq1(n1+i-1,n3+j-1,1)     = -qq1(n1+i-1,n3+j-1,2)
                qq1(n1+i-1,n3+j-1,G_nk+2)= 2.0*qq1(n1+i-1,n3+j-1,G_nk+2)
     $                                        -qq1(n1+i-1,n3+j-1,G_nk+1)
             enddo
             enddo
          else
             qq1(n1:n2,n3:n4,1:G_nk+2) = 0.
          endif
      endif
      deallocate (qqr)
      deallocate (ssqr)
*
*     Interpolate UT1 and VT1
*
      call get_lnpress3d(srclev,ssur,ngd,ana_am_8,ana_bm_8,
     $                   Cstv_pisrf_8,nka+1,presstype)
      call get_lnpress3d(dstlev,ssu0,ngd,Ver_a_8%m(1),Ver_b_8%m(1),
     $                   Cstv_pisrf_8,G_nk+1,presstype)
      call vte_intvertx(uu1,uur,srclev,dstlev, ngd, nka+1,G_nk+1,'UU') 
      deallocate (ssur,uur,ssu0)

      call get_lnpress3d(srclev,ssvr,ngd,ana_am_8,ana_bm_8,
     $                   Cstv_pisrf_8,nka+1,presstype)
      call get_lnpress3d(dstlev,ssv0,ngd,Ver_a_8%m(1),Ver_b_8%m(1),
     $                   Cstv_pisrf_8,G_nk+1,presstype)
      call vte_intvertx(vv1,vvr,srclev,dstlev, ngd, nka+1,G_nk+1,'VV') 
      deallocate (ssvr,vvr,ssv0)

*
*-----------------------------------------------------------------------
      return
      end
*
