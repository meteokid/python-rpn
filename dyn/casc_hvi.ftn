! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
*** casc_hvi - take incoming lo-res data, interpolate to hi-res data
*              and place into the pieces of the BCS target grid as
*              described in bcs_did
*
#include "model_macros_f.h"
*
* xpn=> xpq1
* ypn=> ypq1
* xpun = > xpu1
* ypvn = > ypv1
      subroutine casc_hvi (trname_a,   
     $       xpq1,ypq1,xpu1,ypv1,xpaq1,ypaq1,xpau1,ypav1,
     $       uu1,vv1,tt1,zd1,ssq1,qq1,ww1,tr1,ib1,
     $       topo1,
     $       uun,vvn,ttn,zdn,meqn,ssqn,qqn,wwn,trn,
     $       n1,n2,n3,n4,n21,n41,lnk,
     $       nis,njs,nka_m,nka_s,nka_t,presstype,ntra)
      implicit none
*
*nka_m - number of momentum levels
*nka_s - number of thermo + special levels
*nka_t - number of true thermo levels
*presstype:
* 1=hyb
* 2=eta
* 3=sig
* 4=press
* 5=ecmwf
* 6=stag
      character*8 trname_a(ntra)
      logical b1,b2
      integer n1,n2,n3,n4,d1,d2,d11,d21,lnk,nis,njs,nka_m,nka_s,nka_t
      integer ii,jj,jjj,kk,ntra,ib1,presstype
      real*8 xpq1(*),ypq1(*),xpu1(*),ypv1(*)
      real*8 xpaq1(*),ypaq1(*),xpau1(*),ypav1(*)
      real uun(*),vvn(*),ttn(*),zdn(*),meqn(*),ssqn(*),
     $     qqn(*),wwn(*),trn(*),
     $     uu1(n1:n2,n3:n4,*),
     $     vv1(n1:n2,n3:n4,*),
     $     tt1(n1:n2,n3:n4,*),
     $     zd1(n1:n2,n3:n4,*),
     $     qq1(n1:n2,n3:n4,*),
     $     ww1(n1:n2,n3:n4,*),
     $    ssq1(n1:n2,n3:n4),
     $     tr1(*),
     $     topo1(n1:n21,n3:n41)
         
*
*author    M. Desgagne  2001 (MC2)
*
*revision
* v3_30 - Lee V.       - initial version for GEMLAM


#include "glb_ld.cdk"
#include "bcsdim.cdk"
#include "bcsgrds.cdk"
#include "bcsmem.cdk"
#include "lam.cdk"
#include "geomg.cdk"
#include "schm.cdk"
#include "pres.cdk"
#include "tr3d.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
#include "itf_phy_busind.cdk"
#include "ptopo.cdk"
*
      integer i,j,k,n,nga,err,cnt,tr1_id
      integer n21,n41,nid,njd,nid1,njd1,ngd,ngd1,nidu,njdv
      logical Vertint_L
      integer, dimension (:), allocatable :: idx,idu,idy
      real  tr3 (n1:n2,n3:n4,G_nk+2)
      real, dimension (:,:), allocatable :: uur,vvr,ttr,zdr,ssqr,qqr,wwr,meqx
      real, dimension (:,:), allocatable :: ssur,ssvr,ssu0,ssv0
      real, dimension (:,:), allocatable :: ssq0x,topo_temp,ttx,ssq0,pres
      real, dimension (:,:,:), allocatable :: trr,dstlev,srclev
      real, dimension (:), allocatable :: ssqx,rna
      real*8, dimension (:  ), allocatable ::
     $              cxa,cxb,cxc,cxd,cua,cub,cuc,cud,cya,cyb,cyc,cyd
      real*8 lnpis_8,lnpref_8
*
*-----------------------------------------------------------------------
*
      lnpref_8 = log(Cstv_pref_8)
      nga = nis * njs
      nid = n2-n1+1
      njd = n4-n3+1
      ngd = nid*njd
      nid1 = n21-n1+1
      njd1 = n41-n3+1
      ngd1 = nid1 * njd1
      if (ngd.le.0) return
*
      allocate ( idx(nid1), idy(njd1), idu(max(nid,njd)) )
      allocate ( cxa(nid1),cxb(nid1),cxc(nid1),cxd(nid1),
     $           cua(max(nid1,njd1)),cub(max(nid1,njd1)),
     $           cuc(max(nid1,njd1)),cud(max(nid1,njd1)),
     $           cya(njd1),cyb(njd1),cyc(njd1),cyd(njd1))
*
*
      allocate (uur(ngd,nka_m),vvr(ngd,nka_m),zdr(ngd,nka_t),
     $          ssur(nid,njd),ssvr(nid,njd),
     $          ttr(ngd,nka_s),ssqr(nid,njd),
     $          qqr(ngd,nka_m+1),wwr(ngd,nka_t),
     $          ttx(ngd1,nka_s),ssqx(ngd1),
     $          trr(ngd,nka_s,ntra))
*
* Perform horizontal interpolations for inflated BCS boxes
*
      call grid_to_grid_coef(xpq1,nid1,xpaq1,nis,idx,cxa,cxb,cxc,cxd,
     $                                                  Lam_hint_S)
      call grid_to_grid_coef(ypq1,njd1,ypaq1,njs,idy,cya,cyb,cyc,cyd,
     $                                                  Lam_hint_S)

      call hinterpo ( ttx,nid1,njd1, ttn,nis,njs,nka_s,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      if (presstype.eq.4) then
          allocate(meqx(ngd1,nka_m))
          call hinterpo ( meqx,nid1,njd1, meqn,nis,njs,nka_m,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
          ssqx=0.0
      else
          allocate(meqx(ngd1,1))
          call hinterpo ( meqx,nid1,njd1, meqn,nis,njs,   1,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
          call hinterpo ( ssqx,nid1,njd1, ssqn,nis,njs,   1,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      endif

*
* Perform horizontal interpolations for BCS boxes
*
      call grid_to_grid_coef(xpq1,nid,xpaq1,nis,idx,cxa,cxb,cxc,cxd,
     $                                                  Lam_hint_S)
      call grid_to_grid_coef(ypq1,njd,ypaq1,njs,idy,cya,cyb,cyc,cyd,
     $                                                  Lam_hint_S)
      if (.not.Schm_hydro_L.and.ana_q_L) then
      call hinterpo ( qqr,nid,njd, qqn,nis,njs,nka_m+1,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      endif
      if (ana_zdw_L) then
      call hinterpo ( wwr,nid,njd, wwn,nis,njs,nka_t,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      call hinterpo ( zdr,nid,njd, zdn,nis,njs,nka_t,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      endif
      do k=1,ntra
         if (trname_a(k).ne.'!@@NOT@@') 
     $   call hinterpo (trr(1,1,k),nid,njd,trn((k-1)*nga*(nka_s)+1),nis,njs,
     $           nka_s,idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      end do

* Horizontal interpolation ===> U point (xpu1,ypq1)
* unn=>uur (xpau1,ypaq1) ===> (xpu1,ypq1)
      call grid_to_grid_coef (xpu1,nid,xpau1,nis,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
      call hinterpo  (uur,nid,njd,uun,nis,njs,nka_m,
     $               idu,idy,cua,cub,cuc,cud,cya,cyb,cyc,cyd,Lam_hint_S)

* ssqn=>ssur (xpaq1,ypaq1) ===> (xpu1,ypq1)
      call grid_to_grid_coef (xpu1,nid,xpaq1,nis,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
      call hinterpo (ssur,nid,njd,ssqn,nis,njs,1,
     $               idu,idy,cua,cub,cuc,cud,cya,cyb,cyc,cyd,Lam_hint_S)

* Horizontal interpolation ===> V point (xpq1,ypv1)
* vvn=>vvr (xpaq1,ypav1) ===> (xpq1,ypv1)
      call grid_to_grid_coef (ypv1,njd,ypav1,njs,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
      call hinterpo (vvr,nid,njd,vvn,nis,njs,nka_m,
     $               idx,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,Lam_hint_S)

      call grid_to_grid_coef (ypv1,njd,ypaq1,njs,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
* ssqn=>ssvr (xpaq1,ypaq1) ===> (xpq1,ypv1)
      call hinterpo (ssvr,nid,njd,ssqn,nis,njs,1,
     $               idx,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,Lam_hint_S)

      deallocate (idx,idy,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,
     $                                        cya,cyb,cyc,cyd)
      allocate  (topo_temp(nid1,njd1),
     $           ssq0x(nid1,njd1),
     $           ssq0(nid,njd),
     $           ssu0(nid,njd),
     $           ssv0(nid,njd),pres(ngd1,nka_s)  )
      do j=1,njd1
      do i=1,nid1
         topo_temp(i,j) = topo1(n1+i-1,n3+j-1)
      enddo
      enddo

      do k=1,nka_s
         do j=1,njd
         do i=1,nid
            ttr((j-1)*nid+i,k) = ttx((j-1)*nid1+i,k)
         enddo
         enddo
      enddo

*     Obtain pressure S
      if (presstype.eq.4) then
*     Analysis is on pressure coordinates
          allocate (rna(nka_m))
          do i=1,nka_m
             rna(i)=ana_am_8(i)
          enddo
          call gz2p0(ssq0x,meqx,topo_temp,rna,ngd1,nka_m)
          deallocate (rna)
*
          do j=1,njd1
          do i=1,nid1
             ssq0x(i,j) =ssq0x(i,j)-lnpref_8
          enddo
          enddo
      else
*     Analysis NOT on pressure coordinates
          call get_press3d(pres,ssqx,ngd1,ana_as_8,ana_bs_8,
     $                   Cstv_pref_8,nka_s,presstype)
          call adj_ss2topo(ssq0x, topo_temp,pres,meqx,ttx,ngd1,nka_s)
          deallocate(pres)

          do j=1,njd1
          do i=1,nid1
             ssq0x(i,j) = log(ssq0x(i,j)/Cstv_pref_8)
          enddo
          enddo
      endif

*Calc for st1
      do j=1,njd
      do i=1,nid
         ssq0(i,j)=  ssq0x(i,j)
         ssqr(i,j) = ssqx((j-1)*nid1+i)
         ssq1(n1+i-1,n3+j-1)= ssq0(i,j)
      enddo
      enddo

*Calc for ssu0,ssv0
      nidu=nid
      njdv=njd
      if (l_east) nidu=nid-1
      if (l_north)njdv=njd-1
      do j=1,njd
      do i=1,nidu
         ssu0(i,j)= (ssq0x(i,j)+ssq0x(i+1,j  ))*.5
      enddo
      enddo

      if (l_east) then
          do j=1,njd
             ssu0(nid,j)= ssq0x(nid,j)
          enddo 
      endif
 
      do j=1,njdv
      do i=1,nid
         ssv0(i,j)= (ssq0x(i,j)+ssq0x(i  ,j+1))*.5
      enddo
      enddo
      if (l_north) then
          do i=1,nid
             ssv0(i,njd)= ssq0x(i,njd)
          enddo 
      endif

* Vertical interpolation (in log(pressure))
      allocate (dstlev(nid,njd,G_nk+1),srclev(nid,njd,nka_t) )
*     Interpolate ZD,W 
*
      if (ana_zdw_L) then
         call get_lnpress3d(srclev,ssqr,ngd,ana_at_8,ana_bt_8,
     $                   Cstv_pref_8,nka_t,presstype)
         call get_lnpress3d(dstlev,ssq0,ngd,Ver_a_8%t,Ver_b_8%t,
     $                   Cstv_pref_8,G_nk+1,6)
*
         call vte_intvertx(ww1,wwr,srclev,dstlev, ngd, nka_t,G_nk+1,'WW') 
         call vte_intvertx(zd1,zdr,srclev,dstlev, ngd, nka_t,G_nk+1,'ZD') 
      else
         do k=1,G_nk+1
            do j=n3,n4
            do i=n1,n2
               ww1(i,j,k)=0.
               zd1(i,j,k)=0.
            enddo
            enddo
         enddo
      endif
      deallocate (wwr,zdr,srclev,dstlev)
*
*     Interpolate TT,Tracers
*
      allocate (dstlev(nid,njd,G_nk+2),srclev(nid,njd,nka_s) )
      call get_lnpress3d(srclev,ssqr,ngd,ana_as_8,ana_bs_8,
     $                   Cstv_pref_8,nka_s,presstype)
      call get_lnpress3d(dstlev,ssq0,ngd,Ver_a_spcl_8%t,Ver_b_spcl_8%t,
     $                   Cstv_pref_8,G_nk+2,6)
      call vte_intvertx(tt1,ttr,srclev,dstlev, ngd, nka_s,G_nk+2,'VT') 
      deallocate (ttr)
* Interpolate Tracers and place in bcs space
      do 100 n=1,Tr3d_ntr
         tr1_id = (n-1)*ngd*(G_nk+2)
         jj=-1
         do k=1,ntra
            if (Tr3d_name_S(n).eq.trname_a(k)(1:4)) jj=k
         end do
* If data found for this tracer
         if (jj.gt.0) then
             call vte_intvertx(tr3,trr(1,1,jj),srclev,dstlev,ngd,nka_s,G_nk+2,'HU') 
* ALWAYS clip tracers to zero after vertical interpolation (Desgagne)
            do k=1,G_nk+2
            do j=n3,n4
            do i=n1,n2
               tr3(i,j,k)=max(tr3(i,j,k),0.0)
            enddo
            enddo
            enddo
         else
            do k=1,G_nk+2
            do j=n3,n4
            do i=n1,n2
               tr3(i,j,k)=Tr3d_sval(n)
            enddo
            enddo
            enddo
         endif
         if (.not.Schm_moist_L) then
            jjj=-1
* See if it is a humid tracer
            do kk = 1,h2o_ntr
               if (Tr3d_name_S(n)(1:2).eq.h2o_name_S(kk)(1:2)) jjj=kk
            enddo
            if (jjj.gt.0) then
* If no moist scheme, put humid tracers to zero
                do k=1,G_nk+2
                do j=n2,n4
                do i=n1,n3
                   tr3(i,j,k)=0.0
                enddo
                enddo
                enddo
            endif
         endif
* Fill the BCS area
         cnt=0
         do k=1,G_nk+2
         do j=n3,n4
         do i=n1,n2
            cnt=cnt+1
            tr1(cnt+tr1_id+ib1) = tr3(i,j,k)
         end do
         end do
         end do
 100  continue
      deallocate (trr)
      deallocate (dstlev,srclev)
*
      if (.not.Schm_hydro_L) then
          if(ana_q_L) then
             allocate (dstlev(nid,njd,G_nk+1),srclev(nid,njd,nka_m+1) )
             call get_lnpress3d(dstlev,ssq0,ngd,Ver_a_8%m(1),Ver_b_8%m(1),
     $                   Cstv_pref_8,G_nk,6)
             do j=1,njd
             do i=1,nid
                lnpis_8 = ssq0(i,j) + Cstv_Zsrf_8
                dstlev(i,j,G_nk+1) = lnpis_8
             enddo
             enddo
*find pressure levels for qqr(2:nka_m) = qt1(1:G_nk)
             call get_lnpress3d(srclev(1,1,2),ssqr,ngd,ana_am_8,ana_bm_8,
     $                   Cstv_pref_8,nka_m-1,presstype)
*set pressure level for qqr(1) = qt1(0)= 0
*set pressure level for qqr(nka_m+1) = qt1(G_nk+1)= psurf
             do j=1,njd
             do i=1,nid
                 srclev(i,j,1) = ana_at_8(1)
                 lnpis_8 = ssqr(i,j) + Cstv_Zsrf_8
                 srclev(i,j,nka_m+1) = lnpis_8
                 if(Schm_virlev_L)
     $                qqr((j-1)*nid+i,nka_m+1) = 
     $                (qqr((j-1)*nid+i,nka_m+1)+qqr((j-1)*nid+i,nka_m) ) *0.5                 
             enddo
             enddo
             if(Schm_virlev_L)qqr(:,1)=0.

             call vte_intvertx(qq1(n1,n3,2),qqr,srclev,dstlev, ngd, nka_m+1,G_nk+1,'QQ') 
             deallocate (dstlev,srclev)
             if(Schm_virlev_L)then
                do j=1,njd
                do i=1,nid
                   qq1(n1+i-1,n3+j-1,1)     = -qq1(n1+i-1,n3+j-1,2)
                   qq1(n1+i-1,n3+j-1,G_nk+2)= 2.0*qq1(n1+i-1,n3+j-1,G_nk+2)
     $                  -qq1(n1+i-1,n3+j-1,G_nk+1)
                enddo
                enddo
             endif
          else
             qq1(n1:n2,n3:n4,1:G_nk+2) = 0.
          endif
      endif
      deallocate (qqr)
      deallocate (ssqr)
*
*     Interpolate UT1 and VT1
*
      allocate (dstlev(nid,njd,G_nk+1),srclev(nid,njd,nka_m) )
      call get_lnpress3d(srclev,ssur,ngd,ana_am_8,ana_bm_8,
     $                   Cstv_pref_8,nka_m,presstype)
      call get_lnpress3d(dstlev,ssu0,ngd,Ver_a_8%m(1),Ver_b_8%m(1),
     $                   Cstv_pref_8,G_nk+1,6)
      call vte_intvertx(uu1,uur,srclev,dstlev, ngd, nka_m,G_nk+1,'UU') 
      deallocate (ssur,uur,ssu0)

      call get_lnpress3d(srclev,ssvr,ngd,ana_am_8,ana_bm_8,
     $                   Cstv_pref_8,nka_m,presstype)
      call get_lnpress3d(dstlev,ssv0,ngd,Ver_a_8%m(1),Ver_b_8%m(1),
     $                   Cstv_pref_8,G_nk+1,6)
      call vte_intvertx(vv1,vvr,srclev,dstlev, ngd, nka_m,G_nk+1,'VV') 
      deallocate (ssvr,vvr,ssv0)
      deallocate (dstlev,srclev)

*
*-----------------------------------------------------------------------
      return
      end
*
