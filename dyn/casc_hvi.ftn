*** casc_hvi - take incoming lo-res data, interpolate to hi-res data
*              and place into the pieces of the BCS target grid as
*              described in bcs_did
*
#include "model_macros_f.h"
*
      subroutine casc_hvi (trname_a,   
     $       xpqd,ypqd,xpud,ypvd,xpqs,ypqs,xpus,ypvs,
     $       uu1,uu2,vv1,vv2,tt1,tt2,psd1,psd2,
     $       tr1,ww1,ww2,qsec1,qsec2,ss1,ss2,ib1,ib2,
     $       topo1,topo2,topu1,topu2,topv1,topv2,
     $       uun,vvn,psdn,ttn,fisn,p0n,ssn,wwn,qsecn,trn,
     $       n1,n2,n3,n4,d1,d2,lnk,nid,njd,
     $       nis,njs,nka,nvar,ntra,b1,b2)
      implicit none
*
      character*8 trname_a(ntra)
      logical b1,b2
      integer n1,n2,n3,n4,d1,d2,lnk,nid,njd,nis,njs,nka
      integer ii,jj,jjj,nvar,ntra,ib1,ib2,dd1,dd2
      real*8 xpqd(*),ypqd(*),xpud(*),ypvd(*)
      real*8 xpqs(*),ypqs(*),xpus(*),ypvs(*)
      real uun(*),vvn(*),psdn(*),ttn(*),fisn(*),
     $     p0n(*),ssn(*),
     $     wwn(*),qsecn(*),trn(*),
     $     uu1(n1:n2,n3:n4,*),uu2(n1:n2,n3:n4,*),
     $     tt1(n1:n2,n3:n4,*),tt2(n1:n2,n3:n4,*),
     $     vv1(n1:n2,n3:n4,*),vv2(n1:n2,n3:n4,*),
     $    psd1(n1:n2,n3:n4,*),psd2(n1:n2,n3:n4,*),
     $     tr1(*),
     $     ww1(n1:n2,n3:n4,*),ww2(n1:n2,n3:n4,*),
     $     qsec1(n1:n2,n3:n4,*),qsec2(n1:n2,n3:n4,*),
     $     ss1(n1:n2,n3:n4,*),ss2(n1:n2,n3:n4,*),
     $     topo1(n1:n2,n3:n4),topo2(n1:n2,n3:n4),
     $     topu1(n1:n2,n3:n4),topu2(n1:n2,n3:n4),
     $     topv1(n1:n2,n3:n4),topv2(n1:n2,n3:n4)
         
*
*author    M. Desgagne  2001 (MC2)
*
*revision
* v3_30 - Lee V.       - initial version for GEMLAM
* v4_00 - Plante A.    - Staggered version

#include "glb_ld.cdk"
#include "bcsdim.cdk"
#include "bcsgrds.cdk"
#include "bcsmem.cdk"
#include "lam.cdk"
#include "geomg.cdk"
#include "schm.cdk"
#include "pres.cdk"
#include "tr3d.cdk"
#include "itf_phy_busind.cdk"
#include "type.cdk"
#include "ver.cdk"
*
      integer i,j,k,kk,n,ngd,nga,err,cnt,id
      logical Vertint_L
      integer, dimension (:), allocatable :: idx,idu,idy
      real  , dimension (:), allocatable :: ana_p0,ana_p0u,ana_p0v
      real, dimension (:,:), allocatable :: uur,vvr,psdr,ttr,
     $     fisr, ssr,wwr,qsecr
      real, dimension (:,:,:), allocatable :: trr,uu3,vv3,psd3,tt3,
     $         ss3,ww3,qsec3,tr3
      real, dimension (:,:), allocatable ::
     $     gz_temp,ttru,ttrv,fisru,fisrv,ps,psu,psv,
     $         topo_temp,topu_temp,topv_temp
      real*8, dimension (:  ), allocatable ::
     $              cxa,cxb,cxc,cxd,cua,cub,cuc,cud,cya,cyb,cyc,cyd
      real pia_special_t(l_nk+1),pibb_special_t(l_nk+1)
*
*-----------------------------------------------------------------------
*
      ngd = nid * njd
      nga = nis * njs
      if (ngd.le.0) return
      allocate ( idx(nid), idu(max(nid,njd)), idy(njd) )
      allocate ( cxa(nid),cxb(nid),cxc(nid),cxd(nid),
     $           cua(max(nid,njd)),cub(max(nid,njd)),
     $           cuc(max(nid,njd)),cud(max(nid,njd)),
     $           cya(njd),cyb(njd),cyc(njd),cyd(njd))
*
      call grid_to_grid_coef(xpqd,nid,xpqs,nis,idx,cxa,cxb,cxc,cxd,
     $                                                  Lam_hint_S)
      call grid_to_grid_coef(ypqd,njd,ypqs,njs,idy,cya,cyb,cyc,cyd,
     $                                                  Lam_hint_S)
*
      allocate (uur(ngd,nka),vvr(ngd,nka),psdr(ngd,nka),
     $          ttr(ngd,nka),fisr(ngd,1),
     $          ssr(ngd,1),
     $          wwr(ngd,nka),qsecr(ngd,nka),
     $          ana_p0(ngd), ana_p0u(ngd),ana_p0v(ngd),
     $          fisru(ngd,1),fisrv(ngd,1),ttru(ngd,nka),ttrv(ngd,nka),
     $          trr(ngd,nka,ntra))
*
* Perform horizontal interpolations
*
      if (nvar.eq.5)then
         Vertint_L=.true.
         call hinterpo ( ttr,nid,njd, ttn,nis,njs,nka,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
         call hinterpo ( fisr,nid,njd, fisn,nis,njs,1,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      else
         Vertint_L=.false.
         call hinterpo (ttr,nid,njd,ttn,nis,njs,nka,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
         call hinterpo (ssr,nid,njd,ssn,nis,njs,1,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
         call hinterpo (psdr,nid,njd,psdn,nis,njs,nka,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
         If (.not.Schm_hydro_L.and.nvar.gt.11) then
         call hinterpo (wwr,nid,njd,wwn,nis,njs,nka,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
         call hinterpo (qsecr,nid,njd,qsecn,nis,njs,nka,
     $               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
         endif
      endif
*
      call hinterpo (ana_p0,nid,njd,p0n,nis,njs,1,
     $     idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
*
      do k=1,ntra
         if (trname_a(k).ne.'!@@NOT@@') 
     $   call hinterpo (trr(1,1,k),nid,njd,trn((k-1)*nga*nka+1),nis,njs,
     $           nka,idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      end do

* Horizontal interpolation (xpus,ypqs) ===> (xpud,ypqd)
      call grid_to_grid_coef (xpud,nid,xpus,nis,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
      call hinterpo  (uur,nid,njd,uun,nis,njs,nka,
     $               idu,idy,cua,cub,cuc,cud,cya,cyb,cyc,cyd,Lam_hint_S)
*
      if (Vertint_L) then
* Compute p0,tt,gz on U grid from analysis
* Horizontal interpolation (xpqs,ypqs) ===> (xpud,ypqd)
         call grid_to_grid_coef (xpud,nid,xpqs,nis,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
         call hinterpo (ana_p0u,nid,njd,p0n,nis,njs,1,
     $               idu,idy,cua,cub,cuc,cud,cya,cyb,cyc,cyd,Lam_hint_S)
         call hinterpo (ttru,nid,njd,ttn,nis,njs,nka,
     $               idu,idy,cua,cub,cuc,cud,cya,cyb,cyc,cyd,Lam_hint_S)
         call hinterpo (fisru,nid,njd,fisn,nis,njs,1,
     $               idu,idy,cua,cub,cuc,cud,cya,cyb,cyc,cyd,Lam_hint_S)
      endif

* Horizontal interpolation (xpqs,ypvs) ===> (xpqd,ypvd)
      call grid_to_grid_coef (ypvd,njd,ypvs,njs,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
      call hinterpo (vvr,nid,njd,vvn,nis,njs,nka,
     $               idx,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,Lam_hint_S)

      if (Vertint_L) then
* Compute p0,tt,gz on V grid from analysis
* Horizontal interpolation (xpqs,ypqs) ===> (xpqd,ypvd)
         call grid_to_grid_coef (ypvd,njd,ypqs,njs,idu,cua,cub,cuc,cud,
     $                                                   Lam_hint_S)
         call hinterpo (ana_p0v,nid,njd,p0n,nis,njs,1,
     $               idx,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,Lam_hint_S)
         call hinterpo (ttrv,nid,njd,ttn,nis,njs,nka,
     $               idx,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,Lam_hint_S)
         call hinterpo (fisrv,nid,njd,fisn,nis,njs,1,
     $               idx,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,Lam_hint_S)
      endif

      deallocate (idx,idy,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,
     $                                        cya,cyb,cyc,cyd)
      allocate (ps(nid,njd),psu(nid,njd),psv(nid,njd),
     $          gz_temp(ngd,max(G_nk,nka)))

      allocate ( uu3(n1:d1+n2,n3:d2+n4,lnk),
     $           vv3(n1:d1+n2,n3:d2+n4,lnk),
     $           psd3(n1:d1+n2,n3:d2+n4,lnk+1),
     $           tt3(n1:d1+n2,n3:d2+n4,lnk+1),
     $           ss3(n1:d1+n2,n3:d2+n4,1),
     $           tr3 (n1:d1+n2,n3:d2+n4,lnk+1),
     $           ww3(n1:d1+n2,n3:d2+n4,lnk+1),
     $           qsec3(n1:d1+n2,n3:d2+n4,0:lnk+1) )
      allocate  (topo_temp(n1:d1+n2,n3:d2+n4),
     $           topu_temp(n1:d1+n2,n3:d2+n4),
     $           topv_temp(n1:d1+n2,n3:d2+n4) )
      if (b1) then
         do j=n3,n4
         do i=n1,n2
            topo_temp(i,j) = topo1(i,j)
            topu_temp(i,j) = topu1(i,j)
            topv_temp(i,j) = topv1(i,j)
         enddo
         enddo
      endif
      if (b2) then
         do j=n3,n4
         do i=n1,n2
            topo_temp(i+d1,j+d2)=topo2(i,j)
            topu_temp(i+d1,j+d2)=topu2(i,j)
            topv_temp(i+d1,j+d2)=topv2(i,j)
         enddo
         enddo
      endif


      if (Vertint_L) then
* Preparation for vertical interpolation, grid phi
* Compute vt from analysis using TT and HU
* Compute hydrostatic GZ on NKA analysis levels
         do i=1,ngd
            gz_temp(i,nka) = fisr(i,1)
         enddo
         call p0vt2gz_hyb ( gz_temp, ana_pia, ana_pibb, ana_p0,
     $                      ttr,ngd, nka,.false.,.false.)

* Finally, compute pressure on model surface (PS) using p0 and GZ of analysis
         call getp0 ( ps, topo_temp,ana_pia,ana_pibb, ana_p0, gz_temp,
     $                    ttr, ngd, nka,.false.)
* Interpolate VT
         do k=1,g_nk+1
            pia_special_t(k)=Ver_pia_spcl_8%t(k)
            pibb_special_t(k)=Ver_pibb_spcl_8%t(k)
         end do
         call vte_hyb2hyb (tt3,pia_special_t,pibb_special_t,ps,G_nk+1,ttr,
     $         ana_pia,ana_pibb, ana_p0, nka, ngd, 'VT',.false.)         
*
* Preparation for vertical interpolation, grid U
* Compute hydrostatic GZ on analysis levels
         do i=1,ngd
            gz_temp(i,nka) = fisru(i,1)
         enddo
         call p0vt2gz_hyb ( gz_temp, ana_pia, ana_pibb, ana_p0u,
     $                      ttru,ngd, nka,.false.,.false.)
* Finally, compute pressure on model surface (PS)
         call getp0 ( psu, topu_temp,ana_pia,ana_pibb, ana_p0, 
     $                  gz_temp, ttru, ngd, nka,.false.)
*
* Preparation for vertical interpolation, grid V
* Compute hydrostatic GZ on analysis levels
         do i=1,ngd
            gz_temp(i,nka) = fisrv(i,1)
         enddo
         call p0vt2gz_hyb ( gz_temp, ana_pia, ana_pibb, ana_p0v,
     $                      ttru,ngd, nka,.false.,.false.)
* Finally, compute pressure on model surface (PS)
* psv=ana_p0v
         call getp0 ( psv, topv_temp,ana_pia,ana_pibb, ana_p0, 
     $                  gz_temp, ttrv, ngd, nka,.false.)
*
* Interpolate UT1
         call vte_hyb2hyb (uu3,Ver_pia%m,Ver_pibb%m,psu,G_nk, uur,
     $         ana_pia,ana_pibb, ana_p0u, nka, ngd, 'UU',.false.)
* Interpolate VT1
         call vte_hyb2hyb (vv3,Ver_pia%m,Ver_pibb%m,psv,G_nk, vvr,
     $         ana_pia,ana_pibb, ana_p0v, nka, ngd, 'VV',.false.)

* BCS_predat does not calculate wind related fields. These calculations
* would be done under the space which contains halos
         call bcs_predat(ss3,ps,nid,njd,lnk)
      else
* NO VERTINT
         do k=1,lnk+1
         kk=min(k,lnk)
         do j=1,njd
         do i=1,nid
            ii=(j-1)*nid+i
            tt3(i+n1-1,j+n3-1,k)=ttr(ii,k)
            uu3(i+n1-1,j+n3-1,kk)=uur(ii,kk)
            vv3(i+n1-1,j+n3-1,kk)=vvr(ii,kk)
            psd3(i+n1-1,j+n3-1,k)=psdr(ii,k)
         enddo
         enddo
         enddo
         do j=1,njd
         do i=1,nid
            ii=(j-1)*nid+i
            ss3(i+n1-1,j+n3-1,1)=ssr(ii,1)
         enddo
         enddo
         If (.not.Schm_hydro_L.and.nvar.gt.11) then
            do k=0,lnk+1
            kk=max(k,1)
            do j=1,njd
            do i=1,nid
            ii=(j-1)*nid+i
            ww3(i+n1-1,j+n3-1,kk)=wwr(ii,kk)
            qsec3(i+n1-1,j+n3-1,k)=qsecr(ii,k)
            enddo
            enddo
            enddo
         endif
      endif
*
* Interpolate Tracers and place in bcs space
      do 100 n=1,Tr3d_ntr
         id = (n-1)*bcs_sz
         jj=-1
         do k=1,ntra
            if (Tr3d_name_S(n).eq.trname_a(k)(1:4)) jj=k
         end do
* If data found for this tracer
         if (jj.gt.0) then
            if (Vertint_L) then
               call vte_hyb2hyb (tr3,pia_special_t,pibb_special_t,ps,G_nk+1,trr(1,1,jj),
     $           ana_pia,ana_pibb, ana_p0, nka,ngd,trname_a(jj)(1:2),.false.)
            else
               do k=1,lnk+1
               do j=1,njd
               do i=1,nid
                  ii=(j-1)*nid+i
                  tr3(i+n1-1,j+n3-1,k)=trr(ii,k,jj)
               enddo
               enddo
               enddo
            endif
* ALWAYS clip tracers to zero after vertical interpolation (Desgagne)
            do k=1,lnk+1
            do j=1,njd
            do i=1,nid
               tr3(i+n1-1,j+n3-1,k)=max(tr3(i+n1-1,j+n3-1,k),0.0)
            enddo
            enddo
            enddo
         else
* No data found for this tracer, set to user-defined value
            do k=1,lnk+1
            do j=1,njd
            do i=1,nid
               tr3(i+n1-1,j+n3-1,k)=tr3d_sval(n)
            enddo
            enddo
            enddo
         endif
         if (.not.Schm_moist_L) then
            jjj=-1
* See if it is a humid tracer
            do kk = 1,h2o_ntr
               if (trname_a(jj)(1:2).eq.h2o_name_S(kk)(1:2)) jjj=kk
            enddo
            if (jjj.gt.0) then
* If no moist scheme, put humid tracers to zero
                do k=1,lnk+1
                do j=1,njd
                do i=1,nid
                   tr3(i+n1-1,j+n3-1,k)=0.0
                enddo
                enddo
                enddo
            endif
         endif
* Fill the BCS area
         if (b1) then
             cnt=0
             do k=1,lnk+1
             do j=n3,n4
             do i=n1,n2
                cnt=cnt+1
                tr1(cnt + id+ib1) = tr3(i,j,k)
             end do
             end do
             end do
         endif
         if (b2) then
             cnt=0
             do k=1,lnk+1
             do j=n3,n4
             do i=n1,n2
                cnt=cnt+1
                tr1(cnt + id+ib2) = tr3(i+d1,j+d2,k)
             end do
             end do
             end do
         endif
 100  continue
* Place other fields in BCS space
      if (b1) then
         do k=1,lnk+1
         do j=n3,n4
         do i=n1,n2
            kk=min(k,lnk)
            uu1(i,j,kk)= uu3(i,j,kk)
            vv1(i,j,kk)= vv3(i,j,kk)
            tt1(i,j,k) = tt3(i,j,k)
         enddo
         enddo
         enddo
         do j=n3,n4
         do i=n1,n2
            ss1(i,j,1) = ss3(i,j,1)
         enddo
         enddo
      endif
*
      if (b2) then
         do k=1,lnk+1
         do j=n3,n4
         do i=n1,n2
            kk=min(k,lnk)
            uu2(i,j,kk)= uu3(i+d1,j+d2,kk)
            vv2(i,j,kk)= vv3(i+d1,j+d2,kk)
            tt2(i,j,k) = tt3(i+d1,j+d2,k)
         end do
         end do
         end do 
         do j=n3,n4
         do i=n1,n2
            ss2(i,j,1) = ss3(i+d1,j+d2,1)
         enddo
         enddo
      endif
      if (.not. Vertint_L) then
         call gem_stop('casc_hvi : verifier traitement de p0t1 et p0t2',-1)

        if (b1) then
            do k=1,lnk+1
            do j=n3,n4
            do i=n1,n2
              psd1(i,j,k) = psd3(i,j,k)
            enddo
            enddo
            enddo
        endif
        if (b2) then
            do k=1,lnk+1
            do j=n3,n4
            do i=n1,n2
               psd2(i,j,k) = psd3(i+d1,j+d2,k)
            enddo
            enddo
            enddo
          endif
      endif
*
*
      If (.not.Schm_hydro_L.and.nvar.gt.11) then
          if (b1) then
             do k=0,lnk+1
             kk=max(k,1)
             do j=n3,n4
             do i=n1,n2
                ww1(i,j,kk) =   ww3(i,j,kk)
                qsec1(i,j,k)= qsec3(i,j,k)
             enddo
             enddo
             enddo
          endif
          if (b2) then
             do k=0,lnk+1
             kk=max(k,1)
             do j=n3,n4
             do i=n1,n2
                ww2(i,j,kk) = ww3(i+d1,j+d2,kk)
                qsec2(i,j,k)= qsec3(i+d1,j+d2,k)
             enddo
             enddo
             enddo
          endif
      endif
      deallocate (uur,vvr,psdr,ttr,fisr,
     $            ssr,trr,wwr,qsecr,
     $            ps,psu,psv,
     $            ana_p0,ana_p0u,ana_p0v,gz_temp,
     $            fisru,fisrv,ttru,ttrv)
      deallocate (uu3,vv3,psd3,tt3,
     $            ss3,tr3,ww3,qsec3)
      deallocate (topo_temp,topu_temp,topv_temp)
*
*-----------------------------------------------------------------------
      return
      end
*
