!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
copyright (C) 2001  MSC-RPN COMM  %%%MC2%%%
***s/r acid_outdyn_3df - output in the form of 3DF files
*
#include "model_macros_f.h"
*
      subroutine acid_outdyn_3df ( datev, mode, gid, gif, gjd, gjf )
      implicit none
*
      character* (*) datev
      integer mode, gid, gif, gjd, gjf
*
*author M.Desgagne ( MC2 2001)
*
*revision
* v3_30 - V.Lee - initial version for GEM LAM (new I/O)
* v4_05 - Lepine M.         - VMM replacement with GMM
*
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "geomg.cdk"
#include "out.cdk"
#include "p_geof.cdk"
#include "vt1.cdk"
#include "vth.cdk"
#include "vtx.cdk"
#include "schm.cdk"
#include "grdc.cdk"
#include "tr3d.cdk"
#include "lctl.cdk"
#include "lun.cdk"
*
      integer i,j,k,nis,njs,ind_o(G_nk+2),cnt,unf,nvar
      real, pointer    , dimension(:,:,:) :: tr
*
*------------------------------------------------------------------
*
      if ((out_nisl.le.0).or.(out_njsl.le.0)) return
      if (Lun_debug_L) write(Lun_out,1000)
*
      nis = out_ifg - out_idg + 1
      njs = out_jfg - out_jdg + 1
      do k=1,G_nk+2
         ind_o(k) = k
      end do
*
      gmmstat = gmm_get(gmmk_topo_s,topo,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(topo)'
      gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(ut1)'
      gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(vt1)'
      gmmstat = gmm_get(gmmk_zdt1_s,zdt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(zdt1)'
      gmmstat = gmm_get(gmmk_tt1_s,tt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(tt1)'
      gmmstat = gmm_get(gmmk_fiptx_s,fiptx,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(fiptx)'
      gmmstat = gmm_get(gmmk_st1_s,st1,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(st1)'
      gmmstat = gmm_get(gmmk_wt1_s,wt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(wt1)'
      gmmstat = gmm_get(gmmk_xth_s,xth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(xth)'
      gmmstat = gmm_get(gmmk_yth_s,yth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(yth)'
      gmmstat = gmm_get(gmmk_zth_s,zth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(zth)'
      gmmstat = gmm_get(gmmk_xcth_s,xcth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(xcth)'
      gmmstat = gmm_get(gmmk_ycth_s,ycth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(ycth)'
      gmmstat = gmm_get(gmmk_zcth_s,zcth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(zcth)'
*
      if (Schm_zdotlag_L) then
         gmmstat = gmm_get(gmmk_xthh_s,xthh,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(xthh)'
         gmmstat = gmm_get(gmmk_ythh_s,ythh,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(ythh)'
         gmmstat = gmm_get(gmmk_zthh_s,zthh,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(zthh)'
         gmmstat = gmm_get(gmmk_xcthh_s,xcthh,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(xcthh)'
         gmmstat = gmm_get(gmmk_ycthh_s,ycthh,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(ycthh)'
         gmmstat = gmm_get(gmmk_zcthh_s,zcthh,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(zcthh)'
      endif
*
      if (.not.Schm_hydro_L) then
         gmmstat = gmm_get(gmmk_qt1_s,qt1,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'acid_outdyn_3df ERROR at gmm_get(qt1)'
      endif
*
      if (Out_blocme.eq.0) 
     $     call out_sfile_3df (datev,unf,'DYNAMICS',gid, gif, gjd, gjf,
     $                                              nvar,Grdc_ntr,mode)
*
* tt1,st1,topo are usually written from e_intthm
      call write_3df (  tt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2,
     $                       'TT  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df (fiptx,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2,
     $                       'FITX',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df (  st1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,1     ,
     $                       'S   ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df ( topo,l_minx,l_maxx,l_miny,l_maxy,nis,njs,1     ,
     $                       'GZ  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
* wt1,zdt1, maybe qt1 from the model
      call write_3df (  wt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1,
     $                       'W   ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df ( zdt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1,
     $                       'ZD  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
*
      if (.not.Schm_hydro_L) then
      call write_3df (qt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2,
     $                       'Q   ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      endif

* tracers written from e_intthm
      do k=1,Grdc_ntr
      do i=1,Tr3d_ntr
         if (trim(Grdc_trnm_S(k)).eq.trim(Tr3d_name_S(i))) then
            nullify(tr)
	    gmmstat = gmm_get('TR/'//trim(Tr3d_name_S(k))//':P',tr,meta3d)
            call write_3df (tr,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2,
     $                      Grdc_trnm_S(k),gid, gif, gjd, gjf,1.0,ind_o,unf )
         endif
      end do
      end do
*
* wind from e_intwind
      call write_3df (  ut1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1,
     $                       'UU  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df (  vt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1,
     $                       'VV  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
*
      if (Lctl_step.eq.Grdc_start.and.Lctl_step.ne.0.and.
     $    mode.eq.2) then
         call write_3df (  xth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'XTH ',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df (  yth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'YTH ',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df (  zth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'ZTH ',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df ( xcth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'XCTH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df ( ycth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'YCTH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df ( zcth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'ZCTH',gid, gif, gjd, gjf,1.0,ind_o,unf )
        if (Schm_zdotlag_L) then
         call write_3df ( xthh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'XTHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df ( ythh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'YTHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df ( zthh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'ZTHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df (xcthh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'XCHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df (ycthh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'YCHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df (zcthh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'ZCHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
        endif
*
      endif
*
      if (Out_blocme.eq.0) then
         close (unf)
      endif
*
 1000 format(3X,'WRITE OUT 3DF for ACID TEST: (S/R ACID_OUTDYN_3DF)')
*------------------------------------------------------------------
      return
      end
*
