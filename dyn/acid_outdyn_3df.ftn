! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
copyright (C) 2001  MSC-RPN COMM  %%%MC2%%%
***s/r acid_outdyn_3df - output in the form of 3DF files
*
#include "model_macros_f.h"
*
      subroutine acid_outdyn_3df ( datev, mode, gid, gif, gjd, gjf )
      implicit none
*
      character* (*) datev
      integer mode, gid, gif, gjd, gjf
*
*author M.Desgagne ( MC2 2001)
*
*revision
* v3_30 - V.Lee - initial version for GEM LAM (new I/O)
*
#include "glb_ld.cdk"
#include "geomg.cdk"
#include "out.cdk"
#include "p_geof.cdk"
#include "vt1.cdk"
#include "vth.cdk"
#include "vtx.cdk"
#include "vthh.cdk"
#include "schm.cdk"
#include "grdc.cdk"
#include "tr3d.cdk"
#include "lctl.cdk"
#include "lun.cdk"
*
      integer  vmmlod,vmmget,vmmuld
      external vmmlod,vmmget,vmmuld
*
      integer*8 pnt_trp(Grdc_ntr)
      integer i,j,k,nis,njs,ind_o(G_nk+2),cnt,unf,key(21),
     $        nvar,err,keyp_,keyp(Grdc_ntr)
      real trp
      pointer (patrp, trp(LDIST_SHAPE,*))
*
*------------------------------------------------------------------
*
      if ((out_nisl.le.0).or.(out_njsl.le.0)) return
      if (Lun_debug_L) write(Lun_out,1000)
*
      nis = out_ifg - out_idg + 1
      njs = out_jfg - out_jdg + 1
      do k=1,G_nk+2
         ind_o(k) = k
      end do
*
      key ( 1)=VMM_KEY ( ut1 )
      key ( 2)=VMM_KEY ( vt1 )
      key ( 3)=VMM_KEY (zdt1 )
      key ( 4)=VMM_KEY ( tt1 )
      key ( 5)=VMM_KEY ( st1 )
      key ( 6)=VMM_KEY (topo )
      key ( 7)=VMM_KEY ( wt1 )
      key ( 8)=VMM_KEY ( xth)
      key ( 9)=VMM_KEY ( yth)
      key (10)=VMM_KEY ( zth)
      key (11)=VMM_KEY ( xcth)
      key (12)=VMM_KEY ( ycth)
      key (13)=VMM_KEY ( zcth)
      key (14)=VMM_KEY ( fiptx)
      nvar= 14
      if (Schm_zdotlag_L) then
           key (nvar+1)=VMM_KEY ( xthh)
           key (nvar+2)=VMM_KEY ( ythh)
           key (nvar+3)=VMM_KEY ( zthh)
           key (nvar+4)=VMM_KEY ( xcthh)
           key (nvar+5)=VMM_KEY ( ycthh)
           key (nvar+6)=VMM_KEY ( zcthh)
           nvar = nvar+6
      endif
*
      if (.not.Schm_hydro_L) then
         nvar=nvar+1
         key(nvar)=VMM_KEY ( qt1 )
      endif
*
      err = vmmlod (key,nvar)
*
      err = VMM_GET_VAR ( ut1 )
      err = VMM_GET_VAR ( vt1 )
      err = VMM_GET_VAR (zdt1 )
      err = VMM_GET_VAR ( tt1 )
      err = VMM_GET_VAR (fiptx)
      err = VMM_GET_VAR ( st1 )
      err = VMM_GET_VAR (topo )
      err = VMM_GET_VAR ( wt1 )
      err = VMM_GET_VAR ( xth )
      err = VMM_GET_VAR ( yth )
      err = VMM_GET_VAR ( zth )
      err = VMM_GET_VAR (xcth )
      err = VMM_GET_VAR (ycth )
      err = VMM_GET_VAR (zcth )
      if (Schm_zdotlag_L) then
          err = VMM_GET_VAR (xthh )
          err = VMM_GET_VAR (ythh )
          err = VMM_GET_VAR (zthh )
          err = VMM_GET_VAR (xcthh)
          err = VMM_GET_VAR (ycthh)
          err = VMM_GET_VAR (zcthh)
      endif
*
      if (.not.Schm_hydro_L) then
         err = VMM_GET_VAR ( qt1 )
      endif
*
      keyp_ = VMM_KEY (trt1)
      do k=1,Grdc_ntr
         do i=1,Tr3d_ntr
            if (Grdc_trnm_S(k).eq.Tr3d_name_S(i)) keyp(k) = keyp_ + i
         end do
      end do
      err = vmmlod(keyp,Grdc_ntr)
      do k=1,Grdc_ntr
         err = vmmget(keyp(k),patrp,trp)
         pnt_trp(k) = patrp
      end do
*
      if (Out_blocme.eq.0) 
     $     call out_sfile_3df (datev,unf,'DYNAMICS',gid, gif, gjd, gjf,
     $                                              nvar,Grdc_ntr,mode)
*
* tt1,st1,topo are usually written from e_intthm
      call write_3df (  tt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2,
     $                       'TT  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df (fiptx,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2,
     $                       'FITX',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df (  st1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,1     ,
     $                       'S   ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df ( topo,l_minx,l_maxx,l_miny,l_maxy,nis,njs,1     ,
     $                       'GZ  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
* wt1,zdt1, maybe qt1 from the model
      call write_3df (  wt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1,
     $                       'W   ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df ( zdt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1,
     $                       'ZD  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
*
      if (.not.Schm_hydro_L) then
      call write_3df (qt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2,
     $                       'Q   ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      endif

* tracers written from e_intthm
      do k=1,Grdc_ntr
         patrp = pnt_trp(k)
         call write_3df (trp,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2,
     $                 Grdc_trnm_S(k),gid, gif, gjd, gjf,1.0,ind_o,unf )
      end do
*
* wind from e_intwind
      call write_3df (  ut1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1,
     $                       'UU  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df (  vt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1,
     $                       'VV  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
*
      if (Lctl_step.eq.Grdc_start.and.Lctl_step.ne.0.and.
     $    mode.eq.2) then
         call write_3df (  xth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'XTH ',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df (  yth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'YTH ',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df (  zth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'ZTH ',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df ( xcth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'XCTH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df ( ycth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'YCTH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df ( zcth,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'ZCTH',gid, gif, gjd, gjf,1.0,ind_o,unf )
        if (Schm_zdotlag_L) then
         call write_3df ( xthh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'XTHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df ( ythh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'YTHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df ( zthh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'ZTHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df (xcthh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'XCHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df (ycthh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'YCHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
         call write_3df (zcthh,1,l_ni,1,l_nj,nis,njs,G_nk ,
     $                       'ZCHH',gid, gif, gjd, gjf,1.0,ind_o,unf )
        endif
*
      endif
*
      if (Out_blocme.eq.0) then
         close (unf)
      endif
*
 1000 format(3X,'WRITE OUT 3DF for ACID TEST: (S/R ACID_OUTDYN_3DF)')
*------------------------------------------------------------------
      return
      end
*
