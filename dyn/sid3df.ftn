! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r sid3df
*
#include "model_macros_f.h"
*
      integer function sid3df (xpaq,ypaq,xpau,ypav,unf,done,
     $                    nia,nja,nka_m,nka_t,presstype)
      implicit none
*author
*     Michel Desgagne - rpn - MC2 2001
*
*revision
* v4_03 - Lee V.            - Adapt to using new pressure functions
*
      logical done
      integer unf,nia,nja,nka_m,nka_t,presstype
      real*8 xpaq(nia), ypaq(nja), xpau(nia), ypav(nja)
*
#include "ifd.cdk"
#include "bcsgrds.cdk"
#include "ptopo.cdk"
#include "lun.cdk"
*
      character*4 nomvar
      integer i,j,k,ni1,nj1,nk1,err
      real*8, dimension (:), allocatable :: xp1,yp1
*-----------------------------------------------------------------------
*
      sid3df  = -1
*
      if (.not.done) then
*
         read (unf,end=33,err=33) 
     $         nomvar,ni1,nj1,nka_m,nka_t,presstype
         if (Lun_debug_L) then
              write(Lun_out,*)'sid3df:'
              write(Lun_out,*)'nomvar,ni1,nj1,presstype=',
     $         nomvar,ni1,nj1,presstype
              write(Lun_out,*)'nka_m,nka_t=',nka_m,nka_t
              if (presstype.eq.0)write(Lun_out,*)'pressure coordinate found'
              if (presstype.eq.1)write(Lun_out,*)'sigma coordinate found'
              if (presstype.eq.2)write(Lun_out,*)'eta sef coordinate found'
              if (presstype.eq.3)write(Lun_out,*)'eta gem coordinate found'
              if (presstype.eq.4)write(Lun_out,*)'hybrid coordinate found'
              if (presstype.eq.5)write(Lun_out,*)'ecmwf coordinate found'
              if (presstype.eq.6)write(Lun_out,*)'staggered hyb coordinate found'
         endif
*
         allocate (xp1(ni1),yp1(nj1))
         read (unf,end=33,err=33) xp1,yp1

         do i=1,nia
            xpaq(i) = xp1(ifd_niad+i-1)
            xpau(i) = 0.5 * (xp1(ifd_niad+i-1) + xp1(ifd_niad+i))
         end do
         xpau(nia) = xpau(nia-1) + (xpau(nia-1) -xpau(nia-2))*0.5
         do j=1,nja
            ypaq(j) = yp1(ifd_njad+j-1)
            ypav(j) = 0.5 * (yp1(ifd_njad+j-1) + yp1(ifd_njad+j))
         end do
         ypav(nja) = ypav(nja-1) + (ypav(nja-1) -ypav(nja-2))*0.5
         deallocate (xp1,yp1)
*
         if (associated(ana_am_8)) deallocate(ana_am_8)
         if (associated(ana_bm_8)) deallocate(ana_bm_8)
         if (associated(ana_at_8)) deallocate(ana_at_8)
         if (associated(ana_bt_8)) deallocate(ana_bt_8)
*
         allocate(ana_am_8(nka_m), ana_bm_8(nka_m),
     $            ana_at_8(nka_t), ana_bt_8(nka_t) )
*
         read (unf,end=33,err=33) 
     $         ana_am_8,ana_bm_8,ana_at_8,ana_bt_8
         if (Lun_debug_L) then
             write(Lun_out,*)'sid3df:'
             write(Lun_out,*)'ana_am_8=',ana_am_8
             write(Lun_out,*)'ana_bm_8=',ana_bm_8
             write(Lun_out,*)'ana_at_8=',ana_at_8
             write(Lun_out,*)'ana_bt_8=',ana_bt_8
         endif
*
      else
         read (unf,end=33,err=33) 
     $         nomvar,ni1,nj1,nka_m,nka_t,presstype
         if (Lun_debug_L) then
              write(Lun_out,*)'sid3df done'
              write(Lun_out,*)'nomvar,ni1,nj1=',
     $         nomvar,ni1,nj1,presstype
              write(Lun_out,*)'nka_m,nka_t=',nka_m,nka_t
         endif
         read (unf,end=33,err=33)
         read (unf,end=33,err=33)
      endif
*
      sid3df = 0
*
*-----------------------------------------------------------------------
 33   return
      end
