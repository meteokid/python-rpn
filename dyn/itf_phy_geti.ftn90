!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r itf_phy_geti
!
#include "model_macros_f.h"
Integer Function itf_phy_geti (vd, opt) 

     Use phy_input_types
     Use phy_input_iface, Only : phy_simple_transforms
     Use itf_phy_iface  , Only : itf_phy_puti_casc
     Implicit None

     Type(variable), Pointer      :: vd
     Type(input_options)          :: opt
!
!Author
!     Lubos Spacek - October 2009
!
!Revision
! v4_10 - Spacek, L.     - First revision
!
!Object
!     This function provides I/O and horizontal interpolation
!     fonctionality for surface fields required by the physics.
!     The treatment is done by Ptopo_myproc=1 and then
!     distributed to other PEs.
!
!Arguments
!          - Output -
! vd       Structure containing desired descriptors
!
!          - Input -
! opt      allowed options: geol_hsea,geol_poin,z0cst
!
!Implicits
#include "gmm.hf"
#include "var_gmm.cdk"

#include "hgc.cdk"
#include "modconst.cdk"
#include "geomn.cdk"
#include "geomg.cdk"
#include "itf_phy_buses.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "path.cdk"
#include "ptopo.cdk"
#include "lun.cdk"
#include "p_geof.cdk"

      Integer, External :: fnom, fstouv, fstinf, fstprm, fstfrm, fclos, fstopc
      Integer, External :: fstluk, fstinl, wkoffit, ezgdef_fmem, ezdefset
      Integer, External :: ezsetopt, ip1_all, ezsint, newdate
      Logical, External :: samegrid

      Type(variable), Pointer                  :: temp
      Type(input_dimensions), Dimension(nip1)  :: idim

      Character , Parameter :: esc = Char( 27 )

      Integer :: i,j,k,ii,ij,ik,nf, nft, nr, iun=10, iok, ier,jer
      Integer :: target_file, tip
      Integer :: dte, det, ipas, p1, p2, p3, g1, g2, g3, g4, bit
      Integer :: dty, swa, lng, dlf, ubc, ex1, ex2, ex3
      Integer :: dum0,dum1,dum2,dum3,dum4,month,day,moa,jj
      Integer :: ni,nj,nk,nijk,sgid,dgid,kind,key,indx,indi,indj,offi,offj
      Integer, Parameter :: nmax=100, fmax=50, lenmax=150
      Integer, Dimension(nip1,4) :: keys,istat
      Logical :: found_L=.False.,interp_L, flag, ier_L
      Character(LEN=1), Dimension(nip1)      :: grd,grref
      Character(LEN=1) :: typ
      Character(LEN=4) :: var
      Character(LEN=12):: lab,cdum
      Character(LEN=lenmax), Dimension(fmax) :: file_found
      Character(LEN=lenmax+15):: command
      Real, Allocatable, Dimension(:,:) :: globalf,localf,field,field2
      Real, Allocatable, Dimension(:,:) :: gmg,gglsea,gmt,gdlat,gdlon,gfis,gal
      Real, Allocatable, Dimension(:,:) :: ghs,gsnodp,gvegindx,gz0,glhtg
      Real, Allocatable, Dimension(:)   :: ax,ay,xfi,yfi
!
      Real :: zp1,poa,poam,sum,sumt
      Real :: busent, busper
      Real(kind=8)  :: rad2deg_8
      Pointer (pabusper,busper(*))
      Pointer (pabusent,busent(*))
!
!     ---------------------------------------------------------------
!opt%isurface = 1 for fcrest, opt%isurface = 3 for isba
!
temp=>vd
!
ier = fstopc('MSGLVL','SYSTEM',0)
ier = fstopc('TOLRNC','SYSTEM',0)
If(Lun_debug_L)ier = fstopc('MSGLVL','INFORM',0)
If(Lun_debug_L)ier = fstopc('TOLRNC','INFORM',0)
!
Call prsdate (dum0,month,day,dum1,dum2,dum3,dum4,Mod_runstrt_S)
ier = Define_grids()
flag=.True. ; itf_phy_geti=-1
!
If(Ptopo_myproc==0)Allocate(globalf(G_ni,G_nj),Stat=ier)
                   Allocate(localf(l_ni,l_nj),Stat=ier)
!
If(Ptopo_myproc==0)&
  Write(Lun_out,"(/,'PHYSICS: acquiring data (S/R ITF_PHY_GETI)',/,46('='))")
If(Lun_debug_L)Call Print_stack()
!
Main1 : Do
! Initialization
   nft=Count_files()
!
   If (nft/=0) Then
      istat=0
      Do target_file=1,nft
         idim=input_dimensions(-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1)
!
         if ((target_file.gt.1).and.(Lun_out.gt.0)) write (Lun_out,1001) trim(vd%nomvar), &
                Trim(vd%file(target_file-1)(index(vd%file(target_file-1),'RUNMOD'):))
!
         if (Lun_out.gt.0) write (Lun_out,1000) trim(vd%nomvar), &
                Trim(vd%file(target_file)(index(vd%file(target_file),'RUNMOD'):)),vd%interp
!
         If (Locate_key(keys)<0) Cycle
!
         Do tip=1,vd%p_nu

            Call RPN_COMM_bcast (idim(tip),11,"MPI_INTEGER"  ,0,"grid",ier)
            Call RPN_COMM_bcastc(grd(tip), 1 ,"MPI_CHARACTER",0,"grid",ier)

            nijk=idim(tip)%ni*idim(tip)%nj*idim(tip)%nk
            Allocate (field(idim(tip)%ni,idim(tip)%nj))
            Allocate (ax(idim(tip)%ni),ay(idim(tip)%nj))
!
            If (grd(tip)=='Z') Then
               If(Ptopo_myproc==0)Then
                  interp_L=samegrid(iun,idim(tip)%ni,idim(tip)%nj, &
                         idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,&
                         Hgc_ig1ro,Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro,xfi,yfi)
               Endif
               Call RPN_COMM_bcast (interp_L,1,"MPI_LOGICAL"  ,0,"grid",ier)
               If(.Not.interp_L)Then
                  ier=Read_Axes()
                  Call RPN_COMM_bcastc(grref(tip), 1,"MPI_CHARACTER" ,0,"grid",ier)
                  Call RPN_COMM_bcast (ax   ,idim(tip)%ni,"MPI_REAL" ,0,"grid",ier)
                  Call RPN_COMM_bcast (ay   ,idim(tip)%nj,"MPI_REAL" ,0,"grid",ier)
                  sgid = ezgdef_fmem(idim(tip)%ni,idim(tip)%nj,grd(tip),grref(tip),&
                         idim(tip)%rig1,idim(tip)%rig2,idim(tip)%rig3,idim(tip)%rig4, ax, ay)
               Endif
            Else
               interp_L = .False.
               sgid = ezgdef_fmem(idim(tip)%ni,idim(tip)%nj, grd(tip),grref(tip),&
                      idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,idim(tip)%ig4, ax, ay)
            Endif
!
            istat(tip,target_file) = Read_field()
            If (Ptopo_myproc==0) Then
               If (interp_L) Then
                  globalf=field(1:G_ni,1:G_nj)
               else
                  ier = ezdefset ( dstf_gid, sgid )
                  ier = ezsetopt ('INTERP_DEGREE', vd%interp)
                  ier = ezsint (globalf, field)
               endif
               if ((opt%isurface/=1).or.(vd%phyvar/='Z0')) &
               ier=phy_simple_transforms(vd%phyvar,opt%z0cst,globalf)
            endif

            Call glbdist (globalf,G_ni,G_nj,localf,1,l_ni,1,l_nj,1,0,0)

            vd%values(:,:,tip)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)

            If (Lun_debug_L) call statf_dm2 (localf,vd%phyvar,tip,'PUTI', &
                                    1,l_ni,1,l_nj,1,1,1,1,1,G_ni,G_nj,1)

            Call Get_global_fields (vd%phyvar,opt%isurface==1)

            Deallocate(field,ax,ay)
         Enddo
         If (Ptopo_myproc==0) then
            ier = fstfrm(iun) ; ier=fclos(iun)
         endif
         If (Sum(istat(:,target_file))==vd%p_nu) Exit
      Enddo
!
      if (.not.Final_check(.false.)) Call itf_phy_puti_casc (vd,opt,istat(1,4))
      flag = flag.and.Final_check(.true.)
!
   Elseif (NFT==0) Then
!
      If (vd%phyvar=='DLAT') localf=Geomn_latrx
      If (vd%phyvar=='DLON') localf=Geomn_lonrx
      If (vd%phyvar=='MF') Then
         gmmstat = gmm_get(gmmk_topo_s,topo,meta2d)
         if (GMM_IS_ERROR(gmmstat)) then
            write(*,*)'itf_phy_geti: ERROR at gmm_get(topo)'
            ier = -1
         endif
         Call handle_error_l(ier==0,'itf_phy_geti','put_info 1')
         localf(1:l_ni,1:l_nj)=topo(1:l_ni,1:l_nj)/Dcst_grav_8
      Endif
      If (vd%phyvar=='DXDY') Then
         Do j=1,l_nj
         Do i=1,l_ni
            localf(i,j)= geomg_hxu_8(i-1)*geomg_hyv_8(j-1)*     &
                         Dcst_rayt_8*Dcst_rayt_8*geomg_cy_8(j)
         Enddo
         Enddo
      Endif
      If(vd%phyvar=='EPONMOD')Then
          localf=1.0
          If(.not.G_lam)Call itf_phy_vlsp(localf)
      Endif
!
      ier = phy_simple_transforms(vd%phyvar,opt%z0cst,localf)
      vd%values(:,:,1)= localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
!
      If(Lun_debug_L) call statf_dm2 (localf,vd%phyvar,tip,'PUTI', &
                              1,l_ni,1,l_nj,1,1,1,1,1,G_ni,G_nj,1)
!
      Call Get_global_fields (vd%phyvar,opt%isurface==1)
!
      If(vd%phyvar=='ALVIS')Call itf_phy_puti_casc (vd,opt,istat(1,4))
   Endif
!
   If ( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
!
End Do Main1
!
if (opt%isurface==1) then
   if (Ptopo_myproc==0)Then
      Call modmg (gmg,gglsea,gmt,gdlat,gdlon,gfis,gal,ghs,gsnodp,gvegindx,  &
                          gz0,glhtg,opt%geol_poin,opt%geol_hsea,G_ni,G_nj)
      ier=phy_simple_transforms('Z0',opt%z0cst,gz0)
   endif
   vd=>temp
   main2 : Do
      Call Dist_global_fields (vd%phyvar)
      If( .Not. Associated(vd%next_value)) Exit
      vd => vd%next_value
   End Do Main2
endif

Call handle_error_l (ier==0,'itf_phy_geti','put_info 2')
If (flag.And.Ptopo_myproc==0) Write(*,*)'All variables found!'
Call handle_error_l(flag,'itf_phy_geti','Missing variables, see the listing')

Call Cor_twater

If (Ptopo_myproc==0) Write(*,"(/a/72('='))")'PROCESSING ANCIENT GEOBUS'

vd=>temp
main3 : Do
!
   If (vd%inbus_L) Then     ! Do we put the variable in a bus?
      If (vd%bper_L) Then    ! Put into busper
         Do j=1,p_nj
            ij=vd%findx+(j-1)*p_bper_siz
            Do k=1,vd%p_nu
               ik=ij+(k-1)*p_ni
               Phy_busper3D(ik:ik+p_ni-1) = vd%values(:,j,k)
            Enddo
         Enddo
      Else                ! Put into the new busent
         Do j=1,p_nj
            ij=vd%findx+(j-1)*p_bent_siz
            Do k=1,vd%p_nu
               ik=ij+(k-1)*p_ni
               geofld(ik:ik+p_ni-1) = vd%values(:,j,k)
            Enddo
         Enddo
      Endif
   Endif            ! If not, next variable is treated
!
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
!
End Do main3
!
vd=>temp
!
Deallocate(localf,xfi,yfi)
If(Ptopo_myproc==0)Deallocate(globalf)
!
itf_phy_geti = 0
!
 1000 format (' TREATING: ',a,' FROM FILE: ',a,' WITH ',a)
 1001 format (' ===> WARNING: VARIABLE ',a,' NOT FOUND IN FILE: ',a)
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Contains
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
Integer Function Locate_key(keys)
Implicit None
Integer,Dimension(30,4) :: keys
logical :: flag
!
!     ---------------------------------------------------------------
!
Locate_key=-1 ; keys=-1 ; flag=.false.
!
If (Ptopo_myproc==0) Then

   ier = fnom   (iun,Trim(vd%file(target_file)),'RND+OLD+R/O',0)
   ier = fstouv (iun,'RND')

   Do tip=1,vd%p_nu
      If(vd%search(target_file)/='V')Then
         keys(tip,1) = Locate_ip1()
         Locate_key=Sign(1,keys(tip,1))
      Else
         If ( day .Gt. 15 ) Then
            jj = 32 - day
            If ( jj .Gt. 15 ) jj = 15
            moa = month + 1
            If ( month .Eq. 12 ) moa = 1
         Else
            jj  = day
            moa = month - 1
            If ( month .Eq. 1 ) moa = 12
         Endif
         poa = ( jj + 13 ) / 28.
         poam = 1. - poa

         vd%datev=-1
         Write(*,*)'    Interpolate ',vd%nomvar,' between months',moa,month

         vd%ip2=moa
         keys(tip,2) = Locate_ip1()
         If (keys(tip,2)<=0) Write(*,6000,advance='no')Trim(vd%nomvar),vd%ip2
         vd%ip2=month
         keys(tip,1) = Locate_ip1()
         If (keys(tip,1)<=0) Write(*,6000,advance='no')Trim(vd%nomvar),vd%ip2

         Locate_key=min(Sign(1,keys(tip,1)),Sign(1,keys(tip,2)))
      Endif
!
      If (Locate_key>=0) Then
         ier = fstprm (keys(tip,1),dte,det,ipas,&
                   idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,bit,dty, &
                   p1,p2, p3, typ, var, lab, grd(tip),&
                   idim(tip)%ig1, idim(tip)%ig2, idim(tip)%ig3, idim(tip)%ig4,&
                   swa, lng, dlf, ubc, ex1, ex2, ex3)
         If (grd(tip)=='Z') Then
            keys(tip,3) = fstinf (iun, ni,nj,nk,-1,' ',&
                          idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,' ','>>')
            keys(tip,4) = fstinf (iun, ni,nj,nk,-1,'',&
                          idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,'','^^')

            ier = fstprm (keys(tip,3),dte,det,ipas,ni,nj,nk,bit,dty,&
                      p1, p2, p3, typ, var, lab, grref(tip),&
                      idim(tip)%rig1, idim(tip)%rig2,&
                      idim(tip)%rig3, idim(tip)%rig4, swa,&
                      lng, dlf, ubc, ex1, ex2, ex3)
         Endif
      Else
         flag = .true.
      Endif
   Enddo
!
   if (flag) then
      ier=fstfrm(iun);ier=fclos(iun)
   endif
!
Endif
Call RPN_COMM_bcast (Locate_key,1,"MPI_INTEGER"  ,0,"grid",ier)
!
6000 Format(/,'!!! Error', 75('*'),/,'     Variable ',a,&
            ' not available at IP2: ',i5,/,'!!! Error',75('*'),/)
!
!     ---------------------------------------------------------------
!
End Function Locate_key
!
!
Integer Function Locate_ip1()
!
!     ---------------------------------------------------------------
!
If (vd%ip1(tip) .Eq. -1 .Or. vd%ip1(tip) .Eq. 0 ) Then
   Locate_ip1 = fstinf (iun, idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,vd%datev,vd%etk,&
                        vd%ip1(tip),vd%ip2,vd%ip3,vd%typvar,vd%nomvar )
Else
   Call convip ( vd%ip1(tip), zp1, kind, -1, cdum, .False. )
   Locate_ip1 = fstinf (iun, idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,vd%datev,vd%etk,&
                        ip1_all(zp1,kind),vd%ip2,vd%ip3,vd%typvar,vd%nomvar )
Endif
!
!     ---------------------------------------------------------------
!
End Function Locate_ip1
!
!
Integer Function Read_axes()
Read_axes=-1
!
!     ---------------------------------------------------------------
!
If (Ptopo_myproc==0) Then
   If ( keys(tip,3)>0) Then
      ier = fstluk( ax, keys(tip,3), idim(tip)%ni,1,      1)
      jer = fstluk( ay, keys(tip,4), 1,      idim(tip)%nj,1)
      Read_axes = ier*jer
   Endif
Endif
!
Call RPN_COMM_bcast (Read_axes,1,"MPI_INTEGER"  ,0,"grid",ier)
!
!     ---------------------------------------------------------------
!
End Function Read_axes
!
!
Integer Function Read_field()
!
!     ---------------------------------------------------------------
!
If (Ptopo_myproc==0) Then
   Read_field=-1
   ier = fstopc('MSGLVL','INFORM',0)
   ier = fstopc('TOLRNC','INFORM',0)
   ier = fstluk( field, keys(tip,1), idim(tip)%ni,idim(tip)%nj,idim(tip)%nk)
   If ( keys(tip,2)>0) Then
      Allocate(field2(idim(tip)%ni,idim(tip)%nj))
      ier = fstluk( field2, keys(tip,2), idim(tip)%ni,idim(tip)%nj,idim(tip)%nk)
      field = poa*field + poam*field2
      Deallocate(field2)
   Endif
   If(.Not.Lun_debug_L)ier = fstopc('MSGLVL','SYSTEM',0)
   If(.Not.Lun_debug_L)ier = fstopc('TOLRNC','SYSTEM',0)
   Read_field=1
Endif
!
Call RPN_COMM_bcast (Read_field,1,"MPI_INTEGER"  ,0,"grid",ier)
!
!     ---------------------------------------------------------------
!
End Function Read_field
!
!
Integer Function Define_grids()
!
Define_grids=0
!
!     ---------------------------------------------------------------
!
! Local grid
!
Allocate(xfi(p_ni),yfi(p_nj))
rad2deg_8 = 180.0d0/Acos(-1.d0)
offi = Ptopo_gindx(1,Ptopo_myproc+1)-1
offj = Ptopo_gindx(3,Ptopo_myproc+1)-1
Do i=1,p_ni
   indx = p_offi + offi + i
   xfi(i) = G_xg_8(indx)*rad2deg_8
End Do
Do i=1,p_nj
   indx = p_offj + offj + i
   yfi(i) = G_yg_8(indx)*rad2deg_8
End Do
dgid = ezgdef_fmem (p_ni , p_nj , 'Z', 'E', Hgc_ig1ro,&
                    Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
Deallocate(xfi,yfi)
!
! Global grid
!
Allocate(xfi(G_ni+1),yfi(G_nj))
rad2deg_8 = 180.0d0/Acos(-1.d0)
Do i=1,G_ni+1
   xfi(i) = G_xg_8(i)*rad2deg_8
End Do
Do i=1,G_nj
   yfi(i) = G_yg_8(i)*rad2deg_8
End Do
dstf_gid = ezgdef_fmem (G_ni, G_nj , 'Z', 'E', Hgc_ig1ro,&
                        Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
!
!     ---------------------------------------------------------------
!
End Function Define_grids
!
!
Integer Function Count_files()
!
!     ---------------------------------------------------------------
!
Count_files=0
nf=0;nft=1;nr=0;
If (Ptopo_myproc==0) Then
   file_found=''
! File names
   Do i=1,nfiles
      If (Len_trim(vd%file(i))/=0) Then
         nf=nf+1
         vd%file(nf)=Trim(Path_phy_S)//Trim(vd%file(i))
      Endif
   Enddo
   Do i=1,nreps
      If(Len_trim(vd%rep(i))/=0)nr=nr+1
   Enddo
   Do i = 1,nf
      Inquire (FILE=Trim(vd%file(i)),EXIST=found_L)
      If (.Not.found_L) then
         write (Lun_out,"(/' FILE: ',a,' NOT AVAILABLE')") Trim(vd%file(i))
         Cycle
      endif
      ier = wkoffit(Trim(vd%file(i)))
      If ((ier/=1).And.(ier/=2).And.(ier/=33).And.(ier/=34)) Then
         Write (Lun_out,"(/'Format unknown file: ',a/)") Trim(vd%file(i))
         Cycle
      Endif
      file_found(nft)=vd%file(i)
      nft=nft+1
   Enddo
   Count_files=nft-1
Endif
Call handle_error_l((Count_files.eq.nf),'itf_phy_geti','INPUT FILES')

Call RPN_COMM_bcast (Count_files,1,"MPI_INTEGER"  ,0,"grid",ier)
!
!     ---------------------------------------------------------------
!
End Function Count_files
!
!
Logical Function Final_check (action)
Logical :: action

Logical           :: flag
Integer           :: i,j,k,ier,dtpr,tmpr
!
!     ---------------------------------------------------------------
!
If(Ptopo_myproc==0)Then
 flag=.true.
 ier = newdate(vd%datev,dtpr,tmpr,-3)
 Do j=1,vd%p_nu
    If(Sum(istat(j,:))==0)Then
       If(action)Write(*,6000)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j),dtpr,tmpr
       flag=.False..and.flag
    Else
       flag=.True..and.flag
       If(action)Then
          If(interp_L)Then
             Write(*,6010)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j),dtpr,tmpr
          Else
             Write(*,6020)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j),dtpr,tmpr
           Endif
       Endif
    Endif
 Enddo
Final_check=flag
Endif
!
Call RPN_COMM_bcast (Final_check,1,"MPI_LOGICAL"  ,0,"grid",ier)
!
 6000 Format(/,'!!! Error', 75('*'),/,'     Variable ',a,' alias ',a,&
             ' not available at LEVEL: ',i5,' DATEV: ',i8.8,1x,i8.8/,&
               '!!! Error',75('*'),/)
 6010 Format('     Variable ',a,' alias ',a,&
             '  distributed at LEVEL ',i5,' DATEV: ',i8.8,1x,i8.8)
 6020 Format('     Variable ',a,' alias ',a,&
             ' interpolated at LEVEL ',i5,' DATEV: ',i8.8,1x,i8.8)
!
!     ---------------------------------------------------------------
!
End Function Final_check
!
!
Subroutine Print_stack
!
!     ---------------------------------------------------------------
!  
Do
   Write(Lun_out,6000)
   Write(Lun_out,6010)vd%nomvar,vd%phyvar,vd%interp,vd%search,vd%etk,&
                      vd%typvar,vd%findx
   Write(Lun_out,"('IP1',2(15i5,/,3x))")vd%ip1(1:vd%p_nu)
   Write(Lun_out,"('FILE ',2(a,/,5x))")(Trim(vd%file(i)),i=1,nfiles)
   Write(Lun_out,"('REPS ',2(a,/,5x))")(Trim(vd%rep(i)),i=1,nfiles)
   Write(Lun_out,"(72('='))")
   If ( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
End Do
!
vd=>temp
!
6000 Format('ENTRY NAME ','PHY NAME ',9x,'INTERP ',10x,'SEARCH ', &
            'LABEL',3x,'TYPE',1x,'POSITION')
6010 Format(a4,7x,a16,2x,a16,2x,3a,3x,a8,2x,a2,i8)
!
!     ---------------------------------------------------------------
! 
End Subroutine Print_stack
!
!
Subroutine Cor_twater
Real :: grav,cpd,cor
!
!     ---------------------------------------------------------------
! 
grav = Dcst_grav_8
cpd  = Dcst_cpd_8
cor  = grav/cpd
vd=>temp
Do
   If (vd%phyvar=='MF') Then
      Allocate(gfis(l_ni,l_nj))
      gfis=vd%values(:,:,1)
   Endif
   If (vd%phyvar=='MT') Then
      Allocate(gmt(l_ni,l_nj))
      gmt=vd%values(:,:,1)
   Endif
   If ( .Not. Associated(vd%next_value)) Exit
!
   vd => vd%next_value
!
End Do
!
vd=>temp
!
If (Allocated(gfis).And.Allocated(gmt)) Then
   Do
      If (vd%phyvar=='TWATER') Then
         Where(gfis>gmt)vd%values(:,:,1)=vd%values(:,:,1)-(gfis-gmt)*cor
      Endif
      If ( .Not. Associated(vd%next_value)) Exit
      vd => vd%next_value
   End Do
!
   vd=>temp
!
   Deallocate(gfis,gmt)
Endif
!
!     ---------------------------------------------------------------
! 
End Subroutine Cor_twater
!
Subroutine Get_global_fields (name,doit)
     Character(len=*) ::  name
     logical          ::  doit
!
if (.not.doit) return

If(Ptopo_myproc==0)Then
     If(name=='MG')Then
       Allocate(gmg(G_ni,G_nj))
       gmg=globalf
     Endif
!
     If(name=='GLSEA')Then
       Allocate(gglsea(G_ni,G_nj))
       gglsea=globalf
     Endif
!
     If(name=='MT')Then
       Allocate(gmt(G_ni,G_nj))
       gmt=globalf
     Endif
!
     If(name=='ALNOSNO')Then
       Allocate(gal(G_ni,G_nj))
       gal=globalf
     Endif
!
     If(name=='HS')Then
       Allocate(ghs(G_ni,G_nj))
       ghs=globalf
     Endif
!
     If(name=='SNODP'.And.tip==1)Then
       Allocate(gsnodp(G_ni,G_nj))
       gsnodp=globalf
     Endif
!
     If(name=='VEGINDX')Then
       Allocate(gvegindx(G_ni,G_nj))
       gvegindx=globalf
     Endif
!
     If(name=='Z0')Then
       Allocate(gz0(G_ni,G_nj))
       gz0=globalf
     Endif
!
     If(name=='LHTG')Then
       Allocate(glhtg(G_ni,G_nj))
       glhtg=globalf
     Endif
Endif
!
     If(name=='MF')Then
       If(Ptopo_myproc==0)Allocate(gfis(G_ni,G_nj))
       Call glbcolc (gfis,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1)
     Endif
!
     If(name=='DLAT')Then
       If(Ptopo_myproc==0)Allocate(gdlat(G_ni,G_nj))
       Call glbcolc (gdlat,G_ni,G_nj, &
                            Geomn_latrx,1,l_ni,1,l_nj,1)
         If(Ptopo_myproc==0)Then
            ier=phy_simple_transforms(vd%phyvar,opt%z0cst,gdlat)
         Endif
     Endif
!
     If(name=='DLON')Then
       If(Ptopo_myproc==0)Allocate(gdlon(G_ni,G_nj))
       Call glbcolc (gdlon,G_ni,G_nj, &
                            Geomn_lonrx,1,l_ni,1,l_nj,1)
         If(Ptopo_myproc==0)Then
            ier=phy_simple_transforms(vd%phyvar,opt%z0cst,gdlon)
         Endif
     Endif
!
End Subroutine Get_global_fields
!
!     ---------------------------------------------------------------
!
Subroutine Dist_global_fields(name)
     Character(len=*) ::  name
!
 If(name=='MG')Then
     Call glbdist (gmg,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1,0,0)       
     vd%values(:,:,1)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
     If(Ptopo_myproc==0)Deallocate(gmg)
 Endif
!
 If(name=='GLSEA')Then
     Call glbdist (gglsea,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1,0,0)       
     vd%values(:,:,1)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
     If(Ptopo_myproc==0)Deallocate(gglsea)
 Endif
!
 If(name=='MT')Then
     If(Ptopo_myproc==0)Deallocate(gmt)
 Endif
!
 If(name=='ALNOSNO')Then
     Call glbdist (gal,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1,0,0)       
     vd%values(:,:,1)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
     If(Ptopo_myproc==0)Deallocate(gal)
 Endif
!
 If(name=='HS')Then
     Call glbdist (ghs,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1,0,0)       
     vd%values(:,:,1)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
     If(Ptopo_myproc==0)Deallocate(ghs)
 Endif
!
 If(name=='SNODP')Then
     Call glbdist (gsnodp,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1,0,0)       
     vd%values(:,:,1)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
     If(Ptopo_myproc==0)Deallocate(gsnodp)
 Endif
!
 If(name=='VEGINDX')Then
     Call glbdist (gvegindx,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1,0,0)       
     vd%values(:,:,1)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
     If(Ptopo_myproc==0)Deallocate(gvegindx)
 Endif
!
 If(name=='Z0')Then
     Call glbdist (gz0,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1,0,0)       
     vd%values(:,:,1)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
     If(Ptopo_myproc==0)Deallocate(gz0)
 Endif
!
 If(name=='LHTG')Then
     Call glbdist (glhtg,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1,0,0)       
     vd%values(:,:,1)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
     If(Ptopo_myproc==0)Deallocate(glhtg)
 Endif
!
 If(name=='MF')Then
     If(Ptopo_myproc==0)Deallocate(gfis)
 Endif
!
 If(name=='DLAT')Then
     If(Ptopo_myproc==0)Deallocate(gdlat)
 Endif
!
 If(name=='DLON')Then
     If(Ptopo_myproc==0)Deallocate(gdlon)
 Endif
!
End Subroutine Dist_global_fields
!
!     ---------------------------------------------------------------
! 
End Function itf_phy_geti


