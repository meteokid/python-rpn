!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r adw_main - adw_main_1_wnd: Process winds in preparation for advection
!                 adw_main_2_pos: Calculate upstream positions at th and t1
!                 adw_main_3_int: Interpolation of rhs
!
#include "model_macros_f.h"
#include "msg.h"
!
      subroutine adw_main (F_it,F_isStatStep_L)
!
      implicit none
!
      integer F_it
      logical F_isStatStep_L
!
!author
!     alain patoine
!
!revision
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_01 - Lee V.            - Initialize Lam truncated trajectory counters
! v3_20 - Tanguay M.        - Option of storing instead of redoing TRAJ 
! v4_04 - Tanguay M.        - Staggered version TL/AD 
! V4_10 - Plante A.         - Thermo upstream positions
!
!object
!     see id section
!
!arguments
!______________________________________________________________________
!        |                                                       |     |
! NAME   | DESCRIPTION                                           | I/O |
!--------|-------------------------------------------------------|-----|
! F_it   | total number of iterations for trajectories           |  i  |
!________|_______________________________________________________|_____|
!
!notes
!______________________________________________________________________
!                             WORK FIELDS                              |
!----------------------------------------------------------------------|
! There are 3 different species of work fields used throughout the     |
! advection process.                                                   |
!----------------------------------------------------------------------|
! wrk1?: Local grid, no halos, allocated in adw_main (12 units)        |
!        Used in adw_main_2_pos and adw_main_3_int to cary upstream    |
!        positions coordinates, interpolation parameters and           |
!        interpolated values.                                          |
!----------------------------------------------------------------------|
! wrk2?: Used to store positions and interpolation parameters relative |
!        to the work to be done for north and south neighbors.         |
!        Allocated to fit the number of points to treat.               |
!        Used both in adw_main_2_pos and adw_main_3_int (12 units).    |
!----------------------------------------------------------------------|
! wrk3?: Advection grid, with halos, allocated in adw_main (3 units).  |
!        Used for different purpose:                                   |
!                                                                      |
!                            adw_main_1_wnd ---> ( winds in work3 )    |
!                                                                      |
!    ( winds in work3 ) ---> adw_main_2_pos ---> ( t1 pos. in wrk3 )   |
!                                                                      |
!    ( t1 pos. in wrk3) ---> adw_main_3_int                            |
!                                                                      |
! Note that when we cary t1 positions in wrk3, it is larger than the   |
! data.                                                                |
!______________________________________________________________________|
!
!implicits
#include "gmm.hf"
!#include "var_gmm.cdk"
#include "glb_ld.cdk"
!      integer G_nk
!      integer l_ni,l_nj
#include "adw.cdk"
!      integer adw_nit,adw_njt
!      integer            Adw_trunc(4)
       include "v4dg.inc"
!      integer V4dg_conf
!      logical V4dg_oktr_L
#include "vth.cdk"
#include "vt1.cdk"
!
!modules
!***********************************************************************
      type(gmm_metadata) :: dummy_gmm_meta
      integer :: i,istat
      real, dimension(Adw_nit*Adw_njt,  G_nk  ) :: pxm,pym,pzm,um,vm,wm
      real, dimension(Adw_nit*Adw_njt,  G_nk+1) :: pxt,pyt,pzt,ut,vt,wt
      real, dimension(Adw_nit*Adw_njt,2*G_nk+1) :: su,sv,sw
      real, dimension(l_ni*l_nj*(l_nk+1)) :: l_xct1,l_yct1,l_zct1
      real dummy

      logical v4dstore_L
!
!***********************************************************************
      call msg(MSG_DEBUG,'ADVECT THE RIGHT-HAND-SIDES: (S/R ADW_MAIN)')
!***********************************************************************
      v4dstore_L = V4dg_conf.ne.0 .and. V4dg_oktr_L 
!
      do i=1, 4
         Adw_trunc(i) = 0
      enddo
!
      call adw_main_1_wnd2(su,sv,sw,um,vm,wm,ut,vt,wt,l_ni,l_nj,G_nk)
!
      istat = gmm_get(gmmk_xth_s,xth,dummy_gmm_meta)
      istat = min(istat,gmm_get(gmmk_yth_s,yth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zth_s,zth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xcth_s,xcth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_ycth_s,ycth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zcth_s,zcth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xct1_s,xct1,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_yct1_s,yct1,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zct1_s,zct1,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xth_thermo_s,xth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_yth_thermo_s,yth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zth_thermo_s,zth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xcth_thermo_s,xcth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_ycth_thermo_s,ycth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zcth_thermo_s,zcth_thermo,dummy_gmm_meta))
      call handle_error(istat,'adw_main','gmm_get')
!
      call adw_main_2_pos ( &
           F_it,'m',l_nk, &
           pxm ,pym ,pzm , &
           su  ,sv  ,sw  , &
           xth ,yth ,zth , &
           xcth,ycth,zcth, &
           xct1,yct1,zct1, &
           dummy,dummy)
!
      call adw_main_2_pos ( &
           F_it       ,'t'        ,l_nk+1, &
           pxt        ,pyt        ,pzt, &
           su         ,sv         ,sw, &
           xth_thermo ,yth_thermo ,zth_thermo, &
           xcth_thermo,ycth_thermo,zcth_thermo, &
           l_xct1     ,l_yct1     ,l_zct1, &
           pxm        ,pym)
!
!     Store TRAJ upstream positions 
!     -----------------------------
      if ( v4dstore_L ) call v4d_rwtraj (5,pxm,pym,pzm,pxt,pyt,pzt) 
!
      call adw_main_3_intlag(pxm,pym,pzm,pxt,pyt,pzt,F_isStatStep_L)
!
!     Store TRAJ RHS interpolated
!     ---------------------------
      if ( v4dstore_L ) call v4d_rwtraj (6)
!
!**********************************************************************
!
      return
      end

