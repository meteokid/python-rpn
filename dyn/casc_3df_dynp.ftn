! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r casc_3df_dynp - Reads self-nested 3DF pilot files where
*                      3DF01 files were written after advection and
*                      3DF02 files were written after physics by
*                      the previous driving model.
*
#include "model_macros_f.h"
*
      subroutine casc_3df_dynp (dimgx,dimgy,unf,listgeonm)
      implicit none
*
      character* (*)  listgeonm(2,*)
      integer dimgx,dimgy,unf
*
*author
*     M. Desgagne  April 2006 (MC2 casc_3df_dynp)
*
*revision
* v3_30 - Lee V.         - initial version for GEMDM
* v3_30 - McTaggart-Cowan R. - implement variable orography
*
#include "glb_ld.cdk"
#include "bcsdim.cdk"
#include "bcsgrds.cdk"
#include "bcsmem.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "ifd.cdk"
#include "ind.cdk"
#include "pres.cdk"
#include "lam.cdk"
#include "ptopo.cdk"
#include "schm.cdk"
#include "tr3d.cdk"
#include "vt1.cdk"
#include "lun.cdk"
#include "itf_phy_buses.cdk"
#include "lctl.cdk"
#include "hblen.cdk"
#include "itf_phy_busind.cdk"
#include "itf_phy_config.cdk"
#include "vtopo.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
*
      integer  vmmlod,vmmget,vmmuld,longueur,sid3df
      external vmmlod,vmmget,vmmuld,longueur,sid3df
*
      character*2  md
      character*4  nomvar
      character*8  dynophy,vn
      character*8, dimension (:), pointer :: trname_a, geop_name
      character*4, dimension (:), pointer :: phynm
      character*15 datev
      character*256 fn
      logical done,dyn_done,phy_done,same_topo_L,temp_same_L,flag
      logical dyn_init,phy_init
      integer*8 pnt_trp(Tr3d_ntr)
      integer i,j,k,jj,jjj,kk,nia,nja,nk0,nka,ntra,ntra1,
     $        ni1,nj1,nk1,n,err,
     $        errop,ofi,ofj,l_in,l_jn,mode,nvar, vmmnvar,ungeo,
     $        cnt,nkphy,errdyn,errphy,cumerr,pid,gid,nfphy,
     $        wowp,nij,ijk

      integer i0,in,j0,jn,keyp_,keyp(Tr3d_ntr),ni2,nj2,nvargeo
      integer idd,jdo,mult,shp,bigk,offbb,offbo,offg,ng,nga
      real topo_temp(l_ni,l_nj)

      integer, dimension (:  ), pointer :: idx,idu,idy,nks
      real xi,xf,yi,yf,htopa,maxtopo(2),maxtopo_g(2),
     $     psmin, psmax, psmin_glob, psmax_glob, pr1,pr2
      real  , dimension (:  ), pointer :: phybr
      real*8, dimension (:  ), pointer :: 
     $              xpaq,ypaq,xpau,ypav,xpuu,ypvv,
     $              cxa,cxb,cxc,cxd,cua,cub,cuc,cud,cya,cyb,cyc,cyd
*
      real, dimension (:,:), pointer :: uun,vvn,zdn,ttn,
     $                                  ssqn,meqn,qqn,wwn,
     $                                  meqr,
     $                                  topo_temp1,
     $                                  ssq0,ssu0,ssv0,
     $                                  phybn,ss1
*
      real, dimension (:,:,:), pointer :: trn
*
      real, dimension (:,:,:), pointer :: uu1,vv1,zd1,ttt1,
     $                                  qq1,ww1
      real, dimension (:,:,:,:), pointer :: tr1

*
      real trp
      real ssq_temp(LDIST_SHAPE)
      pointer (patrp, trp(LDIST_SHAPE,*))
      real*8 xpxext(0:dimgx+1), ypxext(0:dimgy+1),lnpis_8
      data nfphy,nkphy /0,0/
*
*-----------------------------------------------------------------------
*
      nvargeo = 9
      if (P_pbl_schsl_S.eq.'ISBA') nvargeo = 14
      allocate (geop_name(nvargeo))
*
      geop_name (1) = 'TWATEREN'
      geop_name (2) = 'ICEDPEN'
      geop_name (3) = 'TGLACEN'
      geop_name (4) = 'TMICEN'
      geop_name (5) = 'SNODPEN'
      geop_name (6) = 'TSOILEN'
      geop_name (7) = 'GLSEAEN'
      geop_name (8) = 'HS'
      geop_name (9) = 'ALEN'
      if (P_pbl_schsl_S.eq.'ISBA') then
         geop_name (8)  = 'WSOILEN'
         geop_name (10) = 'ISOILEN'
         geop_name (11) = 'WVEGEN'
         geop_name (12) = 'WSNOWEN'
         if (P_pbl_snoalb_L) then
         geop_name (13) = 'SNOALEN'
         else 
         geop_name (13) = 'SNOAGEN'
         endif
         geop_name (14) = 'SNOROEN'
      endif
*
      if (Lun_debug_L) write (Lun_out,1000)
*
      keyp_ = VMM_KEY (trt1)
      do k=1,Tr3d_ntr
         keyp(k) = keyp_ + k
      end do
      err = vmmlod(keyp,Tr3d_ntr)
      do k=1,Tr3d_ntr
         err = vmmget(keyp(k),patrp,trp)
         pnt_trp(k) = patrp
      end do
*
      bcs_nia = ifd_niaf - ifd_niad + 1
      bcs_nja = ifd_njaf - ifd_njad + 1
      nia     = bcs_nia
      nja     = bcs_nja
      nga     = nia*nja
      ntra    = 0
      ng      = l_ni * l_nj
      ofi     = l_i0 - 1
      ofj     = l_j0 - 1
      err     = 0
*
* Positional parameters on extended global mass point grid
*
      do i=1,dimgx
         xpxext(i) = G_xg_8(i)
      end do
      xpxext(0) = xpxext(1) - (xpxext(2)-xpxext(1))
      xpxext(dimgx+1) = xpxext(dimgx) + (xpxext(dimgx)-xpxext(dimgx-1))
*
      do i=1,dimgy
         ypxext(i) = G_yg_8(i)
      end do
      ypxext(0) = ypxext(1) - (ypxext(2)-ypxext(1))
      ypxext(dimgy+1) = ypxext(dimgy) + (ypxext(dimgy)-ypxext(dimgy-1))
*
* Positional parameters of model target u and v grids (xpuu and ypvv).
*
      allocate (xpuu(l_ni),ypvv(l_nj))
      do i=1,l_ni
         xpuu(i) = 0.5d0 * (xpxext(ofi+i+1)+xpxext(ofi+i))
      end do
      do j=1,l_nj
         ypvv(j) = 0.5d0 * (ypxext(ofj+j+1)+ypxext(ofj+j))
      end do
*
      datev   = Lam_runstrt_S
*
* Read all needed files and construct the source domain for
* the horizontal interpolation
*
*     wowp = 2 ===> input data has seen the physics
*     wowp = 1 ===> input data just after dynamics (no physics)
*     We prefer to initialize uup, vvp etc... with wowp=2 status.
*
      allocate (xpaq(nia), ypaq(nja), xpau(nia), ypav(nja))
*
      wowp = 3
 48   wowp = wowp - 1
      if (wowp.lt.1) then
         write (6,204)
         err = -1
         goto 999
      endif
*
      write (md,'(i2.2)') wowp
      done     = .false.
      dyn_init = .false.
      phy_init = .false.
      Lam_busper_init_L=.false.
*
      do n=1,ifd_nf
*
         ofi = ifd_minx(n)-1
         ofj = ifd_miny(n)-1
         if (ifd_needit(n)) then
*
            errdyn   = -1
            errphy   = -1
            dyn_done = .false.
            phy_done = .false.
*
            fn ='../casc/3df'//md//'_'//datev//'_'//ifd_fnext(n)
            open (unf,file=fn(1:longueur(fn)),access='SEQUENTIAL',
     $                form='UNFORMATTED',status='OLD',iostat=errop)
*
            if (errop.ne.0) goto 33
*
* Use first file to establish 3D grid dimensions and geo-references
* of all input staggered grids (xpaq, ypaq, xpau and ypva).
*
 55         if (dyn_done.and.phy_done) goto 33
            err = sid3df (xpaq,ypaq,xpau,ypav,unf,done,nia,nja,
     $                                    nka,nvar,ntra1)
            if (err.lt.0) then
                if (dyn_done) then
*               Assumes no physics data are available
                    err=0
                    phy_done = .true.
                    errphy   = 0
                endif
*               Continue to next file
                goto 33
            endif
*
            read (unf,end=1010,err=1010) dynophy,mode
*
            if (dynophy.eq.'PHYSICSS') then
*
               nfphy=nvar+ntra1
               if (.not.phy_init) then
                  if (associated(phybn)) deallocate(phybn)
                  if (associated(phynm)) deallocate(phynm)
                  if (associated(nks  )) deallocate(nks  )
                  allocate (phynm(nfphy),nks(nfphy))
               endif
               read(unf,end=1010,err=1010)(phynm(i),nks(i),i=1,nfphy)
               nkphy=0
               do i=1,nfphy
                  nkphy=nkphy+nks(i)
               enddo
               if (.not.phy_init) allocate(phybn(nga,nkphy))
               phy_init = .true.
               cumerr = 0
               nkphy=1
               do i=1,nfphy
                 k = nks(i)
                 call filmup (phybn(1,nkphy),ifd_niad,ifd_niaf,ifd_njad,
     $                                    ifd_njaf,k,unf,ofi,ofj,cumerr)
                 nkphy = nkphy + k
               enddo
               errphy=cumerr
               phy_done = .true.
               nkphy = nkphy - 1
               if (.not. dyn_done) goto 55
*
            else if (dynophy.eq.'DYNAMICS') then
*
               if (Lun_debug_L) write (Lun_out,1001) 'DYNAMICS'
               ntra=ntra1
               if (.not.dyn_init) then
                  if (associated( uun)) deallocate( uun)
                  if (associated( vvn)) deallocate( vvn)
                  if (associated( zdn)) deallocate( zdn)
                  if (associated( ttn)) deallocate( ttn)
                  if (associated( qqn)) deallocate( qqn)
                  if (associated( wwn)) deallocate( wwn)
                  if (associated(ssqn)) deallocate(ssqn)
                  if (associated(meqn)) deallocate(meqn)
                  if (associated( trn)) deallocate( trn)
                  if (associated( topo_temp1)) deallocate( topo_temp1)
                  if (associated(trname_a)) deallocate(trname_a)
                  allocate (  uun(nga,nka+1), vvn (nga,nka+1),
     $                        zdn(nga,nka+1), ttn (nga,nka+2),
     $                       ssqn(nga,1  )  , meqn(nga,1  ),
     $                       topo_temp1(l_ni+1-(east*1),l_nj+1-(north*1)),
     $                        qqn(nga,nka+2), wwn(nga,nka+1),
     $                       trn (nga,nka+2,ntra), trname_a(ntra) )
                  dyn_init = .true.
               endif
*
               cumerr=0
* read tt1,st1, ME
               call filmup ( ttn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                        nka+2,unf,ofi,ofj,cumerr )
               call filmup (ssqn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                          1,unf,ofi,ofj,cumerr )
               call filmup (meqn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                          1,unf,ofi,ofj,cumerr )
               if (nvar.eq.7.or.nvar.eq.8) then 
* read wt1,zdt1
               call filmup ( wwn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                        nka+1,unf,ofi,ofj,cumerr )
               call filmup ( zdn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                        nka+1,unf,ofi,ofj,cumerr )
               endif
*
               if (nvar.eq.8) then
* read qt1
               call filmup ( qqn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                        nka+2,unf,ofi,ofj,cumerr )
               endif

               if (ntra.gt.0) then
* read tracers
                 call filuptr ( trn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                           nka+2,unf,ofi,ofj,Tr3d_name_S,Tr3d_ntr,
     $                                            trname_a,ntra,cumerr )
               endif
* read winds
               call filmup ( uun,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                        nka+1,unf,ofi,ofj,cumerr )
               call filmup ( vvn,ifd_niad,ifd_niaf,ifd_njad,ifd_njaf,
     $                                        nka+1,unf,ofi,ofj,cumerr )
*
               errdyn   = cumerr
               dyn_done = .true.
               if ((.not.phy_done).and.(Schm_phyms_L)) goto 55
*
            else
               write (6,205) dynophy
               goto 1010
            endif
*
 33         close (unf)
*
            if ((errdyn.lt.0).and.(wowp.gt.1)) goto 48
*
            if (.not.Schm_phyms_L) errphy = 0
            err  = err + errdyn + errphy
            done = .true.
            if (err.lt.0) then
               write (6,203) fn(1:longueur(fn)),Ptopo_myproc
               goto 999
            endif
         endif
      end do
*
 999  call gem_stop('casc_3df_dynp',err)
*
      allocate ( meqr(l_ni,l_nj))
      allocate (idx(l_ni), idu(max(l_ni,l_nj)),idy(l_nj),
     $          cxa(l_ni), cxb(l_ni), cxc(l_ni) ,cxd(l_ni),
     $          cya(l_nj), cyb(l_nj), cyc(l_nj), cyd(l_nj),
     $          cua(max(l_ni,l_nj)) , cub(max(l_ni,l_nj)) ,
     $          cuc(max(l_ni,l_nj)) , cud(max(l_ni,l_nj)))

      call grid_to_grid_coef (xpxext(l_i0),l_ni,
     $                        xpaq,nia,idx,cxa,cxb,cxc,cxd,Lam_hint_S)
      call grid_to_grid_coef (ypxext(l_j0),l_nj,
     $                        ypaq,nja,idy,cya,cyb,cyc,cyd,Lam_hint_S)
*
*
* Reload geofld bus with subset from PHYSICSS=> (xp1,yp1) (geophy grid)
* For exact fields, refer to out_phy_3df
*
      if (nkphy.gt.0 .and. phy_init .and. Schm_phyms_L) then
         if (Lun_debug_L) write (Lun_out,1004)
         if (associated(phybr)) deallocate (phybr)
         allocate(phybr(ng*nkphy))
         call hinterpo (phybr,l_ni,l_nj,phybn,nia,nja,nkphy,
     $         idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
         ofj=0
         do pid=1,nfphy
         do gid=1,p_bgeo_top
            nomvar = geonm(gid,2)
            vn     = geonm(gid,1)
            flag   = .false.
            do k=1,nvargeo
               if (vn.eq.geop_name(k)) flag=.true.
            end do
            if ((phynm(pid).eq.nomvar).and.flag) then
               ofi = geopar(gid,1) -1
               if ((nomvar.eq.'LG').or.(nomvar.eq.'AL')
     $                             .or.(nomvar.eq.'HS')) then
                  do i=1,ng*geopar(gid,3)
                     geofld(ofi+i) = min(max(0.,phybr(ofj+i)),1.)
                  end do
               else
                  do i=1,ng*geopar(gid,3)
                     geofld(ofi+i) = phybr(ofj+i)
                  end do
               endif
               listgeonm(2,gid) = 'OK'
            endif
         enddo
            ofj=ofj+nks(pid)*ng
         enddo
      endif
*
* Copy target topography field from geofld (see geodata.ftn) unless
* "growing" topography is used, in which case the current model
* topography is retained. 
*
      call hinterpo ( meqr,l_ni,l_nj, meqn,nia,nja,    1,idx,idy,
     $                 cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      if (Vtopo_L) then
         if (Lctl_step > Vtopo_start) then
            topo_temp = Ind_topo(1:l_ni,1:l_nj)
         else
            topo_temp = meqr
         endif
         Ind_dtopo(1:l_ni,1:l_nj) = topo_temp - meqr
      else
         do gid=1,P_bgeo_top
           if (geonm(gid,1).eq.'MF') then
             offg = geopar(gid,1)
             cnt = 0
             do j=1,l_nj
             do i=1,l_ni
                cnt=cnt+1
                topo_temp(i,j)=dble(geofld(offg +cnt-1))*Dcst_grav_8
             enddo
             enddo
           endif
         enddo
         do j=1,pil_s
         do i=1,l_ni
            topo_temp(i,j) = meqr(i,j)
         end do
         end do
         do j=l_nj-pil_n+1,l_nj
         do i=1,l_ni
            topo_temp(i,j) = meqr(i,j)
         end do
         end do
         do i=1,pil_w
         do j=pil_s+1,l_nj-pil_n
            topo_temp(i,j) = meqr(i,j)
         end do
         end do
         do i=l_ni-pil_e+1,l_ni
         do j=pil_s+1,l_nj-pil_n
            topo_temp(i,j) = meqr(i,j)
         end do
         end do
         call nesajr (topo_temp, meqr, 1,l_ni,1,l_nj,
     $                         1,0,0,Hblen_x,Hblen_y)
      endif
*
      Ind_topo(1:l_ni,1:l_nj) = topo_temp
* topo is inflated!
      call rpn_comm_xch_halo ( Ind_topo, LDIST_DIM,l_ni,l_nj,1,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
*
      do j=1,l_nj+1-(north*1)
      do i=1,l_ni+1-(east*1)
         topo_temp1(i,j) = Ind_topo(i,j)
      enddo
      enddo
*
      allocate(uu1(l_ni,l_nj,G_nk+1),
     $         vv1(l_ni,l_nj,G_nk+1),
     $         ttt1(l_ni,l_nj,G_nk+2),
     $         zd1(l_ni,l_nj,G_nk+1),
     $         ss1(l_ni,l_nj),
     $         qq1(l_ni,l_nj,0:G_nk+1),
     $         ww1(l_ni,l_nj,G_nk+1),
     $         tr1(l_ni,l_nj,G_nk+2,ntra) )

      call casc_hvi (trname_a,
     $  xpxext(l_i0),ypxext(l_j0),xpuu,ypvv,xpaq,ypaq,xpau,ypav,
     $  uu1,vv1, ttt1,zd1,
     $  ss1,qq1, ww1,tr1,
     $  0, topo_temp1,
     $  uun,vvn,ttn,zdn,meqn,ssqn,qqn,wwn,trn,
     $  1,l_ni,1,l_nj,l_ni+1-(east*1),l_nj+1-(north*1), G_nk,
     $  nia,nja,nka,nvar,ntra)

        Ind_u(1:l_ni+1-(east*1),1:l_nj,1:G_nk+1) = uu1
        Ind_v(1:l_ni,1:l_nj+1-(north*1),1:G_nk+1) = vv1
        Ind_t(1:l_ni,1:l_nj,1:G_nk+2) = ttt1
        Ind_zd(1:l_ni,1:l_nj,1:G_nk+1)=zd1
        Ind_s(1:l_ni,1:l_nj) = ss1
        Ind_w(1:l_ni,1:l_nj,1:G_nk+1)   = ww1
      if (.not. Schm_hydro_L) then
        Ind_q(1:l_ni,1:l_nj,0:G_nk+1) = qq1
      endif
*
      do n=1,Tr3d_ntr
         patrp = pnt_trp(n)
         jj=-1
* If data found for this tracer
         do k=1,ntra
            if (Tr3d_name_S(n).eq.trname_a(k)(1:4)) jj=k
         end do
         if ( jj.gt.0 ) then
            trp(1:l_ni,1:l_nj,1:G_nk+2) = tr1(1:l_ni,1:l_nj,1:G_nk+2,jj)
         endif
      end do
*
*
      deallocate ( uu1,vv1,ttt1,zd1,qq1,ww1,meqr,trname_a)
*
      do j=1,l_nj
      do i=1,l_ni
         lnpis_8 = ss1(i,j) + log(Cstv_pisrf_8)
         ss1(i,j) = exp(Ver_a_8%t(G_nk+1) + Ver_b_8%t(G_nk+1)*lnpis_8)
      enddo
      enddo

*
      psmin = ss1(1,1)
      psmax = ss1(1,1)
      do j=1,l_nj
      do i=1,l_ni
         psmin = min( psmin, ss1(i,j) )
         psmax = max( psmax, ss1(i,j) )
      enddo
      enddo
*
      deallocate (geop_name,ss1)
*
      call rpn_comm_allreduce(psmin,psmin_glob,1,"MPI_REAL","MPI_MIN",
     $                                                     "grid",err)
      call rpn_comm_allreduce(psmax,psmax_glob,1,"MPI_REAL","MPI_MAX",
     $                                                     "grid",err)
      psmin=psmin_glob
      psmax=psmax_glob
*     
      if ( Ptopo_myproc.eq.0 ) then
           write(6,*)'PSMIN = ',PSMIN,' PSMAX = ',PSMAX,
     $                     ' PSMINMAX = ',0.5*(PSMIN+PSMAX),' (PASCAL)'
      endif
*
      Pres_surf = dble(0.5*(psmin+psmax))
      Pres_top  = dble(Pres_ptop*100.)
*
      call v4d_indata3 ()
      call set_dync
*
      call casc_predat()

c      if ( .not. Schm_hydro_L ) Ind_qsec = 0.
*
*
 100  format (' ',65('*'))
 101  format (' (CASC_3DF_DYNP) JUST READ INIT DATA FOR DATE: ',a15,1x,i3)
 203  format (/' PROBLEM WITH FILE: ',a,', PROC#:',i4,' --ABORT--'/)
 204  format (/' NO DATA IN CASC_3DF_DYNP --ABORT--'/)
 205  format (/' Unrecognizable tag found: ',a,'?'/)
 1000 format(
     +3X,'READING DATA IN (S/R CASC_3DF_DYNP)')
 1001 format(
     +3X,'READING ',a,' DATA IN (S/R CASC_3DF_DYNP)')
 1002 format(
     +3X,'READING GEOPHYSS DATA IN (S/R CASC_3DF_DYNP)')
 1003 format(
     +3X,'READING BUSPER   DATA IN (S/R CASC_3DF_DYNP)')
 1004 format(
     +3X,'UPDATING GEOPHY  DATA IN (S/R CASC_3DF_DYNP)')
*
*-----------------------------------------------------------------------
      return

 1010 write (6,203) fn(1:longueur(fn)),Ptopo_myproc
      call gem_stop('casc_3df_dynp',-1)
      return
      end
*
