***s/r nest_indata - Read and process nesting data during LAM 
*                    integration for LBC.
*
#include "model_macros_f.h"
*
      subroutine nest_indata
      implicit none
*
*author 
*     Michel Desgagne   - Spring 2002
*
*revision
* v3_01 - Desgagne M.     - initial version
* v3_03 - Tanguay M.      - Adjoint Lam configuration
* v3_30 - Lee V.          - Hollow cubes and acid test for LAM
*
*object
*	
*arguments
*	none
*
*implicits
#include "schm.cdk"
#include "glb_ld.cdk"
#include "ind.cdk"
#include "lam.cdk"
#include "nest.cdk"
#include "p_geof.cdk"
#include "tr3d.cdk"
#include "ifd.cdk"
#include "v4dg.cdk"
#include "ptopo.cdk"
#include "bcsmem.cdk"
#include "bcsdim.cdk"
#include "type.cdk"
#include "adw.cdk"
#include "lun.cdk"
#include "acid.cdk"
*
      integer  vmmlod,vmmget,vmmuld,bcs_ftype,casc_bcs,casc_bcsh
      external vmmlod,vmmget,vmmuld,bcs_ftype,casc_bcs,casc_bcsh
*
      integer key1(10),nvar,err,ng, keyp(Tr3d_ntr), keyp_
      integer errbcs1,errbcs2,n,id,k,unf,errft(3)
      logical nav_L
      real t1,t2,t3,t4,t5,t6
      pointer (pat1, t1(*)), (pat2, t2(*)), (pat3, t3(*))
      real trp
      pointer (patrp, trp(LDIST_SHAPE,*))
**
*     ---------------------------------------------------------------
*
      if (Lun_debug_L) write (Lun_out,1000)

      ng = LDIST_SIZ
      key1(1) = VMM_KEY(nest_uf)
      key1(2) = VMM_KEY(nest_vf)
      key1(3) = VMM_KEY(nest_tf)
      key1(4) = VMM_KEY(nest_zdf)
      key1(5) = VMM_KEY(nest_sf)
      key1(6) = VMM_KEY(topo)
      key1(7) = VMM_KEY(topu)
      key1(8) = VMM_KEY(topv)
*
      nvar = 8
*
      if (.not. Schm_hydro_L) then
         key1(nvar+1) = VMM_KEY(nest_wf)
         key1(nvar+2) = VMM_KEY(nest_qf)
         nvar = nvar+2
      endif
      err = vmmlod(key1,nvar)
*
      err = VMM_GET_VAR(nest_uf)
      err = VMM_GET_VAR(nest_vf)
      err = VMM_GET_VAR(nest_tf)
      err = VMM_GET_VAR(nest_zdf)
      err = VMM_GET_VAR(nest_sf)
      err = VMM_GET_VAR(topo)
      err = VMM_GET_VAR(topu)
      err = VMM_GET_VAR(topv)
*
      if (.not. Schm_hydro_L) then
         err = VMM_GET_VAR(  nest_wf)
         err = VMM_GET_VAR( nest_qf)
      endif
*
      call hpalloc (pat1, ng*l_nk, err, 1)
      call hpalloc (pat2, ng*(l_nk+1), err, 1)
      call hpalloc (pat3, ng*l_nk, err, 1)
*
*     Equivalencing Ind_u = nest_uf
*
      Ind_u_   = nest_uf_
      Ind_v_   = nest_vf_
      Ind_t_   = nest_tf_
      Ind_zd_ = nest_zdf_
      Ind_s_   = nest_sf_
      Ind_topo_= topo_
      Ind_topu_= topu_
      Ind_topv_= topv_
*
      if (.not. Schm_hydro_L) then
         Ind_w_   = nest_wf_
         Ind_q_  = nest_qf_
      endif
*
      errft = 0
      unf = 76
      nav_L = .false.
      err = bcs_ftype (ifd_ftype,errft,Lam_current_S, nav_L, unf)
      if ((ifd_ftype.eq.'BCS').or.(ifd_ftype.eq.'3DF')) then
*
         if (ifd_ftype.eq.'3DF') then
             errbcs1 = casc_bcs (Lam_current_S,unf,1,0)
             errbcs2 = casc_bcs (Lam_current_S,unf,2,errbcs1)
             errbcs1 = min(0,errbcs1+errbcs2+1)
             if(errbcs1.lt.0) write(6,205) Lam_current_S,Ptopo_myproc
             call stopmpi (errbcs1)
         else if (ifd_ftype.eq.'BCS') then
             errbcs1 = casc_bcsh (Lam_current_S,unf,1,0)
             errbcs2 = casc_bcsh (Lam_current_S,unf,2,errbcs1)
             errbcs1 = min(0,errbcs1+errbcs2+1)
             if(errbcs1.lt.0) write(6,205) Lam_current_S,Ptopo_myproc
             call stopmpi (errbcs1)
         else
             write (6,1001)
             call stopmpi(-1)
         endif
         if (.not.Acid_test_L) then
c            Le fait de ne rien faire sur nest_zdf revient a le mettre a zero
c            call gem_stop('nest_indata : terminer calcul de nest_zdf csh?',-1)
c             call uvs2zd (nest_zdf,nest_uf,nest_vf,csh,LDIST_DIM,l_nk)            
             call trnes (nest_zdf,bcs_zdf(bcs_is),bcs_zdf(bcs_in),bcs_zdf(bcs_iw),
     $            bcs_zdf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,0)
             if (.not. Schm_hydro_L) then
             call trnes (nest_wf,bcs_wf(bcs_is),bcs_wf(bcs_in),bcs_wf(bcs_iw),
     $            bcs_wf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,0)
             call trnes (nest_qf,bcs_qf(bcs_is),bcs_qf(bcs_in),bcs_qf(bcs_iw),
     $            bcs_qf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+2,0)
             endif
         endif
*     Functions above will be filling values into bcs_uf
      else
*
         call readdyn()
*
*        Regular forward gem
*        -------------------
         if(V4dg_conf.eq.0) then
*
            call predat()
*
*        4D-Var
*        ------
         else
*
*        Preprocessing of Control   variables only if ipart=2
*        ----------------------------------------------------
            call v4d_predat(2)
*
*        Preprocessing of Dependent variables only if ipart=3
*        ----------------------------------------------------
            call v4d_predat(3)
*
         endif

*        Stuff values from nest_uf to bcs_uf

         if (l_south.or.l_north.or.l_east.or.l_west) then
         call trnes (nest_uf,bcs_uf(bcs_is),bcs_uf(bcs_in),bcs_uf(bcs_iw),
     $            bcs_uf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,G_nk,0)
         call trnes (nest_vf,bcs_vf(bcs_is),bcs_vf(bcs_in),bcs_vf(bcs_iw),
     $            bcs_vf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,G_nk,0)
         call trnes (nest_tf,bcs_tf(bcs_is),bcs_tf(bcs_in),bcs_tf(bcs_iw),
     $            bcs_tf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,0)
         call trnes (nest_zdf,bcs_zdf(bcs_is),bcs_zdf(bcs_in),bcs_zdf(bcs_iw),
     $            bcs_zdf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,0)
         call trnes (nest_sf,bcs_sf(bcs_is),bcs_sf(bcs_in),bcs_sf(bcs_iw),
     $            bcs_sf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,1,0)
         if (.not. Schm_hydro_L) then
             call trnes (nest_wf,bcs_wf(bcs_is),bcs_wf(bcs_in),bcs_wf(bcs_iw),
     $            bcs_wf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,0)
             call trnes (nest_qf,bcs_qf(bcs_is),bcs_qf(bcs_in),bcs_qf(bcs_iw),
     $            bcs_qf(bcs_ie),l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $                         minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+2,0)
         endif
         keyp_ = VMM_KEY (nest_trf)
         do n=1,Tr3d_ntr
            keyp(n) = keyp_ + n
         end do
         err = vmmlod(keyp,Tr3d_ntr)
         do n=1,Tr3d_ntr
            err = vmmget(keyp(n),patrp,trp)
            id = (n-1)*bcs_sz+1
             call trnes (trp,bcs_trf(id),bcs_trf(id+bcs_in-1),
     $               bcs_trf(id+bcs_iw-1),bcs_trf(id+bcs_ie-1),
     $               l_minx,l_maxx,l_miny,l_maxy,minxs,maxxs,
     $               minys,maxys,minxw,maxxw,minyw,maxyw,G_nk+1,0)
         end do
         err = vmmuld(keyp,Tr3d_ntr)
         endif

      endif

      err=vmmuld(key1,nvar)
*
      call hpdeallc (pat1 ,err,1)
      call hpdeallc (pat2 ,err,1)
      call hpdeallc (pat3 ,err,1)
*
*     ---------------------------------------------------------------
*
 205  format (/' PROBLEM WITH LBCS AT: ',a,', PROC#:',i4,' --ABORT--'/)
 1000 format(3X,'GETTING DATA FROM NEST TO BCS: (S/R NEST_INDATA)')
 1001 format (/' WRONG ifd_ftype in nest_indata: --- ABORT ---'/)
      return
      end

