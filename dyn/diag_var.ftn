***s/r diag_var calculate model diagnostic variables
*
#include "model_macros_f.h"
*
      subroutine diag_var(F_BsPq,F_mu,F_s,F_q,i0,in,j0,jn,nk)
*     
      implicit none
*     
      integer nk
      real F_BsPq(LDIST_SHAPE,0:Nk+1), F_mu(LDIST_SHAPE,Nk+1)
      real F_s(LDIST_SHAPE),           F_q(LDIST_SHAPE,0:Nk+1)
*
*author
*
* Andre Plante july 2006.
*
*revision
*
*object
*       see id section
*
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_BsPq       O    - perturbation ln(pressure)
* F_mu         O    - 
* F_s          I    - 
* F_q          I    - non-hydro perturbation of log(p)
* i0,in,j0,jn  I    - index over which computation will be made.
*
*implicits
#include "lun.cdk"
#include "dcst.cdk"
#include "glb_ld.cdk"
#include "geomg.cdk"
#include "cstv.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
*     
**
      integer i,j,k,i0,in,j0,jn,nij
      real*8 one, half, xxx
      parameter(one=1.d0, half=.5d0 )
      real*8, dimension(i0:in,j0:jn):: xtmp_8, ytmp_8, xrec_8, yrec_8
*
*     ---------------------------------------------------------------
*
      if(
     $     i0.lt.1-G_halox   .or.
     $     in.gt.l_ni+G_halox.or.
     $     j0.lt.1-G_haloy   .or.
     $     jn.gt.l_nj+G_haloy
     $     )then
         call gem_stop('diag_var : dimension error',-1)
      endif
*
      nij = (in - i0 + 1)*(jn - j0 + 1)
*
!$omp parallel private (xxx,xtmp_8,ytmp_8,xrec_8,yrec_8)
*
!$omp do
       do k=0,l_nk+1
         do j= j0, jn
         do i= i0, in
            F_BsPq(i,j,k)=Ver_b_8%m(k)*F_s(i,j)
         enddo
         enddo
      enddo
!$omp enddo
*

      if (.not. Schm_hydro_L) then
!$omp do
      do k=0,l_nk+1
         do j= j0, jn
         do i= i0, in
            F_BsPq(i,j,k) = F_BsPq(i,j,k) +  F_q(i,j,k)
         enddo
         enddo
         if(k.gt.0) then
            xxx=Ver_idz_8%t(k)
            do j= j0, jn
            do i= i0, in
               xrec_8(i,j) =one+ver_dbdz_8%t(k)*F_s(i,j)
               xtmp_8(i,j) = half*( F_q(i,j,k)+F_q(i,j,k-1))
            enddo
            enddo
            call vrec ( yrec_8, xrec_8, nij )
            call vexp ( ytmp_8, xtmp_8, nij )
            do j= j0, jn
            do i= i0, in
               F_mu(i,j,k)= -one + ytmp_8(i,j)*
     $         (one+xxx*(F_q(i,j,k)-F_q(i,j,k-1))*yrec_8(i,j))
            enddo
            enddo
         endif
      enddo
!$omp enddo
      endif
*      
!$omp end parallel
*
*     ---------------------------------------------------------------
*
      return
      end
