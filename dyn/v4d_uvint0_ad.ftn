***s/r v4d_uvint0_ad - ADJ of v4d_uvint0 
*
#include <model_macros_f.h>
*
      subroutine v4d_uvint0_ad (flduint,fldvint,px,py,npts,fldu,fldv,ax,ay,cx,cy,
     %                          wx_8,cox_8,six_8,siy_8,i1,i2,j1,j2,nk,
     %                          grtypi,degree,var)
*
      use v4d_interzone
*
#include "impnone.cdk"
*
      integer npts,i1,i2,j1,j2,nk,degree
*
      real,   pointer, dimension(:,:) :: flduint,fldvint
      real,   pointer, dimension(:)   :: px,py
*
      real fldu(i1:i2,j1:j2,nk),fldv(i1:i2,j1:j2,nk),
     %     ax(i1:i2),ay(j1:j2),cx(i1:i2,6),cy(j1:j2,6)
*
      character*2 var
*
      character*1 grtypi
*
      real*8 wx_8(*),cox_8(*),six_8(*),siy_8(*)
*
*author Tanguay M.
*
*revision
* v3_00 - Tanguay M.        - initial MPI version
*
*object
*     see id section
*
*ADJOINT of
*arguments
* Name         I/O        Description
*----------------------------------------------------------------
* fldu-vint     O         Interpolated wind fields at positions px,py
* px            I         Position x in INPUT grid
* py            I         Position y in INPUT grid
* npts          I         Number of positions
* fldu-v        I         Wind fields on INPUT grid
* ax            I         X axe of INPUT grid
* ay            I         Y axe of INPUT grid
* cx            I         AX difference on INPUT grid
* cy            I         AY difference on INPUT grid
* wx            I         Weights on INPUT grid x axe
* cox,six,siy   I         Cosinus or Sinus of INPUT grid axes
* i1-i2         I         Dimension x in INPUT grid
* j1-j2         I         Dimension y in INPUT grid
* nk            I         Dimension z in INPUT grid
* grtypi        I         Type of INPUT grid
* degree        I         Degree of interpolation
* var           I         Name of fldu-v
*----------------------------------------------------------------
*
*implicits
#include "glb_ld.cdk"
*
      integer i,j,k,gni,jmin,jmax,ni
*
      real*8, parameter :: ZERO_8 = 0.0
*
*     Recall ni = Period if grid='G', Heart if grid='Z'
*     -------------------------------------------------
      if(grtypi.eq.'Z') ni = l_ni
      if(grtypi.eq.'G') ni = i2-i1+1
*
*     Recall dimension of a latitude circle in INPUT grid
*     ---------------------------------------------------
      if(grtypi.eq.'Z') gni = G_ni
      if(grtypi.eq.'G') gni = ni
*
*     Recall j limit
*     --------------
      jmin=j1
      jmax=j2
      if(grtypi.eq.'Z'.and.l_north) jmax=l_nj
      if(grtypi.eq.'Z'.and.l_south) jmin=1
*
*     Adjoint of
*     Closing if wind interpolation in polar zones
*     --------------------------------------------
      if(l_north.or.l_south) call v4d_zonewnd_ad (px,py,npts,fldu,fldv,wx_8,cox_8,six_8,siy_8,
     %                                            i1,i2,j1,j2,nk,jmin,jmax,ni,G_lnimax,gni,grtypi,
     %                                            degree,var,l_north,l_south,2)
*
*     Adjoint of
*     Wind interpolation at px,py positions using EZSCINT
*     ---------------------------------------------------
      if(npts.ne.0) call v4d_ezuvint_ad (flduint,fldvint,px,py,npts,fldu,fldv,ax,ay,cx,cy,
     %                                   i1,i2,j1,j2,nk,jmin,jmax,ni,grtypi,degree)
*
*     Adjoint of
*     Preparation for polar correction if wind interpolation
*     ------------------------------------------------------
      if(l_north.or.l_south) call v4d_zonewnd_ad (px,py,npts,fldu,fldv,wx_8,cox_8,six_8,siy_8,
     %                                            i1,i2,j1,j2,nk,jmin,jmax,ni,G_lnimax,gni,grtypi,
     %                                            degree,var,l_north,l_south,1)
*
*     Adjoint of
*     Fill halo for interpolation between processors if INPUT grid='Z"
*     ----------------------------------------------------------------
      if(grtypi.eq.'Z') then
*
         call rpn_comm_adj_halo( fldv, LDIST_DIM,l_ni,l_nj,nk,
     %                           G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
         call rpn_comm_adj_halo( fldu, LDIST_DIM,l_ni,l_nj,nk,
     %                           G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
*
         do k=1,nk
            do j=l_miny,0
            do i=l_minx,l_maxx
               fldv(i,j,k) = ZERO_8
               fldu(i,j,k) = ZERO_8
            end do
            end do
            do j=l_nj+1,l_maxy
            do i=l_minx,l_maxx
               fldv(i,j,k) = ZERO_8
               fldu(i,j,k) = ZERO_8
            end do
            end do
            do i=l_minx,0
            do j=l_miny,l_maxy
               fldv(i,j,k) = ZERO_8
               fldu(i,j,k) = ZERO_8
            end do
            end do
            do i=l_ni+1,l_maxx
            do j=l_miny,l_maxy
               fldv(i,j,k) = ZERO_8
               fldu(i,j,k) = ZERO_8
            end do
            end do
         end do
*
      endif
*
      return
      end
