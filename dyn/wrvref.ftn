! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r wrvref (to write a new +HYB+ record)
*
#include "model_macros_f.h"
      subroutine wrvref ( unf )
      implicit none
*
*author    V.Lee  - Nov. 2007 (orig from MC2)
*
      integer unf
*
#include "glb_ld.cdk"
#include "out.cdk"
#include "pres.cdk"
#include "grd.cdk"
#include "type.cdk"
#include "ver.cdk"
*
      real*8  wke(G_nk*2+3,3),x1,x2
      real*8 work(G_nk*2+3,3),work1
      real hyb
      integer*8 ip1_8,ip2_8
      integer ig1,ig2,ig3,ig4,ip1,k
      integer  fstecr
      external fstecr
*
      integer err
      do k=1,G_nk
         call convip(ip1,Ver_hyb%m(k),Out_kind,+1,' ',.false.)
         ip1_8 = ip1
         work1 = ip1_8
         ip2_8 = work1
         work(k,1)=ip1_8
         work(k,2)=Ver_a_8%m(k)
         work(k,3)=Ver_b_8%m(k)
      enddo

*     The very top
      call convip(ip1,0.0,Out_kind,+1,' ',.false.)
      ip1_8 = ip1
      work1 = ip1_8
      work(G_nk+1,1)=work1
      work(G_nk+1,2)=Ver_a_8%t(1)
      work(G_nk+1,3)=Ver_b_8%t(1)
      do k=1,G_nk+1
         call convip(ip1,Ver_hyb%t(k),Out_kind,+1,' ',.false.)
         ip1_8 = ip1
         work1 = ip1_8
         ip2_8 = work1
         work(k+G_nk+1,1)=work1
         work(k+G_nk+1,2)=Ver_a_spcl_8%t(k)
         work(k+G_nk+1,3)=Ver_b_spcl_8%t(k)
      enddo

*     The very bottom
      call convip(ip1,1.0,Out_kind,+1,' ',.false.)
      ip1_8 = ip1
      work1 = ip1_8
      work(G_nk*2+3,1)=work1
      work(G_nk*2+3,2)=Ver_a_8%t(G_nk+1)
      work(G_nk*2+3,3)=Ver_b_8%t(G_nk+1)

      do k=1,G_nk
         work1 = work(k,1)
         ip1_8 = work1
         ip1 = ip1_8
         call convip(ip1,hyb,Out_kind,-1,' ',.false.)
c        print *,'wrvref:k=',k,' hyb_m= ',hyb,' a=',work(k,2),' b=',work(k,3),' ip1=',ip1
      enddo

      do k=G_nk+1,G_nk*2+3
         work1 = work(k,1)
         ip1_8 = work1
         ip1 = ip1_8
         call convip(ip1,hyb,Out_kind,-1,' ',.false.)
c        print *,'wrvref:k=',k,' hyb_t= ',hyb,' a=',work(k,2),' b=',work(k,3),' ip1=',ip1
      enddo

c     print *,'wrvref:Pres_ptop=',Pres_ptop
c     print *,'wrvref:Grd_rcoef,Pres_pref=',Grd_rcoef,Pres_pref
*
*     Parameters are described in Pascals
      ig4 = Grd_rcoef*1000
      ig3 = Pres_pref*100
      ig2 = Pres_ptop*100
*     Code for this type of staggered hybrid
      ig1 = Ver_kcode
      

c     print *,'wrvref: ig1,ig2,ig3,ig4=',ig1,ig2,ig3,ig4
      err = fstecr (work,wke,-32,unf,Out_dateo,
     $          int(Out_deet),Out_npas,G_nk*2+3,3,1,Out_ig1,Out_ig2,0,
     $          'X','+HY+',Out_etik_S,'X',ig1,ig2,ig3,ig4,5,.true.)
c     print *,'wrvref: err=',err,'unf=',unf

*
      return
      end

