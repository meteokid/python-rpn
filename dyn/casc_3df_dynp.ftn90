!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r casc_3df_dynp - Reads self-nested 3DF pilot files where
!                      3DF01 files were written after advection and
!                      3DF02 files were written after physics by
!                      the previous driving model.
!
#include "model_macros_f.h"
!
      subroutine casc_3df_dynp(F_u, F_v, F_w, F_t, F_zd, F_s, F_fiptx, F_topo, F_q, F_dtopo,  &
                               Mminx,Mmaxx,Mminy,Mmaxy,dimgx,dimgy,unf,listgeonm)
      use nest_blending, only: nest_blend
      implicit none
!
      character* (*) listgeonm(2,*)
      integer Mminx,Mmaxx,Mminy,Mmaxy,dimgx,dimgy,unf
      real F_u (Mminx:Mmaxx,Mminy:Mmaxy,*), F_v(Mminx:Mmaxx,Mminy:Mmaxy,*), &
           F_w (Mminx:Mmaxx,Mminy:Mmaxy,*), F_t(Mminx:Mmaxx,Mminy:Mmaxy,*), &
           F_zd(Mminx:Mmaxx,Mminy:Mmaxy,*), F_s(Mminx:Mmaxx,Mminy:Mmaxy  ), &
           F_fiptx(Mminx:Mmaxx,Mminy:Mmaxy,0:*), F_topo (Mminx:Mmaxx,Mminy:Mmaxy), &
           F_q    (Mminx:Mmaxx,Mminy:Mmaxy,0:*), F_dtopo(Mminx:Mmaxx,Mminy:Mmaxy)
!
!author
!     M. Desgagne  April 2006 (MC2 casc_3df_dynp)
!
!revision
! v3_30 - Lee V.         - initial version for GEMDM
! v3_30 - McTaggart-Cowan R. - implement variable orography
! v4_03 - Lee/Desgagne   - ISST
! v4_05 - Desgagne M.    - Add P_pbl_icelac_L, Lam_cascsfc_L 
!                          and Lam_blendoro_L options
! v4_05 - Lee V.         - Ind_u,Ind_v vectors are filled incorrectly
! v4_06 - McTaggart-Cowan R. - Nesajr correction
! v4_06 - Lee V.         - Predat is called outside of this routine
!*
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "bcsdim.cdk"
#include "bcsgrds.cdk"
#include "bcsmem.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "ifd.cdk"
#include "lam.cdk"
#include "ptopo.cdk"
#include "schm.cdk"
#include "tr3d.cdk"
#include "vt1.cdk"
#include "lun.cdk"
#include "itf_phy_buses.cdk"
#include "lctl.cdk"
#include "itf_phy_config.cdk"
#include "vtopo.cdk"
#include "path.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
#include "nest.cdk"
!
!        presstype
!            0 => p =    A                         (B=0),  prs-anal
!            1 => p =    A+B*   ps       , F_p0=ps (A=0),  sig-anal
!            2 => p =    A+B*   ps       , F_p0=ps      ,  etasef-anal
!            3 => p =    A+B*   ps       , F_p0=ps      ,  eta-anal
!            4 => p =    A+B*   ps       , F_p0=ps      ,  hyb-anal
!        ?   5 => p =    A+B*   ps       , F_p0=ps      ,  ecm-anal
!            6 => p =exp(A+B*ln(ps/pref)), F_p0=ps      ,  stg-anal
!
      integer  sid3df
      external sid3df
!
      character*2  md
      character*4  nomvar
      character*8  dynophy,vn
      character*8, dimension (:), pointer :: trname_a, geop_name
      character*4, dimension (:), pointer :: phynm
      character*15 datev
      character*256 fn
      logical done,dyn_done,phy_done,same_topo_L,temp_same_L,flag
      logical dyn_init,phy_init
      integer i,j,k,jj,jjj,kk,nia,nja,nk0,nka_m,nka_t,ntra,ntra_tmp, &
              ni1,nj1,nk1,n,err,presstype,nbits, &
              errop,ofi,ofj,l_in,l_jn,mode,nvar, vmmnvar,ungeo, &
              cnt,nkphy,errdyn,errphy,cumerr,pid,gid,nfphy, &
              wowp,nij,ijk

      integer i0,in,j0,jn,ni2,nj2,nvargeo
      integer idd,jdo,mult,shp,bigk,offbb,offbo,offg,ng,nga
      real topo_temp(l_ni,l_nj),dtopo_temp(l_ni,l_nj),zero(l_ni,l_nj)

      integer, dimension (:  ), pointer :: idx,idu,idy,nks
      real xi,xf,yi,yf,htopa,maxtopo(2),maxtopo_g(2), &
           psmin, psmax, psmin_glob, psmax_glob, pr1,pr2
      real  , dimension (:  ), pointer :: phybr
      real*8, dimension (:  ), pointer ::  &
                    xpaq,ypaq,xpau,ypav,xpuu,ypvv, &
                    cxa,cxb,cxc,cxd,cua,cub,cuc,cud,cya,cyb,cyc,cyd
!
      real, dimension (:,:), pointer :: uun,vvn,zdn,ttn, &
                                        ssqn,meqn,qqn,wwn, &
                                        meqr, &
                                        topo_temp1, &
                                        ssq0,ssu0,ssv0, &
                                        phybn,ss1
!
      real, dimension (:,:,:  ), pointer :: uu1,vv1,zd1,ttt1, &
                                            qq1,ww1,trn,trp
      real, dimension (:,:,:,:), pointer :: tr1

!
      real ssq_temp(LDIST_SHAPE)
      real*8 xpxext(0:dimgx+1), ypxext(0:dimgy+1),lnpis_8
      data nfphy,nkphy /0,0/
!
!-----------------------------------------------------------------------
!
      nvargeo = 9
      Lam_busper_init_L=.false.
      if (P_pbl_schsl_S.eq.'ISBA') nvargeo = nvargeo + 5
      if (P_pbl_icelac_L)          nvargeo = nvargeo + 1
      allocate (geop_name(nvargeo))
!
      geop_name (1) = 'TWATEREN'
      geop_name (2) = 'ICEDPEN'
      geop_name (3) = 'TGLACEN'
      geop_name (4) = 'TMICEN'
      geop_name (5) = 'SNODPEN'
      geop_name (6) = 'TSOILEN'
      geop_name (7) = 'GLSEAEN'
      geop_name (8) = 'HS'
      geop_name (9) = 'ALEN'
      if (P_pbl_schsl_S.eq.'ISBA') then
         geop_name (8)  = 'WSOILEN'
         geop_name (10) = 'ISOILEN'
         geop_name (11) = 'WVEGEN'
         geop_name (12) = 'WSNOWEN'
         if (P_pbl_snoalb_L) then
         geop_name (13) = 'SNOALEN'
         else 
         geop_name (13) = 'SNOAGEN'
         endif
         geop_name (14) = 'SNOROEN'
      endif
      if (P_pbl_icelac_L) geop_name(nvargeo) = 'ICELINEN'
!
      if (Lun_debug_L) write (Lun_out,1000)
!
      bcs_nia = ifd_niaf - ifd_niad + 1
      bcs_nja = ifd_njaf - ifd_njad + 1
      nia     = bcs_nia
      nja     = bcs_nja
      nga     = nia*nja
      ntra    = 0
      ng      = l_ni * l_nj
      ofi     = l_i0 - 1
      ofj     = l_j0 - 1

      err     = 0
!
! Positional parameters on extended global mass point grid
!
      do i=1,dimgx
         xpxext(i) = G_xg_8(i)
      end do
      xpxext(0) = xpxext(1) - (xpxext(2)-xpxext(1))
      xpxext(dimgx+1) = xpxext(dimgx) + (xpxext(dimgx)-xpxext(dimgx-1))
!
      do i=1,dimgy
         ypxext(i) = G_yg_8(i)
      end do
      ypxext(0) = ypxext(1) - (ypxext(2)-ypxext(1))
      ypxext(dimgy+1) = ypxext(dimgy) + (ypxext(dimgy)-ypxext(dimgy-1))
!
! Positional parameters of model target u and v grids (xpuu and ypvv).
!
      allocate (xpuu(l_ni),ypvv(l_nj))
      do i=1,l_ni
         xpuu(i) = 0.5d0 * (xpxext(ofi+i+1)+xpxext(ofi+i))
      end do
      do j=1,l_nj
         ypvv(j) = 0.5d0 * (ypxext(ofj+j+1)+ypxext(ofj+j))
      end do
!
      datev   = Lam_runstrt_S
!
! Read all needed files and construct the source domain for
! the horizontal interpolation
!
!     wowp = 2 ===> input data has seen the physics
!     wowp = 1 ===> input data just after dynamics (no physics)
!     We prefer to initialize uup, vvp etc... with wowp=2 status.
!
      allocate (xpaq(nia), ypaq(nja), xpau(nia), ypav(nja))
!
      wowp = 3
 48   wowp = wowp - 1
      if (wowp.lt.1) then
         write (6,204)
         err = -1
         goto 999
      endif
!
      write (md,'(i2.2)') wowp
      done     = .false.
      dyn_init = .false.
      phy_init = .false.
!
      do n=1,ifd_nf
!
         ofi = ifd_minx(n)-1
         ofj = ifd_miny(n)-1
         if (ifd_needit(n)) then
!
            errdyn   = -1
            errphy   = -1
            dyn_done = .false.
            phy_done = .false.
!
            fn = trim(Path_ind_S)//'/3df'//md// &
                       '_'//datev//'_'//ifd_fnext(n)
            open (unf,file=trim(fn),access='SEQUENTIAL', &
                      form='UNFORMATTED',status='OLD',iostat=errop)
            if (Lun_debug_L) &
            write(Lun_out,*) 'Opening',trim(fn),'err=',errop
!
            if (errop.ne.0) goto 33
!
! Use first file to establish 3D grid dimensions and geo-references
! of all input staggered grids (xpaq, ypaq, xpau and ypva).
!
 55         if (dyn_done.and.phy_done) goto 33
            err = sid3df (xpaq,ypaq,xpau,ypav,unf,done,nia,nja, &
                               nka_m,nka_t,presstype)
            if (err.lt.0) then
                if (dyn_done) then
!               Assumes no physics data are available
                    err=0
                    phy_done = .true.
                    errphy   = 0
                endif
!               Continue to next file
                goto 33
            endif
!
            read (unf,end=1010,err=1010) dynophy,mode,nvar,ntra_tmp
            if (Lun_debug_L) write (Lun_out,1001) dynophy,mode,nvar,ntra_tmp
!
            if (dynophy.eq.'PHYSICSS') then
               nfphy=nvar+ntra_tmp
!
               if (.not.phy_init) then
                  if (associated(phybn)) deallocate(phybn)
                  if (associated(phynm)) deallocate(phynm)
                  if (associated(nks  )) deallocate(nks  )
                  allocate (phynm(nfphy),nks(nfphy))
               endif
               read(unf,end=1010,err=1010)(phynm(i),nks(i),i=1,nfphy)
               nkphy=0
               do i=1,nfphy
                  nkphy=nkphy+nks(i)
                  if (Lun_debug_L) write (Lun_out,*) phynm(i),nks(i)
               enddo
               if (.not.phy_init) allocate(phybn(nga,nkphy))
               phy_init = .true.
               cumerr = 0
!              use nkphy as the pointer in phybn
               nkphy=0
               do i=1,nfphy
                 read (unf,end=1010,err=1010) nomvar,ni1,nj1,nk1,nbits
                 call filmup (nomvar,phybn(1,nkphy+1),ifd_niad,ifd_niaf,ifd_njad, &
                          ifd_njaf,nks(i),unf,ofi,ofj,cumerr,ni1,nj1,nk1,nbits)
                 nkphy=nkphy+nks(i)
               enddo
               errphy=cumerr
               phy_done = .true.
               if (.not. dyn_done) goto 55
!
            else if (dynophy.eq.'DYNAMICS') then
               ntra=ntra_tmp
!
               if (.not.dyn_init) then
                  if (associated( uun)) deallocate( uun)
                  if (associated( vvn)) deallocate( vvn)
                  if (associated( zdn)) deallocate( zdn)
                  if (associated( ttn)) deallocate( ttn)
                  if (associated( qqn)) deallocate( qqn)
                  if (associated( wwn)) deallocate( wwn)
                  if (associated(ssqn)) deallocate(ssqn)
                  if (associated(meqn)) deallocate(meqn)
                  if (associated( trn)) deallocate( trn)
                  if (associated( topo_temp1)) deallocate( topo_temp1)
                  if (associated(trname_a)) deallocate(trname_a)
                  allocate (  uun(nga,nka_m), vvn (nga,nka_m), &
                              zdn(nga,nka_t-1), ttn (nga,nka_t), &
                             ssqn(nga,1  )  , &
                             topo_temp1(l_ni+1-(east*1),l_nj+1-(north*1)), &
                              qqn(nga,nka_m+1), wwn(nga,nka_t-1), &
                             trn (nga,nka_t,ntra), trname_a(ntra) )
                  if (presstype.eq.0) then ! presstype= pressure
                      allocate (meqn(nga,nka_m))
                  else
                      allocate (meqn(nga,1))
                  endif
                  uun=0.; vvn=0.; zdn=0.; ttn=0.; ssqn=0.; trn=0.;
                  wwn=0.; qqn=0.; meqn=0.;
                  dyn_init = .true.
               endif
!
               cumerr=0
               call read_3df(unf,uun,vvn,zdn,ttn,ssqn,meqn,qqn,wwn,trn, &
                        trname_a,nvar,ntra,nga,nka_m,nka_t,ofi,ofj,cumerr)
               errdyn   = cumerr
               dyn_done = .true.
               if ((.not.phy_done).and.(Schm_phyms_L)) goto 55
!
            else
               write (6,205) dynophy
               goto 1010
            endif
!
 33         close (unf)
!
            if ((errdyn.lt.0).and.(wowp.gt.1)) goto 48
!
            if (.not.Schm_phyms_L) errphy = 0
            err  = err + errdyn + errphy
            done = .true.
            if (err.lt.0) then
               write (6,203) trim(fn),Ptopo_myproc
               goto 999
            endif
         endif
      end do
!
 999  call handle_error(err,'casc_3df_dynp','casc_3df_dynp')
!
      allocate ( meqr(l_ni,l_nj))
      allocate (idx(l_ni), idu(max(l_ni,l_nj)),idy(l_nj), &
                cxa(l_ni), cxb(l_ni), cxc(l_ni) ,cxd(l_ni), &
                cya(l_nj), cyb(l_nj), cyc(l_nj), cyd(l_nj), &
                cua(max(l_ni,l_nj)) , cub(max(l_ni,l_nj)) , &
                cuc(max(l_ni,l_nj)) , cud(max(l_ni,l_nj)))

      call grid_to_grid_coef (xpxext(l_i0),l_ni, &
                              xpaq,nia,idx,cxa,cxb,cxc,cxd,Lam_hint_S)
      call grid_to_grid_coef (ypxext(l_j0),l_nj, &
                              ypaq,nja,idy,cya,cyb,cyc,cyd,Lam_hint_S)
!
!
! Reload geofld bus with subset from PHYSICSS=> (xp1,yp1) (geophy grid)
! For exact fields, refer to out_phy_3df
!
      if (Lam_cascsfc_L) then
      if (nkphy.gt.0 .and. phy_init .and. Schm_phyms_L) then
         if (Lun_debug_L) write (Lun_out,1004)
         if (associated(phybr)) deallocate (phybr)
         allocate(phybr(ng*nkphy))
         call hinterpo (phybr,l_ni,l_nj,phybn,nia,nja,nkphy, &
               idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
         ofj=0
         do pid=1,nfphy
         do gid=1,p_bgeo_top
            nomvar = geonm(gid,2)
            vn     = geonm(gid,1)
            flag   = .false.
            do k=1,nvargeo
               if (vn.eq.geop_name(k)) flag=.true.
            end do
            if ((phynm(pid).eq.nomvar).and.flag) then
               ofi = geopar(gid,1) -1
               if ((nomvar.eq.'LG').or.(nomvar.eq.'AL') &
                                   .or.(nomvar.eq.'HS')) then
                  do i=1,ng*geopar(gid,3)
                     geofld(ofi+i) = min(max(0.,phybr(ofj+i)),1.)
                  end do
               else
                  do i=1,ng*geopar(gid,3)
                     geofld(ofi+i) = phybr(ofj+i)
                  end do
               endif
               listgeonm(2,gid) = 'OK'
            endif
         enddo
            ofj=ofj+nks(pid)*ng
         enddo
      endif
      endif
!
! Copy target topography field from geofld (see geodata.ftn) unless
! "growing" topography is used, in which case the current model
! topography is retained. 
!
      call hinterpo ( meqr,l_ni,l_nj, meqn,nia,nja,    1,idx,idy, &
                       cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      if (Vtopo_L) then
         if (Lctl_step > Vtopo_start) then
            topo_temp = F_topo(1:l_ni,1:l_nj)
         else
            do gid=1,P_bgeo_top
               if (geonm(gid,1).eq.'MF') then
                  offg = geopar(gid,1)
                  cnt = 0
                  do j=1,l_nj
                  do i=1,l_ni
                     cnt=cnt+1
                     topo_temp(i,j)=dble(geofld(offg +cnt-1))*Dcst_grav_8
                  enddo
                  enddo
               endif
            enddo
         endif
         dtopo_temp = topo_temp - meqr
         topo_temp = meqr         
         if (Lam_blendoro_L) then
         do j=1,pil_s
            do i=1,l_ni
               dtopo_temp(i,j) = 0.
            end do
         end do
         do j=l_nj-pil_n+1,l_nj
            do i=1,l_ni
               dtopo_temp(i,j) = 0.
            end do
         end do
         do i=1,pil_w
            do j=pil_s+1,l_nj-pil_n
               dtopo_temp(i,j) = 0.
            end do
         end do
         do i=l_ni-pil_e+1,l_ni
            do j=pil_s+1,l_nj-pil_n
               dtopo_temp(i,j) = 0.
            end do
         end do
         zero = 0.
         call nest_blend (dtopo_temp, zero, &
                          1,l_ni,1,l_nj,'M',level=G_nk+1)
         endif
         F_dtopo(1:l_ni,1:l_nj) = dtopo_temp
      else
         do gid=1,P_bgeo_top
           if (geonm(gid,1).eq.'MF') then
             offg = geopar(gid,1)
             cnt = 0
             do j=1,l_nj
             do i=1,l_ni
                cnt=cnt+1
                topo_temp(i,j)=dble(geofld(offg +cnt-1))*Dcst_grav_8
             enddo
             enddo
           endif
         enddo
         if (Lam_blendoro_L) then
         if (presstype.ne.0) then ! presstype not in pressure levels
         do j=1,pil_s
         do i=1,l_ni
            topo_temp(i,j) = meqr(i,j)
         end do
         end do
         do j=l_nj-pil_n+1,l_nj
         do i=1,l_ni
            topo_temp(i,j) = meqr(i,j)
         end do
         end do
         do i=1,pil_w
         do j=pil_s+1,l_nj-pil_n
            topo_temp(i,j) = meqr(i,j)
         end do
         end do
         do i=l_ni-pil_e+1,l_ni
         do j=pil_s+1,l_nj-pil_n
            topo_temp(i,j) = meqr(i,j)
         end do
         end do
         call nest_blend (topo_temp,meqr, &
                          1,l_ni,1,l_nj,'M',level=G_nk+1)
         endif
         endif
      endif
!
      F_topo(1:l_ni,1:l_nj) = topo_temp

! topo is inflated!
      call rpn_comm_xch_halo ( F_topo, LDIST_DIM,l_ni,l_nj,1, &
                    G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
!
      do j=1,l_nj+1-(north*1)
      do i=1,l_ni+1-(east*1)
         topo_temp1(i,j) = F_topo(i,j)
      enddo
      enddo
!
      allocate(uu1(l_ni,l_nj,G_nk+1), &
               vv1(l_ni,l_nj,G_nk+1), &
               ttt1(l_ni,l_nj,G_nk+2), &
               zd1(l_ni,l_nj,G_nk+1), &
               ss1(l_ni,l_nj), &
               qq1(l_ni,l_nj,0:G_nk+1), &
               ww1(l_ni,l_nj,G_nk+1), &
               tr1(l_ni,l_nj,G_nk+2,Tr3d_ntr) )

      call casc_hvi (trname_a, &
        xpxext(l_i0),ypxext(l_j0),xpuu,ypvv,xpaq,ypaq,xpau,ypav, &
        uu1,vv1, ttt1,zd1, &
        ss1,qq1, ww1,tr1, &
        0, l_ni*l_nj*(G_nk+2),topo_temp1, &
        uun,vvn,ttn,zdn,meqn,ssqn,qqn,wwn,trn, &
        1,l_ni,1,l_nj,l_ni+1-(east*1),l_nj+1-(north*1), G_nk, &
        nia,nja,nka_m,nka_t,presstype,ntra)

      F_u(1:l_ni,1:l_nj,1:G_nk+1) = uu1
      F_v(1:l_ni,1:l_nj,1:G_nk+1) = vv1
      F_t(1:l_ni,1:l_nj,1:G_nk+2) = ttt1
      F_zd(1:l_ni,1:l_nj,1:G_nk+1)=zd1
      F_s(1:l_ni,1:l_nj) = ss1
      F_w(1:l_ni,1:l_nj,1:G_nk+1)   = ww1
      if (.not. Schm_hydro_L) then
        F_q(1:l_ni,1:l_nj,0:G_nk+1) = qq1
      endif
!
      do n=1,Tr3d_ntr
         nullify (trp)
         gmmstat = gmm_get('TR/'//trim(Tr3d_name_S(n))//':P',trp,meta3d)
         trp(1:l_ni,1:l_nj,1:G_nk+2) = tr1(1:l_ni,1:l_nj,1:G_nk+2,n)
      end do
!
      deallocate (uu1,vv1,ttt1,zd1,qq1,ww1,tr1,meqr,trname_a)
      do j=1,l_nj
      do i=1,l_ni
         ss1(i,j) = Cstv_pref_8*exp(ss1(i,j))
      enddo
      enddo
!
      psmin = ss1(1,1)
      psmax = ss1(1,1)
      do j=1,l_nj
      do i=1,l_ni
         psmin = min( psmin, ss1(i,j) )
         psmax = max( psmax, ss1(i,j) )
      enddo
      enddo
!
      deallocate (geop_name,ss1)
!
      call rpn_comm_allreduce(psmin,psmin_glob,1,"MPI_REAL","MPI_MIN", &
                                                           "grid",err)
      call rpn_comm_allreduce(psmax,psmax_glob,1,"MPI_REAL","MPI_MAX", &
                                                           "grid",err)
      psmin=psmin_glob
      psmax=psmax_glob
!     
      if ( Ptopo_myproc.eq.0 ) then
           write(6,*)'PSMIN = ',PSMIN,' PSMAX = ',PSMAX, &
                           ' PSMINMAX = ',0.5*(PSMIN+PSMAX),' (PASCAL)'
      endif
!
 100  format (' ',65('*'))
 101  format (' (CASC_3DF_DYNP) JUST READ INIT DATA FOR DATE: ',a15,1x,i3)
 203  format (/' PROBLEM WITH FILE: ',a,', PROC#:',i4,' --ABORT--'/)
 204  format (/' NO DATA IN CASC_3DF_DYNP --ABORT--'/)
 205  format (/' Unrecognizable tag found: ',a,'?'/)
 1000 format( &
      3X,'READING DATA IN (S/R CASC_3DF_DYNP)')
 1001 format( &
      3X,'READING ',a,' DATA IN (S/R CASC_3DF_DYNP)',I4,'nvar=',I4,'ntr=',I4)
 1002 format( &
      3X,'READING GEOPHYSS DATA IN (S/R CASC_3DF_DYNP)')
 1003 format( &
      3X,'READING BUSPER   DATA IN (S/R CASC_3DF_DYNP)')
 1004 format( &
      3X,'UPDATING GEOPHY  DATA IN (S/R CASC_3DF_DYNP)')
!
!-----------------------------------------------------------------------
      return

 1010 write (6,203) trim(fn),Ptopo_myproc

      call handle_error(-1,'casc_3df_dynp','casc_3df_dynp')
      return
      end
!
