***s/r blocthm - output  temperature, humidity and mass fields
*
#include <model_macros_f.h>
*
      subroutine blocthm(F_dostep,F_dostep_max)
*
#include "impnone.cdk"
*
      integer F_dostep(*)
      integer F_dostep_max
*
*author
*     james caveen/andre methot  - rpn june/nov 1995
*
*revision
* v2_00 - Lee V.            - initial MPI version (from blocthm v1_03)
* v2_11 - Desgagne M.       - ptop reproducubility
* v2_21 - Desgagne M.       - new calling sequence for glbdist + correct
* v2_21                       calling sequence mfohra
* v2_21 - J. P. Toviessi    - set dieze (#) slab output and rename
* v2_21                       truncate model output names to 4 characters
* v2_30 - Lee V.            - reorganize slab output to be more efficient
* v2_30 - Edouard S.        - adapt for vertical hybrid coordinate
* v2_30                     - change call to p0vt2gz_hyb
* v2_32 - Lee V.            - reduce dynamic allocation size, add HU,ME output
* v3_00 - Desgagne & Lee    - Lam configuration
*
*object
*     See above id.
*
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_dostep     I    - array containing indices corresponding to the
*                     timestep sets that requires output at this time step.
* F_dostep_max I    - size of F_dostep array
*
*implicits

#include "glb_ld.cdk"
#include "dcst.cdk"
#include "dimout.cdk"
#include "lun.cdk"
#include "geomg.cdk"
#include "schm.cdk"
#include "pres.cdk"
#include "vt1.cdk"
#include "out.cdk"
#include "out2.cdk"
#include "setsor.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "ptopo.cdk"
#include "slab.cdk"
#include "dslab.cdk"
#include "tr3d.cdk"
#include "grid.cdk"
*
*modules
      integer  vmmlod, vmmuld, vmmget, vmmuln, vmmulk
      external vmmlod, vmmuld, vmmget, vmmuln, vmmulk
      integer getvndx
      external getvndx
*
**
      integer cnmvar, cn3dvar, cnnkey, cn2dvar
      parameter (cnmvar=14, cn3dvar=8, cn2dvar=4, cnnkey=5)
      integer i,j,k,kl,jj,kk,jjj,kkk,ii,iii,i0,in,j0,jn
      integer pnlkey (cnnkey),key(Tr3d_ntr),key0
      integer pnerr,pnkey,levset,pnindex,pni2d,pni3d
      integer pni2dx(cn2dvar), pni3dx(cn3dvar)
      real prmult(cn3dvar), pradd(cn3dvar), prmult_pnme,prprlvl,hu
      character*8 ptmvar(cnmvar), pt3dvar(cn3dvar),pt2dvar(cn2dvar)
      logical pl3dvar(cn3dvar)
      pointer (patr, hu(LDIST_SHAPE,*))
      real wk1(G_ni,G_nj),wk2(G_ni,G_nj)
      real wk3(G_ni,G_nj+2),wk4(G_ni,G_nj+2)
      real w1(LDIST_SHAPE), w2(LDIST_SHAPE), w3(LDIST_SHAPE)
      real w4(LDIST_SHAPE), w5(LDIST_SHAPE), w6(LDIST_SHAPE)
      real t1(LDIST_SHAPE,G_nk), t2(LDIST_SHAPE,G_nk)
      real t3(LDIST_SHAPE,G_nk), t4(LDIST_SHAPE,G_nk)
      real gz_temp(l_ni,l_nj,G_nk),tt_temp(l_ni,l_nj,G_nk)
      real ps_temp(l_ni,l_nj)

*     Declarations for slab output
      integer mxout_e
      character*4, dimension(:,:),allocatable :: var_e_S
      character*1, dimension(:,:),allocatable :: typvar_e_S
      integer,     dimension(:,:),allocatable :: ip1_e
      integer,     dimension(:,:),allocatable :: bit_e
      real,        dimension(:,:),allocatable :: mtval_e
      integer,     dimension(:,:),allocatable :: xnio
      integer,     dimension(:), allocatable  :: mtout_e
* ___________________________________________________________________
*
*     1.0     initialization of data
*_______________________________________________________________________
*
*     list of model variables that can be outputted by blocthm
*     at time levels t0,t2 and t1
      data ptmvar /
     $     'FIT0', 'QT0',  'FIP0', 'QPT0', 'PIP0', 'TT0',  'TPL0',
     $     'FIT1', 'QT1',  'FIP1', 'QPT1', 'PIP1', 'TT1',  'TPL1' /
*     list of derived 3-D variables that may be produced by blocthm
*     NOTE: This routine also outputs ME, PN, P0 and PT
      data pt3dvar /'GZ','VT','TT','ES','TD','HR','PX','HU'/
      data pt2dvar /'ME','PN','PT','P0'/
      integer pngz,pnvt,pntt,pnes,pntd,pnhr,pnpx,pnhu
      integer pnme,pnpn,pnpt,pnp0
*     index of each symbol in the list
      data pngz,pnvt,pntt,pnes,pntd,pnhr,pnpx,pnhu
     $     /  1,   2,   3,   4,   5,   6,   7,   8/
      data pnme,pnpn,pnpt,pnp0
     $     /  1,   2,   3,   4/
*     initialize conversion of units
      data prmult  / cn3dvar*1.0/
      data pradd   / cn3dvar*0.0/
*
      prmult_pnme  = 1.0 / Dcst_grav_8
      prmult(pngz) = 0.1 / Dcst_grav_8
      pradd(pnvt)  = -Dcst_tcdk_8
      pradd(pntt)  = -Dcst_tcdk_8
      pradd(pntd)  = -Dcst_tcdk_8
      prmult(pnpx)  = 0.01
*_______________________________________________________________________
*
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
*_______________________________________________________________________
*
*     2.0    Check if output is required for the 3-D model variables
*_______________________________________________________________________
*
      pni3d = 0
      do i=1,cnmvar
         pnindex=getvndx(ptmvar(i))
         if (pnindex.gt.0) then
             pni3d = pni3d + Setsor_useit(pnindex)
         else
            if (Lun_out.gt.0) write(Lun_out,*)
     $           'Error in BLOCTHM:INDEX not found for ',ptmvar(i)
            stop
         endif
      enddo
      if (pni3d.gt.0) then
          call slab3dvar(ptmvar,cnmvar,F_dostep,F_dostep_max,0)
      endif
*_______________________________________________________________________
*
*     3.0    Check if output is required for the 2-D derived variables
*_______________________________________________________________________
*
      pni2d = 0
      do i=1,cn2dvar
         pni2dx(i)=getvndx(pt2dvar(i))
         if (pni2dx(i).gt.0) then
             pni2d = pni2d + Setsor_useit(pni2dx(i))
         else
            if (Lun_out.gt.0) write(Lun_out,*)
     $           'Error in BLOCTHM:INDEX not found for ',pt2dvar(i)
            stop
         endif
      enddo
*_______________________________________________________________________
*
*     3.5    Check if output is required for the 3-D derived variables
*_______________________________________________________________________
      pni3d = 0
      do i=1,cn3dvar
         pni3dx(i)=getvndx(pt3dvar(i))
         if (pni3dx(i).gt.0) then
             pni3d = pni3d + Setsor_useit(pni3dx(i))
         else
            if (Lun_out.gt.0) write(Lun_out,*)
     $           'Error in BLOCTHM:INDEX not found for ',pt3dvar(i)
            stop
         endif
      enddo
      if((pni2d+pni3d) .le. 0) then
*        no more output required
            return
      endif
*_______________________________________________________________________
*
*     4.0    Load and Get required fields
*_______________________________________________________________________
*
      mxout_e = 1 + pni3d*max(l_nk,Dslab_max_lev_p) + pni2d
      allocate ( var_e_S(mxout_e,Grid_sets),
     %           typvar_e_S(mxout_e,Grid_sets),
     %           ip1_e(mxout_e,Grid_sets),
     %           bit_e(mxout_e,Grid_sets),
     %           mtval_e(LDIST_SIZ*mxout_e,Grid_sets),
     %           mtout_e(Grid_sets),
     %           xnio(LDIST_SIZ,Grid_sets) 
     %)
      call set_dslab(0,xnio,LDIST_SIZ,Grid_sets)
      do i=1,Grid_sets
         mtout_e(i)=0
      enddo

      pnlkey(1) = VMM_KEY(fit1)
      pnlkey(2) = VMM_KEY(tt1)
      pnlkey(3) = VMM_KEY(st1)

      pnerr = vmmlod(pnlkey,3)

      pnerr = VMM_GET_VAR(fit1)
      pnerr = VMM_GET_VAR(tt1)
      pnerr = VMM_GET_VAR(st1)
*_________________________________________________________________
*_________________________________________________________________
*
*     4.4    Obtain HUT1 from TR3D
*            _____________________
*_________________________________________________________________
*_________________________________________________________________

      key0 = VMM_KEY (trt1)
      do k=1,Tr3d_ntr
         key(k) = key0 + k
      end do
      pnerr = vmmlod(key,Tr3d_ntr)
      do k=1,Tr3d_ntr
         if (Tr3d_name_S(k).eq.'HU') then
            pnerr = vmmget(key(k),patr,hu)
         endif
      enddo
*_________________________________________________________________
*
*     4.5    Calculation of GZ   
*            _____________________
*_________________________________________________________________
*     compute P0, Ptop, and set boundary condition for GZ 
*     if require recomputation
*
      do j=j0,jn
      do i=i0,in
         w1(i,j) = exp( Out2_wlnph(i,j,l_nk) )
         w2(i,j) = exp( Out2_wlnph(i,j,1)    )
      enddo
      enddo
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         t4 (i,j,k) = fit1(i,j,k)
      enddo
      enddo
      enddo
*
      if ( Out_vt2gz_L ) then
*     Put these variables in non-halo vectors
           do k=1,l_nk
           do j=j0,jn
           do i=i0,in
              tt_temp (i,j,k) = tt1(i,j,k)
              gz_temp(i,j,l_nk)= t4(i,j,l_nk)
           enddo
           enddo
           enddo
           do j=j0,jn
           do i=i0,in
              ps_temp (i,j) = st1(i,j)
           enddo
           enddo
           call p0vt2gz_hyb (gz_temp,geomg_pia,geomg_pib,ps_temp,
     $                          tt_temp,l_ni*l_nj,l_nk,.true.,.false.)
           do k=1,l_nk
           do j=j0,jn
           do i=i0,in
              t4 (i,j,k) = gz_temp(i,j,k)
           enddo
           enddo
           enddo
      endif
*
*_______________________________________________________________________
*
*     5.0    Precomputations for output over pressure levels or PN
*
*        The underground extrapolation can use precalculated
*        temperatures over fictious underground geopotential levels.
*        The number of fictious levels is "Out_nundr".
*        The levels in meters are stored in "Out_zund(Out_nundr)".
*        Both "Out_nundr" and "Out_zund" are user's given 
*        parameters.
*_______________________________________________________________________
*
      if ( Out_nundr .gt. 0 ) then
*
         do 20 kl=1,Out_nundr
         do j=j0,jn
         do i=i0,in
*
*        store fictious height level in t1
*
            t1(i,j,kl) = Out_zund(kl) * Dcst_grav_8
*
*        determine if fictious level is above or below ground
*
            w1(i,j) = t4 (i,j,l_nk) - t1(i,j,kl)
*
            if ( w1(i,j) .gt. 0 ) then
*
*           fictious level is under ground:
*           temperature is obtained by linear EXTrapolation
*           identify under ground grid point
* 
            if ( abs( Out2_wlao(i,j)*180./Dcst_pi_8 ) .ge. 49. ) then
*
                w1(i,j) = tt1(i,j,l_nk) +       .0005 * w1(i,j)
            else
                w1(i,j) = tt1(i,j,l_nk) + Dcst_stlo_8 * w1(i,j)
            endif
*
            w2(i,j) = 1.0
*
         else
*
*           fictious level is above ground:
*           temperature is obtained by linear INTerpolation
*           identify above ground grid point
*
            do k=l_nk-1,1,-1
               w1(i,j) = t4 (i,j,k) - t1(i,j,kl)
               if ( w1(i,j) .gt. 0. ) goto 10
            enddo
 10         continue
*
            w2(i,j)= - ( tt1 (i,j,k) - tt1 (i,j,k+1) ) /
     %                 ( t4  (i,j,k) - t4  (i,j,k+1) )
*
            w1(i,j) = tt1(i,j,k) + w2(i,j) * w1(i,j)
*
            w2(i,j) = 0.0
         endif
*
         enddo
         enddo
*
         call glbcolc (wk1,G_ni,G_nj,w1,LDIST_DIM,1)
         call glbcolc (wk2,G_ni,G_nj,w2,LDIST_DIM,1)
*
*        For all under ground grid points at level t1(i,j,kl)
*        recompute temperature by HORIZONTAL interpolation
*
         if (Ptopo_myproc.eq.0) 
     $        call liebman_2 (wk1,wk2,wk3,wk4,0.1,G_ni,G_nj)
*
         call glbdist (wk1,G_ni,G_nj,w1,LDIST_DIM,1,G_halox,G_haloy)
*
         do j=j0,jn
         do i=i0,in
            t2(i,j,kl) = w1(i,j)
         enddo
         enddo
*
*        At this point:
*        temperature field is stored in t2 for futur use
*        fictious levels  are stored in t1 for futur use
*
 20      continue
      endif
*
*     Calculate vertical derivative of HUT1 with respect to Out2_wlnph
*
      call verder(t3, hu, Out2_wlnph, 2.0,  2.0, LDIST_DIM, G_nk,
     $                                            i0,in,j0,jn)
*_______________________________________________________________________
*
*     6.0 Output 2-D Derived Variables (P0,PT,PN)
*_______________________________________________________________________
*
      if (pni2d.gt.0) then
         do 100 jj=1,F_dostep_max
*        For every Timestep set that outputs at the current timestep
         do 80 kk=1,Outd_sets
            if (Outd_step(kk).eq.F_dostep(jj))then
*     if the Timestep set for this request set Outd(kk) outputs
*     at the current timestep (Lctl_step)
               do 50 ii=1,Outd_var_max(kk)
*            if ME requested for output...
                  if (Outd_var(ii,kk).eq.pni2dx(pnme)) then
                     call insrtslab_d(t4,w2,LDIST_DIM,G_nk,G_nk,
     $                  kk,prmult_pnme,0.0,pni2dx(pnme),0.0,mtout_e,
     $                  var_e_S,typvar_e_S,ip1_e,bit_e,mtval_e,
     $                  LDIST_SIZ,mxout_e,Grid_sets)
                  endif
*            if P0 requested for output...
                  if (Outd_var(ii,kk).eq.pni2dx(pnp0)) then
*       Calculate P0
                     do j= j0, jn 
                     do i= i0, in 
                        w1(i,j) = exp(Out2_wlnph(i,j,l_nk))
                     enddo
                     enddo
                     call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                  kk,.01,0.0,pni2dx(pnp0),0.0,mtout_e,
     $                  var_e_S,typvar_e_S,ip1_e,bit_e,mtval_e,
     $                  LDIST_SIZ,mxout_e,Grid_sets)
                  endif
*            if PT requested for output...
                  if (Outd_var(ii,kk).eq.pni2dx(pnpt)) then
*       Calculate PT
                     do j= j0, jn 
                     do i= i0, in 
                        w1(i,j) = Out2_ptop(i,j)
                     enddo
                     enddo
                     call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                  kk,0.01,0.0,pni2dx(pnpt),0.0,mtout_e,
     $                  var_e_S, typvar_e_S,ip1_e,bit_e,mtval_e,
     $                  LDIST_SIZ,mxout_e,Grid_sets)
                  endif
*            if PN requested for output...
                  if (Outd_var(ii,kk).eq.pni2dx(pnpn)) then
*       Calculate PN
                     call pnm2(w1,tt1,t4,Out2_wlnph,Out2_wlao,
     $                    t2,t1,Out_nundr,LDIST_DIM,G_nk)
                     call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                  kk,.01,0.0,pni2dx(pnpn),0.0,mtout_e,
     $                  var_e_S, typvar_e_S,ip1_e,bit_e,mtval_e,
     $                  LDIST_SIZ,mxout_e,Grid_sets)
                  endif
 50            continue
            endif
 80      continue
 100  continue
      endif
*_______________________________________________________________________
*
*     7.0A   Output 3-D Derived Variables on ETA levels
*_______________________________________________________________________
*
      if (pni3d.gt.0) then
         do 400 jj=1,F_dostep_max
*        For every Timestep set that outputs at the current timestep
         do 300 kk=1,Outd_sets
            if (Outd_step(kk).eq.F_dostep(jj))then
*           if the Timestep set for this request set Outd(kk) outputs
*           at the current timestep (Lctl_step)
            levset = Outd_lev(kk)
            if (Level_typ(levset) .eq. 'E') then
            do 200 ii=1,Outd_var_max(kk)
               pnkey = 0
               do 140 i=1,cn3dvar
                  if (pni3dx(i) .eq. Outd_var(ii,kk)) then
*                 if 3-D variable is found in this request set
                     pl3dvar(i) = .true.
                     pnkey = pnkey + 1
                  else 
                     pl3dvar(i) = .false.
                  endif
 140           continue
*         if any 3-D variables are requested for output in this set
               if (pnkey.gt.0) then
                  do 150 jjj = 1, Level_max(levset)
                     k = nint(Level(jjj,levset))
                     if (pl3dvar(pngz)) then
                          call insrtslab_d(t4,w2,LDIST_DIM,G_nk,k,
     $                    kk,prmult(pngz),pradd(pngz),pni3dx(pngz),
     $                    Level_ip1(jjj,levset),mtout_e,var_e_S,
     $                    typvar_e_S,ip1_e,bit_e,mtval_e,
     $                    LDIST_SIZ,mxout_e,Grid_sets)
                     endif
                     if (pl3dvar(pnvt)) then
                          call insrtslab_d(tt1,w2,LDIST_DIM,G_nk,k,
     $                    kk,prmult(pnvt),pradd(pnvt),pni3dx(pnvt),
     $                    Level_ip1(jjj,levset),mtout_e,var_e_S,
     $                    typvar_e_S,ip1_e,bit_e,mtval_e,
     $                    LDIST_SIZ,mxout_e,Grid_sets)
                     endif
                     if (pl3dvar(pnhu)) then
                          call insrtslab_d(hu,w2,LDIST_DIM,G_nk,k,
     $                    kk,prmult(pnhu),pradd(pnhu),pni3dx(pnhu),
     $                    Level_ip1(jjj,levset),mtout_e,var_e_S,
     $                    typvar_e_S,ip1_e,bit_e,mtval_e,
     $                    LDIST_SIZ,mxout_e,Grid_sets)
                     endif
                     if (pl3dvar(pntt).or.pl3dvar(pntd)
     $                    .or.pl3dvar(pnhr)) then
*       Calculate TT (in w1)
                        do j= j0, jn 
                        call mfottv (w1(1,j),tt1(1,j,k),hu(1,j,k),
     $                                      l_maxx-l_minx+1,1,l_ni)
                        enddo
                     endif
                     if (pl3dvar(pntt)) then
                          call insrtslab_d(w1,w2,LDIST_DIM,1,1,
     $                    kk,prmult(pntt),pradd(pntt),pni3dx(pntt),
     $                    Level_ip1(jjj,levset),mtout_e,var_e_S,
     $                    typvar_e_S,ip1_e,bit_e,mtval_e,
     $                    LDIST_SIZ,mxout_e,Grid_sets)
                     endif
                     if (pl3dvar(pnes).or.pl3dvar(pnpx).or.
     $                    pl3dvar(pntd).or.pl3dvar(pnhr)) then
*     Calculate PX (in w3)
                        do j= j0, jn 
                        do i= i0, in 
                           w3(i,j) = exp(Out2_wlnph(i,j,k))
                        enddo
                        enddo
                     endif
*                     
                     if (pl3dvar(pnpx)) then
                          call insrtslab_d(w3,w4,LDIST_DIM,1,1,
     $                    kk,prmult(pnpx),pradd(pnpx),pni3dx(pnpx),
     $                    Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                    typvar_e_S,ip1_e,bit_e,mtval_e,
     $                    LDIST_SIZ,mxout_e,Grid_sets)
                     endif
                     if (pl3dvar(pnes).or.pl3dvar(pntd)) then
*     Calculate ES (in w2) (w3=PX)
                        do j= j0, jn 
                        call mhuaes(w2(1,j),hu(1,j,k),tt1(1,j,k),
     $                          w3(1,j),w3(1,j),3, .false., .false.,
     $                          l_maxx-l_minx+1,1,l_ni)
                        enddo
                        if (Out_cliph_L) then
*     Clip ES
                           do j= j0, jn 
                           do i= i0, in 
                              w2(i,j) = amin1( w2(i,j), 30.)
                              w2(i,j) = amax1( w2(i,j), 0. )
                           enddo
                           enddo
                        endif
                        if (pl3dvar(pnes)) then
                             call insrtslab_d(w2,w4,LDIST_DIM,1,1,
     $                       kk,prmult(pnes),pradd(pnes),pni3dx(pnes),
     $                       Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                       typvar_e_S,ip1_e,bit_e,mtval_e,
     $                       LDIST_SIZ,mxout_e,Grid_sets)
                        endif
                        if (pl3dvar(pntd)) then
*     Calculate TD (w1=TT,w2=ES, TD=TT-ES)
                           do j= j0, jn 
                           do i= i0, in 
                              w2(i,j) = w1(i,j) - w2(i,j)
                           enddo
                           enddo
                           call insrtslab_d(w2,w4,LDIST_DIM,1,1,
     $                          kk,prmult(pntd),pradd(pntd),pni3dx(pntd),
     $                          Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                          typvar_e_S,ip1_e,bit_e,mtval_e,
     $                          LDIST_SIZ,mxout_e,Grid_sets)
                        endif
                     endif
                     if (pl3dvar(pnhr)) then
*       Calculate HR (w1=TT,w3=PX)
                         do j= j0, jn 
                            call mfohra(w2(1,j), hu(1,j,k),w1(1,j),
     $                      w3(1,j),w3(1,j),3,l_maxx-l_minx+1, 1, l_ni)
                         enddo
                         if ( Out_cliph_L ) then
*       Clip HR
                              do j= j0, jn 
                              do i= i0, in 
                                 w2(i,j)=amin1( w2(i,j), 1.0 )
                                 w2(i,j)=amax1( w2(i,j), 0.  )
                              enddo
                              enddo
                         endif
                         call insrtslab_d(w2,w4,LDIST_DIM,1,1,
     $                        kk,prmult(pnhr),pradd(pnhr),pni3dx(pnhr),
     $                        Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                        typvar_e_S,ip1_e,bit_e,mtval_e,
     $                        LDIST_SIZ,mxout_e,Grid_sets)
                     endif
 150              continue
               endif
 200        continue
            endif
            endif
 300     continue
 400     continue
      endif
      call writslab_d(Dslab_fhand_e,Dslab_slab_e,Dslab_nnio,'dm',
     %                Dslab_ext_S,mtout_e, var_e_S,typvar_e_S,ip1_e,bit_e,
     %                mtval_e,xnio,LDIST_SIZ,mxout_e,Grid_sets)
      do i=1,Grid_sets
         mtout_e(i)=0
      enddo
*_______________________________________________________________________
*
*     7.0B   Output 3-D Derived Variables on PRESSURE levels
*_______________________________________________________________________

      if (pni3d.gt.0) then
         do 800 jj=1,F_dostep_max
*           For every Timestep set that outputs at the current timestep
         do 700 kk=1,Outd_sets
         if (Outd_step(kk).eq.F_dostep(jj))then
*           if the Timestep set for this request set Outd(kk) outputs
*           at the current timestep (Lctl_step)
            levset = Outd_lev(kk)
*
            if (Level_typ(levset) .eq. 'P') then
            do 600 ii=1,Outd_var_max(kk)
               pnkey = 0
*
               do 540 i=1,cn3dvar
                  if (pni3dx(i) .eq. Outd_var(ii,kk)) then
*                 if 3-D variable is found in this request set
                     pl3dvar(i) = .true.
                     pnkey = pnkey + 1
                  else 
                     pl3dvar(i) = .false.
                  endif
 540           continue
*         if any 3-D variables are requested for output in this set
               if (pnkey.gt.0) then
                  do 550 jjj = 1, Level_max(levset)
                     prprlvl = Level(jjj,levset) * 100.0
*       Calculate GZ,VT (w1=GZ, w2=VT)
                     call prgzvta( w1, w2, prprlvl, t4, tt1, Out2_wlnph, Out2_wlao,
     %                        t2, t1, Out_nundr,Out_cubzt_L, 
     $                        Out_linbot, LDIST_DIM,G_nk)
*     Calculate HU (w4=HU,t3=vert.der)
                     call prgen( w4, hu, t3, Out2_wlnph, prprlvl, 
     $                      Out_cubzt_L,LDIST_DIM, G_nk)
                     if ( Out_cliph_L ) then
*     Clip HU
                          do j= j0, jn 
                          do i= i0, in 
                             w4(i,j) = amax1( w4(i,j), 0. )
                          enddo
                          enddo
                     endif
                     if (pl3dvar(pnhu)) then
                          call insrtslab_d(w4,w5, LDIST_DIM,1,1,
     $                    kk,prmult(pnhu),pradd(pnhu),pni3dx(pnhu),
     $                    Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                    typvar_e_S,ip1_e,bit_e,mtval_e,
     $                    LDIST_SIZ,mxout_e,Grid_sets)
                     endif
                     if (pl3dvar(pngz)) then
                          call insrtslab_d(w1,w5, LDIST_DIM,1,1,
     $                    kk,prmult(pngz),pradd(pngz),pni3dx(pngz),
     $                    Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                    typvar_e_S,ip1_e,bit_e,mtval_e,
     $                    LDIST_SIZ,mxout_e,Grid_sets)
                     endif
                     if (pl3dvar(pnvt)) then
                          call insrtslab_d(w2,w5, LDIST_DIM,1,1,
     $                    kk,prmult(pnvt),pradd(pnvt),pni3dx(pnvt),
     $                    Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                    typvar_e_S,ip1_e,bit_e,mtval_e,
     $                    LDIST_SIZ,mxout_e,Grid_sets)
                     endif
                    if (pl3dvar(pntt).or.pl3dvar(pntd)
     $                    .or.pl3dvar(pnhr))then
*     Calculate TT (w2=VT,w4=HU)
                       do j= j0, jn 
                          call mfottv (w1(1,j), w2(1,j), w4(1,j),
     $                                   l_maxx-l_minx+1,1,l_ni)
                       enddo
                    endif
                    if (pl3dvar(pntt)) then
                         call insrtslab_d(w1,w6, LDIST_DIM,1,1,
     $                   kk,prmult(pntt),pradd(pntt),pni3dx(pntt),
     $                   Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                   typvar_e_S,ip1_e,bit_e,mtval_e,
     $                   LDIST_SIZ,mxout_e,Grid_sets)
                    endif
*       Calculate PX for ES,TD,HR
                    if ( pl3dvar(pnes).or.
     $                   pl3dvar(pntd).or.pl3dvar(pnhr)) then
                       do j= j0, jn 
                       do i= i0, in 
                          w3(i,j) = prprlvl
                       enddo
                       enddo
                    endif
                    if (pl3dvar(pnes).or.pl3dvar(pntd)) then
                       do j= j0, jn 
*       Calculate ES (w4=HU,w2=VT,w3=PX)
                       call mhuaes (w5(1,j), w4(1,j), w2(1,j),
     $                              w3(1,j), w3(1,j), 3, .false., .false.,
     $                              l_maxx-l_minx+1, 1, l_ni)
                       enddo
                       if ( Out_cliph_L ) then
*       Clip ES
                       do j= j0, jn 
                       do i= i0, in 
                          w5(i,j) = amin1( w5(i,j), 30.)
                          w5(i,j) = amax1( w5(i,j), 0. )
                       enddo
                       enddo
                       endif
                       if (pl3dvar(pnes)) then
                            call insrtslab_d(w5,w6, LDIST_DIM,1,1,
     $                      kk,prmult(pnes),pradd(pnes),pni3dx(pnes),
     $                      Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                      typvar_e_S,ip1_e,bit_e,mtval_e,
     $                      LDIST_SIZ,mxout_e,Grid_sets)
                       endif
                       if (pl3dvar(pntd)) then
*       Calculate TD (w1=TT,w5=ES, TD=TT-ES)
                           do j= j0, jn 
                           do i= i0, in 
                              w5(i,j) = w1(i,j) - w5(i,j)
                           enddo
                           enddo
                           call insrtslab_d(w5,w6, LDIST_DIM,1,1,
     $                          kk,prmult(pntd),pradd(pntd),pni3dx(pntd),
     $                          Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                          typvar_e_S,ip1_e,bit_e,mtval_e,
     $                          LDIST_SIZ,mxout_e,Grid_sets)
                        endif
                     endif
                     if (pl3dvar(pnhr)) then
*       Calculate HR (w4=HU,w1=TT,w3=PX)
                        do j= j0, jn 
                           call mfohra (w5(1,j), w4(1,j), w1(1,j), w3(1,j), 
     $                                  w3(1,j),3,l_maxx-l_minx+1,1,l_ni)
                        enddo
                        if ( Out_cliph_L ) then
*     Clip HR
                           do j= j0, jn 
                           do i= i0, in 
                              w5(i,j) = amin1( w5(i,j), 1.0 )
                              w5(i,j) = amax1( w5(i,j), 0.  )
                           enddo
                           enddo
                        endif
                        call insrtslab_d(w5,w6, LDIST_DIM,1,1,
     $                       kk,prmult(pnhr),pradd(pnhr),pni3dx(pnhr),
     $                       Level_ip1(jjj,levset),mtout_e, var_e_S,
     $                       typvar_e_S,ip1_e,bit_e,mtval_e,
     $                       LDIST_SIZ,mxout_e,Grid_sets)
                     endif
 550              continue
               endif
 600        continue
         endif
         endif
 700     continue
 800     continue
      endif
      call writslab_d(Dslab_fhand_p,Dslab_slab_p,Dslab_nnio,'dp',
     %                Dslab_ext_S,mtout_e, var_e_S,typvar_e_S,ip1_e,bit_e,
     %                mtval_e,xnio,LDIST_SIZ,mxout_e,Grid_sets)
      deallocate ( var_e_S,ip1_e,bit_e,mtval_e,typvar_e_S,mtout_e,xnio )
*
* ___________________________________________________________________
      pnerr = vmmuln(pnlkey,3)
      pnerr = vmmuln(key,Tr3d_ntr)
*
*
      return
      end
