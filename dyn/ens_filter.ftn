***s/r ens_filter - Fourier filter
*
#include <model_macros_f.h>
      subroutine ens_filter
#include "impnone.cdk"
*
*author 
*     Lubos Spacek - rpn - apr 2005
*
*revision
*
*object
*	
*arguments
*	none
*
*implicits
#include "ptopo.cdk"
#include "glb_ld.cdk"
#include "trp.cdk"
#include "ldnh.cdk"
#include "vt1.cdk"
#include "lctl.cdk"
#include "glb_pil.cdk"
#include "geomg.cdk"
#include "dcst.cdk"
#include "ens_param.cdk"

*
*modules
      integer vmmlod, vmmget, vmmuld
      external vmmlod, vmmget, vmmuld
*
*variables
      integer ix,iy,iz,iz_local,kx,ky,kz
      integer np, rank, ierr, keys(8), npartiel
      integer i, j, k, i0, j0, in, jn, nij, inn, trx
      real    pi, err, deltax, cpdi
      real*8  dpi, aaa2
!     Arrays
      real  , dimension(:,:,:), allocatable  :: dsp_local, fgem
      real  , dimension(:,:,:), allocatable  :: dsp_dif, dsp_gwd
      real  , dimension(:,:,:), allocatable  :: derx_local,dery_local
      real*8, dimension(:,:,:), allocatable  :: psi_local,work_local,ffx_local

************************************************************************

      dpi=4.d0*atan(1.0d0)
      cpdi=1./real(Dcst_cpd_8)
      aaa2= 1.d0/Dcst_rayt_8**2
      deltax=sqrt(((2.0*dpi/real(G_ni))*Dcst_rayt_8)*
     %                ((dpi/real(G_nj))*Dcst_rayt_8))

*
*     Get needed fields in memory
*
      keys(1) = VMM_KEY(ut1)
      keys(2) = VMM_KEY(vt1)
      keys(3) = VMM_KEY(tt1)
      keys(4) = VMM_KEY(difut1)
      keys(5) = VMM_KEY(difvt1)
      keys(6) = VMM_KEY(ugwdt1)
      keys(7) = VMM_KEY(vgwdt1)
      keys(8) = VMM_KEY(mcsph1)
*
      ierr = vmmlod( keys, 8 )
      ierr = VMM_GET_VAR(ut1)
      ierr = VMM_GET_VAR(vt1)
      ierr = VMM_GET_VAR(tt1)
      ierr = VMM_GET_VAR(difut1)
      ierr = VMM_GET_VAR(difvt1)
      ierr = VMM_GET_VAR(ugwdt1)
      ierr = VMM_GET_VAR(vgwdt1)
      ierr = VMM_GET_VAR(mcsph1)
*
*     Markov chain step and if Ens_bc_conf=.false. return
*
      call ens_marfield_cg(mcsph1)
*
      if(.not.Ens_bc_conf)then
        ierr = vmmuld(keys, 8 )
        return
      endif
*
      allocate( dsp_local(LDIST_SHAPE,l_nk))
      allocate( dsp_dif(LDIST_SHAPE,l_nk))
      allocate( dsp_gwd(LDIST_SHAPE,l_nk))
      allocate( psi_local(ldnh_minx:ldnh_maxx,ldnh_miny:ldnh_maxy,l_nk))
      allocate( work_local(ldnh_miny:ldnh_maxy,Trp_12dmin:Trp_12dmax,
     %                                             G_ni+2+Ptopo_npex))
      allocate( ffx_local(Trp_12dmin:Trp_12dmax,Trp_22min:Trp_22max,
     %                                             G_nj+2+Ptopo_npey))
      allocate( derx_local(LDIST_SHAPE,l_nk))
      allocate( dery_local(LDIST_SHAPE,l_nk))

      call rpn_comm_xch_halo (difut1,LDIST_DIM,l_ni,l_nj,G_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
      call rpn_comm_xch_halo (difvt1,LDIST_DIM,l_ni,l_nj,G_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
      call rpn_comm_xch_halo (ugwdt1,LDIST_DIM,l_ni,l_nj,G_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
      call rpn_comm_xch_halo (vgwdt1,LDIST_DIM,l_ni,l_nj,G_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
 
*
*     Calculate kinetic energy of diffusion tendency
*     ===============================================

      i0 = 1
      in = G_ni
      j0 = 1
      jn = G_nj
      inn= 0
      if (G_lam) then
           inn=1
      endif
*
      if(Ens_bc_stat)then
         call glbstat (ut1   ,'UU',LDIST_DIM,G_nk,i0,in-inn,j0,jn,1,G_nk)
         call glbstat (vt1   ,'VV',LDIST_DIM,G_nk,i0,in,j0,jn-1  ,1,G_nk)
         call glbstat (difut1,'dU',LDIST_DIM,G_nk,i0,in-inn,j0,jn,1,G_nk)
         call glbstat (difvt1,'dV',LDIST_DIM,G_nk,i0,in,j0,jn-1  ,1,G_nk)
         call glbstat (tt1,   'T-',LDIST_DIM,G_nk,i0,in,j0,jn,    1,G_nk)
      endif
*
*     Diffusion backscatter
*
      dsp_dif=0.0
      if(Ens_bc_dif)then
        difut1=ut1*difut1 ; difvt1=vt1*difvt1
        call ens_uvduv (dsp_dif, difut1, difvt1, LDIST_DIM, l_nk )
*
        if(Ens_bc_stat)then
          call glbstat (difut1   ,'UdU',LDIST_DIM,G_nk,i0,in-inn,j0,jn,1,G_nk)
          call glbstat (difvt1   ,'VdV',LDIST_DIM,G_nk,i0,in,j0,jn-1  ,1,G_nk)
          call glbstat (dsp_dif,  'D'  ,LDIST_DIM,G_nk,i0,in,j0,jn,1,G_nk)
        endif
      endif
*
*     Gravity wave drag backscatter
*
      dsp_gwd=0.0
      if(Ens_bc_gwd)then
        difut1=ut1*ugwdt1 ; difvt1=vt1*vgwdt1
        call ens_uvgwd (dsp_gwd, difut1, difvt1, LDIST_DIM, l_nk )
*
        if(Ens_bc_stat)then
          call glbstat (difut1   ,'UGdU',LDIST_DIM,G_nk,i0,in-inn,j0,jn,1,G_nk)
          call glbstat (difvt1   ,'VGdV',LDIST_DIM,G_nk,i0,in,j0,jn-1  ,1,G_nk)
          call glbstat (dsp_gwd,  'DGUV',LDIST_DIM,G_nk,i0,in,j0,jn,1,G_nk)
        endif
      endif
*
      dsp_local=dsp_dif+dsp_gwd

*
*     Apply 2D Gaussian filter
*     ===================================================================

      call ens_filter_gauss(dble(Ens_bc_bfc),dble(Ens_bc_lam),dsp_local)

      if(Ens_bc_alpt/=0.0)then
         do k=1,l_nk
            do j=1,l_nj
               do i=1,l_ni
                  tt1(i,j,k)=tt1(i,j,k)+Ens_bc_alpt*cpdi*dsp_local(i,j,k)
     %                                                  *mcsph1(i,j,k)
               enddo
            enddo
         enddo
      endif
*
      do k=1,l_nk
         do j=1,l_nj
            do i=1,l_ni
* avant on a filtre le champ radical D chapeau
c               dsp_local(i,j,k)=dsp_local(i,j,k)*mcsph1(i,j,k)
* maintenant on a filtre le champ D chapeau
               dsp_local(i,j,k)=sqrt(dsp_local(i,j,k))*mcsph1(i,j,k)
            enddo
         enddo
      enddo
*
      if(Ens_bc_stat) then
         call glbstat (dsp_local,'DT',LDIST_DIM,G_nk,i0,in,j0,jn,    1,G_nk)
         call glbstat (tt1,      'T+',LDIST_DIM,G_nk,i0,in,j0,jn,    1,G_nk)
      endif
*
      call rpn_comm_xch_halo (dsp_local,LDIST_DIM,l_ni,l_nj,G_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)

      call rpn_comm_Barrier("grid", ierr)

*     Compute gradient of filtered field
*     ==================================
      i0 = 1
      in = l_niu
      j0 = 1
      jn = l_njv

      if ((G_lam).and.(l_west)) i0 = 2
      if (l_south) j0 = 2


      do k=1,l_nk
         do j= j0, jn 
            do i= i0, l_niu
               difut1(i,j,k)= aaa2*
     %                 (dsp_local(i,j,k)-dsp_local(i-1,j,k)) / geomg_hxu_8(i)
               difut1(i,j,k)=Ens_bc_alph*deltax*difut1(i,j,k)
               vt1(i,j,k) = vt1(i,j,k)+difut1(i,j,k)
            enddo
         enddo
*
         do j= j0, l_njv-pil_n
            do i= i0, in 
               difvt1(i,j,k)= aaa2*(dsp_local(i,j+1,k) - dsp_local(i,j,k))
     %                  *geomg_cy2_8(j)/geomg_hsyv_8(j)
               difvt1(i,j,k)= -Ens_bc_alph*deltax*difvt1(i,j,k)
               ut1(i,j,k) = ut1(i,j,k)+difvt1(i,j,k)
            enddo
         enddo
         if (.not.G_lam) then
            if (l_south) then
            do i = i0, in
               difut1(i,1,k)= 0.0
               difvt1(i,1,k)= 0.0
            end do
            endif

            if (l_north) then
            do i = i0, in
               difut1(i,l_nj,k)= 0.0
               difvt1(i,l_nj,k)= 0.0
            end do
            endif
         endif
      enddo
c ici      if (G_lam) then comme dans out_dq
      if(Ens_bc_stat) then
         call glbstat (mcsph1,'MC',1,l_ni,1,l_nj,G_nk,i0,in,    j0,jn,1,G_nk)
         call glbstat (difut1,'Dx',LDIST_DIM,G_nk,i0,in-inn,j0,jn,1,G_nk)
         call glbstat (difvt1,'Dy',LDIST_DIM,G_nk,i0,in,j0,jn-1  ,1,G_nk)
      endif
c
      if(Ens_bc_div)then
         call rpn_comm_xch_halo (difut1,LDIST_DIM,l_ni,l_nj,G_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
         call rpn_comm_xch_halo (difvt1,LDIST_DIM,l_ni,l_nj,G_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)


         i0 = 1
         in = l_niu
         j0 = 1
         jn = l_njv

         if ((G_lam).and.(l_west)) i0 = 2
         if (l_south) j0 = 2
         do k=1,l_nk
            do j= j0, l_njv-pil_n
               do i= i0, in 
                  derx_local(i,j,k)= aaa2*
     %                (difvt1(i,j,k)-difvt1(i-1,j,k)) / geomg_hxu_8(i)

               enddo
            enddo
*
            do j= j0, jn 
               do i= i0, l_niu
                  dery_local(i,j,k)= aaa2*(difut1(i,j,k) - difut1(i,j-1,k))
     %                  *geomg_cy2_8(j)/geomg_hsyv_8(j)- derx_local(i,j,k)
               enddo
            enddo
            if (.not.G_lam) then
               if (l_south) then
                  do i = i0, in
                     difut1(i,1,k)= 0.0
                     difvt1(i,1,k)= 0.0
                     difut1(i,2,k)= 0.0
                     difvt1(i,2,k)= 0.0
                  end do
               endif

               if (l_north) then
                  do i = i0, in
                     difut1(i,l_nj,k)= 0.0
                     difvt1(i,l_nj,k)= 0.0
                  end do
               endif
            endif
         enddo
         if(Ens_bc_stat)then
            call glbstat (dery_local,'DIV',LDIST_DIM,G_nk,i0,in,j0,jn,1,G_nk)
         endif
         endif
*
      deallocate(psi_local,dsp_local,work_local,ffx_local)
      deallocate(derx_local,dery_local)
      deallocate(dsp_dif,dsp_gwd)

      ierr = vmmuld( keys, 8 )

      end subroutine ens_filter
