***s/r genslabp - generate physic slab descriptors
*
#include <model_macros_f.h>
*
      subroutine genslabp ()
*
#include "impnone.cdk"
*
*
*author 
*     Joseph Pierre  Toviessi cmc/cmdn - april 1996
*
*revision
* v2_00 - Desgagne M.       - initial MPI version (from genslab v1_03)
* v2_10 - Lee V.            - modified to output any variable from the physics
* v2_10                       and moved redundant code into busslab
* v2_20 - Pellerin P.       - added entry bus for output
* v2_21 - Dugas B.          - adapt to climate mode
* v2_21 - J. P. Toviessi    - rename variable names "Slab" to "Pslab"
* v2_21 - Lee/Toviessi      - implement nomfichier and slabini
* v2_30 - V. Lee            - setup of grid definition for each slab output,
* v2_30                       open slab file only if PE should output anything,
* v2_30                       add control of filename extension here
* v2_31 - V. Lee            - changed Pslab_useit to Phy_useit
* v2_32 - V. Lee            - corrected minor bug for 'LO'(long)setup for busmul
* v3_00 - V. Lee            - physics output area is different for LAM
* v3_01 - V. Lee            - corrected MAX SLAB bug by moving inislabfhand to
* v3_01                       busslab routine
*
*object
*	This subroutine generates slab descriptors
*       and prepares for the output of physics slabs
*
*arguments
*       None
*
*implicits
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "dimout.cdk"
#include "lun.cdk"
#include "lctl.cdk"
#include "cstv.cdk"
#include "p_bus.cdk"
#include "dcst.cdk"
#include "slab.cdk"
#include "grid.cdk"
#include "pslab.cdk"
#include "ptopo.cdk"
#include "v4dg.cdk"
#include "outp.cdk"
*
*modules
      integer  doout,slabig34,p_getphydx
      external doout,slabig34,p_getphydx
**
      integer dostep(MAXSET),dostep_max,gridset,west,north,east,south
      integer ierr,pnibp,pnibd,pnibv,pnibe,i_idx
      integer mt,i,j,ii,jj,slabnum,ij
      integer grille_xmin,grille_xmax,grille_ymin,grille_ymax
      real busmul(maxbus),busadd(maxbus)
      logical output_in_PE_L 
      character*12 exten_S
*
*------------------------------------------------------------------
*
*  Determine if any slabs are to be outputted at this timestep
*
      dostep_max = doout(dostep,2)
*
      Pslab_slab = 0
      Pslab_fhand = -1
      if (dostep_max.gt.0) then
        if (Lun_out.gt.0) write(Lun_out,5000) Lctl_step
      else
        if (Lun_out.gt.0) write(Lun_out,5001) Lctl_step
        return
      endif
*
*   Determine the number of variables to be outputted from each bus 

*       pnibp for Permanent bus
*       pnibd for Dynamic bus
*       pnibv for Volatile bus
*       pnibe for Entry bus
*   
      pnibp = 0
      pnibd = 0
      pnibv = 0
      pnibe = 0
      do i = 1, P_bper_top
         if (Phy_useit(i).eq.1) then
            pnibp = pnibp + 1
         endif
      enddo
      do i = 1, P_bdyn_top
         if (Phy_useit(i+P_bper_top).eq.1) then
            pnibd = pnibd + 1
         endif
      enddo
      do i = 1, P_bvol_top
         if (Phy_useit(i+P_bper_top+P_bdyn_top).eq.1) then
            pnibv = pnibv + 1
         endif
      enddo
      if (Lctl_step.eq.0) then
          do i = 1, P_bent_top
             if (Phy_useit(i+P_bper_top+P_bdyn_top+P_bvol_top).eq.1) then
                 pnibe = pnibe + 1
             endif
          enddo
      endif

      if (pnibp+pnibd+pnibv+pnibe.eq.0) return

*  setup of ip2 and ip3
*
      Slab_ip2 = nint(float(Lctl_step)*Cstv_dt_8/3600.0)
      Slab_ip3 = 0
      if (V4dg_conf.ne.0) then
          Slab_ip3 =  V4dg_status
          if (V4dg_conf/100.eq.1.and.V4dg_ad_L)
     %        Slab_ip3 = 20 + V4dg_status
      endif
*
      output_in_PE_L = .false.

      Pslab_ni = p_ni
      north = 0
      south = 0
      east  = 0
      west  = 0
      if (G_lam) then
      if (l_north) north = 1
      if (l_south) south = 1
      if (l_east ) east  = 1
      if (l_west ) west  = 1
      endif
*
*  For each user-defined gridset, setup the grid definitions
      do gridset = 1, Grid_sets
         Pslab_ig1(gridset)=Grid_ig1(gridset)
         Pslab_x0(gridset)=max(Grid_x0(gridset),1+Lam_pil_w-p_nmp)
         Pslab_x1(gridset)=min(Grid_x1(gridset),G_ni-Lam_pil_e+p_nmp)
         Pslab_y0(gridset)=max(Grid_y0(gridset),1+Lam_pil_s-p_nmp)
         Pslab_y1(gridset)=min(Grid_y1(gridset),G_nj-Lam_pil_n+p_nmp)
         if (Pslab_x0(gridset).ne.Grid_x0(gridset))
     %          Pslab_ig1(gridset)=Grid_ig1(gridset)+100
         Grid_ig2(gridset)    = Grid_phi_ig2(gridset)
         Grid_nxgrid(gridset) = Pslab_x1(gridset)-Pslab_x0(gridset)+1
         Grid_nygrid(gridset) = Pslab_y1(gridset)-Pslab_y0(gridset)+1
         Grid_niout(gridset)  = Grid_nxgrid(gridset)
         Grid_njout(gridset)  = Grid_nygrid(gridset)
         if (Grid_nxgrid(gridset).eq.G_ni.and..not.G_lam)
     %       Grid_nxgrid(gridset)=G_ni+1

*  Find the local min and max of both X and Y for each local PE for output
*
         Pslab_xmin(gridset)=max( 
     %      Pslab_x0(gridset)-Ptopo_gindx(1,Ptopo_myproc+1)+1-p_offi,1)
         Pslab_xmax(gridset)=min(
     %      l_ni-(Ptopo_gindx(2,Ptopo_myproc+1)-Pslab_x1(gridset))-p_offi,p_ni)
         Pslab_ymin(gridset)=max(
     %             Pslab_y0(gridset)-Ptopo_gindx(3,Ptopo_myproc+1)+1-p_offj,1)
         Pslab_ymax(gridset)=min(
     %      l_nj-(Ptopo_gindx(4,Ptopo_myproc+1)-Pslab_y1(gridset))-p_offj,p_nj)

*  Setup the correct ig3 and ig4 for each PE
*
         grille_xmin = max(Pslab_x0(gridset),Ptopo_gindx(1,Ptopo_myproc+1))
         grille_xmax = min(Pslab_x1(gridset),Ptopo_gindx(2,Ptopo_myproc+1))
         grille_ymin = max(Pslab_y0(gridset),Ptopo_gindx(3,Ptopo_myproc+1))
         grille_ymax = min(Pslab_y1(gridset),Ptopo_gindx(4,Ptopo_myproc+1))
         grille_xmin = grille_xmin - Pslab_x0(gridset) +1
         grille_xmax = grille_xmax - Pslab_x0(gridset) +1
         grille_ymin = grille_ymin - Pslab_y0(gridset) +1
         grille_ymax = grille_ymax - Pslab_y0(gridset) +1
         Pslab_niout(gridset)=Pslab_xmax(gridset)-Pslab_xmin(gridset)+1
         Pslab_njout(gridset)=Pslab_ymax(gridset)-Pslab_ymin(gridset)+1

         if (Pslab_niout(gridset).gt.0.and.Pslab_njout(gridset).gt.0) then
             output_in_PE_L=.true.
             ierr= slabig34(Grid_ig3(gridset),Grid_ig4(gridset),
     %                 grille_xmin,grille_xmax,grille_ymin,grille_ymax)
             if (ierr.lt.0) then
                 if  (Lun_out.gt.0) write(Lun_out,*)'ERROR in slabig34'
                 call gem_stop('GENSLABP',-1)
             endif

             do j = Pslab_ymin(gridset), Pslab_ymax(gridset)
                do i = Pslab_xmin(gridset), Pslab_xmax(gridset)
                   ij= 1+i-Pslab_xmin(gridset)+
     %                (j-Pslab_ymin(gridset))*Pslab_niout(gridset)
                   Pslab_xnio(ij,gridset)=ij
                enddo
             enddo
         endif
      enddo
*
      if (.not. output_in_PE_L) return
*
*
*  Obtain the different slabs needed, based on the type of
*  grids used in the output. A slab type can only have one
*  grid configuration and point to one clump of data:
*  ie: busper,busdyn,busvol,busent

      do slabnum=1,PSLAB_SLAB_MAX
         Pslab_grid(slabnum) = 0
         do i=1,Pslab_mxout
            Pslab_mtas(i,slabnum) = 0
            Pslab_mtadd(i,slabnum) = 0
            Pslab_mtmul(i,slabnum) = 1.0
         end do
      end do
*
      do i=1,maxbus
         busadd(i)=0.0
         busmul(i)=1.0
      enddo
*
      if (pnibd.gt.0) then

*        Process the Dynamic Bus
         i_idx = P_bper_top
         call busslab(dynpar(1,1),dynpar(1,5),dynpar(1,6),dynon,busadd,
     %                busmul,dynpar(1,4),'D',P_bdyn_top,Outp_var,MAXELEM,
     %                Outp_lev,Outp_grid,Outp_step,Outp_var_max,Outp_sets,
     %                Outp_typvar_S,Phy_xnbits,Slab_ip2,i_idx,dostep,dostep_max)

      endif

      if (pnibv.gt.0) then

*        Process the Volatile Bus
         i_idx = P_bper_top+P_bdyn_top
         call busslab(volpar(1,1),volpar(1,5),volpar(1,6),volon,busadd,
     %                busmul,volpar(1,4),'V',P_bvol_top,Outp_var,MAXELEM,
     %                Outp_lev,Outp_grid,Outp_step,Outp_var_max,Outp_sets,
     %                Outp_typvar_S,Phy_xnbits,Slab_ip2,i_idx,dostep,dostep_max)

      endif
*
      if (pnibe.gt.0) then

*         Process the Entry Bus
          i_idx= P_bper_top+P_bdyn_top+P_bvol_top
          call busslab(entpar(1,1),entpar(1,5),entpar(1,6),enton,busadd,
     %                 busmul,entpar(1,4),'E',P_bent_top,Outp_var,MAXELEM,
     %                 Outp_lev,Outp_grid,Outp_step,Outp_var_max,Outp_sets,
     %                 Outp_typvar_S,Phy_xnbits,Slab_ip2,i_idx,dostep,dostep_max)

      endif
*
      if (pnibp.gt.0) then

*        Process the Permanent Bus
         i_idx=0
*
*        special setup for LA and LO fields from permanent bus
         i = p_getphydx('LA')
         if ( i .gt. 0 ) then
            busmul(i) = 180./Dcst_pi_8
         endif
         i= p_getphydx('LO')
         if ( i .gt. 0 ) then
            busmul(i) = 180./Dcst_pi_8
         endif
*
         call busslab(perpar(1,1),perpar(1,5),perpar(1,6),peron,busadd,
     %                busmul,perpar(1,4),'P',P_bper_top,Outp_var,MAXELEM,
     %                Outp_lev,Outp_grid,Outp_step,Outp_var_max,Outp_sets,
     %                Outp_typvar_S,Phy_xnbits,Slab_ip2,i_idx,dostep,dostep_max)

      endif
*
 5000 format(/,' GENSLABP - PHYSIC SLABS WILL BE WRITTEN FOR STEP (',
     $          I8,')')
 5001 format(/,' GENSLABP - NO PHYSIC OUTPUT FOR STEP (',I8,')')
*
      return
      end
