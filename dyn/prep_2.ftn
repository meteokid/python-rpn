! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r prep_2 - Add metric corrections to r.h.s. of momentum equations.
*               Compute advective contributions on geopotential grid.
*               Interpolate advection contribution from geopotential 
*               grid to wind grids. Update r.h.s with advective 
*               contributions.
*               Combine some rhs obtaining Rt", Rf" and Rc", the linear
*               contributions to the rhs of Helmholtz equation
*
#include "model_macros_f.h"
*
      subroutine prep_2 ( F_ru  ,F_rv  ,F_ruw1 ,F_ruw2 ,F_rvw1 ,F_rvw2, 
     $                    F_xct1,F_yct1,F_zct1 ,F_fis  ,F_rc   ,F_rt ,
     $                    F_rw  ,F_rf  ,F_oru  ,F_orv  ,
     $                    DIST_DIM, ni, nj, Nk )
*
      implicit none
*
      integer DIST_DIM, ni, nj, Nk
      real F_ru    (DIST_SHAPE,Nk)  ,F_rv    (DIST_SHAPE,Nk)  ,
     $     F_ruw1  (DIST_SHAPE,Nk)  ,F_ruw2  (DIST_SHAPE,Nk)  ,
     $     F_rvw1  (DIST_SHAPE,Nk)  ,F_rvw2  (DIST_SHAPE,Nk)  ,
     $     F_xct1  (ni,nj,Nk)       ,F_yct1  (ni,nj,Nk)       ,
     $     F_zct1  (ni,nj,Nk)       ,F_fis   (DIST_SHAPE)     ,
     $     F_rc    (DIST_SHAPE,Nk)  ,F_rt    (DIST_SHAPE,Nk+1),
     $     F_rw    (DIST_SHAPE,Nk+1),F_rf    (DIST_SHAPE,Nk+1),
     $     F_oru   (DIST_SHAPE,Nk)  ,F_orv   (DIST_SHAPE,Nk)
*
*author
*     Alain Patoine 
*
*revision
* v2_00 - Desgagne M.       - initial MPI version (from rhs v1_03)
* v2_21 - Lee V.            - modification for LAM version
* v2_31 - Desgagne M.       - remove stkmemw and switch to adw_*
* v3_00 - Desgagne & Lee    - Lam configuration
* v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
* v3_11 - Gravel S.         - modify for theoretical cases
* v_stg - Plante A.         - Staggered version
*
*object
*
*arguments
*     see appropriate comdeck documentation
*
*implicits
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "lun.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "grd.cdk"
#include "geomg.cdk"
#include "offc.cdk"
#include "schm.cdk"
#include "intuv.cdk"
#include "inuvl.cdk"
#include "type.cdk"
#include "adw.cdk"
#include "cori.cdk"
#include "ver.cdk"
#include "ptopo.cdk"
*
*modules
      integer i, j, k, i0, j0, in, jn, i00, inn, j00, jnn, longueur
      real*8  x, y, z, cx, cy, cz, rx, ry, rz, bbb, mumu, tot,
     $        a1,a2,a3, b1,b2,b3, zero, half, one, four, xxx, yyy, ww1
      real    rdiv(DIST_SHAPE), w_rt
*
      parameter( zero=0.d0, half=.5d0, one=1.d0, four=4.d0 )
**
*     __________________________________________________________________
*
******************************************************************
* Metric corrections to the RHS of horizontal momentum equations *
******************************************************************
      tot = - four*Dcst_omega_8/Cstv_dt_8
*
*     Coriolis term is zero for theoretical cases
*
      if( Schm_theoc_L ) tot = zero
      bbb = ( one - Offc_b0_8 ) / Offc_b0_8
*
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
      if (G_lam) then
         if (l_west)  i0= 1+pil_w -2
         if (l_east)  in= l_ni-pil_e +2
         if (l_south) j0= 1+pil_s -2
         if (l_north) jn= l_nj-pil_n +2
      endif

!$omp parallel private(x,y,z,rz,ry,rx,cx,cy,cz,
!$omp$                   mumu,rdiv,xxx,yyy,w_rt,ww1)
!$omp do
      do 100 k=1,l_nk
      do 100 j= j0, jn
      do 100 i= i0, in

*     Compute components of r(t0) and put in x, y, z
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         y = adw_cy_8(j)
         if (G_lam) then
         x = adw_cx_8(i) * y
         y = adw_sx_8(i) * y
         else
         x = adw_cx_8(l_i0 - 1 + i) * y
         y = adw_sx_8(l_i0 - 1 + i) * y
         endif
         z = adw_sy_8(j)

*     Compute (Rx, Ry, Rz) = (rx, ry, rz)
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         mumu = ( one + F_zct1(i,j,k) )*( one - F_zct1(i,j,k) )
         if (mumu .GT. zero) mumu = one / mumu

         rz = F_rvw2(i,j,k)
         ry =  mumu * (F_xct1(i,j,k)*F_ruw2(i,j,k)-
     $                 F_yct1(i,j,k)*F_zct1(i,j,k)*rz)
         rx = -mumu * (F_yct1(i,j,k)*F_ruw2(i,j,k)+
     $                 F_xct1(i,j,k)*F_zct1(i,j,k)*rz)

*     Compute components of (r - r~) and put in cx, cy, cz
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         cx = x - F_xct1(i,j,k)
         cy = y - F_yct1(i,j,k)
         cz = z - F_zct1(i,j,k)

*     Find components of Coriolis vector  2 * omg/tau * [k' ^ (r - r~)]
*     where geographic unit north vector  k' = r_13 I + r_23 J + r_33 K
*     Then substract them from (rx, ry, rz)
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         if (.not.Cori_cornl_L) then
         rx = rx + ( Grd_rot_8(2,3)*cz - Grd_rot_8(3,3)*cy )*tot
         ry = ry + ( Grd_rot_8(3,3)*cx - Grd_rot_8(1,3)*cz )*tot
         rz = rz + ( Grd_rot_8(1,3)*cy - Grd_rot_8(2,3)*cx )*tot
         endif

*     Compute components of c and put in cx, cy, cz 
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         cx = x + bbb*F_xct1(i,j,k)
         cy = y + bbb*F_yct1(i,j,k)
         cz = z + bbb*F_zct1(i,j,k)

*     Compute mu and modify (Rx,Ry,Rz)
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         mumu = - ( x*rx + y*ry + z*rz )/( x*cx + y*cy + z*cz )
         rx = rx + mumu*cx
         ry = ry + mumu*cy
         rz = rz + mumu*cz

*     Compute advective contributions on G-grid 
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         F_ruw2(i,j,k) = x*ry - y*rx - F_ruw1(i,j,k)
         F_rvw2(i,j,k) = rz - F_rvw1(i,j,k)
         
100   continue 
!$omp enddo
*
**********************************************************
* Final form of the RHS of horizontal momentum equations *
**********************************************************
!$omp single
      call rpn_comm_xch_halo( F_fis , LDIST_DIM, l_ni,l_nj,  1 ,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo( F_ruw2, LDIST_DIM, l_ni,l_nj,G_nk,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo( F_rvw2, LDIST_DIM, l_ni, l_nj,G_nk,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
*
*
      i0 = 1
      in = l_niu
      j0 = 1+pil_s
      jn = l_nj-pil_n
      if (G_lam) then
         if (l_west)  i0=1+pil_w
         if (l_east)  in=l_niu-pil_e
      endif
      j00 = 1
      jnn = l_njv
      i00 = 1+pil_w
      inn = l_ni-pil_e
      if (G_lam) then
         if (l_south) j00 = 1+pil_s
         if (l_north) jnn = l_njv-pil_n
      else
         if (l_south) j00 = 2
         if (l_north) jnn = l_njv-1
      endif
!$omp end single
*
!$omp do
      do k=1,l_nk 

*     Add advective contributions to Ru & Rv
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         do j= j0, jn
         do i= i0, in
            F_ru(i,j,k) =  F_oru(i,j,k) + 
     $                   inuvl_wxxu3_8(i,1)*F_ruw2(i-1,j,k)
     $                 + inuvl_wxxu3_8(i,2)*F_ruw2(i  ,j,k)
     $                 + inuvl_wxxu3_8(i,3)*F_ruw2(i+1,j,k)
     $                 + inuvl_wxxu3_8(i,4)*F_ruw2(i+2,j,k)
         end do
         end do
 
*
         do j= j00, jnn
         do i= i00, inn
            F_rv(i,j,k) =  F_orv(i,j,k) +
     $                   inuvl_wyyv3_8(j,1)*F_rvw2(i,j-1,k)
     $                 + inuvl_wyyv3_8(j,2)*F_rvw2(i,j  ,k)
     $                 + inuvl_wyyv3_8(j,3)*F_rvw2(i,j+1,k)
     $                 + inuvl_wyyv3_8(j,4)*F_rvw2(i,j+2,k)
         end do
         end do
         if (.not.G_lam) then
            if (l_south) then
            do i = 1, l_ni
            F_rv(i,1,k) = F_orv(i,1,k) +
     $                  inuvl_wyyv3_8(1,2)*F_rvw2(i,1,k)
     $                + inuvl_wyyv3_8(1,3)*F_rvw2(i,2,k)
     $                + inuvl_wyyv3_8(1,4)*F_rvw2(i,3,k)
            end do
            endif
            if (l_north) then
            do i = 1, l_ni
            F_rv(i,l_njv,k) = F_orv(i,l_njv,k) +
     $                      inuvl_wyyv3_8(l_njv,1)*F_rvw2(i,l_njv-1,k)
     $                    + inuvl_wyyv3_8(l_njv,2)*F_rvw2(i,l_njv  ,k)
     $                    + inuvl_wyyv3_8(l_njv,3)*F_rvw2(i,l_njv+1,k)
            end do
            endif
         endif

      end do
!$omp enddo
*
**************************************
* Combination of governing equations * 
**************************************
*
!$omp single
      a1 = one / ( Dcst_grav_8 * Cstv_tauT_8 )
      a2 = Ver_epsilon_8 / Cstv_RTstr_8
      a3 = one / ( Cstv_tau_8*Cstv_tauT_8 * Cstv_RTstr_8 )
*
      b1 = Ver_gamma_8 / Cstv_tau_8 
      b2 = Ver_gamma_8 / ( Dcst_cappa_8 * Cstv_tau_8 )
      b3 = Ver_epsilon_8 /Dcst_cappa_8
*
      call rpn_comm_xch_halo( F_ru, LDIST_DIM,l_niu,l_nj,G_nk,
     $             G_halox,G_haloy,G_periodx,G_periody,l_ni,0 ) 
      call rpn_comm_xch_halo( F_rv, LDIST_DIM,l_ni,l_njv,G_nk,
     $             G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
!$omp end single
*
!$omp do
      do k=1,l_nk
*
*        Computing the divergence of the RHS of momentum equations
*        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         if (G_lam) then
             do j= 1+pil_s, l_nj-pil_n
             do i= 1+pil_w, l_ni-pil_e
                rdiv(i,j) = ( F_ru(i,j,k) - F_ru(i-1,j,k) )
     $                        / ( geomg_cy2_8(j)*geomg_hxu_8(i-1) )
     $                    + ( F_rv(i,j,k) - F_rv(i,j-1,k) )
     $                        * geomg_invhsyv_8(j-1)
             end do
             end do
         else
             call caldiv_2 ( rdiv, F_ru(minx,miny,k),
     $                             F_rv(minx,miny,k), LDIST_DIM, 1)
         endif
*
*        Combining divergence & continuity equations : Rc'
*        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         if(Cstv_iC2str_8.eq.0.d0) then
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_ni-pil_e
               F_rc(i,j,k) = rdiv(i,j) - F_rc(i,j,k) / Cstv_tau_8
            end do
            end do
         else if(Cstv_iC2str_8.gt.(1.1-Dcst_cappa_8)/Cstv_RTstr_8) then
            xxx=half*Cstv_iC2str_8*Ver_idz_8%m(k)*Ver_dz_8%t(k+1)
            yyy=half*Cstv_iC2str_8*Ver_idz_8%m(k)*Ver_dz_8%t(k)
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_ni-pil_e
               ww1=xxx*F_rf(i,j,k+1)+yyy*F_rf(i,j,k)
               F_rc(i,j,k) = rdiv(i,j) - (F_rc(i,j,k)-ww1) / Cstv_tau_8
            end do
            end do
         else
            xxx=half*Ver_idz_8%m(k)*Ver_dz_8%t(k+1)
            yyy=half*Ver_idz_8%m(k)*Ver_dz_8%t(k)
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_ni-pil_e
               ww1=xxx*(Cstv_iC2str_8*F_rf(i,j,k+1)+F_rt(i,j,k+1))
     $            +yyy*(Cstv_iC2str_8*F_rf(i,j,k  )+F_rt(i,j,k  ))
               F_rc(i,j,k) = rdiv(i,j) - (F_rc(i,j,k)-ww1) / Cstv_tau_8
            end do
            end do
         endif
*
      end do
!$omp enddo
*
!$omp do
      do k=1,l_nk+1
*
*        Computing Rt" & Rf"
*        ~~~~~~~~~~~~~~~~~~~
*        combining Rw and Rf with Rt in two different ways
*
         if (Schm_hydro_L) then
*           ~~~~~~~~~~~
*           hydrostatic
*           ~~~~~~~~~~~
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_ni-pil_e
               F_rf(i,j,k) =      F_rt(i,j,k)
     $                          - Dcst_cappa_8/Cstv_RTstr_8*F_rf(i,j,k)
               F_rt(i,j,k) = b2 * F_rt(i,j,k)
            end do
            end do
         else
*           ~~~~~~~~~~~~~~~
*           non-hydrostatic
*           ~~~~~~~~~~~~~~~
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_ni-pil_e
               w_rt        = F_rt(i,j,k)
*              Computing Rf'
*              ~~~~~~~~~~~~~
               F_rf(i,j,k) = a1 *   F_rw(i,j,k) +  a2 * F_rf(i,j,k) 
*              Computing Rt"
*              ~~~~~~~~~~~~~
               F_rt(i,j,k) = b2 *   F_rt(i,j,k) +  b2 * F_rf(i,j,k)
*              Computing Rf"
*              ~~~~~~~~~~~~~
               F_rf(i,j,k) = b1 * ( F_rf(i,j,k) -  b3 * w_rt      )
            end do
            end do
         endif 
      enddo
!$omp enddo
*
*************************************************************
* The linear contributions to the RHS of Helmholtz equation *
*************************************************************
*
*     Finish computations of RP(Rc"), combining Rc', Rt", Rf" 
*     and applying boundary conditions
*
!$omp do
      do k=1,l_nk
         xxx=one + half * Ver_dz_8%t(k+1)
         yyy=one - half * Ver_dz_8%t(k)
         do j= 1+pil_s, l_nj-pil_n
         do i= 1+pil_w, l_ni-pil_e
            F_rc(i,j,k) = Ver_dz_8%m(k) * F_rc(i,j,k) 
     $                     - xxx * F_rt(i,j,k+1) + yyy * F_rt(i,j,k)
         end do
         end do
         if (.not. Schm_hydro_L) then    
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_ni-pil_e
               F_rc(i,j,k) = F_rc(i,j,k) + half *
     $                          ( Ver_dz_8%t(k  ) * F_rf(i,j,k  )
     $                          + Ver_dz_8%t(k+1) * F_rf(i,j,k+1) )
            end do
            end do
         endif
      end do
!$omp enddo
!$omp do
*     Applying boundary conditions.
      do j= 1+pil_s, l_nj-pil_n
      do i= 1+pil_w, l_ni-pil_e
         F_rt  (i,j,l_nk+1) = F_rt  (i,j,l_nk+1) - a3 * F_fis(i,j)
         F_rc(i,j,1)      = F_rc(i,j,1)
     $                                - Ver_cstp_8 * F_rt(i,j,1)
         F_rc(i,j,l_nk)   = F_rc(i,j,l_nk)
     $                                + Ver_cssp_8 * F_rt(i,j,l_nk+1)
      end do
      end do
!$omp enddo      
!$omp end parallel
*
*     __________________________________________________________________
*
      return
      end
