! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r out_qc0 - perform qc output at timestep 0
*
#include "model_macros_f.h"
*
      subroutine out_qc0 ()
*
*implicits
*
      implicit none
*
*
*author 
*     V. Lee    - rpn - july 2004
*
*revision
* v3_20 - Lee V.            - initial MPI version (from blocqc0 v3_12)
* v3_30 - McTaggart-Cowan R.- allow for user-defined domain tag extensions
* v3_31 - Lee V.            - bugfix for requested QC but does not exist in PHY
* v4_03 - Lee V.            - modification of Out_etik_S in out_sgrid only
*
*object
*     the output of the QC at timestep 0
*
*arguments
*  NONE
*
*implicits
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "lun.cdk"
#include "geomn.cdk"
#include "schm.cdk"
#include "pres.cdk"
#include "init.cdk"
#include "rstr.cdk"
#include "out3.cdk"
#include "out.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "ptopo.cdk"
#include "tr3d.cdk"
#include "grd.cdk"
#include "grid.cdk"
#include "lctl.cdk"
#include "vt1.cdk"
#include "cstv.cdk"
#include "type.cdk"
#include "ver.cdk"
*
**
      integer doout, longueur,
     $        vmmlod, vmmuld, vmmget, vmmuln
      external doout, longueur,
     $         vmmlod, vmmuld, vmmget, vmmuln
*
      integer err,nrec,dostep(MAXSET),dostep_max,step,key0,key1,
     $        i,j,k,trkey1(Tr3d_ntr),qcset(MAXSET),qcset_max
      character*4 ext_S
      integer i0,in,j0,jn,ii,jj,kk,levset,n,ip3,pnerr,nk_o,nk_ot
      integer qcnbit,qcfilt
      integer,   dimension(:), allocatable :: ind_o
      real, dimension(:,:,:), allocatable :: w5
      real, dimension(:), allocatable :: prprlvl
      real wlnpi_m(LDIST_SHAPE,0:G_nk+1), wlnpi_t(LDIST_SHAPE,G_nk+2)
      real px_ta(LDIST_SHAPE,G_nk+2),qc(LDIST_SHAPE,G_nk+2)
      real deg2rad,qccoef,qct1
      pointer (paqc, qct1(LDIST_SHAPE,*))
      logical periodx_L

**
*
*     check if output is required and initialize control tables
*     ---------------------------------------------------------------
*
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
      dostep_max = doout(dostep,1)
      deg2rad    = acos( -1.0)/180.

      if (dostep_max .le. 0) return

*     CHECK IF QC AT TIMESTEP 0 is requested

      ext_S=""
      qcset_max = 0
      do jj=1,dostep_max
      do kk=1, Outd_sets
         if ( Outd_step(kk).eq.dostep(jj) ) then
            do ii =1,Outd_var_max(kk)
               if (Outd_var_S(ii,kk).eq.'QC') then
                   qcset_max = qcset_max + 1
                   qcset(qcset_max) = kk
                   qcnbit = Outd_nbit(ii,kk)
                   qcfilt = Outd_filtpass(ii,kk)
                   qccoef = Outd_filtcoef(ii,kk)
               endif
            enddo
         endif
      enddo
      enddo

      if ( qcset_max.le.0 ) return

*     PREPARATION of wlnpi_t for out_qc0 
*    ---------------------------

      key0 = VMM_KEY(st1)
      err = vmmlod (key0,1)
      err = VMM_GET_VAR(st1)
*
*        Log-pressure on momentum and thermo levels,
*        with extra momentum levels at top (k=0) and surface (k=G_nk+1)
*        and with an extra thermo level at surface (k=G_nk+2)
*
         wlnpi_m(:,:,0)= Cstv_Ztop_8
         do k=1,G_nk+1
            do j=1,l_nj
            do i=1,l_ni
               wlnpi_m(i,j,k) = Ver_a_8%m(k)
     %                        + Ver_b_8%m(k)*st1(i,j)
               wlnpi_t(i,j,k)=.5d0*(wlnpi_m(i,j,k)+wlnpi_m(i,j,k-1))
            enddo
            enddo
         enddo

         do j=1,l_nj
         do i=1,l_ni
            wlnpi_t(i,j,G_nk+2)=wlnpi_m(i,j,G_nk+1)
         enddo
         enddo

*     setup of ip3

      ip3 = 0
      if (Out3_ip3.eq.-1) ip3 = Lctl_step
      if (Out3_ip3.gt.0 ) ip3 = Out3_ip3

      qc = 0.
      paqc = loc(qc)
      
      key1 = VMM_KEY (trt1)
      do k=1,Tr3d_ntr
         trkey1(k) = key1 + k
      enddo
      pnerr = vmmlod(trkey1,Tr3d_ntr)
      do n=1, Tr3d_ntr
         if (Tr3d_name_S(n).eq.'QC') then
             pnerr = vmmget(trkey1(n),paqc,qct1)
         endif
      enddo
      do j= 1, l_nj
      do i= 1, l_ni
         qct1(i,j,G_nk+2) = qct1(i,j,G_nk+1)
      enddo
      enddo

*     output loop on the number of "sortie" sets

      do 100 n=1, qcset_max
          kk = qcset(n)
          periodx_L=.false.
          if (.not.G_lam .and. 
     $         (Grid_x1(Outd_grid(kk))-Grid_x0(Outd_grid(kk))+1)
     $                                    .eq. G_ni ) periodx_L=.true.
          call out_sgrid(Grid_x0(outd_grid(kk)),Grid_x1(outd_grid(kk)),
     $                   Grid_y0(outd_grid(kk)),Grid_y1(outd_grid(kk)),
     $                   periodx_L, Grid_stride(outd_grid(kk)),
     $                   Grid_etikext_s(outd_grid(kk)),' ' )

          levset = Outd_lev(kk)

          nk_o   = Level_max(levset)
          allocate (ind_o(nk_o+2))

          call out_slev(Level_typ(levset),Level(1,levset),
     $                    ind_o,nk_o,nk_ot,G_nk,Level_kind_ip1,'d')
          call out_sfile(Out3_closestep,Lctl_step,ip3,ext_S)
          call out_href(Grid_ig1(outd_grid(kk)),Grid_ig2(outd_grid(kk)),
     $                  Geomn_longs,Geomn_latgs)
 
          if (Out_levtyp_S.eq.'M') then
              call out_vref(st1,l_minx,l_maxx,l_miny,l_maxy)
              if ( Out3_cliph_L ) then
                   allocate(w5(LDIST_SHAPE,G_nk+2))
                   do k= 1, G_nk+2
                   do j= 1, l_nj
                   do i= 1, l_ni
                      w5(i,j,k) = amax1( qct1(i,j,k), 0. )
                   enddo
                   enddo
                   enddo
              call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,
     $                Ver_hyb%t, 'QC  ',1.0,0.0,  Out_kind,G_nk+2, 
     $                ind_o, nk_ot, qcnbit )
              deallocate(w5)
              else
              call ecris_fst2(qct1,l_minx,l_maxx,l_miny,l_maxy,
     $                Ver_hyb%t, 'QC  ',1.0,0.0,  Out_kind,G_nk+2, 
     $                ind_o, nk_ot, qcnbit )
              endif
          else
              call verder(px_ta, qct1, wlnpi_t, 2.0,2.0,
     $                      l_minx,l_maxx,l_miny,l_maxy, G_nk+2,
     $                      1,l_ni,1,l_nj)

              allocate(w5(LDIST_SHAPE,nk_o))
              allocate( prprlvl(nk_o) )

              do i=1,nk_o
                 prprlvl(i) = Level(i,levset) * 100.0
              enddo

*             Calculate QC (w5=qc_pres,px=vert.der)
              call prgen( w5, qct1, px_ta, wlnpi_t, prprlvl,nk_o,
     $                    Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy, G_nk+2)
              if ( Out3_cliph_L ) then
                   do k= 1, nk_o
                   do j= 1, l_nj
                   do i= 1, l_ni
                      w5(i,j,k) = amax1( w5(i,j,k), 0. )
                   enddo
                   enddo
                   enddo
              endif

              if (qcfilt.gt.0)
     $            call filter(w5,qcfilt,qccoef,'G', .false.,
     $                  l_minx,l_maxx,l_miny,l_maxy, nk_o)
              call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,Level(1,levset),
     $              'QC  ',1.0,       0.0, Out_kind,nk_o, ind_o, nk_o, qcnbit )

              deallocate(w5,prprlvl)

          endif

          deallocate(ind_o)

          call out_cfile

 100  continue

      pnerr = vmmuln(key0,1)
      pnerr = vmmuln(trkey1,Tr3d_ntr)

      return
      end

