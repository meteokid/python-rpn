!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r itf_phy_puti - 
!
#include "model_macros_f.h"
Integer Function itf_phy_puti(vd,opt) 

     Use phy_input_types
     Use phy_input_iface, Only : phy_simple_transforms
     Implicit None

     Type(variable), Pointer                  :: vd,temp,next
     Type(input_options)                      :: opt
     Type(input_dimensions), dimension(nip1)  :: idim
     Character(len=1), dimension(nip1)        ::  grd,grref

      Integer, External :: fnom, fstouv, fstinf, fstprm, fstfrm, fclos, fstopc
      Integer, External :: fstluk, fstinl, wkoffit, ezgdef_fmem, ezdefset
      Integer, External :: ezsetopt, ip1_all, bmf_get, ezsint
      Logical, External :: samegrid
      character , parameter :: esc = char( 27 )
!
!Author
!     Lubos Spacek - October 2009
!
!Revision
! v4_10 - Spacek, L.     - First revision
!
!Object
!     The function provides all arrays necessary for isba.
!     Different from itf_phy_puti_isba in that
!     the interpolation is done by local processors.
!
!Arguments
!          - Output -
! vd       Structure containing desired descriptors
!
!          - Input -
! opt      allowed options: geol_hsea,geol_poin,z0cst
!
!Implicits
#include "hgc.cdk"
#include "modconst.cdk"
#include "geomn.cdk"
#include "geomg.cdk"
#include "itf_phy_buses.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "bmf.cdk"
#include "path.cdk"
#include "ptopo.cdk"
#include "lun.cdk"
#include "lctl.cdk"

      Integer :: i,j,k,ii,ij,ik,nf, nft, nr, iun=10, iok, ier,jer
      Integer :: target_file, tip
      Integer :: dte, det, ipas, p1, p2, p3, g1, g2, g3, g4, bit
      Integer :: dty, swa, lng, dlf, ubc, ex1, ex2, ex3
      Integer :: dum0,dum1,dum2,dum3,dum4,month,day,moa,jj
      Integer :: ni,nj,nk,nijk,sgid,dgid,kind,key,indx,indi,indj,offi,offj
      Integer, Parameter :: nmax=100, fmax=50, lenmax=150
      Integer, Dimension(nip1,4) :: keys,istat
      Logical :: found_L=.False.,interp_L, flag
      Character(LEN=1) :: typ
      Character(LEN=4) :: var
      Character(LEN=12):: lab,cdum
      Character(LEN=lenmax), Dimension(fmax) :: file_found
      Character(LEN=lenmax+15):: command
      Real, Allocatable, Dimension(:,:) :: globalf,localf,field,field2,larr
      Real, Allocatable, Dimension(:)   :: ax,ay,xfi,yfi
!
      real :: zp1,poa,poam,sum,sumt
      real :: busent, busper
      real(kind=8)  :: rad2deg_8
      pointer (pabusper,busper(*))
      pointer (pabusent,busent(*))
!
temp=>vd
ier = fstopc('MSGLVL','SYSTEM',0)
ier = fstopc('TOLRNC','SYSTEM',0)
IF(Lun_debug_L)ier = fstopc('MSGLVL','INFORM',0)
IF(Lun_debug_L)ier = fstopc('TOLRNC','INFORM',0)
 Call prsdate (dum0,month,day,dum1,dum2,dum3,dum4,Mod_runstrt_S)
ier=Define_grids()
flag=.true.;itf_phy_puti=-1
!
If(Ptopo_myproc==0)&
Write(Lun_out,"(/,'PHYSICS ENTRY (S/R ITF_PHY_PUTI)',/,32('='),/)")
IF(Lun_debug_L)Call Print_stack()
If(Ptopo_myproc==0)Allocate(globalf(G_ni,G_nj),Stat=ier)
     Allocate(localf(l_ni,l_nj),larr(l_minx:l_maxx,l_miny:l_maxy),Stat=ier)
!
Main1 : Do
! Initialization
  nft=Count_files()
!
If(nft/=0)then
istat=0
Do target_file=1,nft
  idim=input_dimensions(-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1)
  If(Locate_key(keys)<0)Cycle
!
   do tip=1,vd%p_nu

      call RPN_COMM_bcast (idim(tip),11,"MPI_INTEGER"  ,0,"grid",ier)
      call RPN_COMM_bcastc(grd(tip), 1,"MPI_CHARACTER",0,"grid",ier)

      nijk=idim(tip)%ni*idim(tip)%nj*idim(tip)%nk
      allocate (field(idim(tip)%ni,idim(tip)%nj))
      allocate(ax(idim(tip)%ni),ay(idim(tip)%nj))
!
      If(grd(tip)=='Z')Then
        If(Ptopo_myproc==0)then
           interp_L=samegrid(iun,idim(tip)%ni,idim(tip)%nj, &
                    idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,&
                    Hgc_ig1ro,Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro,xfi,yfi)
        Endif
        Call RPN_COMM_bcast (interp_L,1,"MPI_LOGICAL"  ,0,"grid",ier)
        If(.not.interp_L)Then
          ier=Read_Axes()
          call RPN_COMM_bcastc(grref(tip), 1,"MPI_CHARACTER",0,"grid",ier)
          call RPN_COMM_bcast (ax   ,idim(tip)%ni,"MPI_REAL"  ,0,"grid",ier)
          call RPN_COMM_bcast (ay   ,idim(tip)%nj,"MPI_REAL"  ,0,"grid",ier)
          sgid = ezgdef_fmem(idim(tip)%ni,idim(tip)%nj,grd(tip),grref(tip),&
           idim(tip)%rig1,idim(tip)%rig2,idim(tip)%rig3,idim(tip)%rig4, ax, ay)
        Endif
     Else
        interp_L=.false.
        sgid = ezgdef_fmem(idim(tip)%ni,idim(tip)%nj, grd(tip),grref(tip),&
            idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,idim(tip)%ig4, ax, ay)

     Endif
!
     istat(tip,target_file)=Read_field()
        If(interp_L)Then
           call glbdist (field,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1,0,0)
           If(Ptopo_myproc==0)write(*,*)'SAMEGRID ',vd%nomvar,vd%ip1(tip)
        Else
           call RPN_COMM_bcast (field,nijk   ,"MPI_REAL"  ,0,"grid",ier)
           ier = ezdefset ( dgid, sgid )
           ier = ezsetopt ('INTERP_DEGREE', vd%interp)
!           ier = ezsint(vd%values(:,:,tip), field)
           ier = ezsint(localf, field)
        Endif
        ier=phy_simple_transforms(vd%phyvar,opt%z0cst,localf)
        vd%values(:,:,tip)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
        Call Print_Stat(localf)
        deallocate(field,ax,ay)
   enddo
   If(Ptopo_myproc==0)Then
      ier=fstfrm(iun);ier=fclos(iun)
   Endif
   If(Sum(istat(:,target_file))==vd%p_nu)Exit
Enddo
!
flag=Final_check(flag)

!
!    nft=0
!
   ElseIf(NFT==0)Then
      If(vd%phyvar=='DLAT')localf=Geomn_latrx
      If(vd%phyvar=='DLON')localf=Geomn_lonrx
      If(vd%phyvar=='MF') Then
        ier = bmf_get ('ME  ',bmf_time1,bmf_time2,-1,localf,-1.,&
                                              1,l_ni,1,l_nj,1,1)
        call handle_error_l(ier==0,'itf_phy_puti','put_info 1')
        Call bmf_clear
      Endif
      If(vd%phyvar=='DXDY') Then
         do j=1,l_nj
         do i=1,l_ni
            localf(i,j)= geomg_hxu_8(i-1)*geomg_hyv_8(j-1)*     &
                         Dcst_rayt_8*Dcst_rayt_8*geomg_cy_8(j)
         enddo
         enddo
      Endif
      If(vd%phyvar=='EPONMOD') call itf_phy_vlsp (localf)
      ier=phy_simple_transforms(vd%phyvar,opt%z0cst,localf)
      vd%values(:,:,1)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
      Call Print_Stat(localf)
   Endif
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
End Do Main1
   vd=>temp
!
if(Ptopo_myproc==0)Write(*,"(a/72('='))")'PROCESSING ANCIENT GEOBUS'

main2 : Do
   If(vd%bper_L) then     ! bper
      Do j=1,p_nj
         ij=vd%findx+(j-1)*p_bper_siz
         Do k=1,vd%p_nu
            ik=ij+(k-1)*p_ni
            Phy_busper3D(ik:ik+p_ni-1)=vd%values(:,j,k)
         Enddo
      Enddo
   Else                ! bent
      Do j=1,p_nj
         ij=vd%findx+(j-1)*p_bent_siz
         Do k=1,vd%p_nu
            ik=ij+(k-1)*p_ni
            geofld(ik:ik+p_ni-1)=vd%values(:,j,k)
         Enddo
      Enddo
   Endif
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
End Do main2
!
If(flag.and.Ptopo_myproc==0)write(*,*)'All variables found!'
call handle_error_l(flag,'itf_phy_puti','Missing variables, see the listing')

vd=>temp
!
Deallocate(localf,xfi,yfi)
If(Ptopo_myproc==0)Deallocate(globalf,Stat=ier)
itf_phy_puti=1
!!
contains
!
Integer Function Locate_key(keys)
!
Implicit None
Integer,Dimension(30,4) :: keys
Locate_key=-1;keys=-1
!
if(Ptopo_myproc==0)then
   ier = fnom   (iun,Trim(vd%file(target_file)),'RND+OLD+R/O',0)
   ier = fstouv (iun,'RND')

   Do tip=1,vd%p_nu
   If(vd%search(target_file)/='V')then
      keys(tip,1) = Locate_ip1()
      Locate_key=Sign(1,keys(tip,1))
   Else
      if ( day .gt. 15 ) then
         jj = 32 - day
         if ( jj .gt. 15 ) jj = 15
         moa = month + 1
         if ( month .eq. 12 ) moa = 1
      else
         jj = day
         moa = month - 1
         if ( month .eq. 1 ) moa = 12
      endif
      poa = ( jj + 13 ) / 28.
      poam = 1. - poa

      vd%ip2=month
      keys(tip,1) = Locate_ip1()
      vd%ip2=moa
      keys(tip,2) = Locate_ip1()
      if(keys(tip,2)<=0)Write(*,*)'Error fstinf ',Trim(vd%file(target_file))
      Locate_key=Sign(1,keys(tip,1))*Sign(1,keys(tip,2))
   Endif
!
   If(Locate_key>=0)then
      ier = fstprm (keys(tip,1),dte,det,ipas,&
                   idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,bit,dty, &
                   p1,p2, p3, typ, var, lab, grd(tip),&
                   idim(tip)%ig1, idim(tip)%ig2, idim(tip)%ig3, idim(tip)%ig4,&
                   swa, lng, dlf, ubc, ex1, ex2, ex3)

      If(grd(tip)=='Z')Then
        keys(tip,3) = fstinf (iun, ni,nj,nk,-1,' ',&
                     idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,' ','>>')
        keys(tip,4) = fstinf (iun, ni,nj,nk,-1,'',&
                     idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,'','^^')

        ier = fstprm (keys(tip,3),dte,det,ipas,ni,nj,nk,bit,dty,&
                      p1, p2, p3, typ, var, lab, grref(tip),&
                      idim(tip)%rig1, idim(tip)%rig2,&
                      idim(tip)%rig3, idim(tip)%rig4, swa,&
                      lng, dlf, ubc, ex1, ex2, ex3)
      Endif
   Else
      ier=fstfrm(iun);ier=fclos(iun)
   Endif
   Enddo
Endif
call RPN_COMM_bcast (Locate_key,1,"MPI_INTEGER"  ,0,"grid",ier)
!
End Function Locate_key
!
Integer Function Locate_ip1()
If (vd%ip1(tip) .eq. -1 .or. vd%ip1(tip) .eq. 0 ) then
   Locate_ip1 = fstinf (iun, idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,vd%datev,vd%etk,&
                     vd%ip1(tip),vd%ip2,vd%ip3,vd%typvar,vd%nomvar )
  else
   call convip ( vd%ip1(tip), zp1, kind, -1, cdum, .false. )
   Locate_ip1 = fstinf (iun, idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,vd%datev,vd%etk,&
                     ip1_all(zp1,kind),vd%ip2,vd%ip3,vd%typvar,vd%nomvar )
Endif
End Function Locate_ip1
!
Integer Function Read_axes()
Read_axes=-1
if(Ptopo_myproc==0)then
      if( keys(tip,3)>0)then
          ier = fstluk( ax, keys(tip,3), idim(tip)%ni,1,      1)
          jer = fstluk( ay, keys(tip,4), 1,      idim(tip)%nj,1)
          Read_axes = ier*jer
      endif
endif
call RPN_COMM_bcast (Read_axes,1,"MPI_INTEGER"  ,0,"grid",ier)
End Function Read_axes
!
Integer Function Read_field()
if(Ptopo_myproc==0)then
Read_field=-1
   ier = fstluk( field, keys(tip,1), idim(tip)%ni,idim(tip)%nj,idim(tip)%nk)
   if( keys(tip,2)>0)then
       allocate(field2(idim(tip)%ni,idim(tip)%nj))
       ier = fstluk( field2, keys(tip,2), idim(tip)%ni,idim(tip)%nj,idim(tip)%nk)
       field = poa*field + poam*field2
       deallocate(field2)
   endif
Read_field=1
Endif
call RPN_COMM_bcast (Read_field,1,"MPI_INTEGER"  ,0,"grid",ier)
!
End function Read_field
!
Integer Function Define_grids()
!
!
! Local grid
!
if(.false.)then
  allocate(xfi(p_ni),yfi(p_nj))
   rad2deg_8 = 180.0d0/acos(-1.d0)
  offi = Ptopo_gindx(1,Ptopo_myproc+1)-1
  offj = Ptopo_gindx(3,Ptopo_myproc+1)-1
  do i=1,p_ni
     indx = p_offi + offi + i
     xfi(i) = G_xg_8(indx)*rad2deg_8
  end do
  do i=1,p_nj
     indx = p_offj + offj + i
     yfi(i) = G_yg_8(indx)*rad2deg_8
  end do
  dgid = ezgdef_fmem (p_ni , p_nj , 'Z', 'E', Hgc_ig1ro,&
          Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
deallocate(xfi,yfi)
endif
  allocate(xfi(l_ni),yfi(l_nj))
   rad2deg_8 = 180.0d0/acos(-1.d0)
  offi = Ptopo_gindx(1,Ptopo_myproc+1)-1
  offj = Ptopo_gindx(3,Ptopo_myproc+1)-1
  do i=1,l_ni
     indx = offi + i
     xfi(i) = G_xg_8(indx)*rad2deg_8
  end do
  do i=1,l_nj
     indx = offj + i
     yfi(i) = G_yg_8(indx)*rad2deg_8
  end do
  dgid = ezgdef_fmem (l_ni , l_nj , 'Z', 'E', Hgc_ig1ro,&
          Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
deallocate(xfi,yfi)
!
! Global grid
!
  allocate(xfi(G_ni+1),yfi(G_nj))
   rad2deg_8 = 180.0d0/acos(-1.d0)
  do i=1,G_ni+1
     xfi(i) = G_xg_8(i)*rad2deg_8
  end do
  do i=1,G_nj
     yfi(i) = G_yg_8(i)*rad2deg_8
  end do
  dstf_gid = ezgdef_fmem (G_ni , G_nj , 'Z', 'E', Hgc_ig1ro,&
          Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
End Function Define_grids
!
Integer Function Count_files()
Count_files=0
If(Ptopo_myproc==0)then
   nf=0;nft=1;nr=0;
   file_found=''
! File names
      Do i=1,nfiles
         If(Len_trim(vd%file(i))/=0)Then
            nf=nf+1
            vd%file(nf)=Trim(Path_phy_S)//Trim(vd%file(i))
         Endif
      Enddo
   Do i=1,nreps
      If(Len_trim(vd%rep(i))/=0)nr=nr+1
   Enddo

   Do i = 1,nf
      Inquire (FILE=Trim(vd%file(i)),EXIST=found_L)
      If(.Not.found_L)Cycle
      ier=wkoffit(Trim(vd%file(i)))
      If((ier/=1).And.(ier/=2).And.(ier/=33).And.(ier/=34))Then
         Write (*,"('Format unknown',a)") Trim(vd%file(i))
         Cycle
      Endif
      file_found(nft)=vd%file(i)
      nft=nft+1
   Enddo
   Count_files=nft-1
Endif
call RPN_COMM_bcast (Count_files,1,"MPI_INTEGER"  ,0,"grid",ier)
!
End Function Count_files
!
Logical Function Final_check(flag)
 Integer :: i,j,k
 Logical :: flag
!
If(Ptopo_myproc==0)then
 Do j=1,vd%p_nu
    If(Sum(istat(j,:))==0)Then
       write (*,'( a1 , "[" , i2 , "m" )',advance='no') esc , 91 !46
!       write(*,6000)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j)
       write(*,6000,advance='no')Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j)
       write (*,'( a3 )') esc // "[m"
       flag=.false.
    Else
       If(interp_L)then
         write(*,6010)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j)
       Else
         write(*,6020)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j)
       Endif
    Endif
 Enddo
 Final_check=flag
Endif
 6000 Format(/,'!!! Error', 72('*'),/,'     Variable ',a,' alias ',a,&
             ' not available at level ',i5,/,'!!! Error',72('*'),/)
 6010 Format('     Variable ',a,' alias ',a,&
             '  distributed at level ',i5,/)
 6020 Format('     Variable ',a,' alias ',a,&
             ' interpolated at level ',i5,/)
call RPN_COMM_bcast (Final_check,1,"MPI_LOGICAL"  ,0,"grid",ier)
!
End Function Final_check
Subroutine Print_stack
temp=>vd
  Do
   Write(Lun_out,6000)
   write(Lun_out,6010)vd%nomvar,vd%phyvar,vd%interp,vd%search,vd%etk,&
   vd%typvar,vd%findx
   write(Lun_out,"('IP1',2(15i5,/,3x))")vd%ip1(1:vd%p_nu)
   write(Lun_out,"('FILE ',2(a,/,5x))")(Trim(vd%file(i)),i=1,nfiles)
   write(Lun_out,"('REPS ',2(a,/,5x))")(Trim(vd%rep(i)),i=1,nfiles)
   write(Lun_out,"(72('='))")
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
End Do
vd=>temp
6000 Format('ENTRY NAME ','PHY NAME ',9x,'INTERP ',10x,'SEARCH ', &
'LABEL',3x,'TYPE',1x,'POSITION')
6010 Format(a4,7x,a16,2x,a16,2x,3a,3x,a8,2x,a2,i8)
End Subroutine Print_stack
!
Subroutine Print_stat(local_file)
real,dimension(l_ni,l_nj) :: local_file
If(Lctl_debug_L)Then
       larr(1:l_ni,1:l_nj)=local_file
       call glbcolc (globalf,G_ni,G_nj,larr,l_minx,l_maxx,l_miny,l_maxy,1)
       If(Lun_debug_L)call statfld (globalf,vd%phyvar,&
                       tip,"geopfld",1,G_ni,1,G_nj,1,1,1,1,G_ni,G_nj,1)
Endif
End Subroutine Print_stat
!
End Function itf_phy_puti


