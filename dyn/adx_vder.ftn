! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r adx_vder - compute second derivatives in the vertical in 
*                 preparation for tri-cubic interpolation
*
#include "model_macros_f.h"
*
      subroutine adx_vder (F_inzz, F_in, F_nit, F_njt, F_nk, F_lev_S)
*
#include "impnone.cdk"
*
      character*1 F_lev_S
*
      integer F_nit, F_njt, F_nk
*
      real F_inzz (F_nit, F_njt, F_nk), F_in (F_nit, F_njt, F_nk)
*
*author
*     alain patoine
*
*revision
* v3_00 - Desgagne & Lee    - Lam configuration
* v3_01 - Lee V             - calls to opinv7,optriss7 instead of
* v3_01                       opinv6,optriss6 to correct bug
* v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
*
*object
*     see id section
*
*arguments
*______________________________________________________________________
*              |                                                 |     |
* NAME         | DESCRIPTION                                     | I/O |
*--------------|-------------------------------------------------|-----|
*              |                                                 |     |
* F_inzz       | second derivative along z of F_in               |  o  |
* F_in         | field to be differentiated                      |  i  |
*              |                                                 |     |
* F_nit        | \ total number of points in x,y direction in    |  i  |
* F_njt        | / advection grid (including halos)              |  i  |
*              |                                                 |     |
* F_nk         | number of levels                                |  i  |
*______________|_________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
#include "schm.cdk"
#include "type.cdk"
#include "adx.cdk"
#include "ver.cdk"
************************************************************************
*
      integer i, j, i_deb, j_deb, i_fin, j_fin
*
      real prd, pr1, pr2, pr1p, pr2p
!
      real*8,   dimension(:),pointer :: p_z_8, p_qzz_8, p_qzi_8
!
      if ( F_lev_S .eq. 'm') then
         p_z_8   => Ver_z_8%m
         p_qzz_8 =>adx_qzz_8%m
         p_qzi_8 =>adx_qzi_8%m
      else
         p_z_8   => Ver_z_8%t
         p_qzz_8 =>adx_qzz_8%t
         p_qzi_8 =>adx_qzi_8%t
      endif
************************************************************************
                                  i_deb = 1
      if ( l_west .and. G_lam)    i_deb = adx_halox-1 +2

                                  j_deb = 1
      if ( l_south )              j_deb = adx_haloy-1
      if ( l_south.and. G_lam)    j_deb = adx_haloy-1 +2
*
                                  i_fin = adx_nit
      if ( l_east .and. G_lam)    i_fin = adx_halox + adx_nic -2
                                  j_fin = adx_njt
      if ( l_north )              j_fin = adx_haloy + adx_njc + 2
      if ( l_north .and.G_lam)    j_fin = adx_haloy + adx_njc - 2
*
************************************************************************
      call optriss7 (F_inzz,F_in, i_deb,j_deb,i_fin,j_fin,F_nk,
     %               'Z', p_qzz_8, p_qzz_8(F_nk+1), 
     %               p_qzz_8(2*F_nk+1), .false.,
     %               adx_nit, adx_njt, F_nk, 1 )
*
      call opinv7 (F_inzz, i_deb, j_deb,i_fin, j_fin,F_nk, 'Z', prd, prd,
     %             prd, p_qzi_8, p_qzi_8(F_nk+1), 
     %             p_qzi_8(2*F_nk+1), p_qzi_8(3*F_nk+1), .false.,
     %             'D', adx_nit, adx_njt, F_nk, 1 )
*
      if ( adx_nkbz_L ) then
         if ( G_nk.eq.3 ) then
            pr1 = 0.0
            pr2 = 0.0
         else
            pr1= (p_z_8(2)-p_z_8(1))/(p_z_8(3)-p_z_8(2))
            pr2= (p_z_8(F_nk  )-p_z_8(F_nk-1)) /
     %           (p_z_8(F_nk-1)-p_z_8(F_nk-2))
         endif
         pr1p = pr1 + 1.0
         pr2p = pr2 + 1.0
         pr1  = - pr1
         pr2  = - pr2
!$omp parallel do
         do j=j_deb,j_fin
         do i=i_deb,i_fin
            F_inzz(i,j,1   ) = pr1p*F_inzz(i,j,2)
     %                       + pr1 *F_inzz(i,j,3)
            F_inzz(i,j,F_nk) = pr2p*F_inzz(i,j,F_nk-1)
     %                       + pr2 *F_inzz(i,j,F_nk-2)
         enddo
         enddo
!$omp end parallel do
      endif
*
      return
      end
