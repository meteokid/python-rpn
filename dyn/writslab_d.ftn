***s/r - writslab_d - write out the slab header and slab data for dynamic output
*
#include <model_macros_f.h>
*
      subroutine writslab_d(F_slab_fhand,F_slab_slab,F_slab_nnio,F_pre_S,
     %     F_ext_S,F_mtout,F_var_S,F_typvar_S,F_ip1,F_bit,F_mtval,F_xnio,
     %              NN,MXOUT,MXGRD)
*
#include "impnone.cdk"
      integer NN,MXOUT,MXGRD
      integer F_slab_fhand,F_slab_slab,F_slab_nnio(MXGRD)
      character*2 F_pre_S
      character*4 F_var_S(MXOUT,MXGRD)
      character*1 F_typvar_S(MXOUT,MXGRD)
      character*(*) F_ext_S
      integer F_mtout(MXGRD),F_ip1(MXOUT,MXGRD),F_bit(MXOUT,MXGRD)
      real F_mtval(NN*MXOUT,MXGRD)
      integer F_xnio(NN,MXGRD)
*
*author 
*     J. P. Toviessi - CMC apr 2000
*
*revision
* v2_00 - Toviessi J. P.      - initial version
* v2_30 - Lee V.              - removed calculation of slab xnio array,
* v2_30                         and added the writeout of the slab header,
* v2_30                         slab file opening is determined here.
* v2_32 - Lee V.              - for no compaction on output: E32 not R32
*
*object
*     See above
*
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_slab_fhand  I           file handle to slab file 
* F_slab_slab   I           current slab id number for this writeout to file
* F_slab_nnio   I           number of elements to be written
* F_pre_S       I           prefix for filename of slab
* F_mtout       I           number of fields to output per grid
* F_var_S       I           list of names of each field for output per grid
* F_ip1         I           corresponding ip1 (level) for each field
* F_bit         I           corresponding bit compaction for each field
* F_mtval       I           corresponding data chunk for each field
* F_xnio        I           corresponding xnio for data chunk for each grid
**
#include "lun.cdk"
#include "dimout.cdk"
#include "grid.cdk"
#include "slab.cdk"
*
      integer i,j,k,ierr,np,gridset
      integer,     dimension(:),allocatable :: ip2,ip3,filt,xp,datyp
      
      integer slabdsc,slabxtrf
      external slabdsc,slabxtrf
      data np/0/
*
*
*-------------------------------------------------------------------
*
       allocate ( ip2     (mxout),
     %            ip3     (mxout),
     %            filt    (mxout),
     %            datyp   (mxout),
     %            xp      (mxout) )
       do i=1,mxout
          ip2(i)  =Slab_ip2
          ip3(i)  =Slab_ip3
          filt(i) =0
          xp(i)   =0.0
       enddo
       do gridset = 1, Grid_sets
          if (F_mtout(gridset).gt.0.and.F_slab_nnio(gridset).gt.0) then
             do i=1,mxout
                if (F_bit(i,gridset).eq.32) then
                    datyp(i) = 5
                else
                    datyp(i) = 1
                endif
             enddo
             if (F_slab_fhand.eq.-1) then
                call inislabfhand(Lun_outgem_s,
     %                           F_slab_fhand,F_pre_S,F_ext_S)
             endif
            F_slab_slab = F_slab_slab + 1
             ierr = slabdsc(F_slab_fhand,F_slab_slab, Grid_gxtyp_s(gridset), 
     %            Grid_ixg1(gridset), Grid_ixg2(gridset), 
     %            Grid_ixg3(gridset), Grid_ixg4(gridset), 
     %            Grid_niout(gridset), Grid_njout(gridset),
     %            Grid_nxgrid(gridset), Grid_nygrid(gridset),
     %            Grid_long(Grid_x0(gridset)), Grid_latg(Grid_y0(gridset)),
     %            Grid_typ_s(gridset),
     %            Grid_ig1(gridset),Grid_ig2(gridset),
     %            Grid_ig3(gridset),Grid_ig4(gridset),
     %            F_mtout(gridset), np, F_typvar_S(1,gridset),
     %            F_var_S(1,gridset),F_ip1(1,gridset), ip2,ip3,datyp, 
     %            F_bit(1,gridset), filt, xp)
            ierr = slabxtrf(F_slab_fhand,F_slab_slab,
     %                      F_slab_nnio(gridset),F_xnio(1,gridset),
     %                      F_mtout(gridset),F_mtval(1,gridset) )
          endif
*
       enddo
*
*
      deallocate (ip2,ip3,datyp,filt,xp)
*
*-------------------------------------------------------------------
*
      return
      end
