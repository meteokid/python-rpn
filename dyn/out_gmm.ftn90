!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r out_gmm - output GMM fields
!
#include "model_macros_f.h"
!
      subroutine out_gmm (F_p0,DIST_DIM,F_ip3,F_etikadd_S,F_ext_S, &
           F_rf,F_indo,F_nko,F_nkot,F_set)
      use out_vref_mod, only: out_vref
!
      implicit none
!
      character*6 F_etikadd_S
      character*4 F_ext_S
      integer F_nko,F_nkot,F_set,F_ip3
      integer DIST_DIM
      integer F_indo(*)
      real F_rf(*)
      real F_p0(DIST_SHAPE)
!
!author
!     Lee V.                    - rpn July 2009 (from output VMM)
!
!revision
! v3_20 - Lee V.            - initial MPI version
! v3_30 - McTaggart-Cowan R.- allow for user-defined domain tag extensions
! v3_31 - Lee V.            - kind is set to 2 (press) for 2D fields, not -1
! v4_03 - Lee V.            - modification of Out_etik_S in out_sgrid only
! v4_05 - Lee V.            - adaptation to GMM
!
!object
!     output all the GMM fields
!	
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! F_dostep     I    - array containing indices corresponding to the
!                     timestep sets that requires output at this time step.
! F_dostep_max I    - size of F_dostep array
!
!
! Index vectors for level indentifications
! ----------------------------------------
! 
! There is one vector for the momentum level : Ver_hyb%m.
!
! There are 1 vector for the thermo levels :
!    Ver_hyb%t : Thermo levels without special levels but top and surface.
!
!                Ver_hyb%m(1:G_nk)                 Ver_hyb%t(1:G_nk+1)
! model top
! ===========1        -                              X
! o o o o o o2        -                              -
! - - - - - -3        X                              -
!
! ===========4        -                              X
!  
!    ...             ...                            ...
!
!
! ===========2*k      -                              X
!
! - - - - - -2*k+1    X                              -
!
!    ...             ...                            ...
!
! - - - - - -2*G_nk+1 X                              -
! o o o o o o2*G_nk+2 -                              -
! ===========2*G_nk+3 -                              X
! model surface
!
!----------------------------------------------------------------------
!implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "lun.cdk"
#include "out3.cdk"
#include "out.cdk"
#include "cube.cdk"
#include "outd.cdk"
#include "geomn.cdk"
#include "rhsc.cdk"
#include "init.cdk"
#include "rstr.cdk"
#include "vt0.cdk"
#include "vth.cdk"
#include "vt1.cdk"
#include "vta.cdk"
#include "vtx.cdk"
#include "orh.cdk"
#include "p_geof.cdk"
#include "lctl.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
!
!
!*
      type(gmm_metadata) :: tmp_meta
      character(len=GMM_MAXNAMELENGTH), dimension(256) :: keylist
      integer i,j,k, ii, pnerr,nkeys,gridset,levset,ig2
      integer i0,in,j0,jn
      integer ierr,indo(F_nkot),nko,nkot,nks,nkst
      logical next_L,periodx_L,uvgrid_L
!
!
      real prprlvl(F_nko)
      real, pointer    , dimension(:,:,:) :: tr1
!
!_______________________________________________________________________
!
      nkeys = gmm_keys(keylist)
      periodx_L = .false.
      uvgrid_L=.false.

      if (.not.G_lam .and. (Grid_x1(Outd_grid(F_set))- &
            Grid_x0(Outd_grid(F_set))+1).eq. G_ni ) periodx_L=.true.
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj

      nko=F_nko
      nkot=F_nkot
      nks=nko
      nkst=nkot
      if (F_indo(F_nkot).eq.G_nk+2) nkst=nkot-1
      if (.not. Schm_phyms_L) then
          if (F_indo(F_nko).eq.G_nk+1) nko = nko-1
          if (F_indo(F_nkot).eq.G_nk+2) nkot=nkot-1
      endif
!     Exceptions are: U, V, on MOM
!     Exceptions are: ZD,W on THERMO

      do 100 ii=1,Outd_var_max(F_set)
      do 50 i=1,nkeys
         gridset = Outd_grid(F_set)
         levset = Outd_lev(F_set)
         if (uvgrid_L) then
             uvgrid_L=.false.
             call out_sgrid( &
                 Grid_x0(gridset),Grid_x1(gridset), &
                 Grid_y0(gridset),Grid_y1(gridset), &
                 Cube_ig1(gridset,Level_typ_indx(levset)), &
                 Cube_ig2(gridset,Level_typ_indx(levset)), &
                 periodx_L, Grid_stride(gridset), &
                 Grid_etikext_s(gridset),F_etikadd_S )
         endif
         if (Outd_var_S(ii,F_set).eq.keylist(i)(1:4)) then
             gmmstat = gmm_getmeta(keylist(i),tmp_meta)
             if (GMM_IS_ERROR(gmmstat))  &
                 print *,'out_gmm ERROR at gmm_getmeta on',keylist(i)
             nullify(tr1)
             gmmstat = gmm_get(keylist(i),tr1,tmp_meta)
             if (GMM_IS_ERROR(gmmstat))  &
                 print *,'out_gmm ERROR at gmm_getmeta on',keylist(i)
!
             if (keylist(i)(1:2).eq.'ZD'.or.keylist(i)(1:2).eq.'WT') then
                 call ecris_fst2(tr1, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                      keylist(i),1.0,0.0,Out_kind,G_nk+1, F_indo, nkst, &
                      Outd_nbit(ii,F_set) )
             elseif (keylist(i)(1:3).eq.'UT1'.or.keylist(i)(1:3).eq.'UT0') then
                 uvgrid_L = .true.
                 ig2 = Cube_ig2(gridset,Level_typ_indx(levset))+1
                 call out_sgrid( &
                 Grid_x0(gridset),min(Grid_x1(gridset),G_niu), &
                 Grid_y0(gridset),Grid_y1(gridset), &
                 Cube_ig1(gridset,Level_typ_indx(levset)),ig2, &
                 periodx_L, Grid_stride(gridset), &
                 Grid_etikext_s(gridset),F_etikadd_S )
                 call out_href(Geomn_longu,Geomn_latgs)
                 call out_vref(F_p0,LDIST_DIM,ig2=ig2)
                 call ecris_fst2(tr1, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                      keylist(i),1.0,0.0,Out_kind,G_nk+1, F_indo, nko, &
                      Outd_nbit(ii,F_set) )
             elseif (keylist(i)(1:3).eq.'VT1'.or.keylist(i)(1:3).eq.'VT0') then
                 uvgrid_L = .true.
                 ig2 = Cube_ig2(gridset,Level_typ_indx(levset))+2
                 call out_sgrid( &
                 Grid_x0(gridset),Grid_x1(gridset), &
                 Grid_y0(gridset),min(Grid_y1(gridset),G_njv), &
                 Cube_ig1(gridset,Level_typ_indx(levset)),ig2, &
                 periodx_L, Grid_stride(gridset), &
                 Grid_etikext_s(gridset),F_etikadd_S )
                 call out_href(Geomn_longs,Geomn_latgv)
                 call out_vref(F_p0,LDIST_DIM,ig2=ig2)
                 call ecris_fst2(tr1, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                      keylist(i),1.0,0.0,Out_kind,G_nk+1, F_indo, nko, &
                      Outd_nbit(ii,F_set) )
             elseif (tmp_meta%l(1)%low .eq.1) then !no halo
                    call ecris_fst2(tr1,1,l_ni,1,l_nj,Ver_hyb%m, &
                      keylist(i),1.0,0.0,Out_kind,G_nk, F_indo, nko, &
                      Outd_nbit(ii,F_set))
             elseif (tmp_meta%l(3)%high .eq.0) then !2d halo field
                    call ecris_fst2(tr1,l_minx,l_maxx,l_miny,l_maxy,0.0, &
                      keylist(i),1.0,0.0,  2, 1, 1, 1, &
                      Outd_nbit(ii,F_set) )
             elseif (tmp_meta%l(3)%low .eq.0) then !3d halo with 0 level
                 call ecris_fst2(tr1(l_minx,l_miny,2), &
                      l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                      keylist(i),1.0,0.0,Out_kind,G_nk+1, F_indo, nks, &
                      Outd_nbit(ii,F_set) )
             elseif (tmp_meta%l(3)%high .eq.G_nk) then !3d halo with no surf
                 call ecris_fst2(tr1, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                      keylist(i),1.0,0.0,Out_kind,G_nk, F_indo, nko, &
                      Outd_nbit(ii,F_set) )
             elseif (tmp_meta%l(3)%high .eq.G_nk+1) then !3d halo MOM
                 call ecris_fst2(tr1, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                      keylist(i),1.0,0.0,Out_kind,G_nk+1, F_indo, nko, &
                      Outd_nbit(ii,F_set) )
             elseif (tmp_meta%l(3)%high .eq.G_nk+2) then !3d halo THERMO
                 call ecris_fst2(tr1, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                      keylist(i),1.0,0.0,Out_kind,G_nk+2, F_indo, nko, &
                      Outd_nbit(ii,F_set) )
             endif
             cycle

         endif

  50  continue
 100  continue

! ___________________________________________________________________
      return
      end
