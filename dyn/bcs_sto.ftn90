!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r bcs_sto - Dimensions for the storage of boundary conditions (BCS)
!
#include "model_macros_f.h"
!
      subroutine bcs_sto
!
      implicit none
!
!author
!     M. Desgagne  April 2006 (MC2 setpnt2)
!
!revision
! v3_30 - Desgagne M.        - initial version
! v3_31 - Lee V.             - setup only for LAM
! v4_05 - Plante A.          - top nesting
! v4_10 - Tanguay M.         - Adjust digital filter when LAM
!
!object
!
!arguments
!     None
!
!implicits
#include "bcsdim.cdk"
#include "bcsmem.cdk"
#include "lam.cdk"
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "schm.cdk"
#include "tr3d.cdk"
#include "init.cdk"
!
      integer err, bcs_sz1,nvar,nvar2
!
!----------------------------------------------------------------------
!
      if (.not.G_lam) return
!     Note : Ici on suppose que npex ou npey <=2 donc tous les pe ont
!            au moins un cote.
!            Pour simplifier, la dimention du toit comprend tout la tuile.
!            Donc les zones de pilotage et de blend sont repetees, cela devra etre
!            optimise eventuellement
!
      dimxs = 0
      dimys = 0
      dimxn = 0
      dimyn = 0
      dimxw = 0
      dimyw = 0
      dimxe = 0
      dimye = 0
      dimxt = l_ni
      dimyt = l_nj
!
      minxs = 1
      maxxs = l_ni
      minys = 1
      maxys = Glb_pil_s + Lam_blend_Hy + 1
      if (l_south) then
         dimxs = maxxs - minxs + 1
         dimys = maxys - minys + 1
      endif
      minxn = minxs
      maxxn = maxxs
      minyn = l_nj - Glb_pil_n - Lam_blend_Hy
      maxyn = l_nj
      if (l_north) then
         dimxn = maxxn - minxn + 1
         dimyn = maxyn - minyn + 1
      endif
!
      minxw = 1
      maxxw = Glb_pil_w + Lam_blend_Hx + 1
      minyw = 1 + pil_s + south*(Lam_blend_Hy)
      maxyw = l_nj - pil_n -north*(Lam_blend_Hy)
      if (l_west ) then
         dimxw = maxxw - minxw + 1
         dimyw = maxyw - minyw + 1
      endif
      minxe = l_ni - Glb_pil_e - Lam_blend_Hx
      maxxe = l_ni
      minye = 1 + pil_s + south*(Lam_blend_Hy)
      maxye = l_nj - pil_n - north*(Lam_blend_Hy)
      if (l_east ) then
         dimxe = maxxe - minxe + 1
         dimye = maxye - minye + 1
      endif
!
      bcs_is = 1
      bcs_in = bcs_is + dimxs*dimys*(G_nk+2)
      bcs_iw = bcs_in + dimxn*dimyn*(G_nk+2)
      bcs_ie = bcs_iw + dimxw*dimyw*(G_nk+2)   
      if(Lam_gbpil_T == 0 .and. Lam_blend_T == 0)then
         bcs_sz = bcs_ie + dimxe*dimye*(G_nk+2) - 1
      else
         bcs_it = bcs_ie + dimxe*dimye*(G_nk+2)
         bcs_sz = bcs_it + dimxt*dimyt*(Lam_gbpil_T+Lam_blend_T) - 1
      endif
!
      bcs_sz1 = max(bcs_sz,1)
      nvar = 12
      if (.not. Schm_hydro_L) nvar=nvar+2
      if (Tr3d_ntr.gt.0) nvar = nvar + Tr3d_ntr*2

      BCS_siz_tot = nvar*bcs_sz1

      allocate (BCS_values(BCS_siz_tot))

      pbcsu    = loc (BCS_values(             1))
      pbcsv    = loc (BCS_values( bcs_sz1   + 1))
      pbcst    = loc (BCS_values( bcs_sz1*2 + 1))
      pbcszd   = loc (BCS_values( bcs_sz1*3 + 1))
      pbcss    = loc (BCS_values( bcs_sz1*4 + 1))
      pbcsuf   = loc (BCS_values( bcs_sz1*5 + 1))
      pbcsvf   = loc (BCS_values( bcs_sz1*6 + 1))
      pbcstf   = loc (BCS_values( bcs_sz1*7 + 1))
      pbcszdf  = loc (BCS_values( bcs_sz1*8 + 1))
      pbcssf   = loc (BCS_values( bcs_sz1*9 + 1))
      pbcsw    = loc (BCS_values( bcs_sz1*10+ 1))
      pbcswf   = loc (BCS_values( bcs_sz1*11+ 1))
      nvar=11
!
      if (.not. Schm_hydro_L) then
         pbcsq    = loc (BCS_values( bcs_sz1*(nvar+1) +   1))
         pbcsqf   = loc (BCS_values( bcs_sz1*(nvar+2) +   1))
         nvar=13
      endif
!
      if (Tr3d_ntr.gt.0) then
         pbcstr = loc( BCS_values( bcs_sz1*(nvar+1)    + 1))
         pbcstrf =loc( BCS_values( bcs_sz1*(nvar+1+Tr3d_ntr) + 1))
      endif
!
      call bcs_did (G_ni,G_nj)
!
!     --------------------------------
      if (G_lam.and.Init_balgm_L) then
!     --------------------------------
!
      nvar2= 6 
      if (.not. Schm_hydro_L) nvar2= nvar2+1
      if (Tr3d_ntr.gt.0) nvar2= nvar2+Tr3d_ntr
!
      BCS_siz_tot2 = nvar2*bcs_sz1
!
      allocate (BCS_values2(BCS_siz_tot2))
!
      pbcsu2  = loc (BCS_values2(             1))
      pbcsv2  = loc (BCS_values2( bcs_sz1   + 1))
      pbcst2  = loc (BCS_values2( bcs_sz1*2 + 1))
      pbcszd2 = loc (BCS_values2( bcs_sz1*3 + 1))
      pbcss2  = loc (BCS_values2( bcs_sz1*4 + 1))
      pbcsw2  = loc (BCS_values2( bcs_sz1*5 + 1))
      nvar2=5
!
      if (.not. Schm_hydro_L) then
         pbcsq2 = loc (BCS_values2( bcs_sz1*(nvar2+1) + 1))
         nvar2=6
      endif
!
      if (Tr3d_ntr.gt.0) then
         pbcstr2 = loc (BCS_values2( bcs_sz1*(nvar2+1) + 1))
      endif
!
!     -----
      endif
!     -----
!
!----------------------------------------------------------------------
      return
      end

