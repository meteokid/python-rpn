c  s/r e_genab2_8  - Using Laprise & Girard, generates de A and B of the
c                    hybrid coordinate and the analytical derivative of 
c                    d(psurf*B)/d(A + psurf*B), Also sets Z and other
c                    related vertical parameters.
c
#include "model_macros_f.h"
c
      subroutine genab2_8 ()
      implicit none
c
c author 
c      A. Plante  - CMC - mai 2006
c
c revision
c
c object
c    Using Laprise & Girard, generates de A and B of the hybrid coordinate
c    see: Laprise & Girard, 1990, J. of Climate, eq. 5.1
c    Based on subroutine genab and genab2 genab2_8 also includes the evaluation
c    of the analytical derivative of zsurf*B with respect to Z and other
c    parameters related to the vertical discretazation.
c
c               vvvvvvvvvvvvvvvvv Ver_z_8%m(0) Virtual level
c
c    model top  ================= Ver_z_8%t(1) = Ztop
c
c               - - - - - - - - - Ver_z_8%m(1)
c
c               ================= Ver_z_8%t(2) = ( Ver_z_8%m(2) + Ver_z_8%m(1) ) / 2
c
c               - - - - - - - - - Ver_z_8%m(2)
c
c                      ...
c
c               - - - - - - - - - Ver_z_8%m(G_nk-1)
c
c               ================= Ver_z_8%t(G_nk) = ( Ver_z_8%m(nk) + Ver_z_8%m(nk-1) ) / 2
c
c               - - - - - - - - - Ver_z_8%m(G_nk)
c               o o o o o o o o o Special level 
c model surface ================= Ver_z_8%t(G_nk+1) = Zsurf
c
c               vvvvvvvvvvvvvvvvv Ver_z_8%m(G_nk+1) Virtual level
c
c arguments
c none
c
#include "glb_ld.cdk"
#include "lun.cdk"
#include "dcst.cdk"
#include "pres.cdk"
#include "cstv.cdk"
#include "grd.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
c
      integer ne
      parameter(ne=6)

      integer k,istat,ind
      real*8 pref_8, ptop_8, pr1_8, etatop_8, rcoef_8, ztop_8, zsurf_8
      real*8 tempo_8(G_nk),tmp_8,eta_old,eta_new,log_z
c     __________________________________________________________________
c
c     BEWARE
c     if F_coef is greater than 1., pref is subject to restriction for
c     stability reasons.
c
      allocate(
     $            Ver_a_8%m(0:G_nk+1),    Ver_a_8%t(G_nk+1),
     $            Ver_b_8%m(0:G_nk+1),    Ver_b_8%t(G_nk+1),
     $            Ver_z_8%m(0:G_nk+1),    Ver_z_8%t(G_nk+1),
     $           Ver_dz_8%m(  G_nk  ),   Ver_dz_8%t(G_nk+1),
     $          Ver_idz_8%m(  G_nk  ),  Ver_idz_8%t(G_nk+1),
     $         Ver_dbdz_8%m(  G_nk  ), Ver_dbdz_8%t(G_nk+1),
     $        Ver_fistr_8%m(  G_nk  ),Ver_fistr_8%t(G_nk+1),
     $                               Ver_a_spcl_8%t(G_nk+2),
     $                               Ver_b_spcl_8%t(G_nk+2),
     $                                            stat=istat)
      call check_alloc(istat,'genab2_8 ',1)
c
      pref_8  = 100.0d0*Pres_pref    ! convert to pascal
      ptop_8  = 100.0d0*Pres_ptop    ! convert to pascal
      zsurf_8 = log(Cstv_pisrf_8)
      ztop_8  = log(ptop_8)
      rcoef_8 = Grd_rcoef
c
      etatop_8=ztop_8/log(pref_8)
c
c     ---------------------------
c     Set A, B and Z for %m %t
c     Z = A + B*zsurf
c     ---------------------------
c
c
      pr1_8 = 1.0d0/(1.0d0 - etatop_8)
c
      do k = 1, G_nk
         eta_old=Ver_hybm_8%m(k)
         eta_new=log(eta_old*pref_8)/log(pref_8)
         Ver_b_8%m(k) = ((eta_new - etatop_8)*pr1_8 ) ** Grd_rcoef
         Ver_a_8%m(k) = log(pref_8) * ( eta_new - Ver_b_8%m(k) )
         Ver_z_8%m(k) = Ver_a_8%m(k)+Ver_b_8%m(k)*zsurf_8
      enddo
c
c     Top virtual level
      Ver_a_8%m(0)=2.d0*ztop_8-Ver_a_8%m(1)
      Ver_b_8%m(0)=           -Ver_b_8%m(1)
      Ver_z_8%m(0)= Ver_a_8%m(0)+Ver_b_8%m(0)*zsurf_8
c
c     Bottom virtual level
      Ver_a_8%m(G_nk+1)=    -Ver_a_8%m(G_nk)
      Ver_b_8%m(G_nk+1)=2.d0-Ver_b_8%m(G_nk)
      Ver_z_8%m(G_nk+1)= Ver_a_8%m(G_nk+1)+Ver_b_8%m(G_nk+1)*zsurf_8
c     
      Ver_z_8%t(1)=ztop_8
      Ver_a_8%t(1)=ztop_8
      Ver_b_8%t(1)=0.d0
c
      do k = 2, G_nk
         Ver_b_8%t(k) = 0.5d0*(Ver_b_8%m(k)+Ver_b_8%m(k-1))
         Ver_a_8%t(k) = 0.5d0*(Ver_a_8%m(k)+Ver_a_8%m(k-1))
         Ver_z_8%t(k) = Ver_a_8%t(k)+Ver_b_8%t(k)*zsurf_8
         Ver_b_spcl_8%t(k) = Ver_b_8%t(k)
         Ver_a_spcl_8%t(k) = Ver_a_8%t(k)
      enddo
c
      Ver_a_8%t(G_nk+1)=0.d0
      Ver_b_8%t(G_nk+1)=1.d0
      Ver_z_8%t(G_nk+1)=zsurf_8
c
      Ver_b_spcl_8%t(1)      = 0.5d0*(Ver_b_8%m(1)+Ver_b_8%t(1))
      Ver_b_spcl_8%t(G_nk+1) = 0.5d0*(Ver_b_8%m(G_nk)+Ver_b_8%t(G_nk+1))
      Ver_b_spcl_8%t(G_nk+2) =                        Ver_b_8%t(G_nk+1)
c
      Ver_a_spcl_8%t(1)      = 0.5d0*(Ver_a_8%m(1)+Ver_a_8%t(1))
      Ver_a_spcl_8%t(G_nk+1) = 0.5d0*(Ver_a_8%m(G_nk)+Ver_a_8%t(G_nk+1))
      Ver_a_spcl_8%t(G_nk+2) =                        Ver_a_8%t(G_nk+1)

c     --------------
c     Compute fistar
c     --------------
c     
      pr1_8=-Dcst_rgasd_8*Cstv_tstr_8
      do k = 1, G_nk
         Ver_fistr_8%m(k)=pr1_8*(Ver_z_8%m(k)-zsurf_8)
         Ver_fistr_8%t(k)=pr1_8*(Ver_z_8%t(k)-zsurf_8)
      enddo
      Ver_fistr_8%t(G_nk+1)=0.d0
c
c     -----------------------------------------
c     Compute delta Z and delrond b / delrond Z
c     -----------------------------------------
c
      do k=1,G_nk
           Ver_dz_8%m(k) =  Ver_z_8%t(k+1)-Ver_z_8%t(k)
          Ver_idz_8%m(k) =  1.d0/Ver_dz_8%m(k)
         Ver_dbdz_8%m(k) = (Ver_b_8%t(k+1)-Ver_b_8%t(k))*Ver_idz_8%m(k)
      enddo      
c     
      do k=1,G_nk+1
           Ver_dz_8%t(k) = Ver_z_8%m(k) - Ver_z_8%m(k-1)
          Ver_idz_8%t(k) = 1.d0/Ver_dz_8%t(k)
         Ver_dbdz_8%t(k) = (Ver_b_8%m(k)-Ver_b_8%m(k-1))*Ver_idz_8%t(k)
      enddo
c     
c=======================================================================
c section a enlever eventuellement
c=======================================================================
c
      allocate( Ver_hyb_8%t(G_nk+2),Ver_hybm_8%t(G_nk+2),
     $          Ver_hyb%t(G_nk+1),  Ver_hybm%t(G_nk+2),
     $         stat=istat)
      call check_alloc(istat,'genab2_8',2)
c
      allocate(  Ver_pia%t(G_nk+1),  Ver_pib%t(G_nk+1),
     $           Ver_pia%m(G_nk)  ,  Ver_pib%m(G_nk)  ,
     $     stat=istat)
      call check_alloc(istat,'genab2_8',3)
c
c     Note : Ver_hyb_8%t is not defined for rcoef!=1 (except at top and sfc) but 
c            we put some resonable value in it for the time beeing since
c            some process like the Vertical sponge may use this.
c            Also the output need it for IP1 encoding
c
c     Top level
      Ver_hyb_8%t(1     )=0.5d0*Ver_hyb_8%m(1)
c     No Top special level
c     Bot special level
      Ver_hyb_8%t(G_nk+1)=0.5d0*(Ver_hyb_8%m(G_nk)+1.0d0)
c     Diag level
      Ver_hyb_8%t(G_nk+2)=1.d0
C     Top and surface
      Ver_hybm_8%t(1)=Pres_ptop/Pres_pref
      Ver_hybm_8%t(G_nk+2)=1.d0
C     Special levels      
      Ver_hybm_8%t(G_nk+1)=.5d0*(Ver_hybm_8%m(G_nk)+1.d0)
      do k = 2, G_nk
         Ver_hybm_8%t(k)=0.5d0*(Ver_hybm_8%m(k)+Ver_hybm_8%m(k-1))
         Ver_hyb_8%t(k)=0.5d0*(Ver_hyb_8%m(k)+Ver_hyb_8%m(k-1))        
      enddo
c
      do k = 1, G_nk
         Ver_pia%m(k)  = Ver_a_8%m(k)
         Ver_pib%m(k)  = Ver_b_8%m(k)
      enddo
c
      Ver_hybm%t(1) = Ver_hybm_8%t(1)
      Ver_hybm%t(G_nk+2) = Ver_hybm_8%t(G_nk+2)
      do k = 1, G_nk+1
         Ver_hyb%t(k)  = Ver_hyb_8%t(k)
         Ver_hybm%t(k) = Ver_hybm_8%t(k)
         Ver_pia%t(k)  = Ver_a_8%t(k)
         Ver_pib%t(k)  = Ver_b_8%t(k)

      enddo
c     __________________________________________________________________
c
      return
      end
