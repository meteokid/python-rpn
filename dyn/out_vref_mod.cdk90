!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!*module out_vref_mod - output vertical coordinate tags
!
module out_vref_mod

  private

  public :: out_vref

  interface out_vref
     module procedure out_vref_model
     module procedure out_vref_pres
  end interface

#include "model_macros_f.h"

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine out_vref_model(F_ref,minx,maxx,miny,maxy,ig1,ig2)
    use vGrid_Descriptors, only: vgrid_descriptor,vgd_new,vgd_write,vgd_print,VGD_OK,vgd_get
    ! Write the vertical coordinate descriptor (model levels)

    implicit none

    real, dimension(minx:maxx,miny:maxy), intent(in) :: F_ref !reference (surface) field
    integer, intent(in) :: minx,maxx,miny,maxy          !bounds for reference field
    integer, intent(in), optional :: ig1,ig2            !override 'out.cdk' values of ig1,ig2

    !author
    !     v.lee - rpn march 2008
    !
    !revision
    ! v4_03 - Lee V.            - initial MPI version (from wrvref MC2)
    ! 
    !implicits

#include "glb_ld.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
#include "dimout.cdk"
#include "grd.cdk"
#include "level.cdk"
#include "grid.cdk"
#include "lun.cdk"
#include "out.cdk"

    ! Internal variables
    integer :: err,my_ig1,my_ig2
    type(vgrid_descriptor) :: vgd

    ! Set default values
    my_ig1 = Out_ig1
    if (present(ig1)) my_ig1 = ig1
    my_ig2 = Out_ig2
    if (present(ig2)) my_ig2 = ig2

    ! Write coordinate descriptor

    if (writeDescriptor()) then
       err = vgd_new(vgd,               &
            kind     = Level_kind_ip1,  &
            version  = Level_version,   &
            nk       = G_nk,            &
            ip1      = my_ig1,          &
            ip2      = my_ig2,          &
            ptop_8   = Cstv_ptop_8,     &
            pref_8   = Cstv_pref_8,     &
            rcoef1   = Grd_rcoef(1),    &
            rcoef2   = Grd_rcoef(2),    &
            a_m_8    = Ver_a_8%m,       &
            b_m_8    = Ver_b_8%m,       &
            a_t_8    = Ver_a_8%t,       &
            b_t_8    = Ver_b_8%t,       &
            ip1_m    = Ver_ip1%m,       &
            ip1_t    = Ver_ip1%t)

       if (report(Out_ig1,Out_ig2)) err = vgd_print(vgd,Lun_out)
       err = vgd_write(vgd,unit=Out_unf,format='fst')

    endif

    ! Write out the reference field
    call ecris_fst2 ( F_ref,l_minx,l_maxx,l_miny,l_maxy,0.0, &
                                  'P0',0.01,0.0,-1,1,1,1,32 )

    return
  end subroutine out_vref_model

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine out_vref_pres(F_rf,ig1,ig2)
    use vGrid_Descriptors, only: vgrid_descriptor,vgd_new,vgd_write,vgd_print,VGD_OK
    ! Write the vertical coordinate descriptor (pressure levels)

    implicit none

    real, dimension(:), intent(in) :: F_rf              !List of pressure levels to output
    integer, intent(in), optional :: ig1,ig2            !override 'out.cdk' values of ig1,ig2

    !author
    !     R. McTaggart-Cowan - Aug 2009
    !
    !revision
    !
    !object
    !     Write vertical coordinate descriptor for pressure-coordinate data
    !
    !implicits
#include "out.cdk"
#include "dimout.cdk"
#include "grd.cdk"
#include "level.cdk"
#include "lun.cdk"

    ! Local variables
    integer :: k,err,my_ig1,my_ig2
    integer, dimension(size(F_rf)) :: ip1s
    real*8, dimension(size(F_rf)) :: zero
    type(vgrid_descriptor) :: vgd
    logical, save :: reported=.false.

    ! Set default values
    my_ig1 = Out_ig1
    if (present(ig1)) my_ig1 = ig1
    my_ig2 = Out_ig2
    if (present(ig2)) my_ig2 = ig2

    ! Set initializing values
    zero = 0.d0
    do k=1,size(F_rf)
       call convip(ip1s(k),F_rf(k),2,Level_mode_ip1,'',.false.)
    enddo

    ! Write coordinate descriptor
    if (writeDescriptor()) then

       err = vgd_new(vgd,               &
            kind     = 2,               &
            version  = 1,               &
            nk       = size(F_rf),      &
            ip1      = my_ig1,          &
            ip2      = my_ig2,          &
            a_m_8    = dble(F_rf*100.), &
            b_m_8    = zero,            &
            ip1_m    = ip1s)

       if (report(Out_ig1,Out_ig2)) err = vgd_print(vgd,Lun_out)
       err = vgd_write(vgd,unit=Out_unf,format='fst')

    endif
    
  end subroutine out_vref_pres

  logical function writeDescriptor()
    ! Decide whether or not to write descriptor based on local tile
    implicit none
#include "out.cdk"
    writeDescriptor = (Out_blocme == 0).and.(Out_nisl > 0).and.(Out_njsl > 0)
    return
  end function writeDescriptor

  logical function report(ig1,ig2)
    ! Decide whether or not to report output from the descriptor
    implicit none
#include "lun.cdk"
#include "dimout.cdk"
#include "grid.cdk"
#include "level.cdk"
    integer :: ig1,ig2
    integer :: i
    integer, save :: report_count=0
    integer, dimension(MAXGRID1*LEVEL_NTYP,2), save :: reported
    logical :: found
    report = .false.
    if (.not.Lun_debug_L) return
    i = 1; found = .false.
    do while (.not.found .and. i<=report_count)
       if (ig1 == reported(i,1) .and. ig2 == reported(i,2)) found = .true.
       i = i+1
    enddo
    if (.not.found) then
       report_count = min(report_count+1,size(reported,dim=1))
       reported(report_count,:) = (/ig1,ig2/)
       report = .true.
    endif
    return
  end function report

end module out_vref_mod
