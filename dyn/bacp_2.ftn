***s/r  bacp_2 - backsubstitution ( computation and microtasking )
*
#include "model_macros_f.h"
*
      subroutine bacp_2 ( F_itr   , F_itnlh , F_st0  ,
     $                    F_fip   , F_fis   , F_tt0  ,
     $                    F_ut0   , F_vt0   , F_zdt0 ,
     $                    F_qt0   , F_wt0   , F_p    ,
     $                    F_ru    , F_rv    , F_rt   , F_rw   , 
     $                    F_rf    , F_nu    , F_nv   ,
     $                    F_nt    , F_nw    , F_nf   ,
     $                    DIST_DIM, Nk )
*
      implicit none
*
      integer  F_itr, F_itnlh, DIST_DIM, Nk 
* 
      real     F_st0  (DIST_SHAPE)     ,  F_fip   (DIST_SHAPE,0:Nk+1), 
     %         F_fis  (DIST_SHAPE)     ,  F_tt0   (DIST_SHAPE,  Nk+1),
     %         F_ut0  (DIST_SHAPE,Nk)  ,  F_vt0   (DIST_SHAPE,  Nk)  , 
     %         F_zdt0 (DIST_SHAPE,Nk+1),  F_qt0   (DIST_SHAPE,0:Nk+1),
     %         F_wt0  (DIST_SHAPE,Nk+1),  F_p     (DIST_SHAPE,0:Nk+1),
     %         F_ru   (DIST_SHAPE,Nk)  ,  F_rv    (DIST_SHAPE,  Nk)  ,
     %         F_rt   (DIST_SHAPE,Nk+1),
     %         F_rf   (DIST_SHAPE,Nk+1),  F_nt    (DIST_SHAPE,  Nk+1),
     %         F_rw   (DIST_SHAPE,Nk+1),  F_nu    (DIST_SHAPE,  Nk)  ,
     %         F_nv   (DIST_SHAPE,Nk)  ,  F_nw    (DIST_SHAPE,  Nk+1),
     %         F_nf   (DIST_SHAPE,Nk+1)
*
*author
*     Alain Patoine - split from bac.ftn
*
*revision
* v2_00 - Desgagne M.       - initial MPI version (from rhs v1_03)
* v2_21 - Lee V.            - modifications for LAM version
* v2_30 - Edouard  S.       - adapt for vertical hybrid coordinate
* v2_31 - Desgagne M.       - removed treatment of Hu and Qc
* v3_00 - Desgagne & Lee    - Lam configuration
* v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
* v3_21 - Desgagne M.       - Revision Openmp
*
*object
*     see documentation in s/r bac.
*
*arguments: see documentation of appropriate comdecks 
*
*implicits
#include "glb_ld.cdk"
*
      integer i, j, k, i0, j0, in, jn, nij

      i0 = 1+pil_w
      in = l_ni-pil_e
      j0 = 1+pil_s
      jn = l_nj-pil_n


      call  bacp_2_2      ( F_itr   , F_itnlh, F_st0  ,
     $                      F_fip   , F_fis  , F_tt0  ,
     $                      F_ut0   , F_vt0  , F_zdt0 ,
     $                      F_qt0   , F_wt0  , F_p    ,
     $                      F_ru    , F_rv   , F_rt   , F_rw  ,
     $                      F_rf    , F_nu   , F_nv   ,
     $                      F_nt    , F_nw   , F_nf   ,
     $                      DIST_DIM, Nk, i0, j0, in, jn )
      return
      end
!
! 2e etage pour OpenMP
!

      subroutine bacp_2_2 ( F_itr   , F_itnlh, F_st0  ,
     $                      F_fip   , F_fis  , F_tt0  ,
     $                      F_ut0   , F_vt0  , F_zdt0 ,
     $                      F_qt0   , F_wt0  , F_p    ,
     $                      F_ru    , F_rv   , F_rt   , F_rw  ,
     $                      F_rf    , F_nu   , F_nv   ,
     $                      F_nt    , F_nw   , F_nf   ,
     $                      DIST_DIM, Nk, i0, j0, in, jn )
*
      implicit none
*
      integer  F_itr, F_itnlh, DIST_DIM, Nk 
      real     F_st0  (DIST_SHAPE)     ,  F_fip   (DIST_SHAPE,0:Nk+1),
     %         F_fis  (DIST_SHAPE)     ,  F_tt0   (DIST_SHAPE,  Nk+1),
     %         F_ut0  (DIST_SHAPE,Nk)  ,  F_vt0   (DIST_SHAPE,  Nk)  ,
     %         F_zdt0 (DIST_SHAPE,Nk+1),  F_qt0   (DIST_SHAPE,0:Nk+1),
     %         F_wt0  (DIST_SHAPE,Nk+1),  F_p     (DIST_SHAPE,0:Nk+1),
     %         F_ru   (DIST_SHAPE,Nk)  ,  F_rv    (DIST_SHAPE,  Nk)  ,
     %         F_rt   (DIST_SHAPE,Nk+1),
     %         F_rf   (DIST_SHAPE,Nk+1),  F_nt    (DIST_SHAPE,  Nk+1),
     %         F_rw   (DIST_SHAPE,Nk+1),  F_nu    (DIST_SHAPE,  Nk)  ,
     %         F_nv   (DIST_SHAPE,Nk)  ,  F_nw    (DIST_SHAPE,  Nk+1),
     %         F_nf   (DIST_SHAPE,Nk+1)
*
*
*implicits
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "orh.cdk"
#include "cori.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "lun.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
#include "ptopo.cdk"
*
      integer i, j, k, i0, j0, in, jn, nij, longueur
      real*8  one, two, half, xxx, yyy, zzz, xx1, yy1, p1, p2, p3, p4, p5, p6
      parameter(one=1.d0, two=2.d0, half=.5d0)
      real*8, dimension(i0:in,j0:jn):: xtmp_8, ytmp_8, ztmp_8
      logical finbac
**
      finbac=.false.
      if ( .not. (F_itr .lt. F_itnlh) )finbac=.true.
*     __________________________________________________________________
*
      nij = (in - i0 + 1)*(jn - j0 + 1)

      if ( (Cori_cornl_L) .or. (F_itr .lt. F_itnlh) )
     $   call rpn_comm_xch_halo( F_p  , LDIST_DIM,l_ni,l_nj,G_nk+1,
     $                 G_halox,G_haloy,G_periodx,G_periody,l_ni,0)

      p1 = Dcst_rgasd_8*Cstv_tstr_8
      p2 = one/(Dcst_rgasd_8*Cstv_tstr_8)
      p3 = Cstv_tau_8**2
      p4 = one/Dcst_rayt_8**2  
      p5 = Ver_gokt2RT_8*Ver_epsilon_8
      p6 = Ver_gokt2RT_8
*
!$omp parallel private(xxx,yyy,zzz,xx1,yy1,xtmp_8,ytmp_8,ztmp_8)
*
*     Compute P at top and bottom
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~
*
!$omp do
      do j= j0, jn
         do i= i0, in
            F_p(i,j,0)    = Ver_cst_8 * (F_rt(i,j,1)-F_nt(i,j,1)) 
     $           + Ver_alphat_8*F_p(i,j,1)
            F_p(i,j,l_nk+1) = Ver_alphas_8*F_p(i,j,l_nk) 
     $           - Ver_css_8 * (F_rt(i,j,l_nk+1)-F_nt(i,j,l_nk+1)) 
         end do
      end do
!$omp enddo

!$omp single
      call rpn_comm_xch_halo(F_p,LDIST_DIM,l_ni,l_nj,G_nk+2,
     $     G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
!$omp end single
*
*     Compute U & V
*     ~~~~~~~~~~~~~
*
      if (Cori_cornl_L .or. finbac.and..not.Cori_cornl_L) then
!$omp do
         do k=1,l_nk
            do j= j0, jn
            do i= i0, l_niu-pil_e

               F_ut0(i,j,k)= Cstv_tau_8*( F_ru(i,j,k)-F_nu(i,j,k) -
     $         p4*(F_p(i+1,j,k)-F_p(i,j,k)) * geomg_invhx_8(i) )
            end do
            end do
*
            do j= j0, l_njv-pil_n
            do i= i0, in
               F_vt0(i,j,k)= Cstv_tau_8*( F_rv(i,j,k)-F_nv(i,j,k) -
     $                p4*(F_p(i,j+1,k) - F_p(i,j,k))
     $                  *geomg_cyv2_8(j)*geomg_invhsy_8(j) )
            end do
            end do

         enddo
!$omp enddo
      endif
*
*     Compute q" & w
*     ~~~~~~~~~~~~~~
*
      if (.not. Schm_hydro_L) then
*
         xxx = p5 * ( Ver_idz_8%t(1) + Dcst_cappa_8*half )
         yyy = p5 * ( Ver_idz_8%t(1) - Dcst_cappa_8*half )
         zzz = p3 * half/Ver_idz_8%t(1)
!$omp do
         do j= j0, jn 
         do i= i0, in 
c           Boundary condition at top
            F_qt0(i,j,0) =  zzz * ( F_rf(i,j,1) - F_nf(i,j,1)
     $                       - xxx * F_p(i,j,1) + yyy * F_p(i,j,0)  )
         enddo
         enddo
!$omp enddo
*        Note : we cannot use omp on loop k 
*               due to vertical dependance F_qt0(i,j,k-1)
         do k=1,l_nk+1
            xxx = p5 * ( Ver_idz_8%t(k) + Dcst_cappa_8*half )
            yyy = p5 * ( Ver_idz_8%t(k) - Dcst_cappa_8*half )
            zzz = one/(Ver_idz_8%t(k)+half)
            xx1 = Dcst_grav_8 * (Ver_idz_8%t(k)+half)
            yy1 = Dcst_grav_8 * (Ver_idz_8%t(k)-half)
!$omp do
            do j= j0, jn 
            do i= i0, in 
               F_qt0(i,j,k) = zzz * (  (Ver_idz_8%t(k)-half)*F_qt0(i,j,k-1)
     $                       - p3 * ( F_rf(i,j,k) - F_nf(i,j,k)
     $                       - xxx * F_p(i,j,k) + yyy * F_p(i,j,k-1) ) )
*
               F_wt0(i,j,k) = Cstv_tau_8 * ( F_rw(i,j,k) - F_nw(i,j,k)
     $                  + xx1 * F_qt0(i,j,k) - yy1 * F_qt0(i,j,k-1) )
            end do
            end do            
!$omp enddo     
         end do
*
      endif
*
*     Compute s
*     ~~~~~~~~~
*
!$omp do
      do j= j0, jn 
      do i= i0, in 
        F_st0(i,j) = p2*( half*(F_p(i,j,l_nk+1)+F_p(i,j,l_nk)) - F_fis(i,j) )
      end do
      end do
!$omp enddo
*
      if (.not. Schm_hydro_L) then 
!$omp do
         do j= j0, jn 
         do i= i0, in 
            F_st0(i,j) = F_st0(i,j) 
     $           - half*(F_qt0(i,j,l_nk+1)+F_qt0(i,j,l_nk))
         end do
         end do
!$omp enddo
      endif 
*
*     Compute zd
*     ~~~~~~~~~~~
*
      if(finbac.or.Schm_eulmtemp_L)then
*
!$omp do
         do j= j0, jn 
         do i= i0, in 
            F_zdt0(i,j,1)=0.
            F_zdt0(i,j,l_nk+1)=0.
         enddo
         enddo            
!$omp enddo
!$omp do
         do k=2,l_nk
            xxx=p6*(Ver_idz_8%t(k)-Ver_epsilon_8*half)
            yyy=p6*(Ver_idz_8%t(k)+Ver_epsilon_8*half)
            zzz=Ver_b_8%t(k)/Cstv_tau_8
            do j= j0, jn 
            do i= i0, in 
               F_zdt0(i,j,k)=-Cstv_tau_8*(F_rt(i,j,k)- F_nt(i,j,k)
     $                        + xxx*F_p(i,j,k) - yyy*F_p(i,j,k-1) )
     $                        - zzz*F_st0(i,j)
            enddo
            enddo
         enddo   
!$omp enddo
*
         if (.not. Schm_hydro_L) then
!$omp do
            do k=2,l_nk
               xxx=half/Cstv_tau_8
               do j= j0, jn 
               do i= i0, in 
                  F_zdt0(i,j,k)=F_zdt0(i,j,k)
     $              -xxx*(F_qt0(i,j,k)+F_qt0(i,j,k-1))
               enddo
               enddo
            enddo
!$omp enddo
         endif
*
      endif
*
*     Compute FI'
*     ~~~~~~~~~~~

!$omp do
      do k=0,l_nk+1
         xxx=p1*Ver_b_8%m(k)
         do j= j0, jn 
         do i= i0, in          
            F_fip(i,j,k)=F_p(i,j,k)-xxx*F_st0(i,j)
         enddo
         enddo
      enddo
!$omp enddo
      if (.not. Schm_hydro_L) then
!$omp do
         do k=0,l_nk+1
            do j= j0, jn 
            do i= i0, in          
               F_fip(i,j,k)=F_fip(i,j,k)-p1*F_qt0(i,j,k)       
            enddo
            enddo
         enddo
!$omp enddo
      endif    
*
*     Compute T
*     ~~~~~~~~~
*
!$omp do
      do k=1,l_nk+1
         xxx=p2*Ver_idz_8%t(k)
         do j= j0, jn 
         do i= i0, in          
            xtmp_8(i,j)=one+Ver_dbdz_8%t(k)*F_st0(i,j)
         enddo
         enddo
         call vrec ( ztmp_8, xtmp_8, nij )
         if (.not. Schm_hydro_L) then
            do j= j0, jn 
            do i= i0, in          
               xtmp_8(i,j) = half*(F_qt0(i,j,k)+F_qt0(i,j,k-1))
            enddo
            enddo
            call vexp ( ytmp_8, xtmp_8, nij )
         else
            do j= j0, jn 
            do i= i0, in          
               ytmp_8(i,j) = one
            enddo
            enddo            
         endif
         do j= j0, jn 
         do i= i0, in          
            F_tt0(i,j,k)=Cstv_tstr_8*ytmp_8(i,j)*ztmp_8(i,j)
     $           *(one-xxx*(F_fip(i,j,k)-F_fip(i,j,k-1)))
         enddo
         enddo
      enddo
!$omp enddo
*
!$omp end parallel

*     __________________________________________________________________
*
      return
      end

