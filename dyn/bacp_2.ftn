! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r  bacp_2 - backsubstitution: obtain new values of the variables:
*                                                   u,v,w,t,q,s,zd,fip 
*                   from new P , the right-hand sides (Ru,Rv,Rt,Rw,Rf)
*                                and non-linear terms (Nu,Nv,Nt,Nw,Nf)
*
#include "model_macros_f.h"
*
      subroutine bacp_2 ( F_itr , F_itnlh , F_p   , F_fis ,
     $                    F_u   , F_v     , F_w   , F_t   ,
     $                    F_s   , F_zd    , F_q   , F_fip ,
     $                    F_ru  , F_rv    , F_rt  , F_rw  , F_rf ,
     $                    F_nu  , F_nv    , F_nt  , F_nw  , F_nf ,
     $                    DIST_DIM, Nk )
*
      implicit none
*
      integer  F_itr, F_itnlh, DIST_DIM, Nk 
* 
      real     F_p    (DIST_SHAPE,0:Nk+1) ,  F_fis  (DIST_SHAPE)       ,
     %         F_u    (DIST_SHAPE,  Nk)   ,  F_v    (DIST_SHAPE,  Nk)  ,
     %         F_w    (DIST_SHAPE,  Nk+1) ,  F_t    (DIST_SHAPE,  Nk+1),
     %         F_s    (DIST_SHAPE)        ,  F_zd   (DIST_SHAPE,  Nk+1),
     %         F_q    (DIST_SHAPE,0:Nk+1) ,  F_fip  (DIST_SHAPE,0:Nk+1),
     %         F_ru   (DIST_SHAPE,  Nk)   ,  F_rv   (DIST_SHAPE,  Nk)  ,
     %         F_rt   (DIST_SHAPE,  Nk+1) ,  F_rw   (DIST_SHAPE,Nk+1)  ,
     %         F_rf   (DIST_SHAPE,  Nk+1) ,
     %         F_nu   (DIST_SHAPE,  Nk)   ,  F_nv   (DIST_SHAPE,  Nk)  ,
     %         F_nt   (DIST_SHAPE,  Nk+1) ,  F_nw   (DIST_SHAPE,  Nk+1),
     %         F_nf   (DIST_SHAPE,  Nk+1)
*
*author
*     Alain Patoine - split from bac.ftn
*
*revision
* v2_00 - Desgagne M.       - initial MPI version (from rhs v1_03)
* v2_21 - Lee V.            - modifications for LAM version
* v2_30 - Edouard  S.       - adapt for vertical hybrid coordinate
* v2_31 - Desgagne M.       - removed treatment of Hu and Qc
* v3_00 - Desgagne & Lee    - Lam configuration
* v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
* v3_21 - Desgagne M.       - Revision Openmp
*
*object
*     see documentation in s/r bac.
*
*arguments: see documentation of appropriate comdecks 
*
*implicits
#include "glb_ld.cdk"
*
      integer i, j, k, i0, j0, in, jn, nij

      i0 = 1+pil_w
      in = l_ni-pil_e
      j0 = 1+pil_s
      jn = l_nj-pil_n


      call  bacp_2_2 ( F_itr , F_itnlh , F_p   , F_fis ,
     $                 F_u   , F_v     , F_w   , F_t   ,
     $                 F_s   , F_zd    , F_q   , F_fip ,
     $                 F_ru  , F_rv    , F_rt  , F_rw  , F_rf ,
     $                 F_nu  , F_nv    , F_nt  , F_nw  , F_nf ,
     $                 DIST_DIM, Nk, i0, j0, in, jn )
      return
      end
!
! 2e etage pour OpenMP
!

      subroutine bacp_2_2 ( F_itr , F_itnlh , F_p   , F_fis ,
     $                      F_u   , F_v     , F_w   , F_t   ,
     $                      F_s   , F_zd    , F_q   , F_fip ,
     $                      F_ru  , F_rv    , F_rt  , F_rw  , F_rf  ,
     $                      F_nu  , F_nv    , F_nt  , F_nw  , F_nf  ,
     $                      DIST_DIM, Nk, i0, j0, in, jn )
*
      implicit none
*
      integer  F_itr, F_itnlh, DIST_DIM, Nk , i0, j0, in, jn
      real     F_p    (DIST_SHAPE,0:Nk+1) ,  F_fis  (DIST_SHAPE)       ,
     %         F_u    (DIST_SHAPE,  Nk)   ,  F_v    (DIST_SHAPE,  Nk)  ,
     %         F_w    (DIST_SHAPE,  Nk+1) ,  F_t    (DIST_SHAPE,  Nk+1),
     %         F_s    (DIST_SHAPE)        ,  F_zd   (DIST_SHAPE,  Nk+1),
     %         F_q    (DIST_SHAPE,0:Nk+1) ,  F_fip  (DIST_SHAPE,0:Nk+1),
     %         F_ru   (DIST_SHAPE,  Nk)   ,  F_rv   (DIST_SHAPE,  Nk)  ,
     %         F_rt   (DIST_SHAPE,  Nk+1) ,  F_rw   (DIST_SHAPE,Nk+1)  ,
     %         F_rf   (DIST_SHAPE,  Nk+1) ,
     %         F_nu   (DIST_SHAPE,  Nk)   ,  F_nv   (DIST_SHAPE,  Nk)  ,
     %         F_nt   (DIST_SHAPE,  Nk+1) ,  F_nw   (DIST_SHAPE,  Nk+1),
     %         F_nf   (DIST_SHAPE,  Nk+1)
*
*
*implicits
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "orh.cdk"
#include "cori.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "lun.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
#include "ptopo.cdk"
*
      integer i, j, k, nij, longueur
      real*8  zero, one, half, xxx, yyy, zzz, xx1, p1, p2, p3, p4, p5
      parameter(zero=0.d0, one=1.d0, half=.5d0)
      real*8, dimension(i0:in,j0:jn):: xtmp_8, ytmp_8
      logical finbac
**
      finbac=.false.
      if ( .not. (F_itr .lt. F_itnlh) )finbac=.true.
*     __________________________________________________________________
*
      nij = (in - i0 + 1)*(jn - j0 + 1)

      if ( (Cori_cornl_L) .or. (F_itr .lt. F_itnlh) )
     $   call rpn_comm_xch_halo( F_p  , LDIST_DIM,l_ni,l_nj,G_nk+2,
     $                 G_halox,G_haloy,G_periodx,G_periody,l_ni,0)

      p1 = one/(Cstv_tauT_8*Cstv_RTstr_8)
      p2 = one/Cstv_RTstr_8
      p3 = Cstv_tau_8*Cstv_tauT_8
      p4 = one/Dcst_rayt_8**2  
      p5 = Ver_gokt2RT_8*Ver_epsilon_8
*
!$omp parallel private(xxx,yyy,zzz,xx1,xtmp_8,ytmp_8)
*
*     Compute P at top and bottom
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~
*
!$omp do
      do j= j0, jn
         do i= i0, in
            F_p(i,j,0)      = Ver_alphat_8 * F_p(i,j,1)
     $                   + Ver_cst_8*(F_rt(i,j,     1)-F_nt(i,j,     1)) 
            F_p(i,j,l_nk+1) = Ver_alphas_8 * F_p(i,j,l_nk) 
     $                   - Ver_css_8*(F_rt(i,j,l_nk+1)-F_nt(i,j,l_nk+1)) 
         end do
      end do
!$omp enddo

!$omp single
      call rpn_comm_xch_halo(F_p,LDIST_DIM,l_ni,l_nj,G_nk+2,
     $     G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
!$omp end single
*
*     Compute U & V
*     ~~~~~~~~~~~~~
*
      if (Cori_cornl_L .or. (finbac.and..not.Cori_cornl_L)) then
!$omp do
         do k=1,l_nk
            do j= j0, jn
            do i= i0, l_niu-pil_e

               F_u(i,j,k)= Cstv_tau_8*( F_ru(i,j,k)-F_nu(i,j,k) -
     $                     p4*(F_p(i+1,j,k)-F_p(i,j,k))
     $                       *geomg_invhx_8(i) )
            end do
            end do
*
            do j= j0, l_njv-pil_n
            do i= i0, in
               F_v(i,j,k)= Cstv_tau_8*( F_rv(i,j,k)-F_nv(i,j,k) -
     $                     p4*(F_p(i,j+1,k) - F_p(i,j,k))
     $                       *geomg_cyv2_8(j)*geomg_invhsy_8(j) )
            end do
            end do

         enddo
!$omp enddo
      endif
*
*     Compute q & w
*     ~~~~~~~~~~~~~
*
      if (Schm_hydro_L) then
!$omp do
         do k=1,l_nk+1
            xxx = p1 * ( Ver_idz_8%t(k) + Dcst_cappa_8*half )
            yyy = p1 * ( Ver_idz_8%t(k) - Dcst_cappa_8*half )
            do j= j0, jn
            do i= i0, in
               F_w(i,j,k) = Cstv_RTstr_8/(Dcst_cappa_8*Dcst_grav_8)
     $                     *( F_rf(i,j,k) - F_nf(i,j,k)
     $                     + xxx * F_p(i,j,k) - yyy * F_p(i,j,k-1) )
            end do
            end do
         end do
!$omp enddo
*
      else
*
         xxx = p5 * ( Ver_idz_8%t(1) + Dcst_cappa_8*half )
         yyy = p5 * ( Ver_idz_8%t(1) - Dcst_cappa_8*half )
         zzz = p3 * half*Ver_dz_8%t(1)
!$omp do
         do j= j0, jn 
         do i= i0, in 
c           Top virtual level using boundary condition at true top
            F_q(i,j,0) =  zzz * ( F_rf(i,j,1) - F_nf(i,j,1)
     $                    - xxx * F_p(i,j,1) + yyy * F_p(i,j,0) )
         enddo
         enddo
!$omp enddo
*        Note : we cannot use omp on loop k 
*               due to vertical dependency F_q(i,j,k-1)
         do k=1,l_nk+1
            xxx = p5 * ( Ver_idz_8%t(k) + Dcst_cappa_8*half )
            yyy = p5 * ( Ver_idz_8%t(k) - Dcst_cappa_8*half )
            zzz = p3/Ver_idz_8%t(k)
            xx1 = Dcst_grav_8 * Ver_idz_8%t(k)
!$omp do
            do j= j0, jn 
            do i= i0, in 
               F_q(i,j,k) = F_q(i,j,k-1)
     $                    - zzz *( F_rf(i,j,k) - F_nf(i,j,k)
     $                       - xxx * F_p(i,j,k) + yyy * F_p(i,j,k-1) )
*
               F_w(i,j,k) = Cstv_tauw_8 * ( F_rw(i,j,k) - F_nw(i,j,k)
     $                  + xx1 * (F_q(i,j,k) - F_q(i,j,k-1)) )
            end do
            end do
!$omp enddo     
         end do
*

c         call glbstat (F_q ,'F_q' ,DIST_DIM,G_nk+2,i0,in,j0,jn,1,G_nk+2)
c         call glbstat (F_p ,'F_p' ,DIST_DIM,G_nk+2,i0,in,j0,jn,1,G_nk+2)
c         call glbstat (F_rf,'F_rf',DIST_DIM,G_nk+1,i0,in,j0,jn,1,G_nk+1)
c         call glbstat (F_nf,'F_nf',DIST_DIM,G_nk+1,i0,in,j0,jn,1,G_nk+1)
c         call glbstat (F_w ,'F_w ',DIST_DIM,G_nk+1,i0,in,j0,jn,1,G_nk+1)            
         

      endif
*
*     Compute s
*     ~~~~~~~~~
*
!$omp do
      do j= j0, jn 
      do i= i0, in 
         F_s(i,j) = p2*(half*(F_p(i,j,l_nk+1)+F_p(i,j,l_nk))-F_fis(i,j))
      end do
      end do
!$omp enddo
*
      if (.not. Schm_hydro_L) then 
!$omp do
         do j= j0, jn 
         do i= i0, in 
            F_s(i,j) = F_s(i,j) - half*(F_q(i,j,l_nk+1)+F_q(i,j,l_nk))
         end do
         end do
!$omp enddo
      endif 
*
*     Compute zd
*     ~~~~~~~~~~
*
      if(finbac) then
*
!$omp do
         do k=2,l_nk
            xxx=Ver_gokt2RT_8*(Ver_idz_8%t(k)-Ver_epsilon_8*half)
            yyy=Ver_gokt2RT_8*(Ver_idz_8%t(k)+Ver_epsilon_8*half)
            zzz=Ver_b_8%t(k)/Cstv_tauT_8
            do j= j0, jn 
            do i= i0, in 
               F_zd(i,j,k)=-Cstv_tau_8*(F_rt(i,j,k)- F_nt(i,j,k)
     $                       + xxx*F_p(i,j,k) - yyy*F_p(i,j,k-1) )
     $                       - zzz*F_s(i,j)
            enddo
            enddo
         enddo   
!$omp enddo
*
         if (.not. Schm_hydro_L) then
!$omp do
            do k=2,l_nk
               xxx=half/Cstv_tauT_8
               do j= j0, jn 
               do i= i0, in 
                  F_zd(i,j,k)=F_zd(i,j,k)-xxx*(F_q(i,j,k)+F_q(i,j,k-1))
               enddo
               enddo
            enddo
!$omp enddo
         endif
*
      endif
*
*     Compute FI'
*     ~~~~~~~~~~~

!$omp do
      do k=0,l_nk+1
         xxx=Cstv_RTstr_8*Ver_b_8%m(k)
         do j= j0, jn 
         do i= i0, in          
            F_fip(i,j,k)=F_p(i,j,k)-xxx*F_s(i,j)
         enddo
         enddo
      enddo
!$omp enddo
      if (.not. Schm_hydro_L) then
!$omp do
         do k=0,l_nk+1
            do j= j0, jn 
            do i= i0, in          
               F_fip(i,j,k)=F_fip(i,j,k)-Cstv_RTstr_8*F_q(i,j,k)       
            enddo
            enddo
         enddo
!$omp enddo
      endif    
*
*     Compute T
*     ~~~~~~~~~
*
!$omp do
      do k=1,l_nk+1
         xxx=p2*Ver_idz_8%t(k)
         do j= j0, jn 
         do i= i0, in          
            xtmp_8(i,j)=one+Ver_dbdz_8%t(k)*F_s(i,j)
         enddo
         enddo
         call vrec ( ytmp_8, xtmp_8, nij )
         do j= j0, jn 
         do i= i0, in          
            F_t(i,j,k)=Cstv_Tstr_8*ytmp_8(i,j)
     $           *(one-xxx*(F_fip(i,j,k)-F_fip(i,j,k-1)))
         enddo
         enddo
      enddo
!$omp enddo
*
!$omp end parallel

*     __________________________________________________________________
*
      return
      end

