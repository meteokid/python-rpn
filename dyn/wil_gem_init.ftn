***s/r wil_gem_init - Initial conditions for GEM_SW based on Williamson's cases 
*
#include "model_macros_f.h"
*
      subroutine wil_gem_init (utrue,vtrue,ptrue,MOUNT)
*
      implicit none
*
#include "glb_ld.cdk"
*
      real utrue(G_ni+2,G_nj),vtrue(G_ni+2,G_nj),
     %     ptrue(G_ni+2,G_nj),MOUNT(G_ni+2,G_nj)
*
*author M.Tanguay
*
*revision
* v4_04 - Tanguay M.       - initial version 
* v4_04 - Tanguay M.       - Williamson's cases   
*
#include "geomg.cdk"
#include "ind.cdk"
#include "ver.cdk"
#include "tr3d.cdk"
#include "vt1.cdk"
#include "ptopo.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "wil_williamson.cdk"
*
*     ---------------------------------------------------------------
      integer  vmmlod,vmmget,vmmuld
      external vmmlod,vmmget,vmmuld
*
      integer i,j,k,n,err,key0,key(Tr3d_ntr),l_nj_v,G_nj_v
      real tr
      pointer (patr, tr(LDIST_SHAPE,*))
*
      real work1(LDIST_SHAPE), work2(LDIST_SHAPE)
*
      real*8 fistr_top_8
*
      real, allocatable, dimension(:,:) :: gwork
*     ---------------------------------------------------------------
*
*     ----------
*     Treat Topo
*     ----------
          if (Ptopo_myproc.eq.0) then
*
              allocate (gwork(G_ni,G_nj),STAT=err)
*
              if (Williamson_case.eq.1) then 
                  do j=1,G_nj
                  do i=1,G_ni
                     gwork(i,G_nj-j+1) = 0.0
                  enddo
                  enddo
              else 
                  do j=1,G_nj
                  do i=1,G_ni
                     gwork(i,G_nj-j+1) = Dcst_grav_8*MOUNT(i,j)
                  enddo
                  enddo
              endif
*
          endif
*
          call rpn_comm_barrier("GRID",err)
*
*         Global distribution
*         -------------------
          call glbdist(gwork,G_ni,G_nj,Ind_topo,LDIST_DIM,1,G_halox,G_haloy)
*
*     ------------------------------------------------
*     Treat surface pressure (related to geopotential) 
*     ------------------------------------------------
          fistr_top_8=Ver_fistr_8%m(0)
*
          if (Ptopo_myproc.eq.0) then
*
              do j=1,G_nj
              do i=1,G_ni
                 if(Williamson_case.ne.1) then
                    gwork(i,G_nj-j+1) = Dcst_grav_8 * ptrue(i,j)
                 else
                    gwork(i,G_nj-j+1) = fistr_top_8 
                 endif
              enddo
              enddo
*
          endif
*
*         Global distribution
*         -------------------
          call glbdist(gwork,G_ni,G_nj, work1,LDIST_DIM,1,G_halox,G_haloy)
*
          call rpn_comm_barrier("GRID",err)
*
          do j=1,l_nj
          do i=1,l_ni
             Ind_s(i,j) = (work1(i,j)-fistr_top_8-Ind_topo(i,j))
     $                    /Cstv_rtstr_8
          enddo
          enddo
*
*     -----------------
*     Treat temperature 
*     -----------------
          do k=1,G_nk+2
          do j=1,l_nj
          do i=1,l_ni
             Ind_t(i,j,k) = Cstv_tstr_8
          end do
          end do
          end do
*
*     --------------
*     Treat U-V wind 
*     --------------
          if (Ptopo_myproc.eq.0) then
*
              do j=1,G_nj
              do i=1,G_ni
                 gwork(i,G_nj-j+1) = utrue(i,j)
              enddo
              enddo
*
          endif
*
*         Global distribution
*         -------------------
          call glbdist(gwork,G_ni,G_nj,work1,LDIST_DIM,1,G_halox,G_haloy)
*
          call rpn_comm_barrier("GRID",err)
*
          if (Ptopo_myproc.eq.0) then
*
              do j=1,G_nj
              do i=1,G_ni
                 gwork(i,G_nj-j+1) = vtrue(i,j)
              enddo
              enddo
*
          endif
*
*         Global distribution
*         -------------------
          call glbdist(gwork,G_ni,G_nj,work2,LDIST_DIM,1,G_halox,G_haloy)
*
          call rpn_comm_barrier("GRID",err)
*
*         Convert True winds to Image winds
*         ---------------------------------
          do j=1,l_nj
          do i=1,l_ni
             work1 (i,j) = work1(i,j) * Geomg_cy_8(j)/Dcst_rayt_8
             work2 (i,j) = work2(i,j) * Geomg_cy_8(j)/Dcst_rayt_8
          enddo
          enddo
*
*         Convert Image winds from scalar to staggered grids 
*         --------------------------------------------------
          call itf_phy_uvgridscal ( work1, work2, LDIST_DIM, 1, .false. )
*
          l_nj_v = l_nj 
          if (l_north) l_nj_v = l_nj - 1
*
          G_nj_v = G_nj 
          G_nj_v = G_nj - 1 
*
          do k=1,G_nk
             do j=1,l_nj
             do i=1,l_ni
                Ind_u(i,j,k) = work1(i,j)
             enddo
             enddo
*
             do j=1,l_nj_v
             do i=1,l_ni
                Ind_v(i,j,k) = work2(i,j)
             enddo
             enddo
          enddo
*
*     -------------
*     Treat Tracers 
*     -------------
      if (Tr3d_ntr.gt.0) then
*
         key0 = VMM_KEY (trt1)
         do n=1,Tr3d_ntr
            key(n) = key0 + n 
         end do
*
         err = vmmlod(key,Tr3d_ntr)
         do n=1,Tr3d_ntr
            err = vmmget(key(n),patr,tr)
*
            if (Ptopo_myproc.eq.0) then
*
                do j=1,G_nj
                do i=1,G_ni
                   if (Williamson_case.ne.1) then
                      gwork(i,G_nj-j+1) = 0.0 
                   else
                      gwork(i,G_nj-j+1) = ptrue(i,j)
                   endif
                enddo
                enddo
*
            endif
*
*           Global distribution
*           -------------------
            call glbdist(gwork,G_ni,G_nj,work1,LDIST_DIM,1,G_halox,G_haloy)
*
            call rpn_comm_barrier("GRID",err)
*
            do k=1,G_nk
               do j=1,l_nj
               do i=1,l_ni
                  tr(i,j,k) = work1(i,j) 
               enddo
               enddo
            enddo 
*
         end do
         err = vmmuld(key,Tr3d_ntr)
*
      endif
*
      if (Ptopo_myproc.eq.0) deallocate (gwork) 
*
      return
      end
