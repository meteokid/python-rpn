!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r out_dyn - perform dynamic output
!
#include "model_macros_f.h"
!
      subroutine out_dyn (reg_out,casc_out)
      use out_vref_mod, only: out_vref
      implicit none
!
      logical reg_out
      integer casc_out
!
!author
!     V. Lee    - rpn - July  2004 (from dynout2 v3_12)
!
!revision
! v3_20 - Lee V.            - Initial MPI version (from dynout2 v3_11)

! v3_30 - Milbrandt J.      - Added extra hydrometeor variables (snow and hail)
!                             for Milbrandt-Yau scheme for water-loading
! v3_30 - McTaggart-Cowan R.- Allow for user-defined domain tag extensions
! v4_00 - Plante & Girard   - Log-hydro-pressure coord on Charney-Phillips grid
!                             QR to QL(rain),QG to QJ(graupel),
!                             QC to QB(cloud;Kong-Yau and Milbrandt-Yau only)
! v4_00 - Plante & Girard   - Log-hydro-pressure coord on Charney-Phillips grid
! v4_03 - Lee V.            - modification of Out_etik_S in out_sgrid only
! v4_04 - Tanguay M.        - Staggered version TL/AD
! v4_05 - Lepine/Lee        - VMM replacement with GMM
!
!object
!     Subroutine to control the production of
!     the output of the dynamic variables
!
!arguments
!  NONE
!
!implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "out3.cdk"
#include "lun.cdk"
#include "geomn.cdk"
#include "schm.cdk"
#include "pres.cdk"
#include "init.cdk"
#include "rstr.cdk"
#include "vt0.cdk"
#include "vt1.cdk"
#include "vtx.cdk"
#include "vth.cdk"
#include "p_geof.cdk"
#include "cube.cdk"
#include "outd.cdk"
#include "tr3d.cdk"
#include "grd.cdk"
#include "grdc.cdk"
#include "lctl.cdk"
#include "vt1_m.cdk"
#include "cstv.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "vinterpo.cdk"
#include "out.cdk"
#include "acid.cdk"
!
!*
      integer doout, longueur
      external doout, longueur
!
      integer dostep(MAXSET), dostep_max, step, &
              pnlkey(20),i,j,k
      character*4 ext_S
      character*6 etikadd_S
      integer jj,kk,levset,n,ip3,nk_o,nk_ot,gridset
!     nk_o - number of momentum levels for output
!     nk_ot - number of thermo levels for output
      character*15 datev,pdate
      integer,   dimension(:), allocatable :: ind_o
      integer is,nis,js,jn,njs,iw,ie,niw,jw,njw
      real deg2rad
      real wlnpi_m(LDIST_SHAPE,0:G_nk+1), wlnpi_t(LDIST_SHAPE,G_nk+2)
      real p0(LDIST_SHAPE)
      integer key_m(Tr3d_ntr),ninj
      logical periodx_L,doneonce,ontimec
      real*8 dayfrac,sec_in_day
      parameter ( sec_in_day=86400.0d0 )
      data doneonce/.false./
      save doneonce
!*
!
!     check if output is required and initialize control tables
!     ---------------------------------------------------------------
!
      if (Rstri_rstn_L.and..not.doneonce) goto 998
!
!
!########## REGULAR OUTPUT #######################################
!
      if (reg_out) then
!
      dostep_max = doout(dostep,1)
      deg2rad    = acos( -1.0)/180.
!
      if ( dostep_max.gt.0 ) then

         if (Lun_out.gt.0) write(Lun_out,7001) Lctl_step
      else
!
         if (Lun_out.gt.0) write(Lun_out,7002) Lctl_step
         return
!
      endif
!
      call tmg_start( 66, 'OUT_DYN')
!
!     PREPARATION for OUT_THM
!    ---------------------------
!
      ninj=(l_maxx-l_minx+1)*(l_maxy-l_miny+1)
      gmmstat = gmm_get(gmmk_st1_s,st1,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'out_dyn ERROR at gmm_get(st1)'
      call out_padbuf(st1,l_minx,l_maxx,l_miny,l_maxy,1)
      p0(l_minx:l_maxx,l_miny:l_maxy) = exp(st1(l_minx:l_maxx,l_miny:l_maxy))*Cstv_pref_8     
!
!
!        Log-pressure on momentum and thermo levels, 
!        with extra momentum levels at top (k=0) and surface (k=G_nk+1)
!        and with an extra thermo level at surface (k=G_nk+2)
!
      wlnpi_m(:,:,0)= Cstv_Ztop_8
      do k=1,G_nk+1
         do j=l_miny,l_maxy
         do i=l_minx,l_maxx
            wlnpi_m(i,j,k) = Ver_a_8%m(k) + Ver_b_8%m(k)*st1(i,j)
            wlnpi_t(i,j,k)=.5d0*(wlnpi_m(i,j,k)+wlnpi_m(i,j,k-1))
          enddo
         enddo
      enddo
!
      if (Schm_autobar_L)  wlnpi_t(:,:,1) = Cstv_ztop_8
!
      wlnpi_t (:,:,G_nk+2) = wlnpi_m (:,:,G_nk+1)
!
!     Allocate work space and initialize

!
!     setup of ip3 and modifs to label
!
      ip3 = 0
      etikadd_S = ' '
      ext_S=""
      if (Out3_ip3.eq.-1) ip3 = Lctl_step
      if (Out3_ip3.gt.0 ) ip3 = Out3_ip3
!
      call v4d_out_ipext (ip3, ext_S, etikadd_S)
!
!     setup of filename extension if needed
      if ( ((Init_balgm_L).and.(.not.Rstri_idon_L)).and. &
           ((Lctl_step.ge.(Init_dfnp-1)/2)) ) &
           ext_S = '_dgf'

!     output loop on the number of "sortie" sets
      do 100 jj=1,dostep_max

         do 50 kk=1, Outd_sets

            if ( Outd_step(kk).eq.dostep(jj) ) then
!              (if the timestep set of this sortie set is to output now)
                periodx_L=.false.
                gridset = Outd_grid(kk)
                levset = Outd_lev(kk)
                if (.not.G_lam .and. (Grid_x1(gridset) &
                    -Grid_x0(gridset)+1).eq. G_ni ) periodx_L=.true.
                call out_sgrid(Grid_x0(gridset),Grid_x1(gridset), &
                         Grid_y0(gridset),Grid_y1(gridset), &
                         Cube_ig1(gridset,Level_typ_indx(levset)), &
                         Cube_ig2(gridset,Level_typ_indx(levset)), &
                         periodx_L, Grid_stride(gridset), &
                         Grid_etikext_s(gridset),etikadd_S )
                nk_o   = Level_max(levset)
                allocate (ind_o(nk_o+2))
                call out_slev(Level_types(Level_typ_indx(levset)),Level(1,levset), &
                             ind_o,nk_o,nk_ot,G_nk,Level_kind_ip1,'d')
                call out_sfile(Out3_closestep,Lctl_step,ip3,ext_S)
                call out_href( Geomn_longs,Geomn_latgs)
                if (Out_levtyp_S.eq.'M') then
                   call out_vref(p0,LDIST_DIM)
                elseif (Out_levtyp_S.eq.'P') then
                   call out_vref(Cube_v(1:Cube_vcount(Level_typ_indx(levset)),Level_typ_indx(levset)))
                endif
!
!     output of 3-D tracers
!
                call out_tracer (wlnpi_t,LDIST_DIM,G_nk, &
                            Out_levtyp_S,Level(1,levset),ind_o,nk_ot,kk)
!
!     output of temperature, humidity and mass fields,omega
!     
                call out_thm( wlnpi_m,wlnpi_t,st1, &
                            LDIST_DIM,G_nk,Out_levtyp_S, Level(1,levset), &
                            ind_o,nk_o,nk_ot,kk)
!
!     output of winds
!
                call out_uv(wlnpi_m(l_minx,l_miny,1), &
                    LDIST_DIM,G_nk,Out_levtyp_S,Level(1,levset), &
                    ind_o,nk_o,kk)
!
!     output of divergence and vorticity
!
                call out_dq (wlnpi_m(l_minx,l_miny,1), &
                   LDIST_DIM,G_nk, Out_levtyp_S,Level(1,levset), &
                   ind_o,nk_o,kk)
!
!     output of gmm
!
                call out_gmm (p0, LDIST_DIM, ip3, etikadd_S,ext_S, &
                    Level(1,levset),ind_o,nk_o,nk_ot,kk)
                deallocate (ind_o)
            endif

      call out_cfile
  50  continue

 100  continue
!
!     Delay closure of files, de-allocation, wlog write out if...
      if ( .not. (Lctl_step .eq. 0 .and. Schm_phyms_L)) then
!
!
         if((Init_balgm_L) .and. (.not. Rstri_idon_L) ) then
             call wlog('IOUT')
         else
             call wlog('FOUT')
         endif
      endif
!
      call tmg_stop(66, 'OUT_DYN')
!     end of regular output
      endif
!
!#################################################################
!
!########## SPECIAL OUTPUT FOR CASCADE ###########################
!
      if ((casc_out.gt.0).and.(Grdc_proj_S.ne.'@').and.(Grdc_ndt.ge.0)) &
      then
!
      ontimec = .false.
      if ( Lctl_step.ge.Grdc_start.and.Lctl_step.le.Grdc_end) then
      if ( Grdc_ndt.eq.0 ) then
         ontimec = Lctl_step.eq.0
      else
         ontimec = (mod(Lctl_step+Grdc_start,Grdc_ndt).eq.0)
      endif
      endif
!
      if ( ((Init_balgm_L).and.(.not.Rstri_idon_L)).and. &
           ((Lctl_step.gt.(Init_dfnp-1)/2)) ) ontimec = .false.

      if ( ontimec ) then
!
         if ((Lctl_step.eq.Grdc_start).or.(.not.Grdc_bcs_hollow_L)) then
!
             call out_sgrid (Grdc_gid,Grdc_gif,Grdc_gjd,Grdc_gjf, &
                             0,0,.false.,1,'','')

             call datf2p (pdate,Out3_date)
             dayfrac = dble(Lctl_step) * Cstv_dt_8 / sec_in_day
             call incdatsd (datev,pdate,dayfrac)
             if (Acid_test_L.and.Lctl_step.eq.Grdc_start) then
               call acid_outdyn_3df (datev,casc_out,Grdc_gid,Grdc_gif, &
                                                    Grdc_gjd,Grdc_gjf)
             else
               call out_dyn_3df (datev,casc_out,Grdc_gid,Grdc_gif, &
                                                Grdc_gjd,Grdc_gjf)
             endif
!
         else
!
            call bcs_hollow(Grdc_gid,Grdc_gif,Grdc_gjd,Grdc_gjf, &
            Grdc_gjdi,Grdc_hbsn,Grdc_hbwe,is,nis,js,njs,jn,iw,niw,ie,jw,njw)
            call datf2p (pdate,Out3_date)
            dayfrac = dble(Lctl_step) * Cstv_dt_8 / sec_in_day
            call incdatsd (datev,pdate,dayfrac)
            call out_dyn_bcs (datev,is,nis,js,jn,njs,iw,ie, &
                                         niw,jw,njw,casc_out)
         endif
!
      endif
!
      ontimec = .false.
!
      endif
!
 998  doneonce = .true.
!
 7001 format(/,' OUT_DYN- WRITING DYNAMIC OUTPUT FOR STEP (',I8,')')
 7002 format(/,' OUT_DYN- NO DYNAMIC OUTPUT FOR STEP (',I8,')')
!
      return
      end

