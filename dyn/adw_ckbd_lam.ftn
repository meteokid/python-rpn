***s/r adw_ckbd_lam - check if upstream points from each north/south/east/west
*                   pe's for which an interpolation is requested are
*                   inside own advection source grid.
*
#include "model_macros_f.h"
*
      subroutine adw_ckbd_lam ( F_x_in,  F_y_in,  F_z_in, i0, in,j0,jn,F_nk )
*
      implicit none
*
      integer i0, in, j0, jn, F_nk
      real    F_x_in  ( * ), F_y_in  ( * ), F_z_in  ( * )
*
*author
*     Vivian Lee         March 2002 
*
*revision
* v3_02 - Lee V.  - extracted LAM code originally placed in adw_exch_1
* v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
* v3_30 - Lee V.  - Stop run with only one print statement of problem
*
*object
*     For LAM mode only:
*     Check if upstream points of each PE from their local boundaries
*     north/south/east/west are outside their local advection source
*     grid. If they are and the local boundary is NOT the border of
*     the global grid, the routine will stop. If the local boundary is
*     the border of the global grid AND Adw_trunc_traj_L is TRUE, then
*     the routine will truncate the trajectory and the model will 
*     continue. (Counter for truncated trajectories is activated)
*     If Adw_trunc_traj_L is set to FALSE, the routine will stop and
*     recommend the user to reduce Cstv_dt_8 (timestep length).
*
*arguments
*______________________________________________________________________
*              |                                                 |     |
* NAME         | DESCRIPTION                                     | I/O |
*--------------|-------------------------------------------------|-----|
* F_x_out      | \ coordinates of upstream                       |  o  |
* F_y_out      |   positions outside advection                   |  o  |
* F_z_out      | / source grid                                   |  o  |
*              |                                                 |     |
* F_c_out      | 3D coordinates of points for which upstream     |  o  |
*              | positions are outside advection source grid     |     |
*              |                                                 |     |
* F_x_in       | \                                               |  i  |
* F_y_in       |   upstream positions                            |  i  |
* F_z_in       | /                                               |  i  |
* i0           | starting i position to check for LAM            |  i  |
* in           | ending i position to check for LAM              |  i  |
* j0           | starting j position to check for LAM            |  i  |
* jn           | ending j position to check for LAM              |  i  |
*______________|_________________________________________________|_____|
*
*
*implicits
#include "ptopo.cdk"
#include "glb_ld.cdk"
#include "type.cdk"
#include "geomg.cdk"
#include "adw.cdk"
#include "lun.cdk"

************************************************************************
*
      integer n, nij, i, j, k, ierr
      integer err(8),totalerr(8)
*
      err(:) = 0
      nij  = l_ni*l_nj
*
************************************************************************
*
      if (l_north) then
         do k=1,F_nk
         do j=j0,jn
         do i=i0,in
            n = (k-1)*nij + ((j-1)*l_ni) + i
            if ( F_y_in(n).ge.Adw_yy_8(Adw_njt-(Adw_haloy+1)) ) then
                 if (Adw_trunc_traj_L) then
                     F_y_in(n) = Adw_yy_8(Adw_njt-(Adw_haloy+2))
                     Adw_trunc(1)=Adw_trunc(1) + 1
                 else
                    err(1) = 1
                 endif
            endif
         enddo
         enddo
         enddo
      else
         do k=1,F_nk
         do j=j0,jn
         do i=i0,in
            n = (k-1)*nij + ((j-1)*l_ni) + i
            if ( F_y_in(n).ge.Adw_yy_8(Adw_njt-1) ) then
                 err(1) = 1
                 err(2) = 1+ (F_y_in(n)-Adw_yy_8(Adw_njt-1))/Adw_dly_8(1)
            endif
         enddo
         enddo
         enddo
      endif
*
      if (l_south) then
         do k=1,F_nk
         do j=j0,jn
         do i=i0,in
            n = (k-1)*nij + ((j-1)*l_ni) + i
            if ( F_y_in(n).le.Adw_yy_8(Adw_haloy+2) ) then
                 if (Adw_trunc_traj_L) then
                     F_y_in(n) = Adw_yy_8(Adw_haloy+3)
                     Adw_trunc(2)=Adw_trunc(2) + 1
                 else
                     err(3) = 1
                 endif
            endif
         enddo
         enddo
         enddo
      else
         do k=1,F_nk
         do j=j0,jn
         do i=i0,in
            n = (k-1)*nij + ((j-1)*l_ni) + i
            if ( F_y_in(n).le.Adw_yy_8(2) ) then
                 err(3) = 1
                 err(4) = 1+ (Adw_yy_8(2)-F_y_in(n))/Adw_dly_8(1)
            endif
         enddo
         enddo
         enddo
      endif
*
      if (l_east) then
         do k=1,F_nk
         do j=j0,jn
         do i=i0,in
            n = (k-1)*nij + ((j-1)*l_ni) + i
            if ( F_x_in(n).ge.Adw_xx_8(Adw_nit-(Adw_halox+1)) ) then
                 if (Adw_trunc_traj_L) then
                     F_x_in(n) = Adw_xx_8(Adw_nit-(Adw_halox+2))
                     Adw_trunc(3)=Adw_trunc(3) + 1
                 else
                     err(5) = 1
                 endif
            endif
         enddo
         enddo
         enddo
      else
         do k=1,F_nk
         do j=j0,jn
         do i=i0,in
            n = (k-1)*nij + ((j-1)*l_ni) + i
            if ( F_x_in(n).ge.Adw_xx_8(Adw_nit-1) ) then
                 err(6) = 1+ (F_x_in(n)-Adw_xx_8(Adw_nit-1))/Adw_dlx_8(1)
                 err(5) = 1
            endif
         enddo
         enddo
         enddo
      endif
*
      if (l_west) then
         do k=1,F_nk
         do j=j0,jn
         do i=i0,in
            n = (k-1)*nij + ((j-1)*l_ni) + i
            if ( F_x_in(n).le.Adw_xx_8(Adw_halox+2) ) then
                 if (Adw_trunc_traj_L) then
                     F_x_in(n) = Adw_xx_8(Adw_halox+3)
                     Adw_trunc(4)=Adw_trunc(4) + 1
                 else
                     err(7) = 1
                 endif
            endif
         enddo
         enddo
         enddo
      else
         do k=1,F_nk
         do j=j0,jn
         do i=i0,in
            n = (k-1)*nij + ((j-1)*l_ni) + i
            if ( F_x_in(n).le.Adw_xx_8(2) ) then
                 err(8) = 1+ (Adw_xx_8(2)-F_x_in(n))/Adw_dlx_8(1)
                 err(7) = 1
            endif
         enddo
         enddo
         enddo
      endif
*
      call rpn_comm_ALLREDUCE ( err, totalerr, 8,
     $                 "MPI_INTEGER","MPI_MAX","grid",ierr )
      if (Lun_out.gt.0) then
          if (totalerr(1).gt.0) then
              if (totalerr(2).gt.0) then
                   print *,'error exch northwards: Adw_haloy+',totalerr(2)
              else
                   print *, 'error exch NORTH WALL: reduce Cstv_dt_8'
              endif
          endif
          if (totalerr(3).gt.0) then
              if (totalerr(4).gt.0) then
                   print *,'error exch southwards: Adw_haloy+',totalerr(4)
              else
                   print *, 'error exch SOUTH WALL: reduce Cstv_dt_8'
              endif
          endif
          if (totalerr(5).gt.0) then
              if (totalerr(6).gt.0) then
                   print *,'error exch eastwards: Adw_halox+',totalerr(6)
              else
                   print *, 'error exch EAST WALL: reduce Cstv_dt_8'
              endif
          endif
          if (totalerr(7).gt.0) then
              if (totalerr(8).gt.0) then
                   print *,'error exch westwards: Adw_halox+',totalerr(8)
              else
                   print *, 'error exch WEST WALL: reduce Cstv_dt_8'
              endif
          endif
      endif
      
      if   (totalerr(1).gt.0.or.totalerr(3).gt.0.or.
     %      totalerr(5).gt.0.or.totalerr(7).gt.0) 
     %      call gem_stop ( 'adw_ckbd_lam', -1 )
*     
      return
      end
