!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#include "msg.h"

!/**
subroutine adx_interp_gmm5 ( F_out_S, F_in_S, F_wind_L, &
                             F_capx1, F_capy1, F_capz1, &
                             F_capx2, F_capy2, F_capz2, &
                             F_c1, F_nk, i0,in,j0,jn,k0, F_lev_S)
   implicit none
#include <arch_specific.hf>
!
   !@objective
!
   !@arguments
   character(len=*) :: F_out_S !I, gmm label for interpolated field
   character(len=*) :: F_in_S  !I, gmm label for field to interpolate
   logical :: F_wind_L         !I, .true. if field is wind like
   integer :: F_nk             !I, number of vertical levels
   integer :: i0,in,j0,jn,k0   !I, scope of operator
   integer :: F_c1(*)
   real    :: F_capx1(*), F_capy1(*), F_capz1(*)
   real    :: F_capx2(*), F_capy2(*), F_capz2(*)
   character(len=*) :: F_lev_S !I, m/t : Momemtum/thermo level
!
   !@revisions
   !  2009-12,  Stephane Chamberland: original code from adx_main_3
!**/

#include "gmm.hf"
#include "adx_nml.cdk"

   type(gmm_metadata) :: mymeta
   logical :: mono_L
   integer :: err
   real, pointer, dimension (:,:,:) :: fld_in,fld_out

   !---------------------------------------------------------------------

   call msg(MSG_DEBUG,'adx_interp_gmm')

   err =     gmm_get(F_in_S ,fld_in ,mymeta)
   err = min(gmm_get(F_out_S,fld_out,mymeta),err)
   call handle_error(err,'adx_interp_gmm','gmm_get for '//trim(F_in_S)//', '//trim(F_out_S))

   mono_l = .false.
   if (F_in_S(1:3) == 'TR/') mono_L = adw_mono_L

   if (adw_stats_L) call glbstat2(fld_in, F_in_S, 'adx_int',                  &
           mymeta%l(1)%low,mymeta%l(1)%high, mymeta%l(2)%low,mymeta%l(2)%high,&
           1,F_nk, i0,in,j0,jn,1,F_nk)

   call adx_interp5 (fld_out, fld_in,  F_c1,                 &
                     F_capx1, F_capy1, F_capz1,              &
                     F_capx2, F_capy2, F_capz2,              &
                     mymeta%l(1)%low,mymeta%l(1)%high,       &
                     mymeta%l(2)%low,mymeta%l(2)%high, F_nk, &
                     F_wind_L, mono_L, i0,in,j0,jn,k0, F_lev_S)

   if (adw_stats_L) call glbstat2(fld_out, F_out_S, 'adx_int',                &
           mymeta%l(1)%low,mymeta%l(1)%high, mymeta%l(2)%low,mymeta%l(2)%high,&
           1,F_nk, i0,in,j0,jn,1,F_nk)

   call msg(MSG_DEBUG,'adx_interp_gmm [end]')

   !---------------------------------------------------------------------

   return
end subroutine adx_interp_gmm5
