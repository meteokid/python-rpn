!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r adw_main - adw_main_1_wnd: Process winds in preparation for advection
!                 adw_main_2_pos: Calculate upstream positions at th and t1
!                 adw_main_3_int: Interpolation of rhs
!
#include "model_macros_f.h"
#include "msg.h"
!
      subroutine adw_main (F_it,F_isStatStep_L)
!
      implicit none
#include <arch_specific.hf>
!
      integer F_it
      logical F_isStatStep_L
!
!author
!     alain patoine
!
!revision
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_01 - Lee V.            - Initialize Lam truncated trajectory counters
! v3_20 - Tanguay M.        - Option of storing instead of redoing TRAJ 
! v4_04 - Tanguay M.        - Staggered version TL/AD 
! V4_10 - Plante A.         - Thermo upstream positions
!
!object
!     see id section
!
!arguments
!______________________________________________________________________
!        |                                                       |     |
! NAME   | DESCRIPTION                                           | I/O |
!--------|-------------------------------------------------------|-----|
! F_it   | total number of iterations for trajectories           |  i  |
!________|_______________________________________________________|_____|
!
!notes
!______________________________________________________________________
!                             WORK FIELDS                              |
!----------------------------------------------------------------------|
! There are 3 different species of work fields used throughout the     |
! advection process.                                                   |
!----------------------------------------------------------------------|
! wrk1?: Local grid, no halos, allocated in adw_main (12 units)        |
!        Used in adw_main_2_pos and adw_main_3_int to cary upstream    |
!        positions coordinates, interpolation parameters and           |
!        interpolated values.                                          |
!----------------------------------------------------------------------|
! wrk2?: Used to store positions and interpolation parameters relative |
!        to the work to be done for north and south neighbors.         |
!        Allocated to fit the number of points to treat.               |
!        Used both in adw_main_2_pos and adw_main_3_int (12 units).    |
!----------------------------------------------------------------------|
! wrk3?: Advection grid, with halos, allocated in adw_main (3 units).  |
!        Used for different purpose:                                   |
!                                                                      |
!                            adw_main_1_wnd ---> ( winds in work3 )    |
!                                                                      |
!    ( winds in work3 ) ---> adw_main_2_pos ---> ( t1 pos. in wrk3 )   |
!                                                                      |
!    ( t1 pos. in wrk3) ---> adw_main_3_int                            |
!                                                                      |
! Note that when we cary t1 positions in wrk3, it is larger than the   |
! data.                                                                |
!______________________________________________________________________|
!
!implicits
#include "gmm.hf"
!#include "var_gmm.cdk"
#include "glb_ld.cdk"
!      integer G_nk
!      integer l_ni,l_nj
#include "adw.cdk"
!      integer adw_nit,adw_njt
!      integer            Adw_trunc(4)
       include "v4dg.inc"
!      integer V4dg_conf
!      logical V4dg_oktr_L
#include "vth.cdk"
#include "vt1.cdk"
!
!modules
!***********************************************************************
      type(gmm_metadata) :: dummy_gmm_meta
      integer :: i,istat,i0,in,j0,jn
      real, dimension(Adw_nit*Adw_njt,  G_nk  ) :: pxm,pym,pzm,um,vm,wm
      real, dimension(Adw_nit*Adw_njt,  G_nk+1) :: pxt,pyt,pzt,ut,vt,wt
      real, dimension(Adw_nit*Adw_njt,2*G_nk+1) :: su,sv,sw
      real, dimension(l_ni*l_nj*(l_nk+1)) :: l_xct1,l_yct1,l_zct1
      real dummy

      logical v4dstore_L
      logical :: save_stats_L

!***********************************************************************
      call msg(MSG_DEBUG,'ADVECT THE RIGHT-HAND-SIDES: (S/R ADW_MAIN)')
!***********************************************************************
      save_stats_L = adw_stats_L
      adw_stats_L = (F_isStatStep_L .and. adw_stats_L)
      v4dstore_L = V4dg_conf.ne.0 .and. V4dg_oktr_L 

      do i=1, 4
         Adw_trunc(i) = 0
      enddo

      call adw_main_1_wnd2(su,sv,sw,um,vm,wm,ut,vt,wt,l_ni,l_nj,G_nk)

      istat = gmm_get(gmmk_xth_s,xth,dummy_gmm_meta)
      istat = min(istat,gmm_get(gmmk_yth_s,yth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zth_s,zth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xcth_s,xcth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_ycth_s,ycth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zcth_s,zcth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xct1_s,xct1,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_yct1_s,yct1,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zct1_s,zct1,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xth_thermo_s,xth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_yth_thermo_s,yth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zth_thermo_s,zth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xcth_thermo_s,xcth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_ycth_thermo_s,ycth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zcth_thermo_s,zcth_thermo,dummy_gmm_meta))
      call handle_error(istat,'adw_main','gmm_get')

      call adw_main_2_pos ( &
           F_it,'m',l_nk, &
           pxm ,pym ,pzm , &
           su  ,sv  ,sw  , &
           xth ,yth ,zth , &
           xcth,ycth,zcth, &
           xct1,yct1,zct1, &
           dummy,dummy)

      call adw_main_2_pos ( &
           F_it       ,'t'        ,l_nk+1, &
           pxt        ,pyt        ,pzt, &
           su         ,sv         ,sw, &
           xth_thermo ,yth_thermo ,zth_thermo, &
           xcth_thermo,ycth_thermo,zcth_thermo, &
           l_xct1     ,l_yct1     ,l_zct1, &
           pxm        ,pym)


      if (adw_stats_L) then
         call adw_get_ij0n(i0,j0,in,jn)
         call adx_main_2_pos_stats( &
              'm', su  ,sv  ,sw  , &
              pxm,  pym,  pzm , &
              xth , yth , zth , &
              xcth, ycth, zcth, &
              xct1, yct1, zct1, &
              1-adw_halox,Adw_nit-adw_halox,1-adw_haloy,Adw_njt-adw_haloy,2*l_nk+1,&
              l_ni, l_nj, l_nk,l_nk, i0,in,j0,jn)
         call adx_main_2_pos_stats(  &
              't', su  ,sv  ,sw  , &
              pxt,    pyt,    pzt, &
              xth_thermo,  yth_thermo,  zth_thermo, &
              xcth_thermo, ycth_thermo, zcth_thermo, &
              l_xct1, l_yct1, l_zct1, &
              1-adw_halox,Adw_nit-adw_halox,1-adw_haloy,Adw_njt-adw_haloy,2*l_nk+1,&
              l_ni, l_nj, l_nk,l_nk+1,i0,in,j0,jn)
      endif

!     Store TRAJ upstream positions 
!     -----------------------------
      if ( v4dstore_L ) call v4d_rwtraj (5,pxm,pym,pzm,pxt,pyt,pzt,l_ni,l_nj,G_nk,G_nk+1) 

!     Store TRAJ RHS before interpolation
!     -----------------------------------
      if ( v4dstore_L ) call v4d_rwtraj (11)
      call adw_main_3_intlag(pxm,pym,pzm,pxt,pyt,pzt,F_isStatStep_L)

!     Store TRAJ RHS interpolated
!     ---------------------------
      if ( v4dstore_L ) call v4d_rwtraj (6)

      adw_stats_L = save_stats_L
!**********************************************************************
      return
      end

