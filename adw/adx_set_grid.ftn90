!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "constants.h"
#include "msg.h"

!/**
subroutine adx_set_grid()
   implicit none
   !@objective Compute derived grid parameters
   !@author Stephane Chamberland, 2010-01
   !@revisions
   !**/
#include "adx_dims.cdk"
#include "adx_grid.cdk"
   integer :: istat, i, j
   real*8 :: prhxmn, prhymn
   !---------------------------------------------------------------------
   allocate( &
        adx_xx_8(adx_lminx:adx_lmaxx), &
        adx_cx_8(adx_lni), &
        adx_sx_8(adx_lni), &
        adx_wx_8(adx_lni), &
        adx_yy_8(adx_lminy:adx_lmaxy), &
        adx_cy_8(adx_lnj), &
        adx_sy_8(adx_lnj), &
        stat = istat)
   call handle_error_l(istat==0,'adx_set_grid','problem allocating mem')

   IF_LAM1: if (.not.adx_lam_L) then

      do i = adx_gminx,0
         adx_xg_8(i) = adx_xg_8(i+adx_gni) - CONST_2PI_8
      enddo
      do i = adx_gni+1,adx_gmaxx
         adx_xg_8(i) = adx_xg_8(i-adx_gni) + CONST_2PI_8
      enddo

      j = -1
      adx_yg_8(j) = -1.D0 * (CONST_PI_8 + adx_yg_8(j+2))
      j = 0
      adx_yg_8(j) = -1.D0* CONST_HALF_PI_8
      do j = -2,adx_gminy,-1
         adx_yg_8(j) = 2.D0*adx_yg_8(j+1) - adx_yg_8(j+2)
      enddo
      j = adx_gnj+1
      adx_yg_8(j) = CONST_HALF_PI_8
      j = adx_gnj+2
      adx_yg_8(j) = CONST_PI_8 - adx_yg_8(j-2)
      do j = adx_gnj+3,adx_gmaxy
         adx_yg_8(j) = 2.D0*adx_yg_8(j-1) - adx_yg_8(j-2)
      enddo

   else !IF_LAM1

      prhxmn =  adx_xg_8(2)-adx_xg_8(1)
      do i = 0,adx_gminx,-1
         adx_xg_8(i) = adx_xg_8(i+1) - prhxmn
      enddo
      do i = adx_gni+1,adx_gmaxx
         adx_xg_8(i) = adx_xg_8(i-1) + prhxmn
      enddo

      prhymn =  adx_yg_8(2)-adx_yg_8(1)
      do j = 0,adx_gminy,-1
         adx_yg_8(j) = adx_yg_8(j+1) - prhymn
      enddo
      do j = adx_gnj+1,adx_gmaxy
         adx_yg_8(j) = adx_yg_8(j-1) + prhymn
      enddo

   endif IF_LAM1

   !- advection grid
   do i = adx_lminx,adx_lmaxx
      adx_xx_8(i) = adx_xg_8(adx_li0-1+i)
   enddo
   do j = adx_lminy,adx_lmaxy
      adx_yy_8(j) = adx_yg_8(adx_lj0-1+j)
   enddo

   if (.not.adx_lam_L) then
      do i = 1,adx_lni
         adx_wx_8(i) = 0.5D0*(adx_xx_8(i+1) - adx_xx_8(i-1)) / CONST_2PI_8
      enddo
   endif

   do i = 1,adx_lni
      adx_cx_8(i) = cos(adx_xx_8(i))
      adx_sx_8(i) = sin(adx_xx_8(i))
   enddo

   do j = 1,adx_lnj
      adx_cy_8(j) = cos(adx_yy_8(j))
      adx_sy_8(j) = sin(adx_yy_8(j))
   enddo
   !---------------------------------------------------------------------
   return
end subroutine adx_set_grid
