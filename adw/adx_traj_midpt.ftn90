!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#include "msg.h"
#include "constants.h"
#include "stop_mpi.h"
!/**
subroutine adx_traj_midpt ( F_lon, F_lat, F_x, F_y, F_z, F_um, F_vm, &
                            F_dth,i0,in,j0,jn,k0 )
   implicit none
#include <arch_specific.hf>
!
   !@objective improves estimates of upwind positions
!
   !@arguments
   real, dimension(*) :: &
        F_lon,         &     !O, upwind longitudes at central time 
        F_lat,         &     !I/O, upwind lat at central time 
        F_x, F_y, F_z, &     !O, upwind cartesian positions at central time
        F_um, F_vm           !I, real wind components at midpoint
   real    :: F_dth          !I, half-timestep lenght
   integer :: i0,in,j0,jn,k0 !I, scope of operator
!
   !@author  Claude Girard
   !@revisions
!**/

#include "adx_dims.cdk"
#include "adx_grid.cdk"

   integer :: vnij, i,j,k, n
   real*8 :: pdsyM, pdcyM, pdcyMi, pdsxM, pdcxM, pdsinM, pdsecM
   real*8 :: pdcxA, pdsxA, pdsyA, pdcyA, pdxA, pdyA, pdzA
   real*8,dimension(i0:in,j0:jn) :: beta, sinbeta, pdux, pduy, pduz
   real*8,dimension(i0:in,j0:jn) :: pdzM, pdxM, pdyM, latM, lonM

   !---------------------------------------------------------------------

   call msg(MSG_DEBUG,'adx_trajsp_rot')
   vnij = (in-i0+1)*(jn-j0+1)

!$omp parallel do private(n, &
!$omp pdsyM,pdcyM,pdcyMi,pdsxM,pdcxM,pdsinM,pdsecM, &
!$omp pdcxA,pdsxA,pdsyA,pdcyA,pdxA,pdyA,pdzA, &
!$omp beta,sinbeta,pdux,pduy,pduz, &
!$omp pdzM,pdxM,pdyM,latM,lonM)

   do k=k0,adx_lnk
      do j=j0,jn
         do i=i0,in
            n = (k-1)*adx_mlnij + ((j-1)*adx_mlni) + i

            ! sin and cosin of first guess of upwind positions

            pdsyM  = F_z(n)
            pdcyM  = sqrt((1.d0+pdsyM)*(1.d0-pdsyM))
            pdcyMi = 1.d0 / pdcyM
            pdsxM  = F_y(n) * pdcyMi
            pdcxM  = F_x(n) * pdcyMi

            ! wind components in cartesian coordinate at upwind positions

            pdux(i,j) = - F_um(n) * pdsxM - F_vm(n) * pdcxM * pdsyM
            pduy(i,j) =   F_um(n) * pdcxM - F_vm(n) * pdsxM * pdsyM
            pduz(i,j) =   F_vm(n) * pdcyM

            ! angular displacement
            beta(i,j)= sqrt( pdux(i,j)*pdux(i,j) + pduy(i,j)*pduy(i,j) &
                                                 + pduz(i,j)*pduz(i,j) ) * F_dth
         end do
      end do

      call vsin(sinbeta, beta, vnij)

      do j=j0,jn
         do i=i0,in
            n = (k-1)*adx_mlnij + (j-1)*adx_mlni + i

            ! cartesian coordinates of grid points

            pdcxA = adx_cx_8(adx_trj_i_off+i)
            pdsxA = adx_sx_8(adx_trj_i_off+i)
            pdsyA = adx_sy_8(j)
            pdcyA = adx_cy_8(j)

            ! if very small wind set upwind point to grid point
            if (beta(i,j) < 1.e-10) go to 99

            pdxA = pdcxA * pdcyA
            pdyA = pdsxA * pdcyA
            pdzA = pdsyA

            pdsinM = F_dth * sinbeta(i,j) / beta(i,j)

            pdsecM = 1.d0/sqrt((1.+sinbeta(i,j)) * (1.-sinbeta(i,j)))
            F_x(n) = ( pdxA - pdsinM * pdux(i,j) ) * pdsecM
            F_y(n) = ( pdyA - pdsinM * pduy(i,j) ) * pdsecM
            F_z(n) = ( pdzA - pdsinM * pduz(i,j) ) * pdsecM
99          F_z(n) = min(1.D0,max(1.D0*F_z(n),-1.D0))

            pdxM(i,j) = F_x(n)
            pdyM(i,j) = F_y(n)
            pdzM(i,j) = F_z(n)

         enddo
      enddo

      call vasin (latM, pdzM, vnij)
      call vatan2(lonM, pdyM, pdxM, vnij)

      do j=j0,jn
         do i=i0,in
            n = (k-1)*adx_mlnij + (j-1)*adx_mlni + i
            F_lat(n) = latM(i,j)
            F_lon(n) = lonM(i,j) 
            if (F_lon(n) < 0.) F_lon(n) = F_lon(n) + CONST_2PI_8
         end do
      end do
   enddo
!$omp end parallel do

   call msg(MSG_DEBUG,'adx_traj_midpt [end]')
   !---------------------------------------------------------------------
   return
end subroutine adx_traj_midpt
