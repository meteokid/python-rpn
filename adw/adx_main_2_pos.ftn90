!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#include <model_macros_f.h>
#include "constants.h"
#include "msg.h"
#include "stop_mpi.h"
!/**
subroutine adx_main_2_pos4( F_nb_iter    ,F_l_S , &
                            F_px  ,F_py  ,F_pz  , &
                            F_u   ,F_v   ,F_w   , &
                            F_xth ,F_yth ,F_zth , &
                            F_xcth,F_ycth,F_zcth, &
                            F_xct1,F_yct1,F_zct1, &
                            F_aminx, F_amaxx, F_aminy, F_amaxy, &
                            F_ni, F_nj, k0, F_nk, F_nk_super)
   implicit none
#include <arch_specific.hf>
!
   !@objective calculate upstream positions at th and t1
!
   !@arguments
   integer :: F_nb_iter          !I, total number of iterations for traj
   character(len=1) :: F_l_S     !I, m/t for momentum or thermo level
   integer :: F_aminx, F_amaxx, F_aminy, F_amaxy !I, wind fields array bounds
   integer :: F_ni, F_nj         !I, dims of position fields
   integer :: F_nk, F_nk_super   !I, nb levels
   integer :: k0                 !I, scope of the operation k0 to F_nk
   real, dimension(F_ni,F_nj,F_nk) :: &
        F_px  , F_py  , F_pz     !O, upstream positions valid at t1
   real,dimension(F_aminx:F_amaxx,F_aminy:F_amaxy,F_nk_super),target::&
        F_u   , F_v   , F_w      !I, real destag winds, super-set (mom+thermo)
   real, dimension(F_ni,F_nj,F_nk) :: &
        F_xth , F_yth , F_zth,&  !I/O, upwind longitudes at central time 
        F_xcth, F_ycth, F_zcth,& !O, upwind cartesian positions at central time
        F_xct1, F_yct1, F_zct1   !O, upstream cartesian positions at t1
!
   !@author alain patoine
   !@revisions
   ! v2_31 - Desgagne M.    - removed stkmemw
   ! v2_31 - Tanguay M.     - gem stop if adx_fro_a.gt.0.and.V4dg_conf.ne.0
   ! v3_00 - Desgagne & Lee - Lam configuration
   ! v3_02 - Lee V.         - revert adx_exch_1 for GLB only, added adx_ckbd_lam
   ! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
   ! v3_20 - Valin & Tanguay - Optimized SETINT/TRILIN 
   ! v3_20 - Gravel S.       - Change test a lower and upper boundaries
   ! v3_20 - Tanguay M.      - Improve alarm when points outside advection grid
   ! v3_20 - Dugas B.        - correct calculation for LAM when Glb_pil gt 7
   ! v3_21 - Lee V.          - bug correction, F_yth should not be modified.
   ! v4_05 - Lepine M.       - VMM replacement with GMM
   ! V4_10 - Plante A.       - Support to thermodynamic positions.
   ! V4_14 - Plante A.       - Do not compute position in top pilot zone
   ! v4_40 - Lee/Qaddouri    - add Adw_gccsa_L option for trajsp,trajex
!**/

#include "adx_nml.cdk"
#include "adx_dims.cdk"
#include "adx_grid.cdk"
#include "adx_dyn.cdk"
#include "adx_poles.cdk"

#include "glb_ld.cdk"
#include "adx_interp.cdk"

   real*8, parameter :: PDP_8 = 1.D0 + 1.D-6
   real*8, parameter :: PDM_8 = 1.D0 - 1.D-6
   logical,parameter :: driver = .false.
   logical,parameter :: CLIP_TRAJ = .true.
   logical,parameter :: DO_W      = .false.
   logical,parameter :: DO_UV     = .true.
   real, parameter   :: DTH_1     = 1.

   integer :: i, j, k, iter, ioff
   integer :: i0,in,j0,jn
   real    :: dth
   real, dimension(F_ni,F_nj,F_nk) :: wrkx1,wrky1,wrkx2
   real, dimension(F_ni,F_nj,F_nk) :: xgrid,ygrid,zgrid

   real,   dimension(:,:,:), pointer :: dummy3d
   real*8, dimension(:)    , pointer :: p_z

   !---------------------------------------------------------------------

   call msg(MSG_DEBUG,'adx_main_2_pos ('//trim(F_l_S)//')')

   dummy3d => F_w

   dth  = adx_dt_8/2.

   p_z => adx_verZ_8%t
   if (F_l_S == 'm') p_z => adx_verZ_8%m

   call adx_get_ij0n (i0,in,j0,jn)

   if (driver) then
   open  (741, file='/users/dor/armn/mid/home/gem/v_4.1.3/adx_driver_trilin.bin',form='unformatted')
   write (741) F_aminx,F_amaxx,F_aminy,F_amaxy,F_nk_super,F_ni,F_nj,F_nk,F_nk_super,l_nk
   write (741) adx_lnkt,adx_lnkm,adx_iimax,adx_jjmax,adx_mlni,adx_mlnj,adx_mlnij,adx_nit
   write (741) adx_nijag,adx_int_j_off,adx_int_i_off,adx_dt_8,i0,in,j0,jn
   write (741) adx_gni,adx_gnj,adx_halox,adx_haloy,adx_lni,adx_lnj
   write (741) adx_gminx,adx_gmaxx,adx_gminy,adx_gmaxy,adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy
   write (741) adx_ovdx_8,adx_ovdy_8,adx_ovdz_8,adx_y00_8,adx_x00_8
   write (741) adx_xg_8,adx_yg_8,adx_verZ_8%t,adx_verZ_8%m,       &
               adx_bsx_8,adx_bsy_8,adx_diz_8,adx_xbc_8,adx_ybc_8, &
               adx_cx_8,adx_cy_8,adx_sx_8,adx_sy_8,               &
               adx_bsz_8%t,adx_bsz_8%m,adx_bsz_8%s
   write (741) adx_lcx,adx_lcy,adx_lcz%t,adx_lcz%m,adx_lcz%s
   write (741) F_u,F_v,F_w, F_xth,F_yth,F_zth, F_xcth,F_ycth,F_zcth
   close (741)
   endif

   DO_ITER: do iter = 1, F_nb_iter

      !- 3d interpol of u and v winds and new upstream pos along x and y
      ygrid(:,:,:) = F_yth(:,:,:)
      if (adx_lam_L) then
         call adx_pos_lam4 (wrkx1,wrky1, F_u,F_v, F_xth,ygrid,F_zth, &
                            DTH_1, CLIP_TRAJ, DO_UV, i0,in,j0,jn, &
                            F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,k0,F_nk,F_nk_super)
      else
         call adx_pos_glb4 (wrkx1,wrky1, F_u,F_v, F_xth,ygrid,F_zth, &
                            DTH_1, DO_UV, i0,in,j0,jn, &
                            F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,k0,F_nk,F_nk_super)
      endif

      if (Adw_gccsa_L) then
          call adx_trajsp_gccsa (F_xth,F_yth, wrkx1,wrky1, &
                                       dth,i0,in,j0,jn,k0,adx_lni,adx_lnj)
          wrkx2=wrkx1
      else
          call adx_trajsp2 (F_xth,F_yth, F_xcth,F_ycth,F_zcth, wrkx1,wrky1, &
                                   adx_cx_8,adx_cy_8,adx_sx_8,adx_sy_8, &
                                       dth,i0,in,j0,jn,k0,adx_lni,adx_lnj)
      endif

      !- 3D interpol of zeta dot and new upstream pos along zeta

      ygrid(:,:,:) = F_yth(:,:,:)

      if (adx_lam_L) then
         call adx_pos_lam4 (wrkx1,wrky1, F_w,dummy3d, F_xth,ygrid,F_zth, &
                            -dth, CLIP_TRAJ, DO_W, i0,in,j0,jn, &
                            F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,k0,F_nk,F_nk_super)
      else
         call adx_pos_glb4 (wrkx1,wrky1, F_w,dummy3d, F_xth,ygrid,F_zth, &
                            -dth, DO_W, i0,in,j0,jn, &
                            F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,k0,F_nk,F_nk_super)
      endif

      call tmg_start0(54, 'ADPOS_CZH' )
!$omp parallel
!$omp do
      do k = max(2,k0),F_nk-1
         do j = j0,jn
            do i = i0,in
               F_zth(i,j,k) = p_z(k) + 2.D0*wrkx1(i,j,k)
               !Make sure F_zth is below p_z(1) and above p_z(F_nk)
               F_zth(i,j,k) = min(PDM_8*p_z(F_nk),  &
                    max(1.0d0*F_zth(i,j,k), PDP_8*p_z(1)) )
               F_zth(i,j,k) = 0.5D0*(F_zth(i,j,k) + p_z(k))
            enddo
         enddo
      enddo
!$omp enddo
!$omp end parallel
      call tmg_stop0 (54)
   enddo DO_ITER

   if (Adw_gccsa_L) then
       call adx_trajex_gccsa (F_px, F_py, wrkx2,wrky1,&
                  F_xct1,F_yct1,F_zct1,dth, i0,in,j0,jn,k0)
   else
       call adx_trajex2 (F_px, F_py, F_xct1,F_yct1,F_zct1, &
                     F_xcth,F_ycth,F_zcth,i0,in,j0,jn,k0)
   endif

   call tmg_start0(56, 'ADPOS_FPZ' )
!$omp parallel
!$omp do
   do k = k0,F_nk
      if ((k.eq.1).or.(k.eq.F_nk)) then
         F_pz(i0:in,j0:jn, k) = p_z(k)
         F_pz(i0:in,j0:jn, k) = p_z(k)
      else
         do j = j0,jn
         do i = i0,in
            F_pz(i,j,k) = F_zth(i,j,k) - p_z(k)
            F_pz(i,j,k) = P_z(k) + 2.0 * F_pz(i,j,k)
         enddo
         enddo
      endif
   enddo
!$omp enddo
!$omp end parallel

   call tmg_stop0 (56)

   if (driver) then
   call glbstat2 ( F_xth, 'XTH', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_yth, 'YTH', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_zth, 'ZTH', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_xcth, 'XCH', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_ycth, 'YCH', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_zcth, 'ZCH', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_xct1, 'XC1', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_yct1, 'YC1', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_zct1, 'ZC1', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_px, 'PX', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_py, 'PY', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   call glbstat2 ( F_pz, 'PZ', '', 1,F_ni,1,F_nj,1,F_nk, &
                                     1,F_ni,1,F_nj,k0,F_nk  )
   print*, F_nb_iter
   stop
   endif

   call msg(MSG_DEBUG,'adx_main_2_pos ('//trim(F_l_S)//') [end]')

   !---------------------------------------------------------------------

   return
end subroutine adx_main_2_pos4
