!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/p adw_trilin_turbo - Optimized tri-linear interpolation
!                         with SETINT inside 
!
#include "model_macros_f.h"
!
      subroutine adw_trilin_turbo( F_out, F_in, F_dt,  &
                                    F_x, F_y, F_z, F_capz, &
                                    F_ii, F_jj, F_kk,  &
                                    F_num, i0, in, j0, jn, kn, &
                                    F_hor_L,F_ver_L)
!
      implicit none
!
      integer F_num, i0, in, j0, jn, kn,F_ii(F_num),F_jj(F_num),F_kk(F_num) 
!
      real F_dt, F_in(*)
!
      real F_out(F_num), F_x(F_num), F_y(F_num), F_z(F_num)
      real F_capz(F_num)
!
      logical F_hor_L,F_ver_L
!
!authors
!     Valin & Tanguay  
!
!     (Based on adw_trilin v_3.1.1)
!
!revision
! v3_20 -Valin & Tanguay -  initial version 
! v3_21 -Tanguay M.      -  evaluate min-max vertical CFL as function of k 
! v4_10 -Plante A.       -  Replace single locator vector with 3 vectors.
!                        -  Use super winds for thermo and mometum
!object
!     see id section
!
!     NOTE: capx,capy are recalculated but capz is stored in F_capz
!
!arguments
!______________________________________________________________________
!              |                                                 |     |
! NAME         | DESCRIPTION                                     | I/O |
!--------------|-------------------------------------------------|-----|
! F_out        | F_dt * result of interpolation                  |  o  |
! F_in         | field to interpolate                            |  i  |
!              |                                                 |     |
! F_dt         | multiplicative constant (1.0 or timestep lenght)|  i  |
!              |                                                 |     |
! F_x          | \                                               |  i  |
! F_y          |   x,y,z positions                               |  i  |
! F_z          | /                                               |  i  |
!              |                                                 |     |
! F_capz       | precomputed displacements along the z-direction |  io |
!              |                                                 |     |
! F_ii (jj,kk) | localisation indices                            |  io |
!              |                                                 |     |
! F_num        | number of points to interpolate                 |  i  |
!______________|_________________________________________________|_____|
!
!implicits
#include "glb_ld.cdk"
!      integer G_ni,G_nj
!      integer l_ni,l_nj,l_nk
#include "adw.cdk"
!$$$      #include "type.cdk"
!$$$      logical Adw_hor_L,Adw_ver_L
!$$$      integer            Adw_halox, Adw_haloy
!$$$      integer            Adw_nit, Adw_njt
!$$$      integer            Adw_int_i_off, Adw_int_j_off
!$$$      real*8             Adw_x00_8,  Adw_y00_8
!$$$      real*8             Adw_ovdx_8, Adw_ovdy_8, Adw_ovdz_8
!$$$      type (vertical_i)  Adw_lcz
!$$$      type (vertical_8)  Adw_bsz_8
!$$$      type (vertical_8)  Adw_diz_8
!$$$      DCL_DYNVAR(Adw,    lcx,    integer, (*))
!$$$      DCL_DYNVAR(Adw,    lcy,    integer, (*))
!$$$      DCL_DYNVAR(Adw,  bsx_8,    real*8 , (*))
!$$$      DCL_DYNVAR(Adw,  bsy_8,    real*8 , (*))
!$$$      DCL_DYNVAR(Adw,  xbc_8,    real*8 , (*))
!$$$      DCL_DYNVAR(Adw,  ybc_8,    real*8 , (*))
#include "ver.cdk"
!      #include "type.cdk"
!      type (vertical_8) Ver_z_8  
!$$$      DCL_DYNVAR(V4dcfl, p   ,  integer, (l_nk))
!$$$      DCL_DYNVAR(V4dcfl, n   ,  integer, (l_nk))
!***********************************************************************
!
      integer n, n0, nijag, nij, o1, o2, i, j, k, iimax, jjmax, &
              ii,jj,kk
!
      real capx, capy, capz
!
      real*8 rri, rrj, rrk, prf1, prf2, prf3, prf4, p_z00_8
!
      integer err
!
      p_z00_8 = Ver_z_8%t(1)
!
!     ----------------------------------------------------------------
      nijag = Adw_nit * Adw_njt
      nij = l_ni*l_nj
!
      iimax = G_ni+2*Adw_halox-1
      jjmax = G_nj+Adw_haloy
!
!$omp parallel do private(n,n0,ii,jj,kk,rri,rrj,rrk, &
!$omp capx,capy,capz,o1,o2,prf1,prf2,prf3,prf4)
      do 100 k=1,kn
      do  90 j=j0,jn
      n0 = (k-1)*nij + ((j-1)*l_ni)
      if ( F_hor_L ) then
        do  i=i0,in
          n = n0 + i
!
          rri= F_x(n)
          ii = ( rri - Adw_x00_8 ) * Adw_ovdx_8
          ii = Adw_lcx( ii+1 ) + 1
          if ( rri .lt. Adw_bsx_8(ii) ) ii = ii - 1
          F_ii(n) = max(1,min(ii,iimax))
!
          rrj= F_y(n)
          jj = ( rrj - Adw_y00_8 ) * Adw_ovdy_8
          jj = Adw_lcy( jj+1 ) + 1
          if ( rrj .lt. Adw_bsy_8(jj) ) jj = jj - 1
          F_jj(n) = max(Adw_haloy,min(jj,jjmax))
!
        enddo
      endif
      if ( F_ver_L ) then
        do  i=i0,in
          n = n0 + i
!
          rrk= F_z(n)
          kk = ( rrk - p_z00_8 ) * Adw_ovdz_8
          kk = Adw_lcz%s( kk+1 )


          rrk = rrk - Adw_bsz_8%s(kk)
          if ( rrk .lt. 0.0 ) kk = kk - 1
!     
          capz = rrk * Adw_diz_8(kk)
          if ( rrk .lt. 0.0 ) capz = 1.0 + capz
!
!         We keep F_capz, otherwise we would need rrk  
!         -------------------------------------------
          F_capz(n) = capz
!
          F_kk(n)=kk
!
        enddo
      endif
      do  80 i=i0,in
        n = n0 + i
!
        ii = F_ii(n)
        jj = F_jj(n)
        kk = F_kk(n)
!
        rri= F_x(n)
        rrj= F_y(n)
!
        o1 = (kk)*nijag + (jj-Adw_int_j_off-1)*Adw_nit + (ii-Adw_int_i_off)
        o2 = o1 + Adw_nit
!
!***********************************************************************
!     x interpolation
!***********************************************************************
        capx = (rri-Adw_bsx_8(ii)) *Adw_xbc_8(ii)
!
        prf1 = (1.0 - capx) * F_in(o1) + capx * F_in(o1+1)
        prf2 = (1.0 - capx) * F_in(o2) + capx * F_in(o2+1)
!
        o1 = o1 + nijag
        o2 = o2 + nijag
!
        prf3 = (1.0 - capx) * F_in(o1) + capx * F_in(o1+1)
        prf4 = (1.0 - capx) * F_in(o2) + capx * F_in(o2+1)
!
!***********************************************************************
!     y interpolation
!***********************************************************************
        capy = (rrj-Adw_bsy_8(jj)) *Adw_ybc_8(jj)  
!
        prf1 = (1.0 - capy) * prf1 + capy  * prf2
        prf2 = (1.0 - capy) * prf3 + capy  * prf4
!***********************************************************************
!     z interpolation
!***********************************************************************
        capz = F_capz(n)
!
        F_out(n) = ( (1.0 - capz) * prf1 + capz  * prf2 ) * F_dt
!
   80 continue
   90 continue
  100 continue
!$omp end parallel do
!
      return
      end
