!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r adw_exch_2 -    exchange 1 to 3 fields among processors
!                   ( upstream positions or interpolated values )
!
#include "model_macros_f.h"
!
      subroutine adw_exch_2 ( F_a_fro,   F_b_fro,   F_c_fro, &
                              F_a_for,   F_b_for,   F_c_for, &
                              F_n_fro_n, F_n_fro_s, F_n_fro_a, &
                              F_n_for_n, F_n_for_s, F_n_for_a, &
                              F_n_treat)
      implicit none
!
      integer F_n_fro_n, F_n_fro_s, F_n_fro_a, &
              F_n_for_n, F_n_for_s, F_n_for_a, F_n_treat
!
      real F_a_fro(F_n_fro_a), F_b_fro(F_n_fro_a), F_c_fro(F_n_fro_a), &
           F_a_for(F_n_for_a), F_b_for(F_n_for_a), F_c_for(F_n_for_a)
!
!author
!     alain patoine
!
!revision
! v2_31 - Corbeil L.       - replaced MPI calls by rpn_comm, removed 
! v2_31                      ptopo.cdk and removed stkmem calls
!
!language
!     fortran 90
!
!object
!     see id section
!
!arguments
!______________________________________________________________________
!              |                                                 |     |
! NAME         | DESCRIPTION                                     | I/O |
!--------------|-------------------------------------------------|-----|
!              |                                                 |     |
! F_a_fro      | \                                               |  o  |
! F_b_fro      |   information vectors from neighbors            |  o  |
! F_c_fro      | /                                               |  o  |
!              |                                                 |     |
! F_a_for      | \                                               |  i  |
! F_b_for      |   information vectors for neighbors             |  i  |
! F_c_for      | /                                               |  i  |
!              |                                                 |     |
! F_n_fro_n    | number of information pieces from north neighbor|  i  |
! F_n_fro_s    | number of information pieces from south neighbor|  i  |
! F_n_fro_a    | number of information pieces from all   neighbor|  i  |
! F_n_for_n    | number of information pieces for  north neighbor|  i  |
! F_n_for_s    | number of information pieces for  south neighbor|  i  |
! F_n_for_a    | number of information pieces for  all   neighbor|  i  |
!              |                                                 |     |
! F_n_treat    | number of vectors to exchange                   |  i  |
!              | for exemple, if we exchange upstream positions, |     |
!              | the 3 coordinates will be carried in a, b and c |     |
!              | and F_n_treat should be equal to 3              |     |
!______________|_________________________________________________|_____|
!
!notes
!______________________________________________________________________
!                                                                      |
! The information is strored in the following manner:                  |
!                                                                      |
! F_n_fro_n values followed by F_n_fro_s values = F_n_fro_a values     |
! ---------                    ---------          ---------            |
!                                                                      |
! F_n_for_n values followed by F_n_for_s values = F_n_for_a values     |
! ---------                    ---------          ---------            |
!                                                                      |
! WARNING: This code may result in allocating arrays with 0 size       |
!          and therefore will send an empty message                    |
!______________________________________________________________________|
!
!implicits
#include "glb_ld.cdk"
!      logical G_periody
!***********************************************************************
!
      integer tag, imsg, iproc, nwrn,nwrs,status
      data    tag /10/
!
      integer n
!
      real :: &
         abc_for_n(F_n_for_n,F_n_treat), abc_for_s(F_n_for_s,F_n_treat),  &
         abc_fro_n(F_n_fro_n,F_n_treat), abc_fro_s(F_n_fro_s,F_n_treat)
!
!***********************************************************************

      if ( F_n_for_n .gt. 0 ) then
!
!
         if ( F_n_treat .eq. 1 ) then
!
            do n = 1, F_n_for_n
            abc_for_n(n,1) = F_a_for(n)
            enddo
!
         elseif ( F_n_treat .eq. 2 ) then
!
            do n = 1, F_n_for_n
            abc_for_n(n,1) = F_a_for(n)
            abc_for_n(n,2) = F_b_for(n)
            enddo
!
         elseif ( F_n_treat .eq. 3 ) then
!
            do n = 1, F_n_for_n
            abc_for_n(n,1) = F_a_for(n)
            abc_for_n(n,2) = F_b_for(n)
            abc_for_n(n,3) = F_c_for(n)
            enddo
         endif
!
      endif
!***********************************************************************
      if ( F_n_for_s .gt. 0 ) then
!
!
         if ( F_n_treat .eq. 1 ) then
!
            do n = 1, F_n_for_s
            abc_for_s(n,1) = F_a_for(F_n_for_n+n)
            enddo
!
         elseif ( F_n_treat .eq. 2 ) then
!
            do n = 1, F_n_for_s
            abc_for_s(n,1) = F_a_for(F_n_for_n+n)
            abc_for_s(n,2) = F_b_for(F_n_for_n+n)
            enddo
!
         elseif ( F_n_treat .eq. 3 ) then
!
            do n = 1, F_n_for_s
            abc_for_s(n,1) = F_a_for(F_n_for_n+n)
            abc_for_s(n,2) = F_b_for(F_n_for_n+n)
            abc_for_s(n,3) = F_c_for(F_n_for_n+n)
            enddo
         endif
!
      endif
!***********************************************************************
      call RPN_COMM_swapns(F_n_treat*F_n_for_n,abc_for_n, &
                           F_n_treat*F_n_for_s,abc_for_s, &
                           F_n_treat*F_n_fro_n,nwrn,abc_fro_n, &
                           F_n_treat*F_n_fro_s,nwrs,abc_fro_s, &
                           G_periody,status)
      if ( F_n_fro_n .gt. 0 ) then
!
!
         if ( F_n_treat .eq. 1 ) then
!
            do n = 1, F_n_fro_n
            F_a_fro(n) = abc_fro_n(n,1)
            enddo
!
         elseif ( F_n_treat .eq. 2 ) then
!
            do n = 1, F_n_fro_n
            F_a_fro(n) = abc_fro_n(n,1)
            F_b_fro(n) = abc_fro_n(n,2)
            enddo
!
         elseif ( F_n_treat .eq. 3 ) then
!
            do n = 1, F_n_fro_n
            F_a_fro(n) = abc_fro_n(n,1)
            F_b_fro(n) = abc_fro_n(n,2)
            F_c_fro(n) = abc_fro_n(n,3)
            enddo
         endif
!
      endif
!***********************************************************************
      if ( F_n_fro_s .gt. 0 ) then
!
!
         if ( F_n_treat .eq. 1 ) then
!
            do n = 1, F_n_fro_s
            F_a_fro(F_n_fro_n+n) = abc_fro_s(n,1)
            enddo
!
         elseif ( F_n_treat .eq. 2 ) then
!
            do n = 1, F_n_fro_s
            F_a_fro(F_n_fro_n+n) = abc_fro_s(n,1)
            F_b_fro(F_n_fro_n+n) = abc_fro_s(n,2)
            enddo
!
         elseif ( F_n_treat .eq. 3 ) then
!
            do n = 1, F_n_fro_s
            F_a_fro(F_n_fro_n+n) = abc_fro_s(n,1)
            F_b_fro(F_n_fro_n+n) = abc_fro_s(n,2)
            F_c_fro(F_n_fro_n+n) = abc_fro_s(n,3)
            enddo
         endif
!
      endif
!***********************************************************************
      return
      end
