!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

#include "model_macros_f.h"
#if defined (NEC)
#define ADW_TRICUB_LAG3D   adw_tricub_lag3d_vec
#endif
!
!/**
      subroutine adw_interp_gmm(F_out_S, F_in_S, F_posx, F_posy,  &
                                F_wind_L, F_mono_L, DIST_DIM, F_nk, &
                                i0,in,j0,jn, F_lev_S, F_fact_8)
!TODO: F_posy not used - remove
      implicit none
#include <arch_specific.hf>
      !@objective
      !@arguments
      character(len=*) :: F_out_S, F_in_S
      real :: F_posx(*), F_posy(*)
      logical :: F_wind_L, F_mono_L
      integer  :: DIST_DIM, F_nk, i0,in,j0,jn
      character(len=*) :: F_lev_S
      real(8) :: F_fact_8
      !@revisions
      !  2009-12,  Stephane Chamberland: original code from adw_main_3
      !@includes
#include "gmm.hf"
#include "glb_ld.cdk"
#include "adw_nml.cdk"
!**/
      type(gmm_metadata) :: mymeta
      integer :: i,j,k,err
      real, pointer, dimension (:,:,:) :: fld_in,fld_out
      real(8) :: inverse_fact_8
      !---------------------------------------------------------------------
      err = gmm_get(F_in_S,fld_in,mymeta)
      call handle_error(err,'adw_interp_gmm','gmm_get for'//trim(F_in_S))
      err = gmm_get(F_out_S,fld_out,mymeta)
      call handle_error(err,'adw_interp_gmm','gmm_get for'//trim(F_out_S))

      if (adw_stats_L) then
         call glbstat2(fld_in, F_in_S, 'adw_int',  &
              mymeta%l(1)%low,mymeta%l(1)%high, mymeta%l(2)%low,mymeta%l(2)%high,&
              1,F_nk, i0,in,j0,jn,1,F_nk)
      endif

!$omp parallel
      call adw_interp2(fld_out, fld_in, F_posx, F_posy,  &
                       F_wind_L, F_mono_L, LDIST_DIM, F_nk, &
                       i0,in,j0,jn, F_lev_S)
!$omp end parallel

      if (adw_stats_L) then
         call glbstat2(fld_out, F_out_S, 'adw_int',  &
              mymeta%l(1)%low,mymeta%l(1)%high, mymeta%l(2)%low,mymeta%l(2)%high,&
              1,F_nk, i0,in,j0,jn,1,F_nk)
      endif
      !---------------------------------------------------------------------
      return
      end subroutine adw_interp_gmm




!/**
      subroutine adw_interp2( F_out, F_in, F_posx, F_posy,  &
                              F_wind_L, F_mono_L, DIST_DIM, F_nk, &
                              i0,in,j0,jn, F_lev_S )
      implicit none
#include <arch_specific.hf>
      character*1 F_lev_S
      logical F_wind_L, F_mono_L
      integer DIST_DIM, F_nk, i0,in,j0,jn
      real F_out (DIST_SHAPE, F_nk), &
           F_in  (DIST_SHAPE, F_nk)
      real F_posx(*), F_posy(*)
!
!author
!     alain patoine
!
!revision
! v2_31 - Tanguay M.        - correction parameters adw_vder 
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v3_20 - Gravel & Valin & Tanguay - Lagrange 3D   
! v3_21 - Desgagne M.       - Revision Openmp
! v3_30 - McTaggart-Cowan   - Add truncated lag3d interpolator
! v3_30 - McTaggart-Cowan   - Vectorization subroutines *_vec
! v3_30 - Tanguay M.        - adjust OPENMP for LAM 
!
!object
!     see id section
!
!arguments
!______________________________________________________________________
!              |                                                 |     |
! NAME         | DESCRIPTION                                     | I/O |
!--------------|-------------------------------------------------|-----|
!              |                                                 |     |
! F_out        | interpolated field                              |  o  |
! F_in         | field to interpolate                            |  i  |
! F_wind_L     | switch: .true. : field to interpolate is a wind |  i  |
!              |                  like quantity                  |  i  |
! F_mono_L     | switch: .true. : monotonic interpolation        |  i  |
!______________|_________________________________________________|_____|
!
!implicits
#include "glb_ld.cdk"
!      logical G_lam, G_periodx, G_periody
!      integer G_ni
!      logical l_north, l_south
!      integer l_ni, l_nj
!      integer l_minx, l_maxx, l_miny, l_maxy
#include "adw.cdk"
!**/
      integer i, j, k, nij, nijk, nijkag, n, dest_ni
      real dummy
      !---------------------------------------------------------------------
      nij    = l_ni   *l_nj
      nijk   = l_ni   *l_nj   *F_nk
      nijkag = Adw_nit*Adw_njt*F_nk

!***********************************************************************
! Adjust field to advection grid
! Compute extension beyond the pole if appropriate
!***********************************************************************
!$omp single
      if (G_lam) then
         n=0
         dest_ni=l_ni
      else
         n=999
         dest_ni=G_ni
      endif

      call rpn_comm_xch_halox(F_in, LDIST_DIM, l_ni, l_nj, F_nk, &
           Adw_halox, Adw_haloy, G_periodx, G_periody, F_posx, -Adw_halox+1, &
           Adw_nic+Adw_halox, -Adw_haloy+1, Adw_njc+Adw_haloy, dest_ni, n)
!$omp end single

      if (.not.G_lam) then

         if (l_south) then
             if  (F_wind_L) then
               !set values at the pole = 0.0
               call adw_pol0(F_posx, 0, Adw_nic,Adw_halox,Adw_njc, &
                    Adw_haloy,F_nk)
            else
               !compute weighted average around the pole
               call adw_pols(F_posx,Adw_wx_8, 0, Adw_nic,Adw_halox, &
                    Adw_njc,Adw_haloy,F_nk)
            endif
            !extension of a scalar field beyond the poles
            call adw_polx(F_posx,Adw_xg_8,.true.,Adw_nic,Adw_halox, &
                 Adw_njc,Adw_haloy,F_nk)
         endif

         if (l_north) then
            if  (F_wind_L) then
               call adw_pol0(F_posx,Adw_njc+1,Adw_nic,Adw_halox,Adw_njc, &
                    Adw_haloy,F_nk)
            else
               call adw_pols(F_posx,Adw_wx_8, Adw_njc+1,Adw_nic,Adw_halox, &
                    Adw_njc,Adw_haloy,F_nk)
            endif
            call adw_polx(F_posx,Adw_xg_8,.false.,Adw_nic,Adw_halox, &
                 Adw_njc,Adw_haloy,F_nk)
         endif

      endif

!***********************************************************************
! Interpolate
!***********************************************************************

      call tmg_start0(63, 'ADW_TRICU' )
      call ADW_TRICUB_LAG3D(Adw_wrkc, F_posx, &
           Adw_capx1, Adw_capy1, Adw_capz1, &
           nijk, F_mono_L,i0,in,j0,jn,F_nk,F_lev_S)
      call tmg_stop0(63)

      if (.not.G_lam) then

         if (Adw_fro_a > 0) then
      call tmg_start0(63, 'ADW_TRICU' )
            call ADW_TRICUB_LAG3D(Adw_wrka, F_posx, &
                 Adw_capx2, Adw_capy2, Adw_capz2,  &
                 Adw_fro_a, F_mono_L,1,Adw_fro_a,1,1,1,F_lev_S)
      call tmg_stop0(63)
         endif

!$omp single
         call adw_exch_2(Adw_wrkb, dummy, dummy, &
              Adw_wrka, dummy, dummy, &
              Adw_for_n, Adw_for_s, Adw_for_a, &
              Adw_fro_n, Adw_fro_s, Adw_fro_a, 1)

         if (Adw_for_a > 0) &
              call adw_exch_3(Adw_wrkc, dummy, Adw_wrkb, dummy, Adw_c1, 1)
!$omp end single

      endif
!$omp do
      do k = 1, F_nk
      do j = j0,jn
      do i = i0,in
         F_out(i,j,k) = Adw_wrkc((k-1)*nij+(j-1)*l_ni+i)
      enddo
      enddo
      enddo
!$omp enddo
      !---------------------------------------------------------------------
      return
      end
