!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**   s/r adw_main_2_pos - calculate upstream positions at th and t1
!
#include "model_macros_f.h"
#include "constants.h"
#include "msg.h"
!
      subroutine adw_main_2_pos( &
           F_it  ,F_l_S ,F_nk  , &
           F_px  ,F_py  ,F_pz  , &
           F_u   ,F_v   ,F_w   , &
           F_xth ,F_yth ,F_zth , &
           F_xcth,F_ycth,F_zcth, &
           F_xct1,F_yct1,F_zct1, &
           F_pxc ,F_pyc)
!
      implicit none
!
      integer F_it,F_nk
      character(len=1) :: F_l_S
      real F_px(*)  ,F_py(*)  ,F_pz(*), &
           F_u(*)   ,F_v(*)   ,F_w(*), &
           F_xth(*) ,F_yth(*) ,F_zth(*), &
           F_xcth(*),F_ycth(*),F_zcth(*), &
           F_xct1(*),F_yct1(*),F_zct1(*), &
           F_pxc(*) ,F_pyc(*)
!
!author
!     alain patoine
!
!revision
! v2_31 - Desgagne M.    - removed stkmemw
! v2_31 - Tanguay M.     - gem stop if Adw_fro_a.gt.0.and.V4dg_conf.ne.0
! v3_00 - Desgagne & Lee - Lam configuration
! v3_02 - Lee V.         - revert adw_exch_1 for GLB only, added adw_ckbd_lam
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v3_20 - Valin & Tanguay - Optimized SETINT/TRILIN 
! v3_20 - Gravel S.       - Change test a lower and upper boundaries
! v3_20 - Tanguay M.      - Improve alarm when points outside advection grid
! v3_20 - Dugas B.        - correct calculation for LAM when Glb_pil gt 7
! v3_21 - Lee V.          - bug correction, F_yth should not be modified.
! v4_05 - Lepine M.       - VMM replacement with GMM
! V4_10 - Plante A.       - Support to thermodynamic positions.
!
!language
!     fortran 77
!
!object
!     see id section
!
!arguments
!______________________________________________________________________
!        |                                                       |     |
! NAME   | DESCRIPTION                                           | I/O |
!--------|-------------------------------------------------------|-----|
! F_it   | total number of iterations for trajectory             |  i  |
!        |                                                       |     |
! F_u,F_v| input:  3 components of wind on advection grid        |  io |
! F_w    | output: 3 upstream positions valid at t1              |     |
!________|_______________________________________________________|_____|
!
!implicits
#include "gmm.hf"
#include "var_gmm.cdk"
!      type(gmm_metadata) :: meta3d, tmp_meta1d
!      integer :: gmmstat
#include "glb_ld.cdk"
!      logical G_lam
!      integer G_nk
!      logical l_north, l_south, l_east, l_west
!      integer l_ni, l_nj, l_nk, l_niu, l_njv
!      integer l_minx, l_maxx, l_miny, l_maxy
!      integer pil_n,pil_s,pil_w,pil_e
#include "adw.cdk"
!      logical Adw_ckbd_L
!      logical Adw_hor_L,Adw_ver_L
!      integer            Adw_for_n, Adw_for_s, Adw_for_a
!      integer            Adw_fro_n, Adw_fro_s, Adw_fro_a
!      integer Adw_fn_I(*)
#include "cstv.cdk"
!      real*8    Cstv_dt_8
#include "vth.cdk"
!      real, pointer, dimension (:) :: xth,yth,zth
!      real, pointer, dimension (:) :: xcth,ycth,zcth
!      character(len=8) :: gmmk_xth_s, gmmk_yth_s, gmmk_zth_s
!      character(len=8) :: gmmk_xcth_s, gmmk_ycth_s, gmmk_zcth_s
#include "vt1.cdk"
!      real, pointer, dimension (:)     :: xct1,yct1,zct1
!      character(len=8) :: gmmk_xct1_s, gmmk_yct1_s, gmmk_zct1_s
       include "v4dg.inc"
!      integer V4dg_conf
#include "ver.cdk"
!      #include "type.cdk"
!      type (vertical_8) Ver_z_8  
#include "geomg.cdk"
!      real*8 geomg_x_8(XDIST_SHAPE)
!      real*8 geomg_y_8(YDIST_SHAPE)
#include "schm.cdk"
!      logical schm_zdotmid_l
!$$$#include "acid.cdk"
!      logical acid_test_l
      integer i, j, k, n, nm, ij, ijk, nij, nijk, it
      integer i1,j1,k1,ier,i0,in,j0,jn,k0,kn
!
      integer, dimension(l_ni*l_nj*F_nk) :: n1,loci,locj,lock
      real,    dimension(l_ni*l_nj*F_nk) :: capx1,capy1,capz1
      real,    dimension(l_ni*l_nj*F_nk) :: wrkx1,wrky1,wrkz1,wrkc1,wrk_yth
      integer, dimension(:), allocatable :: n2
      real,    dimension(:), allocatable :: capx2,capy2,capz2
      real,    dimension(:), allocatable :: xpos2,ypos2,zpos2
      real,    dimension(l_ni*l_nj*F_nk) :: xgrid,ygrid,zgrid
!
      real dummy, dth
      real*8 r2pi_8,two,half,pdp,pdm
      parameter (two = 2.0,half=0.5)
!
      real*8 ,dimension(:), pointer :: p_z
!
!!$      print *,'adx_main_2_pos ('//trim(F_l_S)//')'
   
      nij    = l_ni   *l_nj
      nijk   = l_ni   *l_nj   *F_nk
!
      r2pi_8 = two * CONST_PI_8
      dth    = Cstv_dt_8/2.
      pdp    = 1.d0 + 1.d-6
      pdm    = 1.d0 - 1.d-6
      if(F_l_S.eq.'m')then
         p_z =>Ver_z_8%m
         call msg(MSG_DEBUG,'CALC UPSTREAM MOMENTUM POSITIONS: (S/R ADW_MAIN_2_POS)')
      else if(F_l_S.eq.'t')then
         p_z =>Ver_z_8%t
         call msg(MSG_DEBUG,'CALC UPSTREAM THERMO   POSITIONS: (S/R ADW_MAIN_2_POS)')
      else
         call handle_error(-1,'adw_main_2_pos','wrong level descriptor')
      endif         

      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west)  i0=pil_w
          if (l_east)  in=l_niu - pil_e + 2
          if (l_south) j0=pil_s
          if (l_north) jn=l_njv - pil_n + 2
      endif
!
!$$$      if (Acid_test_L)
!$$$     $     call acid_stat_adw_main_2_pos(F_xth,F_xcth,wrkx1,i0,in,j0,jn,F_nk,1)
!
!***********************************************************************
      do it=1,F_it ! begin iterations loop
!***********************************************************************
!
!        ==================================================================
!        3d interpolation of u and v winds
!        ==================================================================
!
         do n = 1,nijk
            wrk_yth(n)=F_yth(n)
         enddo
         if(G_lam)then
!     
            call adw_cliptraj(F_xth,wrk_yth,i0,in,j0,jn,F_nk,'')          
!     
         else
!     
            call adw_exch_1(wrkx1,wrky1,wrkz1,wrkc1,F_xth,wrk_yth,F_zth,F_nk )
!     
            if (V4dg_conf .ne. 0.) then
               ier = 0
               if (Adw_fro_a > 0) ier = -1
               call handle_error(ier,'adw_main_2_pos','TLM-ADJ NOT done: INCREASE HALO')
            endif
!     
            allocate(capx2(max(1,Adw_fro_a)), &
                 capy2(max(1,Adw_fro_a)), &
                 capz2(max(1,Adw_fro_a)), &
                 xpos2 (max(1,Adw_fro_a)), &
                 ypos2 (max(1,Adw_fro_a)), &
                 zpos2 (max(1,Adw_fro_a)), &
                 n2 (max(1,Adw_fro_a)) )
            call adw_exch_2 ( xpos2, ypos2, zpos2, &
                 wrkx1, wrky1, wrkz1, &
                 Adw_fro_n, Adw_fro_s, Adw_fro_a, &
                 Adw_for_n, Adw_for_s, Adw_for_a, 3 )
!     
         endif
!     
         if( .not. Adw_nosetint_L ) then
!     
            call adw_setint ( n1, capx1, dummy, dummy, capy1, dummy, &
                 dummy, capz1, dummy, F_xth, wrk_yth, F_zth, &
                 .true., .true., .true.,nijk,i0,in,j0,jn,F_nk)
!            
            call adw_trilin(wrkx1,F_u,1.0,n1,capx1,capy1,capz1,nijk,i0,in,j0,jn,F_nk)
            call adw_trilin(wrky1,F_v,1.0,n1,capx1,capy1,capz1,nijk,i0,in,j0,jn,F_nk)
!     
         else
!     
            call adw_trilin_turbo (wrkx1,F_u,1.0,F_xth,wrk_yth,F_zth,capz1, &
                 loci,locj,lock,nijk,i0,in,j0,jn,F_nk,.true.,.true.)
            call adw_trilin_turbo (wrky1,F_v,1.0,F_xth,wrk_yth,F_zth,capz1, &
                 loci,locj,lock,nijk,i0,in,j0,jn,F_nk,.false.,.false.)
!     
         endif
!     
!$$$      if (Acid_test_L)
!$$$     $     call acid_stat_adw_main_2_pos(F_xth,F_xcth,wrkx1,i0,in,j0,jn,F_nk,2)
!     
!        ==================================================================
!        Compute new upstream postions along x and y
!        ==================================================================
!     
         if (.not.G_lam) then
            if ( Adw_fro_a .gt. 0 ) then
!     
!     
               if ( Adw_ckbd_L ) call adw_ckbd ( ypos2 )
!     
               call adw_setint ( n2, capx2, dummy, dummy, capy2, dummy, &
                    dummy, capz2, dummy, xpos2, ypos2, zpos2, &
                    .true., .true., .true., Adw_fro_a,1,Adw_fro_a, &
                    1,1,1)
!     
               call adw_trilin ( xpos2, F_u, 1.0, n2, capx2, capy2, capz2, &
                    Adw_fro_a,1,Adw_fro_a,1,1,1)
               call adw_trilin ( ypos2, F_v, 1.0, n2, capx2, capy2, capz2, &
                    Adw_fro_a,1,Adw_fro_a,1,1,1)
!     
            endif
!     
            call adw_exch_2 ( wrkz1, wrk_yth, dummy, &
                 xpos2, ypos2, dummy, &
                 Adw_for_n, Adw_for_s, Adw_for_a, &
                 Adw_fro_n, Adw_fro_s, Adw_fro_a, 2)
!     
            if ( Adw_for_a .gt. 0 ) &
                 call adw_exch_3 ( wrkx1, wrky1, wrkz1, wrk_yth, wrkc1, 2 )
!     
            deallocate(capx2,capy2,capz2,xpos2,ypos2,zpos2,n2)
         endif
!***********************************************************************
         call adw_trajsp ( F_xth, F_yth, F_xcth, F_ycth, F_zcth, wrkx1, wrky1, dth, &
              i0,in,j0,jn)
!***********************************************************************
!     
!        ==================================================================
!        3D interpolation of zeta dot
!        ==================================================================
!
         do n = 1,nijk
            wrk_yth(n) = F_yth(n)
         enddo
!     
!$$$      if (Acid_test_L)
!$$$     $        call acid_stat_adw_main_2_pos(F_xth,F_xcth,wrkx1,i0,in,j0,jn,F_nk,3)
!     
      if(Schm_zdotMid_L)then
         do k = 1, F_nk
         do j = 1, l_nj 
         do i = 1, l_ni
            ijk=(k-1)*nij+(j-1)*l_ni+i
            xgrid(ijk)  = Geomg_x_8(i)
            ygrid(ijk)  = Geomg_y_8(j)
            zgrid(ijk)  = p_z(k)
         enddo         
         enddo         
         enddo 
      endif

         if (G_lam) then
!     
            if(.not.Schm_zdotMid_L)call adw_cliptraj ( F_xth, wrk_yth, i0, in, j0, jn, F_nk, '')
!     
         else
!     
            if(Schm_zdotMid_L)then
               call adw_exch_1 ( wrkx1, wrky1, wrkz1, wrkc1,xgrid,ygrid,zgrid,F_nk )
            else
               call adw_exch_1 ( wrkx1, wrky1, wrkz1, wrkc1,F_xth,wrk_yth,F_zth,F_nk )
            endif
!     
            allocate(capx2(max(1,Adw_fro_a)), &
                 capy2(max(1,Adw_fro_a)), &
                 capz2(max(1,Adw_fro_a)), &
                 xpos2 (max(1,Adw_fro_a)), &
                 ypos2 (max(1,Adw_fro_a)), &
                 zpos2 (max(1,Adw_fro_a)), &
                 n2 (max(1,Adw_fro_a)) )
!     
            call adw_exch_2 ( xpos2, ypos2, zpos2, &
                 wrkx1, wrky1, wrkz1, &
                 Adw_fro_n, Adw_fro_s, Adw_fro_a, &
                 Adw_for_n, Adw_for_s, Adw_for_a, 3 )
!     
         endif
!     
         if( .not. Adw_nosetint_L ) then
!     
            if(Schm_zdotMid_L)then
               call adw_setint ( n1, capx1, dummy, dummy, capy1, dummy, &
                    dummy, capz1, dummy, xgrid, ygrid, zgrid, &
                    .true., .true., .true., nijk,i0,in,j0,jn,F_nk)
            else
               call adw_setint ( n1, capx1, dummy, dummy, capy1, dummy, &
                    dummy, capz1, dummy, F_xth, wrk_yth, F_zth, &
                    .true., .true., .true., nijk,i0,in,j0,jn,F_nk)
            endif
!     
            call adw_trilin (wrkx1,F_w,-dth,n1,capx1,capy1,capz1,nijk,i0,in,j0,jn,F_nk)
!     
!$$$         if (Acid_test_L)
!$$$     $           call acid_stat_adw_main_2_pos(F_xth,F_xcth,wrkx1,i0,in,j0,jn,F_nk,4)
            
         else
!     
            if(Schm_zdotMid_L)then
               call adw_trilin_turbo (wrkx1,F_w,-dth,xgrid,ygrid,zgrid,capz1, &
                    loci,locj,lock,nijk,i0,in,j0,jn,F_nk,.true.,.true.)
!     
            else      
               call adw_trilin_turbo (wrkx1,F_w,-dth,F_xth,wrk_yth,F_zth,capz1, &
                    loci,locj,lock,nijk,i0,in,j0,jn,F_nk,.true.,.true.)
!     
            endif
!     
         endif
!     
         if (.not.G_lam) then

         if (Adw_fro_a > 0 .and. Schm_zdotMid_L) then
            call handle_error(-1,'adw_main_2_pos','The code should not pass in this branch.\n Please report the problem to the developer (zdotMid_L)')
         endif

            if ( Adw_fro_a .gt. 0 ) then
!     
               if ( Adw_ckbd_L ) call adw_ckbd ( ypos2 )
!     
               call adw_setint ( n2, capx2, dummy, dummy, capy2, dummy, &
                    dummy, capz2, dummy, xpos2, ypos2, zpos2, &
                    .true., .true., .true., Adw_fro_a,1,Adw_fro_a, &
                    1,1,1)
!     
               call adw_trilin ( xpos2, F_w, -dth, n2, capx2,capy2,capz2, &
                    Adw_fro_a,1,Adw_fro_a,1,1,1)
!     
            endif
!     
            call adw_exch_2 ( wrkz1, dummy, dummy, &
                 xpos2, dummy, dummy, &
                 Adw_for_n, Adw_for_s, Adw_for_a, &
                 Adw_fro_n, Adw_fro_s, Adw_fro_a, 1)
!     
            if ( Adw_for_a .gt. 0 ) &
                 call adw_exch_3 ( wrkx1, dummy, wrkz1, dummy, wrkc1, 1 )
!     
            deallocate(capx2,capy2,capz2,xpos2,ypos2,zpos2,n2)
         endif
!***********************************************************************
!     
!        ==================================================================
!        Compute new upstream position along zeta
!        ==================================================================
!
!$omp parallel private(n)
!$omp do
         do k = 2,F_nk-1
            do j = j0,jn
            do i = i0,in
               n = (k-1)*nij + ((j-1)*l_ni) + i
               F_zth(n) = p_z(k) + two*wrkx1(n)
!              Make sure F_zth is below p_z(1) and above p_z(F_nk)
               F_zth(n) = min( pdm*p_z(F_nk),  &
                    max( 1.0d0*F_zth(n), pdp*p_z(1) ) )
               F_zth(n) = half*(F_zth(n) + p_z(k))
            enddo
            enddo
         enddo
!$omp enddo
!$omp end parallel
!***********************************************************************
      enddo ! end of iterations loop
!***********************************************************************
      call adw_trajex (F_px, F_py, F_xct1, F_yct1, F_zct1, F_xcth, F_ycth, F_zcth, &
           i0,in,j0,jn)
!
!$omp parallel private(n)
!$omp do
      do j = j0,jn
      do i = i0,in
         n = ((j-1)*l_ni) + i   !for k=1
         F_pz(n) = p_z(1)
         n = (F_nk-1)*nij+((j-1)*l_ni) + i !for k=F_nk
         F_pz(n) = p_z(F_nk)
      enddo
      enddo
!$omp enddo
!$omp do
      do k = 2,F_nk-1
         do j = j0,jn
         do i = i0,in
            n=(k-1)*nij+((j-1)*l_ni) + i
            F_pz(n) = F_zth(n) - p_z(k)
            F_pz(n) = P_z(k) + 2.0 * F_pz(n)
         enddo
         enddo
      enddo      
!$omp enddo
!$omp end parallel

!$omp parallel private(n)
      if(F_l_S.eq.'t')then
!$omp do
         do j = j0,jn
         do i = i0,in
            n = ((j-1)*l_ni) + i !for k=1
            F_px(n) = F_pxc(n)
            F_py(n) = F_pyc(n)
            n  = l_nk*nij+((j-1)*l_ni) + i !for k=l_nk+1
            nm = (l_nk-1)*nij+((j-1)*l_ni) + i !for k=l_nk
            F_px(n) = F_pxc(nm)
            F_py(n) = F_pyc(nm)
         enddo
         enddo
!$omp enddo
      endif
!$omp end parallel
!
!!$      print *,'adx_main_2_pos ('//trim(F_l_S)//') [end]'
!     ---------------------------------------------------------------
      return
      end
