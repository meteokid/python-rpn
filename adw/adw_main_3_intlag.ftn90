!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r adw_main_3_intlag - Interpolation of rhs
!
#include "model_macros_f.h"
#include "msg.h"
!
      subroutine adw_main_3_intlag(F_pxm, F_pym, F_pzm, &
           F_pxt, F_pyt,  F_pzt, F_isStatStep_L)
      implicit none
      real F_pxm(*), F_pym(*), F_pzm(*)
      real F_pxt(*), F_pyt(*), F_pzt(*)
      logical F_isStatStep_L
!
!author
!     alain patoine
!
!revision
! v2_31 - Desgagne & Tanguay  - removed stkmemw, introduce tracers
! v2_31                       - tracers not monotone if V4dg_conf.ne.0
! v3_00 - Desgagne & Lee      - Lam configuration
! v3_02 - Tanguay             - Restore tracers monotone if V4dg_conf.ne.0 
! v3_02 - Lee V.              - revert adw_exch_1 for GLB only, 
! v3_02                         added adw_ckbd_lam,adw_cfl_lam for LAM only
! v3_03 - Tanguay M.          - stop if adw_exch_1 is activated when 4D-Var
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v3_11 - Gravel S.           - introduce key Adw_mono_L 
! v3_20 - Gravel & Valin & Tanguay - Lagrange 3D
! v3_20 - Tanguay M.          - Improve alarm when points outside advection grid
! v3_20 - Dugas B.            - correct calculation for LAM when Glb_pil gt 7
! v3_21 - Desgagne M.         - if  Lagrange 3D, call adw_main_3_intlag
! v4_04 - Tanguay M.          - Staggered version TL/AD
! v4_05 - Lepine M.           - VMM replacement with GMM
! v1_10 - Plante A.           - Thermo upstream positions
!
!language
!     fortran 77
!
!object
!     see id section
!
!arguments
!______________________________________________________________________
!                   |                                            |     |
! NAME              | DESCRIPTION                                | I/O |
!-------------------|--------------------------------------------|-----|
! F_pxm,F_pym,F_pzm | upstream positions at t1 at input, m-levels|  iw |
! F_pxt,F_pyt,F_pzt | upstream positions at t1 at input, t-levels|  iw |
!___________________|____________________________________________|_____|
!
!implicits
#include "gmm.hf"
#include "glb_ld.cdk"
!      logical G_lam
!      logical l_north, l_south, l_east, l_west
!      integer l_ni, l_nj, l_nk, l_niu, l_njv
!      integer l_minx, l_maxx, l_miny, l_maxy
!      integer pil_n,pil_s,pil_w,pil_e
#include "orh.cdk"
!      logical Orh_crank_L
!      integer Orh_icn
!      real, pointer, dimension (:,:,:) :: orhst,orhsc,orhsw,orhsf
!      character(len=8) :: gmmk_orhst_s,gmmk_orhsc_s,gmmk_orhsw_s,gmmk_orhsf_s
#include "schm.cdk"
!      logical Schm_zdotlag_L,Schm_zdotMid_L,Schm_hydro_L
!      integer Schm_itcn
#include "cstv.cdk"
!      real*8    Cstv_tau_8
#include "rhsc.cdk"
!      real, pointer, dimension (:,:,:) :: ruw1,rvw1,ruw2,rvw2
!      real, pointer, dimension (:,:,:) :: rhst,rhsc,rhsw,rhsf
!      character(len=8) :: gmmk_rhst_s,gmmk_rhsc_s
!      character(len=8) :: gmmk_rhsw_s,gmmk_rhsf_s
!      character(len=8) :: gmmk_ruw1_s,gmmk_rvw1_s,gmmk_ruw2_s,gmmk_rvw2_s
#include "type.cdk"
#include "adw.cdk"
#include "tr3d.cdk"
!      integer MAXTR3D
!      parameter ( MAXTR3D = 250 )
!      character*4 Tr3d_name_S(MAXTR3D)
!      integer Tr3d_ntr
#include "vt1.cdk"
!      real, pointer, dimension (:,:,:) :: zdt1,zdup
!      character(len=8) :: gmmk_zdt1_s,gmmk_zdup_s
!#include "ver.cdk"
!      type (vertical_8) Ver_idz_8  
!      type (vertical_8) Ver_wp_8
!      type (vertical_8) Ver_wm_8
!$$$#include "acid.cdk"
!      logical acid_test_l
!
!modules
!***********************************************************************
      integer ier,longueur
      integer n, nij, nijkt, nijkm, nijkad, cnt, unf
      integer i,j,k, n1,n2,np,i0,j0,in,jn,err
      real, allocatable, dimension(:) :: pos_x, pos_y, pos_z
      real, pointer    , dimension(:,:,:) :: tr0,tr1
      !---------------------------------------------------------------------
      call msg(MSG_DEBUG, &
           'ADVECT THE RIGHT-HAND-SIDES: (S/R ADW_MAIN_3_INTLAG)')

      nij    = l_ni   *l_nj
      nijkt  = l_ni   *l_nj   *(l_nk+1)
      nijkm  = l_ni   *l_nj   * l_nk
      nijkad = Adw_nit*Adw_njt*(l_nk+1)
      call hpalloc(Adw_capx1_   ,nijkt,      err,1)
      call hpalloc(Adw_capy1_   ,nijkt,      err,1)
      call hpalloc(Adw_capz1_   ,nijkt,      err,1)
      call hpalloc(Adw_n1_      ,nijkt,      err,1)
      call hpalloc(Adw_xdd1_    ,nijkt,      err,1)
      call hpalloc(Adw_xgg1_    ,nijkt,      err,1)
      call hpalloc(Adw_ydd1_    ,nijkt,      err,1)
      call hpalloc(Adw_ygg1_    ,nijkt,      err,1)
      call hpalloc(Adw_cz1_     ,nijkt,      err,1)
      call hpalloc(Adw_c1_      ,nijkt,      err,1)
      call hpalloc(Adw_wrkb_    ,nijkt,      err,1)
      call hpalloc(Adw_wrkc_    ,nijkt,      err,1)

      allocate ( pos_x(nijkad) )
      allocate ( pos_y(nijkad) )
      allocate ( pos_z(nijkad) )

      call adw_get_ij0n(i0,j0,in,jn)

!**********************************************************************
! Advection/Interpolation on Momentum levels
!**********************************************************************

!$omp parallel do private(n)
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         pos_x(n) =  F_pxm(n)
         pos_y(n) =  F_pym(n)
         pos_z(n) =  F_pzm(n)
      enddo
      enddo
      enddo
!$omp end parallel do

      call adw_main_3_prep(pos_x, pos_y, pos_z, &
           i0, in, j0, jn, nijkad, l_nk, 'm', F_isStatStep_L)

!$$$      if (Acid_test_L) call acid_stat_adw_main_3_intlag(ruw1,ruw2,rvw2,1)

      call adw_interp_gmm(gmmk_ruw2_s, gmmk_ruw1_s, pos_x, pos_y, &
           .true., .false., LDIST_DIM, l_nk,i0,in,j0,jn,'m',1.d0)
      call adw_interp_gmm(gmmk_rvw2_s, gmmk_rvw1_s, pos_x, pos_y, &
           .true., .false., LDIST_DIM, l_nk,i0,in,j0,jn,'m',1.d0)
      call adw_interp_gmm(gmmk_rhsc_s , gmmk_orhsc_s , pos_x, pos_y, &
           .false.,.false., LDIST_DIM, l_nk,i0,in,j0,jn,'m',1.d0)

!$$$      if (Acid_test_L) call acid_stat_adw_main_3_intlag(ruw1,ruw2,rvw2,2)

      call adw_main_3_post()

!**********************************************************************
! Advection/interpolation on thermodynamic levels
!**********************************************************************
!     from upstream position for momentum levels to upstream
!     position for thermodynamic levels

!$omp parallel do
      do n=1,nijkad
         pos_x(n) =  F_pxt(n)
         pos_y(n) =  F_pyt(n)
         pos_z(n) =  F_pzt(n)
      enddo
!$omp end parallel do

      call adw_main_3_prep(pos_x, pos_y, pos_z,  &
           i0, in, j0, jn, nijkad, l_nk+1, 't', F_isStatStep_L)

      call adw_interp_gmm(gmmk_rhst_s, gmmk_orhst_s, pos_x, pos_y,  &
           .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t',1.d0)
      call adw_interp_gmm(gmmk_rhsf_s, gmmk_orhsf_s, pos_x, pos_y,  &
           .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t',1.d0)

      if (.not. Schm_hydro_L) then
         call adw_interp_gmm(gmmk_rhsw_s, gmmk_orhsw_s, pos_x, pos_y,  &
              .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t',1.d0)
      endif
     
      if (Schm_zdotmid_L) then
         call adw_interp_gmm(gmmk_zdup_s,gmmk_zdt1_s, pos_x, pos_y, &
              .false.,.false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t',1.d0)
      endif


      if (Orh_icn == Schm_itcn) then
         do n=1,Tr3d_ntr
            call adw_interp_gmm( &
                 'TR/'//trim(Tr3d_name_S(n))//':M', &
                 'TR/'//trim(Tr3d_name_S(n))//':P', &
                 pos_x, pos_y, &
                 .false. , Adw_mono_L, LDIST_DIM, l_nk+1,i0,in,j0,jn,'t',Cstv_tau_8)
         end do
      endif

      call adw_main_3_post()

!**********************************************************************
      call hpdeallc(Adw_capx1_   ,err,1)
      call hpdeallc(Adw_capy1_   ,err,1)
      call hpdeallc(Adw_capz1_   ,err,1)
      call hpdeallc(Adw_n1_      ,err,1)
      call hpdeallc(Adw_xdd1_    ,err,1)
      call hpdeallc(Adw_xgg1_    ,err,1)
      call hpdeallc(Adw_ydd1_    ,err,1)
      call hpdeallc(Adw_ygg1_    ,err,1)
      call hpdeallc(Adw_cz1_     ,err,1)
      call hpdeallc(Adw_c1_      ,err,1)
      call hpdeallc(Adw_wrkb_    ,err,1)
      call hpdeallc(Adw_wrkc_    ,err,1)

      deallocate (pos_x,pos_y,pos_z)
      !---------------------------------------------------------------------
      return
      end subroutine adw_main_3_intlag


!/**
      subroutine adw_main_3_prep(pos_x, pos_y, pos_z,  &
           i0, in, j0, jn, F_nijk, F_nk, F_type_S, F_isStatStep_L)
      implicit none
      !@objective
      !@arguments
      logical :: F_isStatStep_L
      character(len=*) :: F_type_S
      integer :: i0, in, j0, jn, F_nijk, F_nk
      real, dimension(F_nijk) :: pos_x, pos_y, pos_z
#undef GMM_IS_OK
#include "glb_ld.cdk"
!      logical G_lam
#include "orh.cdk"
!      logical Orh_crank_L
!      integer Orh_icn
#include "schm.cdk"
!      logical Schm_zdotlag_L,Schm_zdotMid_L,Schm_hydro_L
!      integer Schm_itcn
#undef TYPE_CDK
#include "type.cdk"
#include "adw.cdk"
       include "v4dg.inc"
!      integer V4dg_conf
!**/
      integer :: err,dim,i,j,k,n,nij
      !---------------------------------------------------------------------
      if (G_lam) then

          if ((Orh_icn.eq.Schm_itcn .or. .not.Orh_crank_L)  &
              .and. F_isStatStep_L) then
             call adw_cfl_lam(pos_x, pos_y, pos_z,  &
                  i0, in, j0, jn, F_nk, F_type_S)
          endif
          call adw_cliptraj(pos_x, pos_y, i0, in, j0, jn, F_nk,  &
               'INTERP '//trim(F_type_S))
          if (V4dg_conf .ne. 0.) then
              err = 0
              if ((Adw_trunc(1) + Adw_trunc(2) + &
                   Adw_trunc(3) + Adw_trunc(4)) > 0) err = -1
              call handle_error(err,'adw_main_3_prep', &
                   'TLM-ADJ NOT done: INCREASE HALO')
          endif

      else ! if (.not.G_lam) then

         call adw_exch_1(Adw_n1, Adw_xgg1, Adw_xdd1, Adw_c1, &
              pos_x, pos_y, pos_z, F_nk)

         if (V4dg_conf .ne. 0.) then
            err = 0
            if (Adw_fro_a > 0) err = -1
            call handle_error(err,'adw_main_3_prep', &
                 'TLM-ADJ NOT done: INCREASE HALO')
         endif

         dim = max(1,Adw_fro_a)
         call hpalloc(Adw_capx2_   ,dim,      err,1)
         call hpalloc(Adw_capy2_   ,dim,      err,1)
         call hpalloc(Adw_capz2_   ,dim,      err,1)
         call hpalloc(Adw_n2_      ,dim,      err,1)
         call hpalloc(Adw_xdd2_    ,dim,      err,1)
         call hpalloc(Adw_xgg2_    ,dim,      err,1)
         call hpalloc(Adw_ydd2_    ,dim,      err,1)
         call hpalloc(Adw_ygg2_    ,dim,      err,1)
         call hpalloc(Adw_cz2_     ,dim,      err,1)
         call hpalloc(Adw_wrka_    ,dim,      err,1)

         call adw_exch_2(Adw_capx2, Adw_capy2, Adw_capz2, &
              Adw_n1, Adw_xgg1, Adw_xdd1, &
              Adw_fro_n, Adw_fro_s, Adw_fro_a, &
              Adw_for_n, Adw_for_s, Adw_for_a, 3)

         if (Adw_fro_a>0 .and. Adw_ckbd_L) then
            call adw_ckbd(Adw_capy2)
         endif

      endif

     ! Keep positions in CAP fields

      nij = l_ni*l_nj

!$omp parallel private(n)
!$omp do
      do k=1,F_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         Adw_capx1(n) = pos_x(n)
         Adw_capy1(n) = pos_y(n)
         Adw_capz1(n) = pos_z(n)
      end do
      end do
      end do
!$omp enddo
!$omp end parallel

      if (adw_stats_L) then
         call glbstat2 (adw_capx1, 'cpx1', 'adw_3',  &
              1,l_ni, 1,l_nj, 1,F_nk, &
              i0,in,j0,jn,1,F_nk)
         call glbstat2 (adw_capy1, 'cpy1', 'adw_3',  &
              1,l_ni, 1,l_nj, 1,F_nk, &
              i0,in,j0,jn,1,F_nk)
         call glbstat2 (adw_capz1, 'cpz1', 'adw_3',  &
              1,l_ni, 1,l_nj, 1,F_nk, &
              i0,in,j0,jn,1,F_nk)
      endif
      !---------------------------------------------------------------------
      return
      end subroutine adw_main_3_prep


!/**
      subroutine adw_main_3_post()
      implicit none
      !@objective
#include "glb_ld.cdk"
!      logical G_lam
#undef TYPE_CDK
#include "type.cdk"
#include "adw.cdk"
!**/
      integer :: err
      !---------------------------------------------------------------------
      if (.not.G_lam) then
         call hpdeallc(Adw_capx2_   ,err,1)
         call hpdeallc(Adw_capy2_   ,err,1)
         call hpdeallc(Adw_capz2_   ,err,1)
         call hpdeallc(Adw_n2_      ,err,1)
         call hpdeallc(Adw_xdd2_    ,err,1)
         call hpdeallc(Adw_xgg2_    ,err,1)
         call hpdeallc(Adw_ydd2_    ,err,1)
         call hpdeallc(Adw_ygg2_    ,err,1)
         call hpdeallc(Adw_cz2_     ,err,1)
         call hpdeallc(Adw_wrka_    ,err,1)
      endif
      !---------------------------------------------------------------------
      return
      end subroutine adw_main_3_post
