!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#include "msg.h"

!/**
subroutine adw_model2adw_grid_uv(F_u_adw, F_v_adw, F_u_model,F_v_model, F_nk)
   implicit none
#include "adw_dims.cdk"
   !@objective Extend the grid from model to adw with filled halos
   !@arguments
   integer :: F_nk             !I, number of levels
   real,dimension(adw_mlminx:adw_mlmaxx,adw_mlminy:adw_mlmaxy,F_nk) :: &
        F_u_model, F_v_model   !I, winds on model-grid
   real,dimension(adw_lminx:adw_lmaxx,adw_lminy:adw_lmaxy,F_nk) :: &
        F_u_adw ,F_v_adw       !O, winds on adw-grid
   !**/
   integer :: nrow, j1
   !---------------------------------------------------------------------
   call msg(MSG_DEBUG,'adw_model2adw_grid_uv')
   nrow = 999
   if (adw_lam_L) nrow = 0
   call rpn_comm_xch_halox( &
        F_u_model, adw_mlminx,adw_mlmaxx,adw_mlminy,adw_mlmaxy, &
        adw_mlni, adw_mlnj, F_nk, adw_halox, adw_haloy, &
        adw_is_period_x, adw_is_period_y, &
        F_u_adw, adw_lminx,adw_lmaxx,adw_lminy,adw_lmaxy, adw_lni, nrow)
   call rpn_comm_xch_halox( &
        F_v_model, adw_mlminx,adw_mlmaxx,adw_mlminy,adw_mlmaxy, &
        adw_mlni, adw_mlnj, F_nk, adw_halox, adw_haloy, &
        adw_is_period_x, adw_is_period_y, &
        F_v_adw, adw_lminx,adw_lmaxx,adw_lminy,adw_lmaxy, adw_lni, nrow)

   !$omp parallel private(j1)
   IF_LAM: if (.not.adw_lam_L) then
      if (adw_is_south) then
         j1 = 0
         call adw_polw2(F_u_adw, F_v_adw, &
              j1, adw_lni, adw_halox, adw_lnj, adw_haloy, F_nk)
      endif
      if (adw_is_north) then
         j1 = adw_lnj+1
         call adw_polw2(F_u_adw, F_v_adw, &
              j1, adw_lni, adw_halox, adw_lnj, adw_haloy, F_nk)
     endif
   endif IF_LAM
   !$omp end parallel

   call msg(MSG_DEBUG,'adw_model2adw_grid_uv [end]')
   !---------------------------------------------------------------------
   return
end subroutine adw_model2adw_grid_uv


!/**
subroutine adw_model2adw_grid_scalar(F_fld_adw, F_fld_model, &
     F_nk, F_pol0_L, F_extend_L)
   implicit none
#undef __ADW_DIMS__
#include "adw_dims.cdk"
   !@objective Extend the grid from model to adw with filled halos
   !@arguments
   logical :: F_extend_L  !I, Extend field beyond poles
   logical :: F_pol0_L    !I, Set values=0 around poles (e.g. 4 winds)
   integer :: F_nk        !I, number of levels
   real, dimension(adw_mlminx:adw_mlmaxx,adw_mlminy:adw_mlmaxy,F_nk) :: &
        F_fld_model       !I, fld on model-grid
   real, dimension(adw_lminx:adw_lmaxx,adw_lminy:adw_lmaxy,F_nk) :: &
        F_fld_adw         !O, fld on adw-grid
   !**/
   integer :: nrow
   logical :: is_south_L
   !---------------------------------------------------------------------
   call msg(MSG_DEBUG,'adw_model2adw_grid_scalar')

   nrow = 999
   if (adw_lam_L) nrow = 0
   call rpn_comm_xch_halox( &
        F_fld_model, adw_mlminx,adw_mlmaxx,adw_mlminy,adw_mlmaxy, &
        adw_mlni, adw_mlnj, F_nk, adw_halox, adw_haloy, &
        adw_is_period_x, adw_is_period_y, &
        F_fld_adw, adw_lminx,adw_lmaxx,adw_lminy,adw_lmaxy, adw_lni, nrow)

   IF_LAM: if (.not.adw_lam_L) then
      if (adw_is_south) then
         is_south_L = .true.
         call adw_pole0s(F_fld_adw, F_fld_model, &
              F_nk, F_pol0_L, F_extend_L, is_south_L)
      endif

      if (adw_is_north) then
         is_south_L = .false.
         call adw_pole0s(F_fld_adw, F_fld_model, &
              F_nk, F_pol0_L, F_extend_L, is_south_L)
      endif
   endif IF_LAM

   call msg(MSG_DEBUG,'adw_model2adw_grid_scalar [end]')
   !---------------------------------------------------------------------
   return

contains !=====================================================================

   !/**
   subroutine adw_pole0s(F_fld_adw, F_fld_model, &
        F_nk, F_pol0_L, F_extend_L, F_is_south_L)
      implicit none
#undef __ADW_DIMS__
#include "adw_dims.cdk"
#include "adw_grid.cdk"
      !@objective Extend the grid from model to adw with filled halos
      !@arguments
      logical :: F_is_south_L !I, .true. if south pole
      logical :: F_extend_L   !I, Extend field beyond poles
      logical :: F_pol0_L     !I, Set values=0 around poles (e.g. 4 winds)
      integer :: F_nk         !I, number of levels
      real, dimension(adw_mlminx:adw_mlmaxx,adw_mlminy:adw_mlmaxy,F_nk) :: &
           F_fld_model        !I, fld on model-grid
      real, dimension(adw_lminx:adw_lmaxx,adw_lminy:adw_lmaxy,F_nk) :: &
           F_fld_adw          !O, fld on adw-grid
      !**/
      integer :: j1, j2, i, k
      real*8  :: ww_8
      !---------------------------------------------------------------------
      call msg(MSG_DEBUG,'adw_pole0s')

!$omp parallel private(j1,j2,ww_8)
      if (F_is_south_L) then
         j1 = 0
         j2 = 1
      else
         j1 = adw_lnj+1
         j2 = adw_lnj
      endif

      if  (F_pol0_L) then
         !set values at the pole = 0.0
         !$omp do
         do k = 1, F_nk
            do i = adw_lminx, adw_lmaxx
               F_fld_adw(i,j1,k) = 0.0
            enddo
         enddo
         !$omp enddo
      else
         !compute weighted average around the pole
         !$omp do
         do k = 1, F_nk
            ww_8 = 0.D0
            do i = 1, adw_lni
               ww_8 = ww_8 + adw_wx_8(i) * dble(F_fld_adw(i,j2,k))
            enddo
            do i = adw_lminx, adw_lmaxx
               F_fld_adw(i,j1,k) = sngl(ww_8)
            enddo
         enddo
         !$omp enddo
      endif
      if (F_extend_L) then
         !extension of a scalar field beyond the poles
         call adw_polx2(F_fld_adw, &
              is_south_L, adw_lni, adw_halox, adw_lnj, adw_haloy, F_nk)
      endif
!$omp end parallel

      call msg(MSG_DEBUG,'adw_pole0s [end]')
      !---------------------------------------------------------------------
      return
   end subroutine adw_pole0s

end subroutine adw_model2adw_grid_scalar
