!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r adw_trajex - compute positions at origin (o) by 
!                   extrapolation using positions at 
!                   mid-trajectory (m)
!
#include "model_macros_f.h"
#include "constants.h"
!
      subroutine adw_trajex ( F_xto,  F_yto,  F_xcto, F_ycto, &
                              F_zcto, F_xctm, F_yctm, F_zctm,i0,in,j0,jn)
      implicit none
#include <arch_specific.hf>
!
      real   F_xto (*), F_yto (*), F_xcto(*), F_ycto(*), &
             F_zcto(*), F_xctm(*), F_yctm(*), F_zctm(*)
      integer i0,in,j0,jn
!
!author
!     alain patoine
!
!revision
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
!
!object
!     see id section
!
!arguments
!______________________________________________________________________
!              |                                                 |     |
! NAME         | DESCRIPTION                                     | I/O |
!--------------|-------------------------------------------------|-----|
!              |                                                 |     |
! F_xto        | upstream x positions at origin                  |  o  |
! F_yto        | upstream y positions at origin                  |  o  |
! F_xcto       | upstream x cartesian positions at origin        |  o  |
! F_ycto       | upstream y cartesian positions at origin        |  o  |
! F_zcto       | upstream z cartesian positions at origin        |  o  |
! F_xctm       | upstream x cartesian positions at mid-traj.     |  i  |
! F_yctm       | upstream y cartesian positions at mid-traj.     |  i  |
! F_zctm       | upstream z cartesian positions at mid-traj.     |  i  |
!______________|_________________________________________________|_____|
!
!implicits
#include "glb_ld.cdk"
!      integer l_ni, l_nj, l_nk
#include "adw.cdk"
!      DCL_DYNVAR(Adw, cx2d_8,    real*8 , (*))
!      DCL_DYNVAR(Adw, sx2d_8,    real*8 , (*))
!      DCL_DYNVAR(Adw, cy2d_8,    real*8 , (*))
!      DCL_DYNVAR(Adw, sy2d_8,    real*8 , (*))
!***********************************************************************
      integer i,j,k, n, ij, nij, vnij
!
      real*8 prx, pry, prz, prdot2, r2pi_8, two
      real*8 xasin(i0:in,j0:jn), yasin(i0:in,j0:jn)
      real*8 xatan(i0:in,j0:jn), yatan(i0:in,j0:jn), zatan(i0:in,j0:jn)
!
      parameter (two = 2.0)
!***********************************************************************
      nij  = l_ni*l_nj
      vnij = (in-i0+1)*(jn-j0+1)
!
      r2pi_8 = two * CONST_PI_8
!     call tmg_start ( 34, 'adw_trajex' )
!***********************************************************************
!$omp parallel private(xasin,yasin,xatan,yatan,zatan,n,ij,prx,pry,prz,prdot2)
!$omp do
      do k=1,l_nk
         do j=j0,jn
         do i=i0,in
!
              n = (k-1)*nij+((j-1)*l_ni) + i
             ij = mod( n-1, nij ) + 1
            pry = dble(Adw_cy2d_8(ij))
            prx = dble(Adw_cx2d_8(ij)) * pry
            pry = dble(Adw_sx2d_8(ij)) * pry
            prz = dble(Adw_sy2d_8(ij))
!
            prdot2 = 2.0 * ( prx * dble(F_xctm(n)) + &
                             pry * dble(F_yctm(n)) + &
                             prz * dble(F_zctm(n)) )
!
            F_xcto(n) = prdot2 * dble(F_xctm(n)) - prx
            F_ycto(n) = prdot2 * dble(F_yctm(n)) - pry
            F_zcto(n) = prdot2 * dble(F_zctm(n)) - prz
!
            xatan(i,j) = F_xcto(n)
            yatan(i,j) = F_ycto(n)
            xasin(i,j) = max(-1.,min(1.,F_zcto(n)))
!
         enddo
         enddo
!
         call vatan2(zatan, yatan, xatan, vnij)
         call vasin(yasin, xasin, vnij)
!
         do j=j0,jn
         do i=i0,in
             n = (k-1)*nij+((j-1)*l_ni) + i
            F_xto(n) = zatan(i,j)
            F_yto(n) = yasin(i,j)
            if ( F_xto(n) .lt. 0.0 ) F_xto(n) = F_xto(n) + r2pi_8
         enddo
         enddo
      enddo
!$omp enddo
!$omp end parallel
!
!     call tmg_stop (34)
      return
      end
