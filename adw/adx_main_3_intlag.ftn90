!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#include "msg.h"
#include "stop_mpi.h"
#include "model_macros_f.h"

!/**
subroutine adx_main_3_intlag7 ( F_px, F_py, F_pz, F_fields_list,        &
                                F_fields_type_L, F_nfields, F_is_mom_L, &
                                F_doAdwStat_L, F_ni,F_nj,F_k0,F_nk)
   implicit none
#include <arch_specific.hf>
!
   !@objective Interpolation of rhs
!
   !@arguments
   logical :: F_is_mom_L     !I, momentum level if .true. (thermo if not)
   logical :: F_doAdwStat_L  !I, compute stats if .true.
   integer :: F_ni,F_nj,F_nk !I, pos array dims
   integer :: F_k0           !I, vertical scope F_k0 to F_nk
   integer :: F_nfields      !I, nb of fields to advect
   logical, dimension(2,F_nfields)         :: F_fields_type_L !I, fields type
   character(len=*), dimension(2,F_nfields):: F_fields_list   !I, gmm flds lbls
   real, dimension(F_ni,F_nj,F_nk) :: F_px, F_py, F_pz !I, upstream positions at t1
!
   !@author alain patoine
   !@revisions
   ! v2_31 - Desgagne & Tanguay  - removed stkmemw, introduce tracers
   ! v2_31                       - tracers not monotone if V4dg_conf.ne.0
   ! v3_00 - Desgagne & Lee      - Lam configuration
   ! v3_02 - Tanguay             - Restore tracers monotone if V4dg_conf.ne.0 
   ! v3_02 - Lee V.              - revert adx_exch_1 for GLB only, 
   ! v3_02                         added adx_ckbd_lam,adx_cfl_lam for LAM only
   ! v3_03 - Tanguay M.          - stop if adx_exch_1 is activated when 4D-Var
   ! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
   ! v3_11 - Gravel S.           - introduce key adx_mono_L 
   ! v3_20 - Gravel & Valin & Tanguay - Lagrange 3D
   ! v3_20 - Tanguay M.          - Improve alarm when points outside advection grid
   ! v3_20 - Dugas B.            - correct calculation for LAM when Glb_pil gt 7
   ! v3_21 - Desgagne M.         - if  Lagrange 3D, call adx_main_3_intlag
   ! v4_04 - Tanguay M.          - Staggered version TL/AD
   ! v4_05 - Lepine M.           - VMM replacement with GMM
   ! v1_10 - Plante A.           - Thermo upstream positions
   ! v4_40 - Tanguay M.          - Revision TL/AD
!**/

#include "adx_nml.cdk"
#include "adx_dims.cdk"
#include "adx_poles.cdk"
#include "ptopo.cdk"
#include "lun.cdk"
#include "lctl.cdk"
#include "orh.cdk"
#include "schm.cdk"
#include "step.cdk"
   include "v4dg.inc"

   integer, parameter :: FIELD_IN  = 1
   integer, parameter :: FIELD_OUT = 2
   integer, parameter :: IS_MOM    = 1
   integer, parameter :: IS_WIND   = 2

   character(len=1) :: level_type_S

   integer :: n
   integer :: i0,j0,in,jn, istat
   integer, dimension(F_ni,F_nj,F_nk) :: exch_c1
   real   , dimension(F_ni,F_nj,F_nk) :: exch_n1, exch_xgg1, exch_xdd1
   real   , dimension(:), allocatable :: capx2,capy2,capz2
   real   , dimension(3)              :: minv,maxv

   integer, external :: adx_ckbd3

   integer outside,sum_outside,ier
   logical done_once_L
   save done_once_L
   data done_once_L /.false./

   !---------------------------------------------------------------------

   call msg(MSG_DEBUG, 'adx_main_3_intlag')

   call adx_get_ij0n (i0,in,j0,jn)

   level_type_S = 't'
   if (F_is_mom_L) level_type_S = 'm'

   if (adx_lam_L) then

      if (F_doAdwStat_L) call adx_cfl_lam3 (F_px, F_py, F_pz, i0,in,j0,jn, &
                                            F_ni,F_nj,F_k0,F_nk, level_type_S)

      call adx_cliptraj3 ( F_px, F_py, i0, in, j0, jn, F_ni,F_nj,F_k0,F_nk,  &
                                        'INTERP '//trim(level_type_S))

   else

      call adx_exch_1c ( exch_n1, exch_xgg1, exch_xdd1, exch_c1, &
                              F_px, F_py, F_pz, F_ni,F_nj,F_k0,F_nk )
!
      if ( V4dg_conf.ne.0.0 ) then
!
            outside = 0
            if ( Adx_fro_a .gt. 0 ) outside = 1
!
            sum_outside = 0
            call rpn_comm_Allreduce(outside,sum_outside,1,"MPI_INTEGER", &
                                                   "MPI_SUM","grid",ier)
!
            if ( sum_outside.ne.0.and..not.done_once_L.and.Ptopo_myproc.eq.0 ) then
                 write(Lun_out,*) 'NUMBER OF PE WITH OUTSIDERS IN ADW_MAIN_3_LAG AT current TIME-CN = ',sum_outside
                 call flush(Lun_out)
            endif

!
      endif
!
      allocate ( capx2(max(1,adx_fro_a)), &
                 capy2(max(1,adx_fro_a)), &
                 capz2(max(1,adx_fro_a)) )

      call adx_exch_2 ( capx2, capy2, capz2,             &
                        exch_n1, exch_xgg1, exch_xdd1,   &
                        adx_fro_n, adx_fro_s, adx_fro_a, &
                        adx_for_n, adx_for_s, adx_for_a, 3)

      istat = 1
      if (adx_fro_a>0 .and. adw_ckbd_L) &
      istat = adx_ckbd3 (capy2,adx_fro_n,adx_fro_s)

   endif

   do n = 1, F_nfields
      if (F_fields_type_L(IS_MOM,n) .neqv. F_is_mom_L) cycle
      call adx_interp_gmm7 ( F_fields_list(FIELD_OUT,n), F_fields_list(FIELD_IN,n), & 
                             F_fields_type_L(IS_WIND,n),                            &
                             F_px, F_py, F_pz, capx2, capy2, capz2, exch_c1,        &
                             F_nk, i0, in, j0, jn, F_k0, level_type_S )
   end do

   if (.not.adx_lam_L) deallocate ( capx2, capy2, capz2 )

   if (V4dg_conf.ne.0.and.Lctl_step.eq.Step_total.and.Orh_icn.eq.Schm_itcn) done_once_L = .true.

   call msg(MSG_DEBUG, 'adx_main_3_intlag [end]')

   !---------------------------------------------------------------------

   return
end subroutine adx_main_3_intlag7
