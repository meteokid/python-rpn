!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#include <stop_mpi.h>
#include <msg.h>
#include <model_macros_f.h>

!/**
subroutine adx_main7 (F_su, F_sv, F_sw, &
                      F_fields_list, F_fields_type_L, F_nfields, &
                      F_minx,F_maxx,F_miny,F_maxy,F_nks, F_nb_iter, F_doAdwStat_L)
   implicit none
#include <arch_specific.hf>
!
   !@objective Perform advection
!
   !@arguments
   logical :: F_doAdwStat_L   !I, will compute stats if .true.
   integer :: F_nb_iter       !I, total number of iterations for trajectories
   integer :: F_minx,F_maxx,F_miny,F_maxy !I, bounds of model's wind arrays
   integer :: F_nks           !I, nb levels - super-set of m+l levels
   integer :: F_nfields       !I, nb of fields to advect
   logical, dimension(2, F_nfields) :: &
        F_fields_type_L       !I, fields type
   character(len=*),dimension(2, F_nfields) :: &
        F_fields_list         !I, list of gmm labels of fields to advect
   real, dimension(F_minx:F_maxx,F_miny:F_maxy, F_nks) :: &
        F_su, F_sv, F_sw      !I, real destag winds, super-set (mom+thermo)
!
   !@author  alain patoine
   !@revisions
   ! v3_00 - Desgagne & Lee    - Lam configuration
   ! v3_01 - Lee V.            - Initialize Lam truncated trajectory counters
   ! v3_20 - Tanguay M.        - Option of storing instead of redoing TRAJ 
   ! v4_04 - Tanguay M.        - Staggered version TL/AD 
   ! V4_10 - Plante A.         - Thermo upstream positions
   ! V4_14 - Plante A.         - No advection in top pilote zone
   ! V4_30 - Plante A.         - Added Adw_thermopos_S
   ! v4_40 - Tanguay M.        - Revision TL/AD
   !@description
   !  adx_main_2_pos: Calculate upstream positions at th and t1
   !  adx_main_3_int: Interpolation of rhs
!**/

#include <gmm.hf>
#include "adx_gmm.cdk"
#include "adx_dims.cdk"
#include "adx_nml.cdk"
#include "glb_ld.cdk"
!!$#include "v4d_cfl.cdk"
   include "v4dg.inc"

   logical, parameter :: IS_MOM_LEVEL = .true.
   logical, parameter :: POLE0_L = .false.
   logical, parameter :: EXTEND_L = .false.

   logical :: save_stats_L
   type(gmm_metadata) :: my_meta,my_meta_t,my_meta2
   integer :: i,j,istat,i0,in,j0,jn,k0
   real, dimension(adx_mlni,adx_mlnj,adx_lnkm) :: &
        pxm,pym,pzm
   real, dimension(adx_mlni,adx_mlnj,adx_lnkt) :: &
        pxt,pyt,pzt,l_xct1, l_yct1, l_zct1
   real, dimension(adx_lminx:adx_lmaxx,adx_lminy:adx_lmaxy,F_nks) :: &
        a_su,a_sv,a_sw
   real :: dummy

   real, pointer, dimension(:) :: &
        xth, yth, zth, xcth, ycth, zcth, &
        xth_t, yth_t, zth_t, &
        xcth_t, ycth_t, zcth_t, &
        xct1, yct1, zct1
   !
   logical v4dstore_L

#define IS_SAME_BOUNDS(M1,M2) (M1%l(1)%low == M2%l(1)%low .and. M1%l(1)%high == M2%l(1)%high .and. M1%l(2)%low == M2%l(2)%low .and. M1%l(2)%high == M2%l(2)%high)

   !---------------------------------------------------------------------

   call msg(MSG_DEBUG,'adx_main')

   k0=adx_gbpil_t+1

   v4dstore_L   = V4dg_conf.ne.0 .and. V4dg_oktr_L
   save_stats_L = adw_stats_L
   adw_stats_L  = (F_doAdwStat_L .and. adw_stats_L)

   call adx_grid_uv (a_su,a_sv, F_su,F_sv,                    &
                     adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, &
                     F_minx,F_maxx,F_miny,F_maxy, F_nks)

   call adx_grid_scalar (a_sw, F_sw,                          &
                         adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy, &
                         F_minx,F_maxx,F_miny,F_maxy, F_nks, POLE0_L, EXTEND_L)

   istat = GMM_OK
   istat = min(gmm_get(adx_xth_s,xth,my_meta),istat)
   istat = min(gmm_get(adx_yth_s,yth,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_zth_s,zth,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 

   istat = min(gmm_get(adx_xcth_s,xcth,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_ycth_s,ycth,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_zcth_s,zcth,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 

   istat = min(gmm_get(adx_xct1_s,xct1,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_yct1_s,yct1,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 
   istat = min(gmm_get(adx_zct1_s,zct1,my_meta2),istat)
   if (.not.(IS_SAME_BOUNDS(my_meta,my_meta2))) istat = -1 

   if(trim(Adw_thermopos_S).eq.'TRAJ')then
      istat = min(gmm_get(adx_xth_t_s,xth_t,my_meta_t),istat)
      istat = min(gmm_get(adx_yth_t_s,yth_t,my_meta2),istat)
      if (.not.(IS_SAME_BOUNDS(my_meta_t,my_meta2))) istat = -1 
      istat = min(gmm_get(adx_zth_t_s,zth_t,my_meta2),istat)
      if (.not.(IS_SAME_BOUNDS(my_meta_t,my_meta2))) istat = -1 
      
      istat = min(gmm_get(adx_xcth_t_s,xcth_t,my_meta2),istat)
      if (.not.(IS_SAME_BOUNDS(my_meta_t,my_meta2))) istat = -1 
      istat = min(gmm_get(adx_ycth_t_s,ycth_t,my_meta2),istat)
      if (.not.(IS_SAME_BOUNDS(my_meta_t,my_meta2))) istat = -1 
      istat = min(gmm_get(adx_zcth_t_s,zcth_t,my_meta2),istat)
      if (.not.(IS_SAME_BOUNDS(my_meta_t,my_meta2))) istat = -1 


   endif

   !TODO: check my_meta and my_meta_t compared to adx_mlnijk

   call handle_error(istat,'adx_main','gmm_get')

   call tmg_start0 (50, 'ADW_TRAJE')

!!$   V4d_cfl_kind_S = 'm'
   call adx_main_2_pos4( F_nb_iter, 'm'  , &
                         pxm , pym , pzm , &
                         a_su, a_sv, a_sw, &
                         xth , yth , zth , &
                         xcth, ycth, zcth, &
                         xct1, yct1, zct1, &
        adx_lminx, adx_lmaxx, adx_lminy, adx_lmaxy, &
        adx_mlni , adx_mlnj , k0 , adx_lnkm , F_nks)

   call adx_get_ij0n (i0,in,j0,jn)

   if(trim(Adw_thermopos_S).eq."TRAJ")then
!!$      V4d_cfl_kind_S = 't'
      call adx_main_2_pos4(&
           F_nb_iter, 't'        , &
           pxt   , pyt   , pzt   , &
           a_su  , a_sv  , a_sw  , &
           xth_t , yth_t , zth_t , &
           xcth_t, ycth_t, zcth_t, &
           l_xct1, l_yct1, l_zct1, &
           adx_lminx, adx_lmaxx, adx_lminy, adx_lmaxy, &
           adx_mlni , adx_mlnj , k0 , adx_lnkt , F_nks)
   else if(trim(Adw_thermopos_S).eq."INT_Z")then
      call adx_cubicpos(pxt,pyt,pzt,pxm,pym,pzm,adx_mlni,adx_mlnj,k0,adx_lnkm,i0,in,j0,jn,.false.)         
   else if(trim(Adw_thermopos_S).eq."INT_XYZ")then
      call adx_cubicpos(pxt,pyt,pzt,pxm,pym,pzm,adx_mlni,adx_mlnj,k0,adx_lnkm,i0,in,j0,jn,.true.)         
   else
      call handle_error(-1,'adx_main','Error specifying Adw_thermopos_S (TRAJ,INT_Z,INT_XYZ)')
   endif

!$omp parallel
!$omp do
   do j = j0,jn
      do i = i0,in
         pxt(i,j,       1) = pxm(i,j,       1)
         pyt(i,j,       1) = pym(i,j,       1)
         pxt(i,j,adx_lnkt) = pxm(i,j,adx_lnkm)
         pyt(i,j,adx_lnkt) = pym(i,j,adx_lnkm)
      enddo
   enddo
!$omp enddo
!$omp end parallel

   call tmg_stop0 (50)

   if (adw_stats_L) then
      call adx_main_2_pos_stats( &
           'm', &
           a_su  ,a_sv  ,a_sw  , &
           pxm,  pym,  pzm , &
           xth , yth , zth , &
           xcth, ycth, zcth, &
           xct1, yct1, zct1, &
           adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy,F_nks,&
           adx_mlni, adx_mlnj, adx_lnkm,adx_lnkm,i0,in,j0,jn,k0,adx_lnkm)
      if(trim(Adw_thermopos_S).eq."TRAJ")then         
         call adx_main_2_pos_stats(  &
              't', &
              a_su  ,a_sv  ,a_sw  , &
              pxt,    pyt,    pzt, &
              xth_t,  yth_t,  zth_t, &
              xcth_t, ycth_t, zcth_t, &
              l_xct1, l_yct1, l_zct1, &
              adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy,F_nks,&
              adx_mlni, adx_mlnj, adx_lnkm,adx_lnkt,i0,in,j0,jn,k0,adx_lnkt)
      endif
   endif

!  Store TRAJ upstream positions
!  -----------------------------
   if ( v4dstore_L ) call v4d_rwtraj (5,pxm,pym,pzm,pxt,pyt,pzt, &
                                      adx_mlni,adx_mlnj,adx_lnkm,adx_lnkt)
!
!  Store TRAJ RHS before interpolation
!  -----------------------------------
   if ( v4dstore_L ) call v4d_rwtraj (11)

   call tmg_start0 (60, 'ADW_INLAG')

   call adx_main_3_intlag7 ( pxm, pym, pzm, F_fields_list, F_fields_type_L, F_nfields, &
                             IS_MOM_LEVEL, F_doAdwStat_L, adx_mlni,adx_mlnj,k0,adx_lnkm )
   call adx_main_3_intlag7 ( pxt, pyt, pzt, F_fields_list, F_fields_type_L, F_nfields, &
                        .not.IS_MOM_LEVEL, F_doAdwStat_L, adx_mlni,adx_mlnj,k0,adx_lnkt )

   call tmg_stop0 (60)

!  Store TRAJ RHS interpolated
!  ---------------------------
   if ( v4dstore_L ) call v4d_rwtraj (6)

   adw_stats_L = save_stats_L
   call msg(MSG_DEBUG,'adx_main [end]')

   !---------------------------------------------------------------------

   return
end subroutine adx_main7

