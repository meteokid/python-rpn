!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r itf_phy_fillbus_tl - TLM of Fill the slice workspace variable for the physics
!
#include "model_macros_f.h"
!
      subroutine itf_phy_fillbus_tr(F_busdyn,F_busper,F_jdo,F_step,nk)
      implicit none
#include <arch_specific.hf>
!
      integer F_step, F_jdo, nk
      real F_busdyn(*),F_busper(*)
!
!author 
!     Stephane Laroche - January 2002
!
!revision
! v3_00 - Laroche S.            - initial MPI version
! v3_02 - Tanguay M./Laroche S. - do not assume TRAJ HU positive
!                               - contribution of surface pressure
! v3_30 - Tanguay M.            - adapt TL/AD to itf
!                               - Validation for LAM version
! v4_03 - Spacek L.             - Staggered version
! v4_12 - Spacek L.             - GMM version
!
!object
!	Fill the slice trajectory for the physics.
!
      include "v4dg.inc"
#include "glb_ld.cdk"
#include "itf_phy_buses.cdk"
!
!notes
!
      integer i, k, n
      integer pid,soit,lght,stepm1,stepone
      integer index, numtr
      integer kmm,ktm,bmm,btm
      integer utrajm,vtrajm,ttrajm,hutrajm
      integer utrajp,vtrajp,ttrajp,hutrajp,ptrajp
      integer sigm,sigt
!
!     ---------------------------------------------------------------
!
      stepm1=F_step-1;stepone=1
      kmm=-1;ktm=-1;bmm=-1;btm=-1
      utrajm=-1;vtrajm=-1;ttrajm=-1;hutrajm=-1;
      utrajp=-1;vtrajp=-1;ttrajp=-1;hutrajp=-1;ptrajp=-1
      sigm=-1;sigt=-1
!
!     Find indexes in busper
!
      do n=1,p_bper_top
         if (pernm(n)(1:3).eq.'KMM')call getindx2(pernm(n),'PER',kmm,lght,soit)
         if (pernm(n)(1:3).eq.'KTM')call getindx2(pernm(n),'PER',ktm,lght,soit)
         if (pernm(n)(1:3).eq.'BMM')call getindx2(pernm(n),'PER',bmm,lght,soit)
         if (pernm(n)(1:3).eq.'BTM')call getindx2(pernm(n),'PER',btm,lght,soit)
      end do
!
!     Find indexes in busdyn
!
      call getindx2 ('PW_PM:P',  'DYN', pid, lght, soit)

      do n=1,p_bdyn_top
         if (dynnm(n)(1:6).eq.'UTRAJM')                                     &
                            call getindx2(dynnm(n),'DYN',utrajm ,lght,soit)
         if (dynnm(n)(1:6).eq.'VTRAJM')                                     &
                            call getindx2(dynnm(n),'DYN',vtrajm ,lght,soit)
         if (dynnm(n)(1:6).eq.'TTRAJM')                                     &
                            call getindx2(dynnm(n),'DYN',ttrajm ,lght,soit)
         if (dynnm(n)(1:7).eq.'HUTRAJM')                                    &
                            call getindx2(dynnm(n),'DYN',hutrajm,lght,soit)
         if (dynnm(n)(1:6).eq.'UTRAJP')                                     &
                            call getindx2(dynnm(n),'DYN',utrajp ,lght,soit)
         if (dynnm(n)(1:6).eq.'VTRAJP')                                     &
                            call getindx2(dynnm(n),'DYN',vtrajp ,lght,soit)
         if (dynnm(n)(1:6).eq.'TTRAJP')                                     &
                            call getindx2(dynnm(n),'DYN',ttrajp ,lght,soit)
         if (dynnm(n)(1:7).eq.'HUTRAJP')                                    &
                            call getindx2(dynnm(n),'DYN',hutrajp,lght,soit)
         if (dynnm(n)(1:6).eq.'PTRAJP')                                     &
                            call getindx2(dynnm(n),'DYN',ptrajp ,lght,soit)
         if (dynnm(n)(1:7).eq.'PW_PM:P')                                    &
                            call getindx2(dynnm(n),'DYN',sigm   ,lght,soit)
         if (dynnm(n)(1:7).eq.'PW_PT:P')                                    &
                            call getindx2(dynnm(n),'DYN',sigt   ,lght,soit)
      end do
!
!   Trajectory for vertical diffusion
!
      if( V4dg_phy_pbl.eq.2) then
         numtr=22
         index=0;        call v4d_rtrnch                                    &
        (F_busper,kmm,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=nk;       call v4d_rtrnch                                    &
        (F_busper,ktm,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=nk+1;     call v4d_rtrnch                                    &
        (F_busper,bmm,numtr,F_step,index,F_jdo,p_offi,p_ni,1)
         index=nk+2;     call v4d_rtrnch                                    &
        (F_busper,btm,numtr,F_step,index,F_jdo,p_offi,p_ni,1)
      endif
!
!    Trajectory t-
! 
         numtr=21
         index=0;        call v4d_rtrnch                                    &
        (F_busdyn,utrajm ,numtr,stepm1,index,F_jdo,p_offi,p_ni,nk)
         index=nk;       call v4d_rtrnch                                    &
        (F_busdyn,vtrajm ,numtr,stepm1,index,F_jdo,p_offi,p_ni,nk)
         index=2*nk;     call v4d_rtrnch                                    &
        (F_busdyn,ttrajm ,numtr,stepm1,index,F_jdo,p_offi,p_ni,nk)
         index=3*nk;     call v4d_rtrnch                                    &
        (F_busdyn,hutrajm,numtr,stepm1,index,F_jdo,p_offi,p_ni,nk)
!
!   Trajectory t+
!
         index=0;        call v4d_rtrnch                                    &
        (F_busdyn,utrajp ,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=nk;       call v4d_rtrnch                                    &
        (F_busdyn,vtrajp ,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=2*nk;     call v4d_rtrnch                                    &
        (F_busdyn,ttrajp ,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=3*nk;     call v4d_rtrnch                                    &
        (F_busdyn,hutrajp,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=4*nk;     call v4d_rtrnch                                    &
        (F_busdyn,ptrajp ,numtr,F_step,index,F_jdo,p_offi,p_ni,1)
!
!   Sigmas
!
         numtr=20
         index=0;        call v4d_rtrnch                                    &
        (F_busdyn,sigm ,numtr,stepone,index,F_jdo,p_offi,p_ni,nk-1)
         index=nk;       call v4d_rtrnch                                    &
        (F_busdyn,sigt ,numtr,stepone,index,F_jdo,p_offi,p_ni,nk)
!
!     ---------------------------------------------------------------
!
      return
      end
