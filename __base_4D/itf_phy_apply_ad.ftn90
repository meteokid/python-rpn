!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r itf_phy_apply - apply tendencies to dynamical variables
!
#include "model_macros_f.h"
!
      subroutine itf_phy_apply_ad ( F_apply_L )
      use nest_blending_ad, only: nest_blend_ad
      implicit none
#include <arch_specific.hf>
!
      logical,intent(IN) :: F_apply_L
  !
  !author
  !     Lubos Spacek    - Nov 2010 
  !
  !revision
  ! v4_20 - Spacek, L.       - Initial revision
  !
  !Object
#include "gmm.hf"
#include "glb_ld.cdk"
#include "cstv.cdk"
#include "nest.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "geomg.cdk"
#include "lam.cdk"
#include "vt1.cdk"
#include "vtx.cdk"
#include "p_geof.cdk"
#include "pw.cdk"
#include "itf_phy_buses.cdk"
#include "lctl.cdk"
#include "out3.cdk"

      logical nest_it, flag_u, flag_v
      integer i, j, k, n, err, cnt, UU_indx, VV_indx, km1
      integer HU_indx, TT_indx, gmmstat
      real wk2(LDIST_SHAPE,p_nk),con(YDIST_SHAPE), &
           tdu(LDIST_SHAPE,p_nk),tdv(LDIST_SHAPE,p_nk)
      real, pointer, dimension(:,:,:) :: hu
      type(gmm_metadata) :: meta3d
!     __________________________________________________________________
!
      flag_u  = .False. ; flag_v = .false.
      wk2     = 0.
!
      nest_it = ( Lam_0ptend_L .and. G_lam .and. &
                ((Lam_blend_Hx.gt.0).or.(Lam_blend_Hy.gt.0)) )
!
      con(:)  = cos(geomg_y_8(:)) / Dcst_rayt_8
!
      cnt     = 0
      UU_indx = 0; VV_indx = 0; HU_indx = 0; TT_indx = 0

      do n = 1,p_bvol_top

         if (volnm(n)(1:5) .eq. 'PHYTD') then
            cnt = cnt + 1
            if  (volnm(n)(7:)  .eq. 'UU') UU_indx=cnt
            if  (volnm(n)(7:)  .eq. 'VV') VV_indx=cnt
            if  (volnm(n)(7:)  .eq. 'HU') HU_indx=cnt
            if  (volnm(n)(7:)  .eq. 'TT') TT_indx=cnt
         endif
      enddo


      gmmstat = gmm_get(gmmk_tt1_s,tt1     ,meta3d)
      call tt2virt_ad (tt1, .true., 'P')

      cnt = HU_indx
      nullify(hu)
      gmmstat = gmm_get('TR/HU:P',hu,meta3d)
      do k=1,p_nk
         phy_tend(:,:,k,cnt) = phy_tend(:,:,k,cnt) + Cstv_dt_8*hu(:,:,k)
      end do
      if ( nest_it ) call nest_blend_ad (phy_tend(:,:,:,cnt),wk2,LDIST_DIM,1,p_nk,'M')

      cnt = TT_indx
      gmmstat = gmm_get('PW_TT:P',pw_tt_plus,meta3d)
      do k= 1, p_nk
         phy_tend(:,:,k,cnt) = phy_tend(:,:,k,cnt) + Cstv_dt_8*pw_tt_plus(:,:,k)
      end do
      if ( nest_it ) call nest_blend_ad (phy_tend(:,:,:,cnt),wk2,LDIST_DIM,1,p_nk,'M')

!
      gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
      gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
      gmmstat = gmm_get('PW_UU:P',pw_uu_plus,meta3d)
      gmmstat = gmm_get('PW_VV:P',pw_vv_plus,meta3d)

      tdu = 0. ; tdv = 0.

      do k=l_nk+1,1,-1
         tdu(1:l_niu,1:l_nj ,k+1) = tdu(1:l_niu,1:l_nj ,k+1) + Cstv_dt_8*ut1(1:l_niu,1:l_nj ,k)
         tdv(1:l_ni ,1:l_njv,k+1) = tdv(1:l_ni ,1:l_njv,k+1) + Cstv_dt_8*vt1(1:l_ni ,1:l_njv,k)
      end do

      if ( nest_it ) then
         call nest_blend_ad (tdu,wk2,LDIST_DIM,1,p_nk,'U')
         call nest_blend_ad (tdv,wk2,LDIST_DIM,1,p_nk,'V')
      endif

      call itf_phy_uvgridscal_ad (tdu, tdv, LDIST_DIM, p_nk, .false. )

      do k= 1, p_nk
      do j= 1, l_nj
      do i= 1, l_ni
         phy_tend(i,j,k,UU_indx) = phy_tend(i,j,k,UU_indx) + Cstv_dt_8*pw_uu_plus(i,j,k)
         phy_tend(i,j,k,VV_indx) = phy_tend(i,j,k,VV_indx) + Cstv_dt_8*pw_vv_plus(i,j,k)
      end do
      end do
      end do

      if ( nest_it ) then
         call blend_pntr_ad (phy_tend(l_minx,l_miny,1,UU_indx),wk2,LDIST_DIM,1,p_nk,'M')
         call blend_pntr_ad (phy_tend(l_minx,l_miny,1,VV_indx),wk2,LDIST_DIM,1,p_nk,'M')
      endif

      do k= 1, p_nk
      do j= 1, l_nj
         phy_tend(1:l_ni,j,k,UU_indx) = tdu(1:l_ni,j,k)*con(j)
         phy_tend(1:l_ni,j,k,VV_indx) = tdv(1:l_ni,j,k)*con(j)
      end do
      end do

!     __________________________________________________________________
!
    end subroutine itf_phy_apply_ad
