!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r v4d_rwtraj_cvn - For Conversion from 3D-Var to GEM variables: Read (Write) from (on) TRAJ WA file at each time step 
!
#include "model_macros_f.h"
!
      subroutine v4d_rwtraj_cvn (numtr)
!
      use v4d_prof, only: Pr_doobs
!
      implicit none
!
      integer numtr
!
!author M.Tanguay
!
!revision
! v4_12 - Tanguay M.        - initial MPI version
! v4_12 - Tanguay M.        - Reset Communication 3D_Var-(TL/AD)
! v4_XX - Morneau/Tanguay   - Reset HU clipping based on HR (S.Laroche) 
!
!object
!
!
!arguments
! Name         I/O     Description
!-------------------------------------------------------------------------
! numtr        I       Indicates which portion of TRAJECTORY to Read-Write 
!-------------------------------------------------------------------------
!
!implicits
#include "gmm.hf"
#include "glb_ld.cdk"
#include "lun.cdk"
#include "lctl.cdk"
#include "vt1.cdk"
#include "vt1_m.cdk"
#include "schm.cdk"
#include "tr3d.cdk"
#include "step.cdk"
#include "ver.cdk"
      include "v4dg.inc"
!
!     --------------------------------------------------
      type(gmm_metadata) :: meta2d,meta3d
      integer :: gmmstat
      integer istep, iadd 
!
      logical plpr_L,time0_L,time_L
!
      character*16 tr_name
      real, pointer, dimension(:,:,:) :: hut1,hut1_m
!
      integer i,j,k
      logical done_once_L,hu_threshold_L
      save done_once_L
      data done_once_L /.false./
!
!     Work arrays
!     -----------
      real work(l_ni*l_nj*(l_nk+2)),hut1work(LDIST_SHAPE,(l_nk+2))
      real hrwork(l_ni,(l_nk+2)),huwork(l_ni,(l_nk+2)),txwork(l_ni,(l_nk+2))
      real lpwork(l_ni,(l_nk+2)),pxwork(l_nk+2)
      real threshold
!     --------------------------------------------------
!
      if (.NOT.(V4dg_conf.ne.0.and.V4dg_4dvar_L)) return
!
      if (numtr.ne.40.and.numtr.ne.41) call handle_error(-1,'v4d_rwtraj_cvn','RWTRAJ_CVN numtr not DONE')
!
!     Specify if we need to impose a threshold to hu
!     ----------------------------------------------
      hu_threshold_L = .true.
!CCC  threshold = 0.02
      threshold = 0.05
!
      if (.not.done_once_L.and.Lun_out.gt.0) write(Lun_out,*) 'VALUE OF THRESHOLD =',threshold
      done_once_L = .true.
!
!     Verify if INITIAL TIME requested
!     --------------------------------
      time0_L = Lctl_step.eq.0
!
!     Verify if .NOT.INITIAL time requested
!     -------------------------------------
      time_L = Lctl_step.ne.0.and.Pr_doobs(Lctl_step).gt.0
!
      if (.NOT.(time0_L.or.time_L)) return
!
      if (Lun_debug_L.and.Lun_out.gt.0) write(Lun_out,*) 'CALL V4D_RWTRAJ_CVN with NUMTR =',numtr
!
!     Flag to trace storing and retrieving of trajectory
!     --------------------------------------------------
      plpr_L = .false.
      plpr_L = plpr_L.and.Lun_out.gt.0 
!
      istep = Lctl_step 
!
      if (numtr.eq.40.or.numtr.eq.41) then
!
!        ----------------
!        Read TRAJ Fields 
!        ----------------
         if (V4dg_rwtr.eq.0) then
!
!        Recover starting address 
!        ------------------------
         if (V4dg_ad_L) iadd = V4dg_addtab_ad(numtr,istep,1,1) 
         if (V4dg_tl_L) iadd = V4dg_addtab_tl(numtr,istep,1,1) 
!
         gmmstat = gmm_get(gmmk_tt1_m_s,tt1_m,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'v4d_rwtraj_cvn ERROR at gmm_get(tt1_m)'
         gmmstat = gmm_get(gmmk_st1_m_s,st1_m,meta2d)
         if (GMM_IS_ERROR(gmmstat)) print *,'v4d_rwtraj_cvn ERROR at gmm_get(st1_m)'
!
!        Load TRAJ humidity field
!        ------------------------
         tr_name = 'TRM/HU:P'
         gmmstat = gmm_get(tr_name,hut1_m,meta3d)

!        TANGENT LINEAR MODEL
!        --------------------
         if (V4dg_tl_L) then
!
            call v4d_rwfld (tt1_m,LDIST_DIM,l_nk+2, &
                            iadd,plpr_L,'TT1_M   ',V4dg_ad_L,0,-1)
!
            call v4d_rwfld (hut1_m,LDIST_DIM,l_nk+2, &
                            iadd,plpr_L,'HUT1_M  ',V4dg_ad_L,0,-1)
!
            call v4d_rwfld (st1_m,LDIST_DIM,1, &
                            iadd,plpr_L,'ST1_M   ',V4dg_ad_L,0,-1)
!
         endif
!
!        ADJOINT MODEL
!        -------------
         if (V4dg_ad_L) then
!
            call v4d_rwfld (st1_m,LDIST_DIM,1, &
                            iadd,plpr_L,'ST1_M   ',V4dg_ad_L, &
                            l_ni*l_nj*(l_nk+2)    ,-1)
!
            call v4d_rwfld (hut1_m,LDIST_DIM,l_nk+2, &
                            iadd,plpr_L,'HUT1_M  ',V4dg_ad_L, &
                            l_ni*l_nj*(l_nk+2)    ,-1)
!
            call v4d_rwfld (tt1_m,LDIST_DIM,l_nk+2, &
                            iadd,plpr_L,'TT1_M   ',V4dg_ad_L, &
                            l_ni*l_nj             ,-1)
!
         endif
!
!        -----------------
!        Write TRAJ Fields 
!        -----------------
         elseif(V4dg_rwtr.eq.1) then
!
         gmmstat = gmm_get(gmmk_tt1_s,tt1,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'v4d_rwtraj_cvn ERROR at gmm_get(tt1)'
         gmmstat = gmm_get(gmmk_st1_s,st1,meta2d)
         if (GMM_IS_ERROR(gmmstat)) print *,'v4d_rwtraj_cvn ERROR at gmm_get(st1)'
!
!        Load humidity field
!        -------------------
         tr_name = 'TR/HU:P'
         gmmstat = gmm_get(tr_name,hut1,meta3d)
!
         do k=1,l_nk+2
            do j=l_miny,l_maxy
               do i=l_minx,l_maxx
!!!               hut1work(i,j,k) = MAX(2.5e-6,hut1(i,j,k))
                  hut1work(i,j,k) = hut1(i,j,k)
               enddo
            enddo
         enddo
!
!        Check if the relative humidity is less then threshold
!        in percent (threshold*100)
!        ------------------------------------------------------
         if (hu_threshold_L) then

             do j=1,l_nj

                do k=1,l_nk+2
                   do i=1,l_ni
                      hrwork(i,k) = threshold*(((float(k)/(l_nk+2)))**2)
                      txwork(i,k) = tt1(i,j,k) 
                      lpwork(i,k) = exp( Ver_z_8%t(k) + Ver_b_8%t(k)*st1(i,j) )  
                   enddo
                enddo

                CALL MHRAHU (huwork,hrwork,txwork,pxwork,lpwork, &
                             3,.false.,.true.,l_ni,l_nk+2,l_ni)

                do k=1,l_nk+2
                   do i=1,l_ni
                      huwork(i,k) = MAX(2.5e-6,huwork(i,k))
                      if (hut1(i,j,k).lt.huwork(i,k)) hut1work(i,j,k) = huwork(i,k)
                   enddo
                enddo

             enddo

         endif
!
!        Store starting TLM address
!        --------------------------
         V4dg_addtab_tl(numtr,istep,1,1) = V4dg_addtr 
         iadd                            = V4dg_addtr 
!
            call v4d_rwfld (tt1,LDIST_DIM,l_nk+2, &
                            iadd,plpr_L,'TT1     ',V4dg_ad_L,0,1)
!
!!!         call v4d_rwfld (hut1    ,LDIST_DIM,l_nk+2, &
            call v4d_rwfld (hut1work,LDIST_DIM,l_nk+2, &
                            iadd,plpr_L,'HUT1    ',V4dg_ad_L,0,1)
!
            call v4d_rwfld (st1,LDIST_DIM,1, &
                            iadd,plpr_L,'ST1     ',V4dg_ad_L,0,1)
!
!        Store starting ADJOINT address 
!        ------------------------------
         V4dg_addtab_ad(numtr,istep,1,1) = iadd - l_ni*l_nj
         V4dg_addtr                      = iadd
!
         endif
!
      endif

      return
      end
