!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r  bacp_2_ad - ADJ of bacp_2_tl 
!
#include "model_macros_f.h"
!
      subroutine bacp_2_ad ( &
                          F_itr, F_itnlh, F_p , F_fis, &
                          F_u  , F_v    , F_w , F_t  , &
                          F_s  , F_zd   , F_q , F_fip, F_nest_q, &
                          F_ru , F_rv   , F_rt, F_rw , F_rf    , F_rb, &
                          F_nu , F_nv   , F_nt, F_nw , F_nf    , F_nb, &
!
                          F_t_m,F_s_m,F_fip_m, & 
!
                          DIST_DIM, Nk )
!
      implicit none
#include <arch_specific.hf>
!
      integer  F_itr, F_itnlh, DIST_DIM, Nk
!
      real     F_p     (DIST_SHAPE,0:Nk+1) ,  F_fis(DIST_SHAPE)       , &
               F_u     (DIST_SHAPE,  Nk)   ,  F_v  (DIST_SHAPE,  Nk)  , &
               F_w     (DIST_SHAPE,  Nk+1) ,  F_t  (DIST_SHAPE,  Nk+1), &
               F_s     (DIST_SHAPE)        ,  F_zd (DIST_SHAPE,  Nk+1), &
               F_q     (DIST_SHAPE,0:Nk+1) ,  F_fip(DIST_SHAPE,0:Nk+1), &
               F_nest_q(DIST_SHAPE,0:Nk+1) , &
               F_ru    (DIST_SHAPE,  Nk)   ,  F_rv (DIST_SHAPE,  Nk)  , &
               F_rt    (DIST_SHAPE,  Nk+1) ,  F_rw (DIST_SHAPE,  Nk+1), &
               F_rf    (DIST_SHAPE,  Nk+1) ,  F_rb (DIST_SHAPE)       , &
               F_nu    (DIST_SHAPE,  Nk)   ,  F_nv (DIST_SHAPE,  Nk)  , &
               F_nt    (DIST_SHAPE,  Nk+1) ,  F_nw (DIST_SHAPE,  Nk+1), &
               F_nf    (DIST_SHAPE,  Nk+1) ,  F_nb (DIST_SHAPE)
!
      real     F_t_m  (DIST_SHAPE,  Nk+1)  ,  F_s_m  (DIST_SHAPE)     , & 
               F_fip_m(DIST_SHAPE,0:Nk+1)
!
!author M.Tanguay
!
!revision
! v2_10 - Tanguay M.        - initial MPI version
! v2_30 - Edouard S.        - remove pi' at the top (F_pptt0)
! v2_31 - Tanguay M.        - adapt for vertical hybrid coordinate and LAM version 
!                           - adapt for tracers in tr3d  
! v3_00 - Tanguay M.        - adapt to restructured bacp_2 
! v3_03 - Tanguay M.        - Adjoint Lam and NoHyd configuration 
! v3_11 - Tanguay M.        - AIXport+Opti+OpenMP for TLM-ADJ
! v3_21 - Tanguay M.        - Revision Openmp
! v3_30 - Tanguay M.        - Enforce similarities between NL and TRAJ TL  
! v4_04 - Tanguay M.        - Staggered version TL/AD 
! v4_12 - Tanguay M.        - OPENMP TL/AD
! v4_12 - Tanguay M.        - TL/AD Open top
! v4_40 - Tanguay M.        - Revision TL/AD
!
!object
!     see id section 
!
!arguments
!     see documentation of appropriate comdecks 
!
!implicits
#include "glb_ld.cdk"
#include "lam.cdk"
!
      integer i0, j0, in, jn, k0
!
      i0 = 1+pil_w
      in = l_ni-pil_e
      j0 = 1+pil_s
      jn = l_nj-pil_n
      k0 = 1+Lam_gbpil_T
!
      call  bacp_2_2_ad ( &
                       F_itr, F_itnlh, F_p , F_fis, &
                       F_u  , F_v    , F_w , F_t  , &
                       F_s  , F_zd   , F_q , F_fip, F_nest_q, &
                       F_ru , F_rv   , F_rt, F_rw , F_rf    , F_rb, &
                       F_nu , F_nv   , F_nt, F_nw , F_nf    , F_nb, &
!
                       F_t_m,F_s_m,F_fip_m, & 
!
                       DIST_DIM, Nk, i0, j0, k0, in, jn )
!
      return
      end
!
      subroutine bacp_2_2_ad ( &
                            F_itr, F_itnlh, F_p , F_fis, &
                            F_u  , F_v    , F_w , F_t  , &
                            F_s  , F_zd   , F_q , F_fip, F_nest_q, &
                            F_ru , F_rv   , F_rt, F_rw , F_rf    , F_rb, &
                            F_nu , F_nv   , F_nt, F_nw , F_nf    , F_nb, &
!
                            F_t_m,F_s_m,F_fip_m, & 
!
                            DIST_DIM, Nk, i0, j0, k0, in, jn )
!
      implicit none
#include <arch_specific.hf>
!
      integer  F_itr, F_itnlh, DIST_DIM, Nk , i0, j0, k0, in, jn
      real     F_p     (DIST_SHAPE,0:Nk+1) ,  F_fis(DIST_SHAPE)       , &
               F_u     (DIST_SHAPE,  Nk)   ,  F_v  (DIST_SHAPE,  Nk)  , &
               F_w     (DIST_SHAPE,  Nk+1) ,  F_t  (DIST_SHAPE,  Nk+1), &
               F_s     (DIST_SHAPE)        ,  F_zd (DIST_SHAPE,  Nk+1), &
               F_q     (DIST_SHAPE,0:Nk+1) ,  F_fip(DIST_SHAPE,0:Nk+1), &
               F_nest_q(DIST_SHAPE,0:Nk+1) , &
               F_ru    (DIST_SHAPE,  Nk)   ,  F_rv (DIST_SHAPE,  Nk)  , &
               F_rt    (DIST_SHAPE,  Nk+1) ,  F_rw (DIST_SHAPE,  Nk+1), &
               F_rf    (DIST_SHAPE,  Nk+1) ,  F_rb (DIST_SHAPE)       , &
               F_nu    (DIST_SHAPE,  Nk)   ,  F_nv (DIST_SHAPE,  Nk)  , &
               F_nt    (DIST_SHAPE,  Nk+1) ,  F_nw (DIST_SHAPE,  Nk+1), &
               F_nf    (DIST_SHAPE,  Nk+1) ,  F_nb (DIST_SHAPE)
!
      real     F_t_m  (DIST_SHAPE,  Nk+1)  , F_s_m  (DIST_SHAPE)      , & 
               F_fip_m(DIST_SHAPE,0:Nk+1)
!
!implicits
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "orh.cdk"
#include "cori.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "lun.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
#include "ptopo.cdk"
!
      integer i, j, k, nij, kminzd
      real*8  xxx_8, yyy_8, zzz_8, p1_8, p2_8, p3_8, p4_8, xxx_m_8
!
      real*8  ONE_8, HALF_8, ZERO_8
      parameter(ONE_8=1.d0, HALF_8=.5d0, ZERO_8=0.0)
!
      real*8, dimension(i0:in,j0:jn):: xtmp_8, ytmp_8
!
      real*8, dimension(i0:in,j0:jn,l_nk+1):: xtmpk_m_8,ytmpk_m_8
!
      real*8 Pbar_8(DIST_SHAPE,Nk+1)
!
      logical finbac_L
!
!     __________________________________________________________________
!
      if (.not.Cori_cornl_L) call handle_error(-1,'bacp_2_ad','NOT Cori_cornl_L not done')
      if (   Schm_opentop_L) call handle_error(-1,'bacp_2_ad','  Schm_opentop_L not done')
      if (.not.Schm_hydro_L) call handle_error(-1,'bacp_2_ad','NOT Schm_hydro_L not done')
!
      finbac_L=.false.
      if ( .not. (F_itr .lt. F_itnlh) )finbac_L=.true.
!
      nij = (in - i0 + 1)*(jn - j0 + 1)
!
!     ZERO adjoint work fields  
!     ------------------------
      xtmp_8 = 0.
      ytmp_8 = 0.
      Pbar_8 = 0.
!
      xxx_8  = 0.
!
      p1_8 = Cstv_tau_8*Cstv_RTstr_8/Dcst_grav_8
      p2_8 = ONE_8/Cstv_RTstr_8
      p3_8 = ONE_8/Dcst_grav_8
      p4_8 = ONE_8/Dcst_rayt_8**2

!$omp parallel private(xxx_8,yyy_8,zzz_8,xxx_m_8, &
!$omp          xtmp_8,ytmp_8,kminzd) shared(Pbar_8,ytmpk_m_8,xtmpk_m_8)

!     ADJ of
!     Compute T
!     ~~~~~~~~~
!
      if(.not.Schm_autobar_L) then            ! safer for autobar
!
      if(Schm_opentop_L) then
!$omp do 
         do j=j0,jn
            do k= 1,k0-1
            yyy_8=Cstv_RTstr_8*Ver_dz_8%t(k)/Cstv_Tstr_8
            do i=i0,in
!
!              TRAJECTORY
!              ----------
               xxx_m_8=ONE_8+Ver_dbdz_8%t(k)*F_s_m(i,j)
!
               xxx_8         = yyy_8*(F_t_m(i,j,k)*F_fip(i,j,k-1))     
               F_t  (i,j,k)  = yyy_8*(             F_fip(i,j,k-1)*xxx_m_8) + F_t(i,j,k) 
               F_fip(i,j,k)  =                     F_fip(i,j,k-1)          + F_fip(i,j,k)
               F_fip(i,j,k-1)= ZERO_8
!
               F_s(i,j) = Ver_dbdz_8%t(k)*xxx_8 + F_s(i,j)
!
            end do
            end do
         end do
!$omp end do 
      endif
!
!     ADJ 
!     ---
!$omp do 
      do k=l_nk+1,k0,-1
!
!        TRAJECTORY
!        ----------
         do j= j0, jn
         do i= i0, in
!
            xtmpk_m_8(i,j,k)=ONE_8+Ver_dbdz_8%t(k)*F_s_m(i,j)
!
         enddo
         enddo
!
         call vrec ( ytmpk_m_8(i0,j0,k), xtmpk_m_8(i0,j0,k), nij )

      end do
!$omp end do 

!$omp do 
      do j= j0, jn

         do k=l_nk+1,k0,-1

         xxx_8=p2_8*Ver_idz_8%t(k)
!
         do i= i0, in
!
            ytmp_8(i,j)    = Cstv_Tstr_8*F_t(i,j,k) &
                 *(ONE_8-xxx_8*(F_fip_m(i,j,k)-F_fip_m(i,j,k-1))) 
            F_fip (i,j,k)  = Cstv_Tstr_8*ytmpk_m_8(i,j,k) &
                 *(     -xxx_8*( F_t(i,j,k)) )                    + F_fip (i,j,k)
            F_fip (i,j,k-1)= Cstv_Tstr_8*ytmpk_m_8(i,j,k) &
                 *(     -xxx_8*(-F_t(i,j,k)) )                    + F_fip (i,j,k-1)
            F_t   (i,j,k)  = ZERO_8  
!
            xtmp_8(i,j) = -ytmp_8(i,j)/xtmpk_m_8(i,j,k)**2 
            ytmp_8(i,j) = ZERO_8
!
            F_s   (i,j) = Ver_dbdz_8%t(k)*xtmp_8(i,j) + F_s(i,j)
            xtmp_8(i,j) = ZERO_8
!
         enddo
         enddo
!
      end do
!$omp end do 
!
      endif
!
!     ZERO adjoint work fields  
!     ------------------------
      xtmp_8 = 0.
!
!     ADJ of
!     Compute FI'
!     ~~~~~~~~~~~

!$omp do 
      do j= j0, jn
      do i= i0, in
!
         F_fip(i,j,l_nk+1)=0.0
!
      enddo
      enddo
!$omp enddo 
!
      if (.not. Schm_hydro_L) then
!$omp do 
         do k=l_nk,k0-1,-1
            do j= j0, jn
            do i= i0, in
!
               F_q(i,j,k) = -Cstv_RTstr_8*F_fip(i,j,k) + F_q(i,j,k)
!
            enddo
            enddo
         enddo
!$omp enddo 
      endif
!
!$omp do 
      do j= j0, jn

         do k=l_nk,k0-1,-1
!
         if(k.eq.0) then
            xxx_8=0.d0
         else
            xxx_8=Cstv_RTstr_8*Ver_b_8%m(k)
         endif
!
         do i= i0, in
!
            F_p  (i,j,k) =        F_fip(i,j,k) + F_p(i,j,k)
            F_s  (i,j)   = -xxx_8*F_fip(i,j,k) + F_s(i,j)
            F_fip(i,j,k) = ZERO_8
!
         enddo

         enddo
!
      enddo
!$omp enddo 

!     ADJ of
!     Compute zd
!     ~~~~~~~~~~
!
      if(.not.Schm_autobar_L) then  ! safer for autobar
!
!        ADJ of
!        N.B.  Top Boundary condition:
!                 Closed Top:  F_zd(i,j,1) = 0
!                   Open Top:  F_zd(i,j,k0) is computed
!
         kminzd=2
         if(Schm_opentop_L) kminzd=k0
!
         if (.not. Schm_hydro_L) then
!$omp do 
            do k=l_nk,kminzd,-1
!
               do j= j0, jn
               do i= i0, in
                  F_q(i,j,k)  = -Cstv_invT_8*(Ver_wp_8%t(k)*F_zd(i,j,k)) + F_q(i,j,k)
                  F_q(i,j,k-1)= -Cstv_invT_8*(Ver_wm_8%t(k)*F_zd(i,j,k)) + F_q(i,j,k-1)
               enddo
               enddo
!
            enddo
!$omp enddo 
         endif
!
!$omp do 
         do j= j0, jn
!
            do k=l_nk,kminzd,-1

            xxx_8=Ver_gokt2RT_8*Ver_idz_8%t(k)
            yyy_8=Ver_gokt2RT_8*Ver_epsilon_8
            zzz_8=Ver_b_8%t(k)*Cstv_invT_8

            if(Schm_autobar_L) zzz_8=0.d0
!
            do i= i0, in
!
               F_rt  (i,j,k)  =-Cstv_tau_8*(          F_zd(i,j,k) ) + F_rt  (i,j,k)
               F_nt  (i,j,k)  =-Cstv_tau_8*(         -F_zd(i,j,k) ) + F_nt  (i,j,k) 
               F_p   (i,j,k)  =-Cstv_tau_8*(  xxx_8*( F_zd(i,j,k))) + F_p   (i,j,k)
               F_p   (i,j,k-1)=-Cstv_tau_8*(  xxx_8*(-F_zd(i,j,k))) + F_p   (i,j,k-1)
               Pbar_8(i,j,k)  =-Cstv_tau_8*(- yyy_8*  F_zd(i,j,k) ) + Pbar_8(i,j,k)
               F_s   (i,j)    =             - zzz_8*  F_zd(i,j,k)   + F_s   (i,j)
               F_zd  (i,j,k)  =ZERO_8               
!
            enddo

            enddo
!
         enddo
!$omp enddo 
!
      endif
!
!     ADJ of
!     Compute s
!     ~~~~~~~~~
!
      if (.not. Schm_hydro_L) then
!
!$omp do 
         do j= j0, jn
         do i= i0, in
            F_q(i,j,l_nk+1) = - Ver_wp_8%t(l_nk+1)*F_s(i,j) + F_q(i,j,l_nk+1)
            F_q(i,j,l_nk)   = - Ver_wm_8%t(l_nk+1)*F_s(i,j) + F_q(i,j,l_nk)  
         end do
         end do
!$omp end do 
!
      endif
!
!$omp do 
      do j= j0, jn
      do i= i0, in
!
         F_p(i,j,l_nk+1) = p2_8*(Ver_wp_8%t(l_nk+1)*F_s(i,j)) + F_p(i,j,l_nk+1)
         F_p(i,j,l_nk)   = p2_8*(Ver_wm_8%t(l_nk+1)*F_s(i,j)) + F_p(i,j,l_nk) 
         F_s(i,j)        = ZERO_8
!
      end do
      end do
!$omp end do 
!
!     ADJ of
!     Compute q & w
!     ~~~~~~~~~~~~~
!
      if(.not.Schm_hydro_L) then
!
!        ADJ of
!        Compute q
!        ~~~~~~~~~
!
!        N.B.  Top Boundary condition:
!                 Closed Top:  F_q(i,j,0) = 0
!                   Open Top:  F_q(i,j,k0-1) is externally specified
!
!        Note : we cannot use omp on loop k
!               due to vertical dependance F_q(i,j,k-1)
!
!$omp do 
         do k=l_nk+1,k0,-1
!
            xxx_8 = p3_8*Ver_dz_8%t(k)
!
            do j= j0, jn
            do i= i0, in
!
               F_q (i,j,k-1) =                            F_q(i,j,k)   + F_q (i,j,k-1)
               F_rw(i,j,k)   = - xxx_8 *(                 F_q(i,j,k) ) + F_rw(i,j,k)
               F_nw(i,j,k)   = - xxx_8 *(               - F_q(i,j,k) ) + F_nw(i,j,k) 
               F_w (i,j,k)   = - xxx_8 *( - Cstv_invT_8 * F_q(i,j,k) ) + F_w (i,j,k)
               F_q (i,j,k)   = ZERO_8
!
            end do
            end do
!
         end do
!$omp end do 
!
         if (Schm_opentop_L) then
!$omp do 
            do j= j0, jn
            do i= i0, in
!
               F_nest_q(i,j,k0-1) = F_q(i,j,k0-1) + F_nest_q(i,j,k0-1)
               F_q     (i,j,k0-1) = ZERO_8
!
            end do
            end do
!$omp end do 
         endif
!
       endif

!     ADJ of
!     Compute w
!     ~~~~~~~~~
!
!$omp do 
         do j= j0, jn
         do k=l_nk+1,k0,-1
         do i= i0, in
!
           F_rf  (i,j,k)   = p1_8 * (   F_w(i,j,k) )                                        +  F_rf  (i,j,k)
           F_nf  (i,j,k)   = p1_8 * ( - F_w(i,j,k) )                                        +  F_nf  (i,j,k) 
           F_p   (i,j,k)   = p1_8 * ( Ver_gokt2RT_8 * ( (   F_w(i,j,k) )*Ver_idz_8%t(k) ) ) +  F_p   (i,j,k) 
           F_p   (i,j,k-1) = p1_8 * ( Ver_gokt2RT_8 * ( ( - F_w(i,j,k) )*Ver_idz_8%t(k) ) ) +  F_p   (i,j,k-1)
           Pbar_8(i,j,k)   = p1_8 * ( Ver_gokt2RT_8 * (   Dcst_cappa_8  *F_w(i,j,k)     ) ) +  Pbar_8(i,j,k)
           F_w   (i,j,k)   = ZERO_8
!
           F_p   (i,j,k)   = Ver_wp_8%t(k)*Pbar_8(i,j,k) + F_p(i,j,k)
           F_p   (i,j,k-1) = Ver_wm_8%t(k)*Pbar_8(i,j,k) + F_p(i,j,k-1)
           Pbar_8(i,j,k)   = ZERO_8
!
         end do
         end do
         end do
!$omp end do 

!     ADJ of
!     Compute U & V
!     ~~~~~~~~~~~~~
!
      if (Cori_cornl_L .or. (finbac_L.and..not.Cori_cornl_L)) then
!
!$omp do 
         do k=l_nk,k0,-1
!
            do j= l_njv-pil_n,j0,-1
            do i= i0,in
!
               F_rv (i,j,  k) = Cstv_tau_8*(          F_v(i,j,k) ) + F_rv(i,j,  k)
               F_nv (i,j,  k) = Cstv_tau_8*(        - F_v(i,j,k) ) + F_nv(i,j,  k) 
               F_p  (i,j+1,k) = Cstv_tau_8*(-p4_8*(   F_v(i,j,k) ) * Geomg_invDYv_8(j) ) + F_p (i,j+1,k) 
               F_p  (i,j,  k) = Cstv_tau_8*(-p4_8*( - F_v(i,j,k) ) * Geomg_invDYv_8(j) ) + F_p (i,j,  k)
               F_v  (i,j,  k) = ZERO_8
!
            end do
            end do
!
            do j= j0,jn
            do i= l_niu-pil_e,i0,-1
!
               F_ru (i,  j,k) = Cstv_tau_8*(          F_u(i,j,k) ) + F_ru(i,j,k) 
               F_nu (i,  j,k) = Cstv_tau_8*(        - F_u(i,j,k) ) + F_nu(i,j,k)
               F_p  (i+1,j,k) = Cstv_tau_8*(-p4_8*(   F_u(i,j,k) ) * Geomg_invDXu_8(i) ) + F_p(i+1,j,k)
               F_p  (i,  j,k) = Cstv_tau_8*(-p4_8*( - F_u(i,j,k) ) * Geomg_invDXu_8(i) ) + F_p(i,  j,k) 
               F_u  (i,  j,k) = ZERO_8
!
            end do
            end do
!
         enddo
!$omp enddo 
!
      endif

!$omp single 

      call rpn_comm_adj_halo(F_p,LDIST_DIM,l_ni,l_nj,G_nk+2, &
           G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
!
!     Zero F_p halo
!     --------------
      call v4d_zerohalo ( F_p,l_ni,l_nj,LDIST_DIM, G_nk+2)

!$omp end single 
!
!     ADJ of
!     Compute P at top and bottom
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!$omp do 
      do j= j0, jn
         do i= i0, in
!
            F_p (i,j,l_nk)   =   Ver_alfas_8 *   F_p(i,j,l_nk+1)  + F_p (i,j,l_nk) 
            F_rt(i,j,l_nk+1) = - Ver_css_8   *(  F_p(i,j,l_nk+1)) + F_rt(i,j,l_nk+1)
            F_nt(i,j,l_nk+1) = - Ver_css_8   *(- F_p(i,j,l_nk+1)) + F_nt(i,j,l_nk+1)
            F_p (i,j,l_nk+1) = ZERO_8
!
            F_p (i,j,k0)    = Ver_alfat_8 *  F_p(i,j,k0-1)  + F_p (i,j,k0) 
            F_rb(i,j)       = Ver_cst_8   *( F_p(i,j,k0-1)) + F_rb(i,j)
            F_nb(i,j)       = Ver_cst_8   *(-F_p(i,j,k0-1)) + F_nb(i,j)
            F_p (i,j,k0-1) = ZERO_8
!
         end do
      end do
!$omp end do 

!$omp end parallel
 
!
      if ( (Cori_cornl_L) .or. (F_itr .lt. F_itnlh) ) then
!
         call rpn_comm_adj_halo( F_p  , LDIST_DIM,l_ni,l_nj,G_nk+2, &
                       G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
!
!        Zero F_p halo
!        --------------
         call v4d_zerohalo ( F_p,l_ni,l_nj,LDIST_DIM, G_nk+2)
!
      endif
!
!     __________________________________________________________________
!
      return
      end
