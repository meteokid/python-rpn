!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r v4d_grdjok - At first call, read time-variable adjoint profiles from 3D-Var
!                   and fill the adjoint model profiles structure. At the current
!                   bin, do adjoint of interpolation at obs. locations.
!
#include "model_macros_f.h"
!
      subroutine v4d_grdjok 
!
      use v4d_prof
      use v4dz
      use v4d_interint0
!
      implicit none
!
!author N.Ek
!
!revision
! v3_00 - N. Ek             - initial MPI version
! v3_00   M. Tanguay        - adapt to Simon's exchange
! v3_01 - M. Tanguay        - correction for empty processors 
! v3_02 - M. Tanguay        - locate HU in tracers 
! v3_11 - M. Tanguay        - correct relationship between stepob and timestep
!                           - Add option for profiles done on U-V grids for winds 
! v3_30 - Fillion/Tanguay   - Adapt diagnostics for LAM
! v3_31 - Tanguay M.        - Add OPENMP directives 
! v4_12 - Tanguay M.        - Reset Communication 3D_Var-(TL/AD)
! v4_40 - Tanguay/Morneau   - Adapt to vertical stag grid 
!
!object
!     -----------------------------------------------------------------------
!     Each processor do the following:
!         1) At first call: Read time-variable adjoint profiles from 3D-Var
!                           and fill the adjoint model profiles structure (l_mv).
!         2) At the current bin, do adjoint of
!            Conversion from GEM units to 3D-Var units and Reverse Staggering
!     -----------------------------------------------------------------------
!
!implicits
#include "gmm.hf"
#include "glb_ld.cdk"
#include "lctl.cdk"
#include "lun.cdk"
#include "vt1.cdk"
#include "vt1_m.cdk"
#include "ptopo.cdk"
#include "tr3d.cdk"
#include "path.cdk"
#include <clib_interface.cdk>
#include <prof_f.h>
#include "step.cdk"
      include "v4dg.inc"
!
!     Local variables
!     ---------------
      integer, external :: prof_rdrec, prof_bitptrn
!
      type(gmm_metadata) :: meta2d,meta3d
      integer :: gmmstat
      integer pnerr, ier, ip, i, j, k, irec, inmvar8, nobproc, &
              kkk, ibid1, ibid2, ind, nsim3d, nbin, npr, i1, i2, j1, j2, &
              kstatus, jobs, n ,nnk, idim(2)
!
      character*16 tr_name
      real, pointer, dimension(:,:,:) :: hut1,hut1_m
!
      real,    pointer, dimension(:,:) :: profx,profy,prbid 
      real*8,  pointer, dimension(:,:) :: fprof_8
      real*8,  pointer, dimension(:)   :: fprof2d_8
      integer, pointer, dimension(:)   :: mdltag
!
      integer, pointer, dimension(:)   :: done 
      integer, pointer, dimension(:)   :: nob 
!
      real wijk1(LDIST_SHAPE,l_nk+1),wijk2(LDIST_SHAPE,l_nk+1),wbid(LDIST_SHAPE,l_nk+1), &
           wijk3(LDIST_SHAPE,l_nk+2),wijk4(LDIST_SHAPE,l_nk+2),wij5(LDIST_SHAPE)
!
      logical plpr_L, rdvar_L
!
      real*8, parameter :: ZERO_8 = 0.0
!
      character(len=2) :: cljx_S, cljy_S
!     ______________________________________________________
!
!     Caution for Saroja:
!     ------------------
!     In V4D_CSTJOK/V4D_GRDJOK, we evaluate model profiles (G_nk) at obs locations (V4dzgauss_nk).
!
      write(Lun_out,1000) Lctl_step
!
!     Nullify pointers for prof_gvar
!     ------------------------------
      nullify(profx,profy,prbid,fprof_8,fprof2d_8,mdltag)
!
!     Flag for diagnostics 
!     --------------------
      plpr_L = .false.
      plpr_L = plpr_L.and.Lun_out.gt.0
!
!     Recall the dimensions of the fields presented to the interpolation
!     ------------------------------------------------------------------
      i1=V4dz_i1
      i2=V4dz_i2
      j1=V4dz_j1
      j2=V4dz_j2
!
!     Establish at which bin we are    
!     -----------------------------
      nbin = (Lctl_step - Pr_ibin0) / V4dg_stepob + 1
!
!     Zero adjoint variables
!     ----------------------
      wijk1 = ZERO_8
      wijk2 = ZERO_8
      wijk3 = ZERO_8
      wijk4 = ZERO_8
      wijk4 = ZERO_8
!
      wij5  = ZERO_8
!
      if (V4dg_pruv_L) wbid = ZERO_8 
!
!     -----------------------------------------------------------------------------
!     Read dwya PROF file containing time-variables adjoint profiles ONLY ONCE 
!     (at FIRST CALL to v4d_grdjok) and fill adjoint model profiles structure (l_mv) 
!     by classifying them according to their model tag
!     -----------------------------------------------------------------------------
      if (.not.Pr_ropen_L) then
!     -------------------------
!
         Pr_ropen_L = .true.
!
!        Initialize counter for maximal number of adjoint profiles in the local processor
!        as function of bin 
!        --------------------------------------------------------------------------------
         if (Pr_nobproc.ne.0) then 
             allocate(done(Pr_nobproc),STAT=pnerr)
             do i = 1,Pr_nobproc
                done(i) = 0
             end do
         end if
!
         allocate(nob(Pr_maxbin),STAT=pnerr)
         do n = 1,Pr_maxbin
            nob(n) = 0
         end do
!
!        Open dwya PROF file to read the adjoint model profiles
!        ------------------------------------------------------
         write(cljx_S,'(i2.2)') Ptopo_mycol
         write(cljy_S,'(i2.2)') Ptopo_myrow
!
         Pr_type3file_S = trim(Path_xchg_S)//'/dwya_' &
                          //cljx_S//'_'//cljy_S//'.prof'
!
         write(Lun_out,*) 'Opening adjoint dwya MODEL-PROFILE input file'
!
         Pr_ihdlin = prof_open (Pr_type3file_S,'READ','FILE',Pr_dsnooze_8)
!
         if (Pr_ihdlout.le.0) then
             write(Lun_out,*) 'Cannot open adjoint MODEL-PROFILE input file !'
             kstatus = - 99
         end if
!
         write(Lun_out,*) 'Reading records in dwya PROF file'  
!
!        N.B.!!  Currently there is no direct verification that adjoint
!                profiles and model profiles have the same dimensions
!        -------------------------------------------------------------
!
         irec = 0
         nobproc = 0
!
!        Verify if record 
!        ----------------
         readrec: do
!
         ier = prof_rdrec(Pr_ihdlin)
!
         if (ier .ne. 0) then  ! Record is no read
            if (irec .ne. 0) then
                exit readrec     ! We are at the end of the file
            else
                write(Lun_out,*) 'No records to read in ADJOINT-PROFILE input file!'
                call handle_error(-1,'v4d_grdjok','No records to read in ADJOINT-PROFILE input file')
            end if
         else                 ! There is a record
!
            irec = irec + 1
!
            write(Lun_out,*) 'READING RECORD #', irec,'.....(prof_rdrec)'
!
!           Verify 3d-Var simulation no.
!           ----------------------------
            pnerr = prof_gvar(Pr_ihdlin, nsim3d,PRM_EVNT)
            if (nsim3d.ne.Pr_nsim4d) then
                write(Lun_out,*) 'WRONG SIMULATION NUMBER NSIM3D = ',nsim3d,' NSIM4D = ',Pr_nsim4d
                call handle_error(-1,'v4d_grdjok','WRONG SIMULATION NUMBER NSIM3D')
            else
                write(Lun_out,*) 'NSIM3D IS THE RIGHT SIMULATION NUMBER = ',nsim3d
            end if
!
!           Input the corresponding Model-profile Tag(s)
!           --------------------------------------------
            pnerr = prof_gvar(Pr_ihdlin, mdltag, V2D_MTAG)
!
            if (pnerr .ne. 0) then
                write(Lun_out,*) 'Error: No V2D_MTAG found'
                call handle_error(-1,'v4d_grdjok','Error: No V2D_MTAG found')
            end if
!
            npr = size(mdltag, 1)
!
            if (plpr_L) then
                write(Lun_out,*) 'Size of MDLTAG =',npr,'in record =',irec
                write(Lun_out,*) 'Content of MDLTAG =',(mdltag(k), k=1,npr),'in record =',irec
            end if
            write(Lun_out,*) 'Total number of adjoint profiles in this record = ',npr
!
!            nobproc = nobproc + npr
            nobproc = npr
            if (nobproc.gt.Pr_nobproc) then
                write(Lun_out,*) 'Error: NOBPROC GT PR_NOBPROC'
                call handle_error(-1,'v4d_grdjok','Error: NOBPROC GT PR_NOBPROC')
            end if
!
!           Find out which fields are in current record
!           -------------------------------------------
            pnerr = prof_bitptrn(Pr_ihdlin,ibid1,ibid2,kkk,inmvar8) 
!
            if (pnerr .ne. 0) then ! PRM_MVAR is not input
                write(Lun_out,*) 'Error: cannot read PRM_MVAR'
                call handle_error(-1,'v4d_grdjok','Error: cannot read PRM_MVAR')
            end if
!
            do i = 1, Pr_nvars
!
               rdvar_L = btest( inmvar8, Pr_varindx(i) )   
!
               if (rdvar_L) then
!
                   kkk = i   
                   if (plpr_L) write(Lun_out,*) 'Fill adjoint structure of Varindx =',Pr_varindx(i), &
                                                'Variable: ',Pr_varname(i),'from record =',irec
!
!                  Read the adjoint profiles
!                  ------------------------- 
                   if (Pr_varindx(kkk).eq.V2D_PSUR) then
                       pnerr = prof_gvar( Pr_ihdlin,fprof2d_8,V2D_PSUR )
                       npr = size ( fprof2d_8, 1 )
                   else
                       pnerr = prof_gvar( Pr_ihdlin,fprof_8,Pr_varindx(kkk) )
                       npr = size ( fprof_8,   2 )
                       nnk = size ( fprof_8,   1 )
                   end if
!
!                  Use Model-profile-tags to insert the adjoint profiles
!                  in the location that matches the correct px,py for this bin 
!                  -----------------------------------------------------------
                   do ip = 1, npr      ! for all the adjoint profiles
!
                      if (Pr_varindx(kkk).eq.V2D_PSUR) then
!
                          Pr_mlprof(1,mdltag(ip),kkk)% ptr = fprof2d_8(ip)
!
                      else  
!$omp parallel do
                          do k = 1, nnk 
                             Pr_mlprof(k,mdltag(ip),kkk)% ptr = fprof_8(k,ip)
                          end do
!$omp end parallel do
                      end if
!
!                     Accumulate number of adjoint profiles at the given bin 
!                     ------------------------------------------------------ 
                      if (done(mdltag(ip)).eq.0) & 
                          nob(Pr_bintag(mdltag(ip))) = nob(Pr_bintag(mdltag(ip))) + 1 
!
                      done(mdltag(ip)) = 1
!
                   end do ! npr
!
               end if ! rdvar_L
!
            end do ! Pr_nvars 
!
         end if  ! if (ier .eq. 0) ! Record is read
!
         deallocate ( fprof_8,    STAT=ier )
         deallocate ( fprof2d_8,  STAT=ier )
         deallocate ( mdltag,     STAT=ier )

         end do readrec
!
!        Diagnostics  
!        -----------
         do n = 1,Pr_maxbin
            write(Lun_out,*) 'For BIN =',n,' Local number of adjoint profiles = ',nob(n)
            if (nob(n).ne.Pr_nob(n)) then 
                write(Lun_out,*) 'For BIN =',n,' PR_NOB and NOB are different ',Pr_nob(n),nob(n)
                call handle_error(-1,'v4d_grdjok','PR_NOB and NOB are different')
            end if
         end do
         write(Lun_out,*) 'Local number of adjoint profiles for all times = ',nobproc
         if (nobproc.ne.Pr_nobproc) then 
             write(Lun_out,*) 'PR_NOBPROC and NOBPROC are different ',Pr_nobproc,nobproc
             call handle_error(-1,'v4d_grdjok','PR_NOBPROC and NOBPROC are different')
         end if
!
         if (Pr_nobproc.ne.0) deallocate( done, STAT=ier )
         deallocate( nob, STAT=ier )
!
         write(Lun_out,*) ' '
!
!        Close dwya PROF file 
!        --------------------
         ier = prof_close (Pr_ihdlin,Pr_llfrm_L)
!
         write(Lun_out,*) 'Closing adjoint dwya MODEL-PROFILE input file'
!
!     ------------------------------
      end if  ! if (.not.Pr_ropen_L)
!     ------------------------------
!
      if (plpr_L) then
          npr = Pr_l_mv(V3D_UTRU,nbin) % nprof
          npr=min(npr,Pr_l_mv(V3D_TEMP,nbin) % nprof)
          npr=min(npr,Pr_l_mv(V3D_SPHU,nbin) % nprof)
          npr=min(npr,Pr_l_mv(V2D_PSUR,nbin) % nprof)
          if (npr.ne.0) then
             jobs=1
             write(Lun_out,fmt='(//,6x,"Printing one profile of GOMOBS ADJOINT...",/,2x,a,4(4x,A))') &
                               'Level','UU','VV'
             do k = 1,G_nk+1
                write(Lun_out,fmt='(2x,i3,4(4x,e12.5))')k, &
                              Pr_l_mv(V3D_UTRU,nbin) % fprof(k,jobs), &
                              Pr_l_mv(V3D_VTRU,nbin) % fprof(k,jobs)
             end do
             write(Lun_out,fmt='(//,6x,"Printing one profile of GOMOBS ADJOINT...",/,2x,a,4(4x,A))') &
                               'Level','TT','HU'
             do k = 1,G_nk+2
                write(Lun_out,fmt='(2x,i3,4(4x,e12.5))')k, &
                              Pr_l_mv(V3D_TEMP,nbin) % fprof(k,jobs), &
                              Pr_l_mv(V3D_SPHU,nbin) % fprof(k,jobs)
             end do
                write(Lun_out,fmt='(//,6x,"Printing GOMOBS ADJOINT...",(4x,A),(4x,e12.5))') &
                              'PS',Pr_l_mv(V2D_PSUR,nbin) % fprof(1,jobs)
          end if
      end if
!
!     Get fields in memory
!     --------------------
      gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_grdjok ERROR at gmm_get(ut1)'
      gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_grdjok ERROR at gmm_get(vt1)'
      gmmstat = gmm_get(gmmk_tt1_s,tt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_grdjok ERROR at gmm_get(tt1)'
      gmmstat = gmm_get(gmmk_st1_s,st1,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_grdjok ERROR at gmm_get(st1)'
!
!     Load humidity field
!     -------------------
      tr_name = 'TR/HU:P'
      gmmstat = gmm_get(tr_name,hut1,meta3d)
!
!     Get TRAJ fields in memory
!     -------------------------
      gmmstat = gmm_get(gmmk_tt1_m_s,tt1_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_grdjok ERROR at gmm_get(tt1_m)'
      gmmstat = gmm_get(gmmk_st1_m_s,st1_m,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_grdjok ERROR at gmm_get(st1_m)'
!
!     Load TRAJ humidity field
!     ------------------------
      tr_name = 'TRM/HU:P'
      gmmstat = gmm_get(tr_name,hut1_m,meta3d)
!
!     ADJOINT of
!     -------------------------------------------
!     Evaluate profiles at observations locations
!     -------------------------------------------
!
!        ADJOINT of
!        ----------------------------------
!        Contribution from surface pressure
!        ----------------------------------
            npr = Pr_l_mv(V2D_PSUR,nbin) % nprof
            write(Lun_out,*) 'Evaluate adjoint profiles PS at BIN = ',nbin, &
                             'Number of profiles = ',npr
!
            if (npr.ne.0) then
!
            allocate ( profx (1,npr), STAT=ier )
!
!$omp parallel do
            do j=1,npr
               profx(1,j) = Pr_l_mv(V2D_PSUR,nbin) % fprof(1,j)
            end do
!$omp end parallel do

            end if

!           Adjoint of
!           Interpolation to observation locations using EZSCINT
!           ----------------------------------------------------
            call v4d_scint0_ad(profx,Pr_l_mv(V2D_PSUR,nbin)%px,Pr_l_mv(V2D_PSUR,nbin)%py,npr, &
                               wij5,V4dz_ax,V4dz_ay,V4dz_cx,V4dz_cy, &
                               V4dz_wx_8,i1,i2,j1,j2,1, &
                               V4dz_grtypi,V4dz_degree,'4S')
!
            if (npr.ne.0) deallocate( profx ) 
!
!        ADJOINT of
!        --------------------------
!        Contribution from humidity
!        --------------------------
            npr =  Pr_l_mv(V3D_SPHU,nbin) % nprof 
            write(Lun_out,*) 'Evaluate adjoint profiles HU at BIN = ',nbin, &
                             'Number of profiles = ',npr
!
            if (npr.ne.0) then
!
            allocate ( profx (l_nk+2,npr), STAT=ier )
!
!$omp parallel do
            do k = 1,l_nk+2
               do j=1,npr
                  profx(k,j)= Pr_l_mv(V3D_SPHU,nbin) % fprof(k,j)
               end do
            end do
!$omp end parallel do
!
            end if 
!
!           Adjoint of
!           Interpolation to observation locations using EZSCINT
!           ----------------------------------------------------
            call v4d_scint0_ad(profx,Pr_l_mv(V3D_SPHU,nbin)%px,Pr_l_mv(V3D_SPHU,nbin)%py,npr, &
                               wijk4,V4dz_ax,V4dz_ay,V4dz_cx,V4dz_cy, &
                               V4dz_wx_8,i1,i2,j1,j2,l_nk+2, &
                               V4dz_grtypi,V4dz_degree,'HU')
!
            if (npr.ne.0) deallocate( profx ) 
!
!        ADJOINT of
!        -----------------------------
!        Contribution from temperature
!        -----------------------------
            npr =  Pr_l_mv(V3D_TEMP,nbin) % nprof 
            write(Lun_out,*) 'Evaluate adjoint profiles TT at BIN = ',nbin, &
                             'Number of profiles = ',npr
!
            if (npr.ne.0) then
!
            allocate ( profx (l_nk+2,npr), STAT=ier )
!
!$omp parallel do
            do k = 1,l_nk+2
               do j=1,npr
                  profx(k,j)= Pr_l_mv(V3D_TEMP,nbin) % fprof(k,j)
               end do
            end do
!$omp end parallel do
!
            end if
!
!           Adjoint of
!           Interpolation to observation locations using EZSCINT
!           ----------------------------------------------------
            call v4d_scint0_ad(profx,Pr_l_mv(V3D_TEMP,nbin)%px,Pr_l_mv(V3D_TEMP,nbin)%py,npr, &
                               wijk3,V4dz_ax,V4dz_ay,V4dz_cx,V4dz_cy, &
                               V4dz_wx_8,i1,i2,j1,j2,l_nk+2, &
                               V4dz_grtypi,V4dz_degree,'TT')
!
            if (npr.ne.0) deallocate( profx ) 
!
!        ADJOINT of
!        --------------------------------
!        Contribution from U-V components
!        --------------------------------
            npr = Pr_l_mv(V3D_UTRU,nbin) % nprof
            write(Lun_out,*) 'Evaluate adjoint profiles UV at BIN = ',nbin, &
                             'Number of profiles = ',npr
!
            if (npr.ne.0) then
!
            allocate ( profx (l_nk+1,npr), STAT=ier )
            allocate ( profy (l_nk+1,npr), STAT=ier )
            if (V4dg_pruv_L) allocate ( prbid (l_nk+1,npr), STAT=ier )
!
!$omp parallel do
            do k=1,l_nk+1
               do j=1,npr
                  profx(k,j)= Pr_l_mv(V3D_UTRU,nbin) % fprof(k,j)
                  profy(k,j)= Pr_l_mv(V3D_VTRU,nbin) % fprof(k,j)
               end do
            end do
!$omp end parallel do
!
            end if
!
!           Adjoint of
!           Interpolation to observation locations using EZSCINT
!           ----------------------------------------------------
            if (.not.V4dg_pruv_L) then
!
               call v4d_uvint0_ad(profx,profy,Pr_l_mv(V3D_UTRU,nbin)%px,Pr_l_mv(V3D_UTRU,nbin)%py,npr, &
                                  wijk1,wijk2,V4dz_ax,V4dz_ay,V4dz_cx,V4dz_cy, &
                                  V4dz_wx_8,V4dz_cox_8,V4dz_six_8,V4dz_siy_8, &
                                  i1,i2,j1,j2,l_nk+1,V4dz_grtypi,V4dz_degree,'UV')
!
            else
!
               if (npr.ne.0) then
!
               wbid = ZERO_8
!
!$omp parallel do
               do k=1,l_nk+1
                  do j=1,npr
                     prbid(k,j)= ZERO_8
                  end do
               end do
!$omp end parallel do
               end if
!
               call v4d_uvint0_ad(prbid,profy,Pr_l_mv(V3D_UTRU,nbin)%px,Pr_l_mv(V3D_UTRU,nbin)%pyv,npr, & 
                                  wbid,wijk2,V4dz_ax,V4dz_ayv,V4dz_cx,V4dz_cyv, &
                                  V4dz_wx_8,V4dz_cox_8,V4dz_six_8,V4dz_siyv_8, &
                                  i1,i2,j1,j2,l_nk+1,'V',V4dz_degree,'UV')
!
               wbid = ZERO_8
!
               if (npr.ne.0) then
!$omp parallel do
               do k=1,l_nk+1
                  do j=1,npr
                     prbid(k,j)= ZERO_8
                  end do
               end do
!$omp end parallel do
               end if
!
               call v4d_uvint0_ad (profx,prbid,Pr_l_mv(V3D_UTRU,nbin)%pxu,Pr_l_mv(V3D_UTRU,nbin)%py,npr, &
                                   wijk1,wbid,V4dz_axu,V4dz_ay,V4dz_cxu,V4dz_cy, &
                                   V4dz_wxu_8,V4dz_coxu_8,V4dz_sixu_8,V4dz_siy_8, &
                                   i1,i2,j1,j2,l_nk+1,'U',V4dz_degree,'UV')
!
               wbid = ZERO_8
!
            end if
!
            if (npr.ne.0) deallocate( profx, profy ) 
            if (npr.ne.0.and.V4dg_pruv_L) deallocate( prbid ) 
!
      if (plpr_L) then
         if (Ptopo_myproc.eq.0) write(Lun_out,*) 'AFTER EZSCINT_AD'
            call glbstat2(wijk1,'UT1' ,' GRDJOK',LDIST_DIM,1,G_nk+1,1,G_ni,1,G_nj,1,G_nk+1)
            call glbstat2(wijk2,'VT1' ,' GRDJOK',LDIST_DIM,1,G_nk+1,1,G_ni,1,G_nj,1,G_nk+1)
            call glbstat2(wijk3,'TT1' ,' GRDJOK',LDIST_DIM,1,G_nk+2,1,G_ni,1,G_nj,1,G_nk+2)
            call glbstat2(wij5 ,'ST1' ,' GRDJOK',LDIST_DIM,1,   1,1,G_ni,1,G_nj,1,1)
            call glbstat2(wijk4,'HUT1',' GRDJOK',LDIST_DIM,1,G_nk+2,1,G_ni,1,G_nj,1,G_nk+2)
         if (Ptopo_myproc.eq.0) write(Lun_out,*) '-----------------------'
      end if
!
!     ADJOINT of
!     ---------------------------------------
!     Conversion from GEM to 3D-Var variables
!     ---------------------------------------
      call v4d_varconv_ad( wijk1, wijk2, wijk3, wijk4, wij5, &
                           tt1_m, hut1_m, st1_m, LDIST_DIM, l_nk, .false. )
!
      if (plpr_L) then
         if (Ptopo_myproc.eq.0) write(Lun_out,*) 'AFTER VARCONV_AD'
         call glbstat2(wijk1,'UT1' ,' GRDJOK',LDIST_DIM,1,G_nk+1,1,G_ni,1,G_nj,1,G_nk+1)
         call glbstat2(wijk2,'VT1' ,' GRDJOK',LDIST_DIM,1,G_nk+1,1,G_ni,1,G_nj,1,G_nk+1)
         call glbstat2(wijk3,'TT1' ,' GRDJOK',LDIST_DIM,1,G_nk+2,1,G_ni,1,G_nj,1,G_nk+2)
         call glbstat2(wij5 ,'ST1' ,' GRDJOK',LDIST_DIM,1,   1,1,G_ni,1,G_nj,1,1)
         call glbstat2(wijk4,'HUT1',' GRDJOK',LDIST_DIM,1,G_nk+2,1,G_ni,1,G_nj,1,G_nk+2)
         if (Ptopo_myproc.eq.0) write(Lun_out,*) '-----------------------'
      end if
!
!     ADJOINT of
!     ---------------
!     Transfer fields
!     ---------------
!$omp parallel do
      do j=1,l_nj
         do i=1,l_ni
            st1(i,j) = wij5(i,j) + st1(i,j)
            wij5(i,j) = ZERO_8
         end do
      end do
!$omp end parallel do
!
!$omp parallel
!$omp do
      do k=1,l_nk+2
         do j=1,l_nj
            do i=1,l_ni
               hut1 (i,j,k) = wijk4(i,j,k) + hut1(i,j,k)
               wijk4(i,j,k) = ZERO_8
               tt1  (i,j,k) = wijk3(i,j,k) + tt1 (i,j,k)
               wijk3(i,j,k) = ZERO_8
            end do
         end do
      end do
!$omp end do
!
!$omp do
      do k=1,l_nk+1
         do j=1,l_njv
            do i=1,l_ni
               vt1  (i,j,k) = wijk2(i,j,k) + vt1 (i,j,k)
               wijk2(i,j,k) = ZERO_8
            end do
         end do
         do j=1,l_nj
            do i=1,l_niu
               ut1  (i,j,k) = wijk1(i,j,k) + ut1 (i,j,k)
               wijk1(i,j,k) = ZERO_8
            end do
         end do
      end do
!$omp end do
!$omp end parallel
!
      write(Lun_out,1001) Lctl_step
!
 1000 format(/,'V4D_GRDJOK: Beginning for TIMESTEP = ',I8, &
             /,'==================================')
 1001 format(/,'V4D_GRDJOK:    Ending for TIMESTEP = ',I8, &
             /,'==================================')
!
      return
      end
