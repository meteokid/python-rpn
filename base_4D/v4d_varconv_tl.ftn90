!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r v4d_varconv_tl - TLM of conversion control variables GEM <--> 3D-Var
!
#include "model_macros_f.h"
!
      subroutine v4d_varconv_tl( C_ut1, C_vt1, C_tt1, C_hut1, C_st1, &
                                 C_tt1m, C_hut1m, C_st1m, DIST_DIM, Nk, inverse_L )
!
      implicit none
#include <arch_specific.hf>
!
      integer DIST_DIM,Nk
      real C_ut1 (DIST_SHAPE,Nk+1), C_vt1  (DIST_SHAPE,Nk+1), &
           C_tt1 (DIST_SHAPE,Nk+2), C_hut1 (DIST_SHAPE,Nk+2), &
           C_st1 (DIST_SHAPE), &
           C_tt1m(DIST_SHAPE,Nk+2), C_hut1m(DIST_SHAPE,Nk+2), &
           C_st1m(DIST_SHAPE)
      logical inverse_L
!
!author
!     Stephane Laroche 
!
!revision
! v3_00 - Laroche S.       - initial MPI version
! v3_00 - Gauthier P.      - ln q to q 
! v3_00 - Tanguay M.       - verify zeroing of hut1m 
! v3_02 - Laroche S.       - conversion to hybrid coordinate
! v3_11 - Tanguay M.       - Add option for profiles done on U-V grids for winds 
!                          - Add option for staggering already done by 3D-Var
! v3_20 - Buehner & Zadra  - add option for using HU as humidity variable 
! v3_30 - Fillion/Tanguay  - Extend the scaling to all the grid in LAM mode 
! v3_31 - Tanguay M.       - Add OPENMP directives 
! v4_40 - Tanguay/Morneau  - Adapt to vertical stag grid 
!
!object
!
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! C_ut1
! C_vt1
! C_tt1
! C_hut1
! C_st1
!----------------------------------------------------------------
!
!implicits
#include "glb_ld.cdk"
#include "geomg.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "ver.cdk"
      include "v4dg.inc"
!
!modules
!
      integer i, j, k
      real*8 pri2c_8
      real wu(LDIST_SHAPE,l_nk+1),wv(LDIST_SHAPE,l_nk+1)

      if(.not.inverse_L) then
!C
!C     Conversion GEM --> 3D-Var
!C     =========================
!C
!
!C
!C     Winds
!C     -----
!C
      if (.not.V4dg_pruv_L) then 
!
      call itf_phy_uvgridscal ( C_ut1, C_vt1, LDIST_DIM, Nk+1, .true. )

!$omp parallel do
      do k=1,Nk+1
        do j= 1, l_nj 
         pri2c_8 = Dcst_rayt_8/Geomg_cy_8(j)
         do i= 1, l_ni 
            C_ut1(i,j,k) = C_ut1(i,j,k)*pri2c_8
            C_vt1(i,j,k) = C_vt1(i,j,k)*pri2c_8
         end do
        end do
      end do
!$omp end parallel do
!
      else
!
!$omp parallel do
      do k=1,Nk+1
        do j= 1, l_nj
         pri2c_8 = Dcst_rayt_8/Geomg_cy_8(j)
         do i= 1, l_niu
            C_ut1(i,j,k) = C_ut1(i,j,k)*pri2c_8
         end do
        end do
      end do
!$omp end parallel do
!
!$omp parallel do
      do k=1,Nk+1
        do j= 1, l_njv
         pri2c_8 = Dcst_rayt_8/Geomg_cyv_8(j)
         do i= 1, l_ni
            C_vt1(i,j,k) = C_vt1(i,j,k)*pri2c_8
         end do
        end do
      end do
!$omp end parallel do
!
      endif
!C     
!C    Temperature
!C    -----------
!C     
!$omp parallel do
      do k=1,Nk+2
         do j= 1, l_nj 
            do i= 1, l_ni 

               C_tt1(i,j,k) = ( (C_tt1m(i,j,k) + Cstv_tstr_8) &
                    /(1.0 + Dcst_delta_8*C_hut1m(i,j,k)) ) &
                    * (  C_tt1(i,j,k)/(C_tt1m(i,j,k) + Cstv_tstr_8) &
                    -Dcst_delta_8*C_hut1(i,j,k)/(1.0 + Dcst_delta_8*C_hut1m(i,j,k)) )

            end do
         end do
      end do
!$omp end parallel do

!C     
!C    Surface pressure
!C    ----------------
!C     
!$omp parallel do
      do j= 1, l_nj 
         do i= 1, l_ni 

            C_st1(i,j) =  Cstv_pref_8 * exp(C_st1m(i,j)) * C_st1(i,j)

         end do
      end do
!$omp end parallel do
!C
!C    Humidity: Delta(log q) = Delta q / q(ref)
!C    -----------------------------------------
!C
         if (V4dg_chum_s.eq.'LQ') then
!$omp parallel do
         do k=1,Nk+2
            do j= 1, l_nj 
               do i= 1, l_ni 
                  if(C_hut1m(i,j,k).eq.0.0) then
                     C_hut1(i,j,k) = 0.0 
                  else
                     C_hut1(i,j,k) = C_hut1(i,j,k)/C_hut1m(i,j,k) 
                  endif
               end do
            end do
         end do
!$omp end parallel do
         endif

      else
!     
!C     
!C    Conversion 3D-Var --> GEM
!C    =========================
!C
!C    Humidity: Delta q = q(ref) * Delta( log q)
!C    ------------------------------------------
!C
         if (V4dg_chum_s.eq.'LQ') then
!$omp parallel do
         do k=1,Nk+2
            do j= 1, l_nj 
               do i= 1, l_ni 
                  C_hut1(i,j,k) = C_hut1(i,j,k)*C_hut1m(i,j,k)
               end do
            end do
         end do
!$omp end parallel do
         endif
!C     
!C    Winds
!C    -----
!$omp parallel do
       do k=1,Nk+1
       do j=l_miny,l_maxy
       do i=l_minx,l_maxx
          wu(i,j,k) = 0.0 
          wv(i,j,k) = 0.0 
       enddo
       enddo
       enddo
!$omp end parallel do
!
       if(.not.V4dg_ustag_L) then
!$omp parallel do
         do k=1,Nk+1
            do j= 1, l_nj
            pri2c_8 = (1.0/Geomg_cy_8(j))*Dcst_rayt_8
               do i= 1, l_ni
                  C_ut1(i,j,k) = C_ut1(i,j,k)/pri2c_8
               end do
            end do
         end do
!$omp end parallel do
       endif
!
       if(.not.V4dg_vstag_L) then
!$omp parallel do
         do k=1,Nk+1
           do j= 1, l_nj
           pri2c_8 = (1.0/Geomg_cy_8(j))*Dcst_rayt_8
             do i= 1, l_ni
                C_vt1(i,j,k) = C_vt1(i,j,k)/pri2c_8
             end do
           end do
         end do
!$omp end parallel do
       endif
!
       if(.not.V4dg_ustag_L.and..not.V4dg_vstag_L) then
          call itf_phy_uvgridscal ( C_ut1, C_vt1, LDIST_DIM, Nk+1, .false. )
!
       elseif(V4dg_ustag_L.and..not.V4dg_vstag_L) then
          call itf_phy_uvgridscal (    wu, C_vt1, LDIST_DIM, Nk+1, .false. )
!
       elseif(.not.V4dg_ustag_L.and.V4dg_vstag_L) then
          call itf_phy_uvgridscal ( C_ut1,    wv, LDIST_DIM, Nk+1, .false. )
       endif
!
       if(V4dg_ustag_L) then
!$omp parallel do
         do k=1,Nk+1
           do j= 1, l_nj
           pri2c_8 = (1.0/Geomg_cy_8(j))*Dcst_rayt_8
             do i= 1, l_niu
                C_ut1(i,j,k) = C_ut1(i,j,k)/pri2c_8
             end do
           end do
         end do
!$omp end parallel do
       endif
!
       if(V4dg_vstag_L) then
!$omp parallel do
         do k=1,Nk+1
           do j= 1, l_njv
           pri2c_8 = (1.0/Geomg_cyv_8(j))*Dcst_rayt_8
             do i= 1, l_ni
                C_vt1(i,j,k) = C_vt1(i,j,k)/pri2c_8
             end do
           end do
         end do
!$omp end parallel do
       endif
!C     
!C    Temperature
!C    -----------
!C     
!$omp parallel do
         do k=1,Nk+2
            do j= 1, l_nj 
               do i= 1, l_ni 

                  C_tt1(i,j,k) =  C_tt1(i,j,k)*(1.0 + Dcst_delta_8*C_hut1m(i,j,k)) &
                       + C_hut1(i,j,k)*Dcst_delta_8*(C_tt1m(i,j,k) + Cstv_tstr_8) &
                       /(1.0 + Dcst_delta_8*C_hut1m(i,j,k))

               end do
            end do
         end do
!$omp end parallel do

!C     
!C    Surface pressure
!C    ----------------
!C     
!$omp parallel do
         do j= 1, l_nj 
            do i= 1, l_ni 

               C_st1(i,j) = C_st1(i,j)/(Cstv_pref_8 * exp(C_st1m(i,j)))

            end do
         end do
!$omp end parallel do

      endif
!     
      return
      end
