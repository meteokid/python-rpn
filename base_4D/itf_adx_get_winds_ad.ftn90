!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

#include "model_macros_f.h"
#include "msg.h"
#include "stop_mpi.h"

!/**
subroutine itf_adx_get_winds2_ad(F_su,F_sv,F_sw,F_minx,F_maxx,F_miny,F_maxy,F_nk)
!
   implicit none
#include <arch_specific.hf>
!
   !@objective ADJ of itf_adx_get_winds 
!
   !@arguments
   integer :: F_minx,F_maxx,F_miny,F_maxy,F_nk
   real,dimension(F_minx:F_maxx,F_miny:F_maxy,F_nk) :: &
        F_su,F_sv,F_sw !O, model de-stag winds on m-t levels super set
!
   !@author Monique Tanguay
!
   !@revisions
   ! v4_13 - Tanguay M.        - Adjustments GEM413
   ! v4_40 - Tanguay M.        - Revision TL/AD
   !  
!**/
#include "glb_ld.cdk"
#include "gmm.hf"
#include "vth.cdk"
   !      real, pointer, dimension (:,:,:) :: uth,vth,zdth
   !      character(len=8) :: gmmk_uth_s, gmmk_vth_s, gmmk_zdth_s
!!$#include "acid.cdk"
   !      logical acid_test_l
   type(gmm_metadata) :: dummy_gmm_meta
   integer :: istat
   real, dimension(:,:,:), pointer :: um,vm,wm,ut,vt
   real*8, parameter :: ZERO_8 = 0.0
   !---------------------------------------------------------------------
   call msg(MSG_DEBUG,'itf_adx_get_winds_ad')

   istat = GMM_OK
   istat = min(gmm_get(gmmk_uth_s,uth,dummy_gmm_meta),istat)
   istat = min(gmm_get(gmmk_vth_s,vth,dummy_gmm_meta),istat)
   istat = min(gmm_get(gmmk_zdth_s,zdth,dummy_gmm_meta),istat)
   call handle_error(istat,'adx_main_1_wnd','Problem in gmm_get')

   allocate( &
        ut(l_minx:l_maxx,l_miny:l_maxy,l_nk+1), &
        vt(l_minx:l_maxx,l_miny:l_maxy,l_nk+1), &
        wm(l_minx:l_maxx,l_miny:l_maxy,l_nk), &
        stat=istat)
   call handle_error_l(istat==0,'itf_adx_get_winds_ad','Problem allocating mem')
   !
   !Zero adjoint variables
   !----------------------
   ut = ZERO_8
   vt = ZERO_8
   wm = ZERO_8
   !
   call itf_adx_combine_levels_ad(F_sw,wm,zdth,F_nk)
   call itf_adx_combine_levels_ad(F_sv,vth,vt,F_nk)
   call itf_adx_combine_levels_ad(F_su,uth,ut,F_nk)
   !
   call itf_adx_interp_thermo2mom_ad(wm,zdth)
   call itf_adx_interp_mom2thermo_ad(vt,vth)
   call itf_adx_interp_mom2thermo_ad(ut,uth)
   !
   um => ut
   vm => vt
   !
   !Zero adjoint variables
   !----------------------
   um = 0.
   vm = 0.
   !
   call itf_adx_img2real_winds_ad(uth,vth,um,vm)
   call itf_adx_destag_winds_ad(um,vm,uth,vth)
   nullify(um,vm)
   !
   deallocate(ut,vt,wm)

   call msg(MSG_DEBUG,'itf_adx_get_winds_ad [end]')
   !---------------------------------------------------------------------
   return


contains !====================================================================


!/**
   subroutine itf_adx_destag_winds_ad(F_u,F_v,F_uth,F_vth)
!
      implicit none
!
      !@objective ADJ of itf_adx_destag_winds 
!
      !@arguments
      real, dimension(:,:,:), pointer :: F_uth,F_vth !I, staggered winds
      real, dimension(:,:,:), pointer :: F_u,F_v     !O, destaggered winds
!
      !@author Monique Tanguay 
!
      !@revisions
      ! v4_13 - Tanguay M.        - Adjustments GEM413
      ! v4_40 - Tanguay M.        - Revision TL/AD
!**/
#include "glb_ld.cdk"
#include "inuvl.cdk"
      !- CUBIC LAGRANGE INTERPOLATION COEFFICIENTS from AND to U and V grids
      !      real*8 inuvl_wxux3_8(l_minx:l_maxx,4) ! coef for U to PHI-grid
      !      real*8 inuvl_wyvy3_8(l_miny:l_maxy,4) ! coef for V to PHI-grid

#define UNSTAG_X(f,i,j,k,a) (a(i,1)*f(i-2,j,k) + a(i,2)*f(i-1,j,k) + a(i,3)*f(i,j,k) + a(i,4)*f(i+1,j,k))
#define UNSTAG_Y(f,i,j,k,a) (a(j,1)*f(i,j-2,k) + a(j,2)*f(i,j-1,k) + a(j,3)*f(i,j,k) + a(j,4)*f(i,j+1,k))

      integer :: i,j,k, i0,j0,in,jn, nrow=0
      real*8, parameter :: ZERO_8 = 0.0
      !---------------------------------------------------------------------
!      
      !- ADJ of     
      !- Interpolate advection winds to geopotential grid
!
!$omp parallel private(i0,in,j0,jn)

!$omp do 
      DO_K: do k=l_nk,1,-1
!
         i0 = 1
         in = l_ni
         jn = l_njv
         !needed since UNSTAG_Y uses j-2 and j+1
         if (l_south) j0 = 3
         if (l_north) jn = l_njv - 1
!
         IF_LAM: if (.not.G_lam) then

            if (l_north) then
               do i = i0, in
                  F_vth(i,jn+1,k) = inuvl_wyvy3_8(jn+1,3) * F_v(i,jn+1,k) + F_vth(i,jn+1,k)
                  F_vth(i,jn  ,k) = inuvl_wyvy3_8(jn+1,2) * F_v(i,jn+1,k) + F_vth(i,jn  ,k)
                  F_vth(i,jn-1,k) = inuvl_wyvy3_8(jn+1,1) * F_v(i,jn+1,k) + F_vth(i,jn-1,k)
                  F_v  (i,jn+1,k) = ZERO_8
!
                  F_vth(i,jn+1,k) = inuvl_wyvy3_8(jn+2,2) * F_v(i,jn+2,k) + F_vth(i,jn+1,k)
                  F_vth(i,jn  ,k) = inuvl_wyvy3_8(jn+2,1) * F_v(i,jn+2,k) + F_vth(i,jn  ,k)
                  F_v  (i,jn+2,k) = ZERO_8
               enddo
            endif

            if (l_south) then
               do i = i0, in
                  F_vth(i,j0,  k) = inuvl_wyvy3_8(j0-1,4) * F_v(i,j0-1,k) + F_vth(i,j0,  k)
                  F_vth(i,j0-1,k) = inuvl_wyvy3_8(j0-1,3) * F_v(i,j0-1,k) + F_vth(i,j0-1,k)
                  F_vth(i,j0-2,k) = inuvl_wyvy3_8(j0-1,2) * F_v(i,j0-1,k) + F_vth(i,j0-2,k)
                  F_v  (i,j0-1,k) = ZERO_8
!
                  F_vth(i,j0-1,k) = inuvl_wyvy3_8(j0-2,4) * F_v(i,j0-2,k) + F_vth(i,j0-1,k)
                  F_vth(i,j0-2,k) = inuvl_wyvy3_8(j0-2,3) * F_v(i,j0-2,k) + F_vth(i,j0-2,k)
                  F_v  (i,j0-2,k) = ZERO_8
               enddo
            endif

         else !IF_LAM

            !-TODO: make this better: use stag values on borders (one approx)
            do i = i0, in
               do j = jn+1,l_njv
                  F_vth(i,j,k) = F_v(i,j,k) + F_vth(i,j,k)
                  F_v  (i,j,k) = ZERO_8
               enddo
               do j = 1,j0-1
                  F_vth(i,j,k) = F_v(i,j,k) + F_vth(i,j,k)
                  F_v  (i,j,k) = ZERO_8
               enddo
            enddo

         endif IF_LAM
!
         do j = jn,j0,-1
            do i = in,i0,-1
               F_vth(i,j+1,k) = inuvl_wyvy3_8(j,4) * F_v(i,j,k) + F_vth(i,j+1,k)
               F_vth(i,j  ,k) = inuvl_wyvy3_8(j,3) * F_v(i,j,k) + F_vth(i,j  ,k)
               F_vth(i,j-1,k) = inuvl_wyvy3_8(j,2) * F_v(i,j,k) + F_vth(i,j-1,k)
               F_vth(i,j-2,k) = inuvl_wyvy3_8(j,1) * F_v(i,j,k) + F_vth(i,j-2,k)
               F_v  (i,j,  k) = ZERO_8
            enddo
         enddo
!
         i0 = 1
         in = l_niu
         j0 = 1
         jn = l_nj
         if (G_lam) then !needed since UNSTAG_X uses i-2 and i+1
            if (l_west) i0 = 3
            if (l_east) in = l_niu - 1
         endif
!
         do j = j0, jn
!
            !-TODO: make this better: use stag values on borders (one approx)
            do i = in+1,l_niu
               F_uth(i,j,k) = F_u(i,j,k) + F_uth(i,j,k)
               F_u  (i,j,k) = ZERO_8
            enddo
            do i = 1,i0-1
               F_uth(i,j,k) = F_u(i,j,k) + F_uth(i,j,k)
               F_u  (i,j,k) = ZERO_8
            enddo
!
            do i = in,i0,-1
               F_uth(i+1,j,k) = inuvl_wxux3_8(i,4) * F_u(i,j,k) + F_uth(i+1,j,k)
               F_uth(i  ,j,k) = inuvl_wxux3_8(i,3) * F_u(i,j,k) + F_uth(i  ,j,k)
               F_uth(i-1,j,k) = inuvl_wxux3_8(i,2) * F_u(i,j,k) + F_uth(i-1,j,k)
               F_uth(i-2,j,k) = inuvl_wxux3_8(i,1) * F_u(i,j,k) + F_uth(i-2,j,k)
               F_u  (i,  j,k) = ZERO_8
            enddo
!
         enddo
!
      enddo DO_K
!$omp enddo 

!$omp end parallel
!
      call rpn_comm_adj_halo (F_vth,LDIST_DIM,l_ni,l_njv,l_nk, &
                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
!
      call rpn_comm_adj_halo (F_uth,LDIST_DIM,l_niu,l_nj,l_nk, & 
                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
!
!     Zero F_vth halo
!     ---------------
      call v4d_zerohalo ( F_vth,l_ni,l_njv,LDIST_DIM, l_nk)
!
!     Zero F_ru halo
!     --------------
      call v4d_zerohalo ( F_uth,l_niu,l_nj,LDIST_DIM, l_nk)
!
      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_destag_winds_ad


!/**
   subroutine itf_adx_img2real_winds_ad(F_ur,F_vr,F_ui,F_vi)
!
      implicit none
!
      !@objective ADJ of itf_adx_img2real_winds 
!
      !@arguments
      real, dimension(:,:,:), pointer :: F_ui,F_vi !I=image winds
      real, dimension(:,:,:), pointer :: F_ur,F_vr !O=real winds
!
      !@author Monique Tanguay
!
      !@revisions
      ! v4_13 - Tanguay M.        - Adjustments GEM413
      ! v4_40 - Tanguay M.        - Revision TL/AD
!**/
#include "glb_ld.cdk"
#include "geomg.cdk"
      !      real*8 Geomg_cy_8(l_miny:l_maxy) !cosine of latitude
      integer :: i,j,k, i0,j0,in,jn
      real*8  :: sc_8
      real*8, parameter :: ZERO_8 = 0.0
      !---------------------------------------------------------------------
!
!$omp parallel private(i0,in,j0,jn)

      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
         if (l_west) i0 = 3
         if (l_east) in = l_niu - 1
      endif

!$omp do
      do k = 1,l_nk
         do j = j0,jn
            sc_8 = 1.D0 / geomg_cy_8(j)
            do i = i0,in
               F_ui(i,j,k) = sc_8 * F_ur(i,j,k) + F_ui(i,j,k)
               F_ur(i,j,k) = ZERO_8
            enddo
         enddo
      enddo
!$omp enddo
!
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
         if (l_south) j0 = 3
         if (l_north) jn = l_njv - 1
      endif

!$omp do
      do k = 1,l_nk
         do j = j0,jn
            sc_8 = 1.D0 / geomg_cy_8(j)
            do i = i0,in
               F_vi(i,j,k) = sc_8 * F_vr(i,j,k) + F_vi(i,j,k)
               F_vr(i,j,k) = ZERO_8
            enddo
         enddo
      enddo
!$omp enddo

!$omp end parallel
!
      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_img2real_winds_ad


!/**
   subroutine itf_adx_interp_thermo2mom_ad(F_fld_m,F_fld_t)
!
      implicit none
!
      !@objective ADJ of itf_adx_interp_thermo2mom 
!
      !@arguments
      real, dimension(:,:,:), pointer :: F_fld_t !intent(inout)
      real, dimension(:,:,:), pointer :: F_fld_m !intent(inout)
!
      !@author Monique Tanguay
!
      !@revisions
      ! v4_13 - Tanguay M.        - Adjustments GEM413
      ! v4_40 - Tanguay M.        - Revision TL/AD
!**/
#include "glb_ld.cdk"
#include "ver.cdk"
      integer :: i,j,k, i0,j0,in,jn
      real*8  :: xx_8,x1_8,x2_8,x3_8,x4_8,w1_8,w2_8,w3_8,w4_8,den_8
#define lag3_8(xx_8,x1_8,x2_8,x3_8,x4_8) (((xx_8 - x2_8)* (xx_8 - x3_8)* (xx_8 - x4_8)) &
                                        / ((x1_8 - x2_8)* (x1_8 - x3_8)* (x1_8 - x4_8)))
      real*8, parameter :: ZERO_8 = 0.0
      !---------------------------------------------------------------------

!$omp parallel private(i0,in,j0,jn,xx_8,x1_8,x2_8,x3_8,x4_8,w1_8,w2_8,w3_8,w4_8,den_8)

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
      if (G_lam) then
         if (l_west)  i0 = 3
         if (l_east)  in = l_ni - 1
         if (l_south) j0 = 3
         if (l_north) jn = l_nj - 1
      endif
      !
      !- ADJ of
      !- Note  F_fld_t(i,j,l_nk+1) = 0
      k = l_nk
      w1_8 = (Ver_z_8%m(k)-Ver_z_8%t(k+1)) / (Ver_z_8%t(k)-Ver_z_8%t(k+1))

!$omp do 
      do j = j0, jn
         do i = i0, in
            F_fld_t(i,j,k) = w1_8*F_fld_m(i,j,k) + F_fld_t(i,j,k)
            F_fld_m(i,j,k) = ZERO_8 
         enddo
      enddo
!$omp enddo 

      !
      !- ADJ of
      !- Note  F_fld_t(i,j,1) = 0
      k = 1
      w2_8 = (Ver_z_8%t(k)-Ver_z_8%m(k)) / (Ver_z_8%t(k)-Ver_z_8%t(k+1))

!$omp do 
      do j = j0, jn
         do i = i0, in
            F_fld_t(i,j,k+1) = w2_8* F_fld_m(i,j,k) + F_fld_t(i,j,k+1)
            F_fld_m(i,j,k)   = ZERO_8
         enddo
      enddo
!$omp enddo 

      !
      !- ADJ of
!$omp do 
      do j = j0, jn
         do k=l_nk-1,2,-1
         xx_8 = Ver_z_8%m(k)
         x1_8 = Ver_z_8%t(k-1)
         x2_8 = Ver_z_8%t(k)
         x3_8 = Ver_z_8%t(k+1)
         x4_8 = Ver_z_8%t(k+2)
         w1_8 = lag3_8(xx_8, x1_8, x2_8, x3_8, x4_8)
         w2_8 = lag3_8(xx_8, x2_8, x1_8, x3_8, x4_8)
         w3_8 = lag3_8(xx_8, x3_8, x1_8, x2_8, x4_8)
         w4_8 = lag3_8(xx_8, x4_8, x1_8, x2_8, x3_8)
            do i = i0, in
               F_fld_t(i,j,k-1) = w1_8*F_fld_m(i,j,k) + F_fld_t(i,j,k-1)
               F_fld_t(i,j,k  ) = w2_8*F_fld_m(i,j,k) + F_fld_t(i,j,k  )
               F_fld_t(i,j,k+1) = w3_8*F_fld_m(i,j,k) + F_fld_t(i,j,k+1)
               F_fld_t(i,j,k+2) = w4_8*F_fld_m(i,j,k) + F_fld_t(i,j,k+2)
               F_fld_m(i,j,k)   = ZERO_8
            enddo
         enddo
      enddo
!$omp enddo 

!$omp end parallel 

      !
      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_interp_thermo2mom_ad


!/**
   subroutine itf_adx_interp_mom2thermo_ad(F_fld_t,F_fld_m)
!
      implicit none
!
      !@objective ADJ of itf_adx_interp_mom2thermo 
!
      !@arguments
      real, dimension(:,:,:), pointer :: F_fld_m !intent(inout)
      real, dimension(:,:,:), pointer :: F_fld_t !intent(inout)
!
      !@author Monique Tanguay
!
      !@revisions
      ! v4_13 - Tanguay M.        - Adjustments GEM413
      ! v4_40 - Tanguay M.        - Revision TL/AD
!**/
#include "glb_ld.cdk"
#undef TYPE_CDK
#include "ver.cdk"
      integer :: i,j,k, i0,j0,in,jn
      real*8 xx_8,x1_8,x2_8,x3_8,x4_8,w1_8,w2_8,w3_8,w4_8,den_8
      real*8, parameter :: ZERO_8 = 0.0
      !---------------------------------------------------------------------
!
!$omp parallel private(i0,in,j0,jn,xx_8,x1_8,x2_8,x3_8,x4_8,w1_8,w2_8,w3_8,w4_8,den_8)

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
      if (G_lam) then
         if (l_west)  i0 = 3
         if (l_east)  in = l_ni - 1
         if (l_south) j0 = 3
         if (l_north) jn = l_nj - 1
      endif
      !
      !
      !- ADJ of
      !- Downward Extrapolation
      k = l_nk+1
      den_8 = 1.d0/(Ver_z_8%m(l_nk-1)-Ver_z_8%m(l_nk))
      w1_8 = (Ver_z_8%t(k)     -Ver_z_8%m(l_nk)) * den_8
      w2_8 = (Ver_z_8%m(l_nk-1)-Ver_z_8%t(k)   ) * den_8

!$omp do 
      do j = j0, jn
         do i = i0, in
            F_fld_m(i,j,l_nk-1) = w1_8*F_fld_t(i,j,k) + F_fld_m(i,j,l_nk-1)
            F_fld_m(i,j,l_nk)   = w2_8*F_fld_t(i,j,k) + F_fld_m(i,j,l_nk)
            F_fld_t(i,j,k)      = ZERO_8
         enddo
      enddo
!$omp enddo 

      !
      !- ADJ of
      k = l_nk
      w1_8 = (Ver_z_8%t(k)     -Ver_z_8%m(l_nk)) * den_8
      w2_8 = (Ver_z_8%m(l_nk-1)-Ver_z_8%t(k)   ) * den_8

!$omp do 
      do j = j0, jn
         do i = i0, in
            F_fld_m(i,j,l_nk-1) = w1_8*F_fld_t(i,j,k) + F_fld_m(i,j,l_nk-1)
            F_fld_m(i,j,l_nk)   = w2_8*F_fld_t(i,j,k) + F_fld_m(i,j,l_nk)
            F_fld_t(i,j,k)      = ZERO_8
         enddo
      enddo
!$omp enddo 

      !
      !- ADJ of
      !- Updward Extrapolation
      den_8 = 1.d0/(Ver_z_8%m(1)-Ver_z_8%m(2))
      k = 1
      w1_8 = (Ver_z_8%t(k)-Ver_z_8%m(2)) * den_8
      w2_8 = (Ver_z_8%m(1)-Ver_z_8%t(k)) * den_8

!$omp do 
      do j = j0, jn
         do i = i0, in
            F_fld_m(i,j,1) = w1_8*F_fld_t(i,j,k) + F_fld_m(i,j,1)
            F_fld_m(i,j,2) = w2_8*F_fld_t(i,j,k) + F_fld_m(i,j,2)
            F_fld_t(i,j,k) = ZERO_8
         enddo
      enddo
!$omp enddo 

      !
      !- ADJ of
      k = 2
      w1_8 = (Ver_z_8%t(k)-Ver_z_8%m(2)) * den_8
      w2_8 = (Ver_z_8%m(1)-Ver_z_8%t(k)) * den_8

!$omp do 
      do j = j0, jn
         do i = i0, in
            F_fld_m(i,j,1) = w1_8*F_fld_t(i,j,k) + F_fld_m(i,j,1)
            F_fld_m(i,j,2) = w2_8*F_fld_t(i,j,k) + F_fld_m(i,j,2)
            F_fld_t(i,j,k) = ZERO_8
         enddo
      enddo
!$omp enddo 

      !
      !- ADJ of
!$omp do 
      do j = j0, jn
         do k = l_nk-1,3,-1
         xx_8 = Ver_z_8%t(k)
         x1_8 = Ver_z_8%m(k-2)
         x2_8 = Ver_z_8%m(k-1)
         x3_8 = Ver_z_8%m(k  )
         x4_8 = Ver_z_8%m(k+1)
         w1_8 = lag3_8(xx_8, x1_8, x2_8, x3_8, x4_8)
         w2_8 = lag3_8(xx_8, x2_8, x1_8, x3_8, x4_8)
         w3_8 = lag3_8(xx_8, x3_8, x1_8, x2_8, x4_8)
         w4_8 = lag3_8(xx_8, x4_8, x1_8, x2_8, x3_8)
            do i = i0, in
               F_fld_m(i,j,k-2) = w1_8*F_fld_t(i,j,k) + F_fld_m(i,j,k-2)
               F_fld_m(i,j,k-1) = w2_8*F_fld_t(i,j,k) + F_fld_m(i,j,k-1)
               F_fld_m(i,j,k  ) = w3_8*F_fld_t(i,j,k) + F_fld_m(i,j,k  )
               F_fld_m(i,j,k+1) = w4_8*F_fld_t(i,j,k) + F_fld_m(i,j,k+1)
               F_fld_t(i,j,k)   = ZERO_8
            enddo
         enddo
      enddo
!$omp enddo 

!$omp end parallel 
!
      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_interp_mom2thermo_ad


!/**
   subroutine itf_adx_combine_levels_ad (F_su,F_um,F_ut,F_nk)
!
      implicit none
!
#include "glb_ld.cdk"
!
      !@objective ADJ of itf_adx_combine_levels  
!
      !@arguments
      integer :: F_nk
      real,dimension(l_minx:l_maxx,l_miny:l_maxy,F_nk) :: &
           F_su !O - combined field on both level types
      real,dimension(:,:,:),pointer :: &
           F_um, & !I - field on momentum levels
           F_ut    !I - field on thermo levels
!
      !@author Monique Tanguay
!
      !@revisions
      ! v4_13 - Tanguay M.        - Adjustments GEM413
      ! v4_40 - Tanguay M.        - Revision TL/AD
!**/
      integer i,j,k,k2
      real*8, parameter :: ZERO_8 = 0.0
      !---------------------------------------------------------------------
      
!$omp parallel private(i,j,k,k2)

      k2=0
!$omp do 
      do k = 2, F_nk, 2
!!!      k2 = k2 + 1
         k2 = k/2
         do j = l_miny, l_maxy
            do i = l_minx,l_maxx
               F_um(i,j,k2) = F_su(i,j,k) + F_um(i,j,k2)
               F_su(i,j,k)  = ZERO_8
            enddo
         enddo
      enddo
!$omp enddo 

       
      k2 = 0
!$omp do 
      do k = 1, F_nk, 2
!!!      k2 = k2+1
         k2 = k/2+1
         do j = l_miny, l_maxy
            do i = l_minx,l_maxx
               F_ut(i,j,k2) = F_su(i,j,k)  + F_ut(i,j,k2) 
               F_su(i,j,k)  = ZERO_8
            enddo
         enddo
      enddo
!$omp enddo 

!$omp end parallel 

      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_combine_levels_ad
!
end subroutine itf_adx_get_winds2_ad
