!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

#include "stop_mpi.h"
#include "msg.h"

!/**
subroutine adx_pole0s2_ad (F_fld_adw, &
                           F_aminx,F_amaxx,F_aminy,F_amaxy,F_minx,F_maxx,F_miny,F_maxy,F_nk,&
                           F_pol0_L, F_extend_L, F_is_south_L)
   implicit none
#include <arch_specific.hf>
!
#include "adx_dims.cdk"
#include "adx_grid.cdk"
!
   !@objective ADJ of adx_pole0s 
!
   !@arguments
   logical :: F_is_south_L !I, .true. if south pole
   logical :: F_extend_L   !I, Extend field beyond poles
   logical :: F_pol0_L     !I, Set values=0 around poles (e.g. 4 winds)
   integer :: F_aminx,F_amaxx,F_aminy,F_amaxy !I, adw local array bounds
   integer :: F_minx,F_maxx,F_miny,F_maxy     !I, model's local array bounds
   integer :: F_nk         !I, number of levels
   real, dimension(F_aminx:F_amaxx,F_aminy:F_amaxy,F_nk) :: &
        F_fld_adw          !O, fld on adw-grid
!
   !@author Monique Tanguay
!
   !@revisions
   ! v4_13 - Tanguay M.        - Adjustments GEM413
   ! v4_40 - Tanguay M.        - Revision TL/AD
!**/
   integer :: j1, j2, i, k
   real*8  :: ww_8
   real*8, parameter :: ZERO_8 = 0.0
   !---------------------------------------------------------------------
   call msg(MSG_DEBUG,'adx_pole0s_ad')
   !
   !Zero adjoint variables
   !----------------------
   ww_8 = ZERO_8 
   !
   if (F_is_south_L) then
      j1 = 0
      j2 = 1
   else
      j1 = adx_lnj+1
      j2 = adx_lnj
   endif

   if (F_extend_L) then
      !ADJ of
      !extension of a scalar field beyond the poles
      call adx_polx3_ad(F_fld_adw, F_is_south_L, &
           F_aminx,F_amaxx,F_aminy,F_amaxy, &
           adx_lni,adx_lnj, adx_halox,adx_haloy, F_nk)
   endif
   if  (F_pol0_L) then
      !ADJ of
      !set values at the pole = 0.0
!$omp do 
      do k = F_nk,1,-1
         do i = F_amaxx,F_aminx,-1
            F_fld_adw(i,j1,k) = 0.0
         enddo
      enddo
!$omp enddo 
   else
      !ADJ of
      !compute weighted average around the pole
!$omp do 
      do k = F_nk,1,-1
         do i = F_amaxx,F_aminx,-1
            ww_8              = dble(F_fld_adw(i,j1,k)) + ww_8
            F_fld_adw(i,j1,k) = ZERO_8
         enddo
         do i = adx_lni,1,-1
            F_fld_adw(i,j2,k) = adx_wx_8(i) * ww_8 + F_fld_adw(i,j2,k) 
         enddo
         ww_8 = 0.D0
      enddo
!$omp enddo 
   endif

   call msg(MSG_DEBUG,'adx_pole0s_ad [end]')
   !---------------------------------------------------------------------
   return
end subroutine adx_pole0s2_ad
