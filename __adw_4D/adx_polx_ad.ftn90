!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

#include "stop_mpi.h"

!/**
subroutine adx_polx3_ad(F_field, F_sud, F_aminx,F_amaxx,F_aminy,F_amaxy, &
                        F_lni,F_lnj, F_halox,F_haloy, F_nk )
   implicit none
#include <arch_specific.hf>
!
   !@objective ADJ of adx_polx3 
!
   !@arguments
   integer :: F_lni, F_lnj, F_nk !I, Field computational area dims
   integer :: F_halox, F_haloy   !I, Field halo dims
   integer :: F_aminx,F_amaxx,F_aminy,F_amaxy !I, adw local array bounds
   logical :: F_sud              !I, .T.=S-Pole ; .F.=N-Pole
   real,dimension(F_aminx:F_amaxx,F_aminy:F_amaxy, F_nk):: &
        F_field                  !I/O, field to treat
!
   !@author Monique Tanguay
!
   !@revisions
   ! v4_13 - Tanguay M.        - Adjustments GEM413
   ! v4_40 - Tanguay M.        - Revision TL/AD
!**/
#include "adx_grid.cdk"
#include "adx_poles.cdk"

   integer :: ns, nd, i, i2, k
   real :: e(0:F_lni+49) !TODO: why 49?

   ! Basic statement functions for cubic int. on a non-uniform mesh
   real triprd, delta, poly
   real*8 y_8, y1_8, y2_8, y3_8, y4_8
   real v1, v2, v3, v4
   triprd(y1_8, y2_8, y3_8, y4_8) = (y1_8 - y2_8) * (y1_8 - y3_8) * (y1_8 - y4_8)

   ! triprd is fully symmetric in y2, y3, y4.
   ! and hence delta is symmetric in y2, y3, y4.
   delta(y_8, y1_8, y2_8, y3_8, y4_8) = triprd(y_8, y2_8, y3_8, y4_8) / triprd(y1_8, y2_8, y3_8, y4_8)

   ! delta is a cubic in y which asumes the value 1.0 at y = y1,
   ! and the value 0.0 for y = y2, y3, y4.
   ! consequently a cubic which takes the values v1, v2, v3, v4 at
   ! y = y1, y2, y3, y4, is
   poly(v1, v2, v3, v4, y_8, y1_8, y2_8, y3_8, y4_8) = &
        v1 * delta(y_8, y1_8, y2_8, y3_8, y4_8) + &
        v2 * delta(y_8, y2_8, y1_8, y3_8, y4_8) + &
        v3 * delta(y_8, y3_8, y1_8, y2_8, y4_8) + &
        v4 * delta(y_8, y4_8, y1_8, y2_8, y3_8)
   real*8, parameter :: ZERO_8 = 0.0
   !---------------------------------------------------------------------
   ns = F_lnj
   if (F_sud) ns = 1
   nd = F_lnj+2
   if (F_sud) nd = -1
!
!  Zero adjoint variables
!  ----------------------
   do i = 1,(F_lni+50)
      e(i-1)  = 0.0
   enddo
!
!$omp do
   do k = F_nk,1,-1
!
      do i = F_halox,1,-1
         F_field(F_lni+1-i,nd,k) = F_field(    1-i,nd,k) + F_field(F_lni+1-i,nd,k)
         F_field(      1-i,nd,k) = ZERO_8
         F_field(        i,nd,k) = F_field(F_lni+i,nd,k) + F_field(        i,nd,k)
         F_field(F_lni+  i,nd,k) = ZERO_8
      enddo
!    
!     ADJ of
!     ----------------------------------------------------------------
!     do i = 1, F_lni
!        i2 = adx_iln(i)
!        F_field(i,nd,k) = poly(e(i2-1),e(i2),e(i2+1),e(i2+2),adx_lnr_8(i), &
!             adx_xg_8(i2-1),adx_xg_8(i2),adx_xg_8(i2+1),adx_xg_8(i2+2))
!     enddo
!     ----------------------------------------------------------------
!
      do i=F_lni,1,-1
         i2 = adx_iln(i)
!
         y_8  = adx_lnr_8(i)
         y1_8 = adx_xg_8(i2-1) 
         y2_8 = adx_xg_8(i2) 
         y3_8 = adx_xg_8(i2+1) 
         y4_8 = adx_xg_8(i2+2) 
!
         e(i2+2)    = F_field(i,nd,k) * delta( y_8, y4_8, y1_8, y2_8, y3_8 ) + e(i2+2)
         e(i2+1)    = F_field(i,nd,k) * delta( y_8, y3_8, y1_8, y2_8, y4_8 ) + e(i2+1)
         e(i2)      = F_field(i,nd,k) * delta( y_8, y2_8, y1_8, y3_8, y4_8 ) + e(i2)
         e(i2-1)    = F_field(i,nd,k) * delta( y_8, y1_8, y2_8, y3_8, y4_8 ) + e(i2-1)
         F_field(i,nd,k) = ZERO_8
!
      enddo
!
      do i=F_lni,1,-1
         F_field(i,ns,k) = e(i) + F_field(i,ns,k)
               e(i)      = ZERO_8
      enddo
!
      F_field(2,    ns,k) = e(F_lni+2) + F_field(2,    ns,k)
      e(F_lni+2)          = ZERO_8
      F_field(1,    ns,k) = e(F_lni+1) + F_field(1,    ns,k)
      e(F_lni+1)          = ZERO_8
      F_field(F_lni,ns,k) = e(0)       + F_field(F_lni,ns,k)
      e(0)                = ZERO_8
!
   enddo
!$omp enddo

   !---------------------------------------------------------------------
   return
end subroutine adx_polx3_ad
