!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!opyright (C) 2001  MSC-RPN COMM  %%%MC2%%%
!**s/r out_phy
#include "model_macros_f.h"
!
      subroutine out_phy ( bus_o, F_ni, F_nj, stepno )
      use out_vref_mod, only: out_vref

      implicit none
!
      integer F_ni,F_nj,ni,nj,stepno
      real bus_o(F_ni*F_nj,*)
!
!AUTHOR     Michel Desgagne                July 2004 (MC2)
!
!REVISION
! v3_20 - Lee V.            -  initial GEMDM version
! v3_21 - Lee V.            -  bugfix for LAM output
! v3_30 - McTaggart-Cowan R.-  allow for user-defined domain tag extensions
! v3_31 - Lee V.            - kind is set to 2 (press) for 2D fields, not -1
! v4_03 - Lee V.            - modification of Out_etik_S in out_sgrid only
! v4_05 - Lepine M.         - VMM replacement with GMM
! v4_06 - Lee V.            - out_sgrid,out_href interface changed
!
!
!OBJECT
!    Gather the index of physics variables to write on disk 
!    for the current timestep.
!
!ARGUMENTS
!    NAMES     I/O  TYPE  A/S        DESCRIPTION
!
!   fni         I    I    S    folded dimension along X
!   fnj         I    I    S    folded dimension along Y
!   l_ni        I    I    S    computational hor. dimension along X
!   l_nj        I    I    S    computational hor. dimension along Y
!   ni          I    I    S    regular dimension along X
!   nj          I    I    S    regular dimension along Y
!   stepno      I    I    S    step number
!
!IMPLICIT
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "dcst.cdk"
#include "lctl.cdk"
#include "lun.cdk"
#include "out3.cdk"
#include "geomn.cdk"
#include "init.cdk"
#include "rstr.cdk"
#include "out.cdk"
#include "itf_phy_buses.cdk"
#include "obus.cdk"
#include "grd.cdk"
#include "grid.cdk"
#include "level.cdk"
#include "outp.cdk"
#include "ptopo.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "vt1.cdk"
#include "cstv.cdk"
#include "grdc.cdk"
!
!*
      character*4 ext_S
      character*6 etikadd_S
      character*15 datev,pdate
      character*1024 filen
      integer i,j,k,mult,nk_o,nk_ot,levset,ii,jj,kk,ip3,ig1,gridset
      integer, dimension (:), allocatable :: ind_o
      integer irff(100),key,err,bcs_ext,unf,cobussiz
      integer grille_x0,grille_x1,grille_y0,grille_y1
      logical periodx_L
      real rff(100)
      real p0(LDIST_SHAPE)
      real, dimension(:,:), allocatable :: cobusval
      real*8 dayfrac, sec_in_day
      parameter (sec_in_day=86400.0d0)
!----------------------------------------------------------------------
!
      if (Obus_top.le.0) then
         if (Lun_out.gt.0) write(Lun_out,7002) Lctl_step
         goto 887
      else
         if (Lun_out.gt.0) write(Lun_out,7001) Lctl_step,trim(Out_laststep_S)
      endif
!
!     setup of ip3 and modifs to label
!
      call tmg_start0(67, 'OUT_PHY  ')
      ip3=0
      etikadd_S = ' '
      ext_S=""
      if (Out3_ip3.eq.-1) ip3 = stepno
      if (Out3_ip3.gt.0 ) ip3 = Out3_ip3

      call v4d_out_ipext (ip3, ext_S, etikadd_S)

!     setup of filename extension if needed
      if ( ((Init_balgm_L).and.(.not.Rstri_idon_L)).and. &
           ((stepno.gt.(Init_dfnp-1)/2)) ) &
             ext_S = '_dgf'

!     get st1 for reference field output
      gmmstat = gmm_get(gmmk_st1_s,st1,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'out_phy ERROR at gmm_get(st1)'
      p0(1:l_ni,1:l_nj) = exp(st1(1:l_ni,1:l_nj))*Cstv_pref_8

!########## REGULAR OUTPUT #######################################
!
!     ON sortie_p sets
!
      do 120 kk=1,Outp_sets
         if ( Outp_dostep_L(kk) )then
         periodx_L=.false.
         gridset = Outp_grid(kk)
         levset= Outp_lev(kk)
         if (.not.G_lam .and. (Grid_x1(gridset)-Grid_x0(gridset)+1).eq. G_ni ) periodx_L= .true.
         ig1 = Grid_ig1(gridset)
         bcs_ext = 0
         if (G_lam) bcs_ext = Grd_bsc_ext1
         grille_x0 = max( 1   +bcs_ext, Grid_x0(gridset) )
         grille_x1 = min( G_ni-bcs_ext, Grid_x1(gridset) )
         grille_y0 = max( 1   +bcs_ext, Grid_y0(gridset) )
         grille_y1 = min( G_nj-bcs_ext, Grid_y1(gridset) )
         if (G_lam .and. &
              ( grille_x0.ne.Grid_x0(gridset).or. &
              grille_x1.ne.Grid_x1(gridset).or. &
              grille_y0.ne.Grid_y0(gridset).or. &
              grille_y1.ne.Grid_y1(gridset) ) ) &
              ig1=Grid_ig1(gridset)+100
         call out_sgrid(grille_x0,grille_x1,grille_y0,grille_y1, &
              ig1,Grid_ig2(gridset), &
              periodx_L, Grid_stride(gridset), &
              Grid_etikext_s(gridset),etikadd_S )
         nk_o =  Level_max(levset)
         allocate (ind_o(nk_o+2))
         call out_slev(Level_types(Level_typ_indx(levset)),Level(1,levset), &
              ind_o,nk_o,nk_ot,G_nk,Level_kind_ip1,'p')

         call out_sfile (Out3_closestep,stepno,ip3,ext_S)

         call out_href(Geomn_longs,Geomn_latgs)
         call out_vref(p0,l_minx,l_maxx,l_miny,l_maxy,ig1=ig1)

         do ii=1, Outp_var_max(kk)
            do j=1,Obus_top
               if ( Outp_var_S(ii,kk).eq. Obus_var_S(j) ) then
!
                    if (obus_shp(j).gt.1) then
!                   3D field
                       if (obus_stag(j).eq.0) then
                           call ecris_fst2(bus_o(1,obus_offset(j)), &
                             1,l_ni,1,l_nj,Ver_hyb%t,obus_var_s(j), &
                             Obus_mul(j),Obus_add(j),Out_kind,G_nk+2,ind_o,nk_ot, &
                             Outp_nbit(ii,kk) )
                       else
!                   3D field staggerred
                        do i=1,G_nk
                           rff(i)= Ver_hyb%m(i)
                        enddo
                        rff(G_nk+1)=Ver_hyb%t(G_nk+1)
                        rff(G_nk+2)=Ver_hyb%t(G_nk+2)
                        call ecris_fst2(bus_o(1,obus_offset(j)), &
                            1,l_ni,1,l_nj,rff,obus_var_s(j), &
                            Obus_mul(j),Obus_add(j),Out_kind,G_nk+2,ind_o,nk_ot, &
                            Outp_nbit(ii,kk) )
                       endif
                    else
!                      2D field-multiple
                       if ( obus_mult(j).gt.1) then
                          do mult=1,obus_mult(j)
                              rff(mult)= mult
                              irff(mult)=mult
                          enddo
                          call ecris_fst2(bus_o(1,obus_offset(j)), &
                          1,l_ni,1,l_nj,rff,obus_var_s(j), &
                          Obus_mul(j),Obus_add(j),3,obus_mult(j), &
                          irff,obus_mult(j), Outp_nbit(ii,kk) )
                       else
!                      2d field
                          call ecris_fst2(bus_o(1,obus_offset(j)), &
                                   1,l_ni,1,l_nj,0.0,obus_var_s(j), &
                                   Obus_mul(j),Obus_add(j),  2,1,1,1,  &
                                   Outp_nbit(ii,kk) )
                       endif
                    endif
               endif
            enddo
         enddo
!
         deallocate (ind_o)
!
         call out_cfile
         endif
!
  120 continue

      call tmg_stop0(67)

 887  continue

! Cascading BUSPER variables is currenlty disable.
! Variables should be output through .fst files (outcfg.out)
! and presented back to the model through -anal option of Um_runmod.ksh

      goto 999

      if ( (Grdc_ndt.gt.0) .and. (stepno.eq.Grdc_start) ) then
!     Only done once in the integration
         if (Lun_out.gt.0) write(Lun_out,8001) Lctl_step,trim(Out_laststep_S)
         call out_sgrid (Grdc_gid,Grdc_gif,Grdc_gjd,Grdc_gjf, &
                                         0,0,.false.,1,'','')
         cobussiz=p_bper_siz/(p_ni)
         allocate (cobusval(l_ni*l_nj,cobussiz))
         call out_phycasc ( j, stepno, cobusval )

         call datf2p (pdate,Out3_date)
         dayfrac = dble(stepno) * Cstv_dt_8 / sec_in_day
         call incdatsd (datev,pdate,dayfrac)

         if (Grdc_initphy_L) then ! Dump whole permanent bus
            call out_perbus_3df( cobusval,l_ni,l_nj, &
                            datev,Grdc_gid,Grdc_gif,Grdc_gjd,Grdc_gjf)
         else ! Dump only minimum physics fields out for cascade grid
            call out_phy_3df   ( cobusval,l_ni,l_nj, &
                            datev,Grdc_gid,Grdc_gif,Grdc_gjd,Grdc_gjf)
         endif
         deallocate (cobusval)
      endif
!
 7001 format(/,' OUT_PHY- WRITING PHYSICS OUTPUT FOR STEP (',I8,') in directory: ',a)
 8001 format(/,' OUT_PHY- WRITING CASCADE OUTPUT FOR STEP (',I8,') in directory: ',a)
 7002 format(/,' OUT_PHY- NO PHYSICS OUTPUT FOR STEP (',I8,')')
!!
!----------------------------------------------------------------------
!
 999  return
      end


