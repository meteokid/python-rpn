!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r initial - Performs initialisation
!
#include "model_macros_f.h"
!
      subroutine initial (F_rstrt_L)
!
      implicit none
#include <arch_specific.hf>
!
      logical F_rstrt_L
!
!author 
!     Michel Roch - rpn - june 1993
!
!revision
! v2_00 - Desgagne M.       - initial MPI version
! v2_10 - Lee V.            - call to p_outphyinit
! v3_30 - Desgagne M.       - moved bkup_L to gem_run
! v3_31 - McTaggart-Cowan R.- correction for Vtopo mode in digflt
!
!object
!	
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! F_rstrt_L     O         TRUE if a restart is required
!----------------------------------------------------------------
!
!implicits
#include "gmm.hf"
#include "glb_ld.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "init.cdk"
#include "lctl.cdk"
#include "lun.cdk"
#include "p_geof.cdk" 
#include "vtopo.cdk"
#include "step.cdk"
#include "rstr.cdk"
#include "schm.cdk"
!
      type(gmm_metadata) :: meta2d
      integer n, pndfnph, pnerr, pnlkey1(2), pnfirst, pnlast, gmmstat
      real    prn, promegc, prsum, prwin1, prwin2
!
!     ---------------------------------------------------------------
!
      if ( mod(Init_dfnp,2) .ne. 1 ) then
         if (Lun_out.gt.0) write(Lun_out,2010) Init_dfnp
         call handle_error(-1,'initial','INITIAL')
      endif
!
      if (Lun_out.gt.0) write(Lun_out,2020) Init_dfnp
!
!********************************************************************
!
      pndfnph = (Init_dfnp - 1) / 2

      call hpalloc(Init_dfco_, pndfnph+1, pnerr,1)

      promegc = (2.0 * Dcst_pi_8) / Init_dfpl_8
      prwin1  = Dcst_pi_8 / real(pndfnph + 1)
!
!********************************************************************
!
      Init_dfco(0) = promegc * Cstv_dt_8 / Dcst_pi_8
      prsum        = Init_dfco(0)
!
!********************************************************************
!
      do n=1,pndfnph
         prwin2 = 1.0
         prn    = real(n)
!
         if ( Init_dfwin_L ) then
            prwin2 = prn * prwin1
            prwin2 = sin(prwin2) / prwin2
         endif
!
         Init_dfco(n) = prwin2 *dsin(prn * promegc * Cstv_dt_8) /  &
                        (prn * Dcst_pi_8)
         prsum     = prsum + 2.0 * Init_dfco(n)
      end do
!
      if (Lun_out.gt.0) write(Lun_out,2030)
      if (Lun_out.gt.0)  &
          write(Lun_out,*) (Init_dfco(n),n=0,pndfnph), prsum
!
!********************************************************************
!
      do n=0,pndfnph
         Init_dfco(n) = Init_dfco(n) / prsum
      end do
!
      prsum = Init_dfco(0)
      do n=1,pndfnph
         prsum = prsum + 2.0 * Init_dfco(n)
      end do
!
      if (Lun_out.gt.0) write(Lun_out,2040)
      if (Lun_out.gt.0) &
          write(Lun_out,*) (Init_dfco(n),n=0,pndfnph), prsum
!
!********************************************************************
!
      if ( .not. Rstri_rstn_L ) call digflt()
!
      if (Lun_out.gt.0) write(Lun_out,1000) Lctl_step,Init_dfnp-1
!
      call gem_run (.true., F_rstrt_L)
!
      if (Lctl_step.eq.Init_dfnp-1) then
         Rstri_idon_L = .true.
         call ta2t1tx()
         Lctl_step = (Init_dfnp-1)/2
         if (Vtopo_start >= 0 .and. Lctl_step-Vtopo_start+1 <= Vtopo_ndt) Vtopo_L = .true.
         if (Vtopo_L) then
            gmmstat = gmm_get(gmmk_fis0_s,fis0,meta2d)
            call var_topo2 (fis0, real(Lctl_step), LDIST_DIM)
            call rpn_comm_xch_halo (fis0,LDIST_DIM,l_ni,l_nj,1,&
                    G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
         endif
         if (Lun_out.gt.0) write(Lun_out,1050) Lctl_step
      endif
!
 1000 format(/,' =====> DIGITAL FILTER INITIALIZATION SCHEME: ', &
               'TIMESTEP ',i3,' to TIMESTEP ',i3,/' ',73('='))
 1050 format(/,' =====> DIGITAL FILTER INITIALIZATION SCHEME: ', &
               'COMPLETED',/8x,'LAST TIMESTEP COMPLETED RESET TO:', &
               I5,/' ',55('='))
 2010 format(/,'PROBLEM: THE VARIABLE Init_dfnp = ',i4,'  IS EVEN', &
      /,'==============================================')
 2020 format(/,'PREPARATION OF DIGITAL FILTER PARAMETERS', &
      /,'AND COEFFICIENTS (S/R INITIAL)          ', &
      /,'========================================',/,'Init_dfnp  = ',i4)
 2030 format(/,'Digital filter coefficients and sum', &
      /,'before normalization               ')
 2040 format(/,'Digital filter coefficients and sum', &
      /,'after normalization                ')
!
!     ---------------------------------------------------------------
!
      return
      end
