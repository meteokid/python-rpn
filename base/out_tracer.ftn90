!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r out_tracer - calculate and output tracer fields
!
#include "model_macros_f.h"
!
      subroutine out_tracer (F_wlnph_ta,DIST_DIM,F_nk,levset,set)
!
      implicit none
!
      integer F_nk,DIST_DIM,levset,set
      real F_wlnph_ta(DIST_SHAPE,F_nk+2)
!
!author
!     Lee V.                    - rpn May 2004
!
!revision
! v3_20 - Lee V.            - initial MPI version (from bloctr     v3_12)
! v3_30 - Lee V.            - option to clip tracers with Out3_cliph_L
! v4_05 - Lee V.            - adaptation to GMM
! v4_40 - Lee V.            - change in argument call for this routine & prgen
!
!object
!     output all the tracer fields
!	
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! F_dostep     I    - array containing indices corresponding to the
!                     timestep sets that requires output at this time step.
! F_dostep_max I    - size of F_dostep array
!
!
!implicits
#include "gmm.hf"
#include "glb_ld.cdk"
#include "lun.cdk"
#include "out3.cdk"
#include "out.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "tr3d.cdk"
#include "type.cdk"
#include "ver.cdk"
!
!
!*
      integer i,j,k, ii,n
      integer i0,in,j0,jn,nko,kind,istat
!
!
      integer, dimension(:), allocatable::indo
      real ,dimension(:), allocatable::prprlvl,rf
      real ,dimension(:,:,:), allocatable:: w4
      real t4(LDIST_SHAPE,F_nk+2) 
      logical outvar_L
      real, pointer    , dimension(:,:,:) :: tr1
      type(gmm_metadata) :: mymeta3d
!
!_______________________________________________________________________
!
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
!
      if (Level_typ_S(levset) .eq. 'M') then
!_______________________________________________________________________
!
!     1.0A   Output of tracer variables on ETA levels
!_______________________________________________________________________
!
        kind=Level_kind_ip1
!       Setup the indexing for output
          allocate (indo( min(Level_max(levset),Level_thermo) ))
          call out_slev(Level(1,levset), Level_max(levset), &
                        Level_thermo,indo,nko)
      do ii=1,Outd_var_max(set)
         outvar_L=.false.
         do n=1,Tr3d_ntr
           if (Outd_var_S(ii,set)(1:2).eq.Tr3d_name_S(n)(1:2)) then
               if (Outd_var_S(ii,set)(3:4).eq.'T0') then
                   nullify (tr1)
                   istat=gmm_get('TR/'//Tr3d_name_S(n)(1:2)//':M',tr1,mymeta3d)
                   if (.not.GMM_IS_ERROR(istat)) outvar_L=.true.
                elseif (Outd_var_S(ii,set)(3:4).eq.'T1') then
                   nullify (tr1)
                   istat=gmm_get('TR/'//Tr3d_name_S(n)(1:2)//':P',tr1,mymeta3d)
                   if (.not.GMM_IS_ERROR(istat)) outvar_L=.true.
                endif
                cycle
           endif
         enddo
         if (outvar_L) then
             if (Out3_cliph_L) then
                 do k=1,F_nk+2
                 do j=1,l_nj
                 do i=1,l_ni
                    t4(i,j,k) = amax1(tr1(i,j,k), 0. )
                 enddo
                 enddo
                 enddo
                 call ecris_fst2(t4,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                   Outd_var_S(ii,set),1.0,0.0,kind,F_nk+2,indo,nko,  &
                   Outd_nbit(ii,set) )
             else
                 call ecris_fst2(tr1,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                   Outd_var_S(ii,set),1.0,0.0,kind,F_nk+2,indo,nko,  &
                   Outd_nbit(ii,set) )
             endif
         endif
      enddo
      deallocate(indo)

      else
!_______________________________________________________________________
!
!     1.0B   Output of tracer variables on PRESSURE levels
!_______________________________________________________________________
!
        kind=2

!       Setup the indexing for output
        nko=Level_max(levset)
        allocate ( indo(nko), rf(nko) , prprlvl(nko) )
        do i = 1, nko
           indo(i)=i
           rf(i)= Level(i,levset)
           prprlvl(i) = rf(i) * 100.0
        enddo
        allocate(w4(LDIST_SHAPE,nko))
      do ii=1,Outd_var_max(set)
         outvar_L=.false.
         do n=1,Tr3d_ntr
           if (Outd_var_S(ii,set)(1:2).eq.Tr3d_name_S(n)(1:2)) then
               if (Outd_var_S(ii,set)(3:4).eq.'T0') then
                   nullify (tr1)
                   istat=gmm_get('TR/'//Tr3d_name_S(n)(1:2)//':M',tr1,mymeta3d)
                   if (.not.GMM_IS_ERROR(istat)) outvar_L=.true.
                elseif (Outd_var_S(ii,set)(3:4).eq.'T1') then
                   nullify (tr1)
                   istat=gmm_get('TR/'//Tr3d_name_S(n)(1:2)//':P',tr1,mymeta3d)
                   if (.not.GMM_IS_ERROR(istat)) outvar_L=.true.
                endif
                cycle
           endif
         enddo
         if (outvar_L) then
             call verder (t4,tr1,F_wlnph_ta,2.0,2.0, &
                         l_minx,l_maxx,l_miny,l_maxy,F_nk+2,i0,in,j0,jn)
             call prgen( w4, tr1, t4, F_wlnph_ta, prprlvl,nko, &
                         Out3_cubzt_L, l_minx,l_maxx,l_miny,l_maxy, F_nk+2,&
                         1,l_ni,1,l_nj)
            if (Outd_filtpass(ii,set).gt.0) &
                call filter(w4,Outd_filtpass(ii,set), &
                            Outd_filtcoef(ii,set),'G', .false., &
                            l_minx,l_maxx,l_miny,l_maxy, nko)
            if (Out3_cliph_L) then
               do k=1,nko
               do j=1,l_nj
               do i=1,l_ni
                  w4(i,j,k) = amax1(w4(i,j,k), 0. )
               enddo
               enddo
               enddo
            endif
            call ecris_fst2(w4,l_minx,l_maxx,l_miny,l_maxy,rf, &
               Outd_var_S(ii,set),1.0,0.0,kind,nko,  &
               indo, nko, Outd_nbit(ii,set) )

        endif
      enddo
      deallocate(indo,rf,prprlvl,w4)

      endif
! ___________________________________________________________________
!

      return
      end
