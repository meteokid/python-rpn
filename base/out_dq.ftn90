!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r out_dq - calculate and output divergence and vorticity fields
!
#include "model_macros_f.h"
!
      subroutine out_dq (F_wlnph_m,DIST_DIM, nk,levset,set)
!
      implicit none
#include <arch_specific.hf>
!
      integer nk,DIST_DIM,levset,set

      real F_wlnph_m(DIST_SHAPE,nk+1)
!
!author
!     james caveen/andre methot - rpn july/nov 1995
!
!revision
! v2_00 - Lee V.            - initial MPI version (from out_dq v1_03)
! v2_21 - J. P. Toviessi    - set dieze (#) slab output and rename 
! v2_21                       truncate model output names to 4 characters
! v2_30 - Lee V.            - reorganize slab output to be more efficient
! v2_32 - Lee V.            - reduce dynamic allocation size
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_21 - Lee V.            - Output optimization
! v3_30 - Lee V.            - Bug correction for LAM
! v4_05 - Lee V.            - adaptation to GMM
! v4_40 - Lee V.            - change in argument call for this routine & prgen
!
!object
!     output all the fields related to horizontal vorticity
!     and horizontal divergence.
!	
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! ut1        I    - U wind at T1
! vt1        I    - V wind at T1
! F_wlnph_m      I    - log of      
!
!
!implicits
#include "gmm.hf"
#include "glb_ld.cdk"
#include "lun.cdk"
#include "out3.cdk"
#include "out.cdk"
#include "outd.cdk"
#include "dcst.cdk"
#include "vt1.cdk"
#include "geomg.cdk"
#include "geomn.cdk"
#include "level.cdk"
#include "lctl.cdk"
#include "type.cdk"
#include "ver.cdk"
!
!
!*
      type(gmm_metadata) :: mymeta
      integer i,j,k, ii,j00, istat
      integer i0,in,j0,jn
      real deg2rad
! ___________________________________________________________________
!
!     1.0     initialization of data
!_______________________________________________________________________
!
      integer pnds, pnq3, pnqs, pndd, pnqq, pnqr, psum, nko,kind
      integer, dimension(:), allocatable::indo
      integer nbit(0:Outd_var_max(set)+1),filt(0:Outd_var_max(set)+1)
      real    coef(0:Outd_var_max(set)+1)
      integer :: lastdt = -1
      real, dimension(:,:,:),pointer :: t1,t2,t3,t4,t5,t6,t7,t8
      real, dimension(:,:), pointer :: corio
      save lastdt,t1,t2,t3,t4,t5,t6,t7,t8,corio
!
      real ,dimension(:,:,:), allocatable:: w1,w2
      real ,dimension(:), allocatable::prprlvl,rf
      real uu(minx:maxx,miny:maxy,G_nk+1)
      real vv(minx:maxx,miny:maxy,G_nk+1)
      real w11(minx:maxx,miny:maxy,nk+1)
      real t9(minx:maxx,miny:maxy,nk+1)
!
!_______________________________________________________________________
!
      pnds=0
      pnq3=0
      pnqs=0
      pndd=0
      pnqq=0
      pnqr=0

      do ii=0,Outd_var_max(set)
         coef(ii)=0.0
         filt(ii)=0
         nbit(ii)=0
      enddo

      do ii=1,Outd_var_max(set)
        if (Outd_var_S(ii,set).eq.'DS') pnds=ii
        if (Outd_var_S(ii,set).eq.'Q3') pnq3=ii
        if (Outd_var_S(ii,set).eq.'QS') pnqs=ii
        if (Outd_var_S(ii,set).eq.'DD') pndd=ii
        if (Outd_var_S(ii,set).eq.'QQ') pnqq=ii
        if (Outd_var_S(ii,set).eq.'QR') pnqr=ii
        nbit(ii)=Outd_nbit(ii,set)
        filt(ii)=Outd_filtpass(ii,set)
        coef(ii)=Outd_filtcoef(ii,set)
      enddo
      psum=pnds+pnq3+pnqs+pndd+pnqq+pnqr
      if (psum.eq.0)return
!_______________________________________________________________________

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj

!_______________________________________________________________________
!
!     2.0     Calculation  DS, Q3
!_______________________________________________________________________
!
      If (lastdt .eq. -1) then
          allocate ( corio(minx:maxx,miny:maxy) ) 
          allocate (  t1(minx:maxx,miny:maxy,nk+1) )
          allocate (  t2(minx:maxx,miny:maxy,nk+1) )
          allocate (  t3(minx:maxx,miny:maxy,nk+1) )
          allocate (  t4(minx:maxx,miny:maxy,nk+1) )
          allocate (  t5(minx:maxx,miny:maxy,nk+1) )
          allocate (  t6(minx:maxx,miny:maxy,nk+1) )
          allocate (  t7(minx:maxx,miny:maxy,nk+1) )
          allocate (  t8(minx:maxx,miny:maxy,nk+1) )
!         Calculate coriolis parameter
          deg2rad    = acos( -1.0)/180.
          do j=1,l_nj
          do i=1,l_ni
             corio(i,j) = 2.0 * Dcst_omega_8 * sin(Geomn_latrx(i,j)*deg2rad)
          end do
          end do
      endif

      if (lastdt .ne. Lctl_step) then

          istat = gmm_get(gmmk_ut1_s,ut1,mymeta)
          istat = gmm_get(gmmk_vt1_s,vt1,mymeta)

          uu = ut1
          vv = vt1

          call rpn_comm_xch_halo (uu,LDIST_DIM,l_niu,l_nj,G_nk+1, &
               G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
          call rpn_comm_xch_halo (vv,LDIST_DIM,l_ni,l_njv,G_nk+1, &
               G_halox,G_haloy,G_periodx,G_periody,l_ni,0)

!  Calculate horizontal divergence (DS)  in pi* vertical coordinate
          call caldiv_2 (t1, uu, vv, LDIST_DIM, nk+1)

!  Calculate horizontal relative vorticity (Q3) in pi* vertical coordinate

          call calvor (t2, uu, vv ,t3, LDIST_DIM, nk+1)

                      j00=1
          if (l_south)j00=2

          if (G_lam) then
             if (l_west) then
                t1(1,j00:l_njv,:) = t1(2,j00:l_njv,:)
                t2(1,j00:l_njv,:) = t2(2,j00:l_njv,:)
             endif
             if (l_east) then
                t1(l_ni,j00:l_njv,:) = t1(l_niu,j00:l_njv,:)
                t2(l_ni,j00:l_njv,:) = t2(l_niu,j00:l_njv,:)
             endif
             if (l_south) then
                t1(:,1,:) = t1(:,2,:)
                t2(:,1,:) = t2(:,2,:)
             endif
             if (l_north) then
                t1(:,l_nj,:) = t1(:,l_njv,:)
                t2(:,l_nj,:) = t2(:,l_njv,:)
             endif
          endif

!_______________________________________________________________________
!
!     3.0     Calculation  DD, QR and vertical derivatives
!_______________________________________________________________________
!
          t5=t1 ; t6=t2

! Calculate horizontal divergence (DD) and relative vorticity (QR) 
!     in pressure vertical coordinate
          call calddqr( t5, t6, F_wlnph_m, uu, vv, &
                      t3, t4, t7, t8, t9, LDIST_DIM, nk+1)

! Calculate vertical derivative of DD(t5) with respect to F_wlnph_m
          call verder (t7,t5,F_wlnph_m,2.0,2.0,LDIST_DIM,nk+1,i0,in,j0,jn)
! Calculate vertical derivative of QR(t6) with respect to F_wlnph_m
          call verder (t8,t6,F_wlnph_m,2.0,2.0,LDIST_DIM,nk+1,i0,in,j0,jn)
! Calculate vertical derivative of DS(t1) with respect to F_wlnph_m
          call verder (t3,t1,F_wlnph_m,2.0,2.0,LDIST_DIM,nk+1,i0,in,j0,jn)
!       get vertical derivative of Q3(wijk2) with respect to F_wlnph_m
          call verder (t4,t2,F_wlnph_m,2.0,2.0,LDIST_DIM,nk+1,i0,in,j0,jn)

      endif

      lastdt = Lctl_step

      if (Level_typ_S(levset) .eq. 'M') then
!
!_______________________________________________________________________
!
!     5.0A   Output of DS, Q3, QS, DD, QR, and QQ on ETA levels
!_______________________________________________________________________
!
!       Setup the indexing for output
        kind=Level_kind_ip1
        allocate (indo( min(Level_max(levset),Level_momentum) ))
        call out_slev(Level(1,levset), Level_max(levset), &
                      Level_momentum,indo,nko)

          if (pnds.ne.0) &
             call ecris_fst2(t1,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
              'DS  ',1.0,0.0,kind,nk+1, indo, nko, nbit(pnds) )
          if (pnqs.ne.0) then
             do k=1,nk+1
             do j= j0, jn
                do i= i0, in
                   w11(i,j,k) = t2(i,j,k) + corio(i,j)
                enddo
             enddo
             enddo
             call ecris_fst2(w11,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
              'QS  ',1.0,0.0,kind,nk+1, indo, nko, nbit(pnqs) )
          endif
          if (pnqq.ne.0) then
             do k=1,nk+1
             do j= j0, jn 
                do i= i0, in
                   w11(i,j,k) = t6(i,j,k) + corio(i,j)
                enddo
             enddo
             enddo
             call ecris_fst2(w11,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
              'QQ  ',1.0,0.0,kind,nk+1, indo, nko, nbit(pnqq) )
          endif
          if (pnq3.ne.0) &
             call ecris_fst2(t2,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
              'Q3  ',1.0,0.0,kind,nk+1, indo, nko, nbit(pnq3) )
          if (pndd.ne.0) &
             call ecris_fst2(t5,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
              'DD  ',1.0,0.0,kind,nk+1, indo, nko, nbit(pndd) )
          if (pnqr.ne.0) &
             call ecris_fst2(t6,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
              'QR  ',1.0,0.0,kind,nk+1, indo, nko, nbit(pnqr) )
          deallocate(indo)
      else
!_______________________________________________________________________
!
!     5.0B   Output of DS, Q3, QS, DD, QR, and QQ on PRESSURE levels
!_______________________________________________________________________
!
!       Set kind to 2 for pressure output
        kind=2
!
!       Setup the indexing for output
        nko=Level_max(levset)
        allocate ( indo(nko), rf(nko) , prprlvl(nko) )
        do i = 1, nko
           indo(i)=i
           rf(i)= Level(i,levset)
           prprlvl(i) = rf(i) * 100.0
        enddo
        allocate(w1(LDIST_SHAPE,nko))
        allocate(w2(LDIST_SHAPE,nko))

         if ( pnds.ne.0 ) then
              call prgen( w1, t1, t3, F_wlnph_m, prprlvl,nko, &
                          Out3_cubds_L, l_minx,l_maxx,l_miny,l_maxy, G_nk+1,&
                          1,l_ni,1,l_nj)
             if (filt(pnds).gt.0) &
               call filter(w1,filt(pnds),coef(pnds),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
               call ecris_fst2(w1,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'DS  ',1.0,0.0, kind,nko, indo, nko, nbit(pnds) )
         endif
         if ( pnq3.ne.0 .or. pnqs.ne.0 ) then
              call prgen( w1, t2, t4, F_wlnph_m, prprlvl,nko, &
                          Out3_cubqs_L, l_minx,l_maxx,l_miny,l_maxy, G_nk+1,&
                          1,l_ni,1,l_nj)
         endif
         if ( pnqs.ne.0 ) then
             do k=1, nko
             do j= j0, jn 
             do i= i0, in
                w2(i,j,k) = w1(i,j,k) + corio(i,j)
             enddo
             enddo
             enddo
             if (filt(pnqs).gt.0) &
               call filter(w2,filt(pnqs),coef(pnqs),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
               call ecris_fst2(w2,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'QS  ',1.0,0.0, kind,nko, indo, nko, nbit(pnqs) )
         endif
         if ( pnq3.ne.0 ) then
             if (filt(pnq3).gt.0) &
               call filter(w1,filt(pnq3),coef(pnq3),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
               call ecris_fst2(w1,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'Q3  ',1.0,0.0, kind,nko, indo, nko, nbit(pnq3) )
         endif
         if ( pndd.ne.0 ) then
             call prgen( w1, t5, t7, F_wlnph_m, prprlvl,nko, &
                         Out3_cubdd_L, l_minx,l_maxx,l_miny,l_maxy, G_nk+1,&
                         1,l_ni,1,l_nj)
             if (filt(pndd).gt.0) &
               call filter(w1,filt(pndd),coef(pndd),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
               call ecris_fst2(w1,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'DD  ',1.0,0.0, kind,nko, indo, nko, nbit(pndd) )
         endif
         if ( pnqr.ne.0 .or. pnqq.ne.0 ) then
             call prgen( w1, t6, t8, F_wlnph_m, prprlvl,nko, &
                         Out3_cubqq_L, l_minx,l_maxx,l_miny,l_maxy, G_nk+1,&
                         1,l_ni,1,l_nj)
         endif
         if ( pnqq.ne.0 ) then
             do k=1,nko
             do j= j0, jn 
             do i= i0, in
                w2(i,j,k) = w1(i,j,k) + corio(i,j)
             enddo
             enddo
             enddo
             if (filt(pnqq).gt.0) &
               call filter(w2,filt(pnqq),coef(pnqq),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
               call ecris_fst2(w2,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'QQ  ',1.0,0.0, kind,nko, indo, nko, nbit(pnqq) )
         endif
         if ( pnqr.ne.0 ) then
             if (filt(pnqr).gt.0) &
               call filter(w1,filt(pnqr),coef(pnqr),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
               call ecris_fst2(w1,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'QR  ',1.0,0.0, kind,nko, indo, nko, nbit(pnqr) )
         endif
         deallocate(indo,rf,prprlvl,w1,w2)
      endif
! ___________________________________________________________________
!

      return
      end
