!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r out_dq - Compute and output divergence and vorticity

      subroutine out_dq (F_wlnph_m, Minx,Maxx,Miny,Maxy, nk,levset,set)
      implicit none
#include <arch_specific.hf>

      integer Minx,Maxx,Miny,Maxy,nk,levset,set
      real    F_wlnph_m(Minx:Maxx,Miny:Maxy,nk)

!author
!    Michel Desgagne   - spring 2014
!
!revision
! v2_00 - Desgagne M.       - initial MPI version (from caldiv v1_03)
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v4.70 - Gaudreault S.     - removing wind images
! v4.70 - Desgagne M.       - major refactorization

#include "gmm.hf"
#include "glb_ld.cdk"
#include "grid.cdk"
#include "out3.cdk"
#include "outd.cdk"
#include "vt1.cdk"
#include "level.cdk"
#include "ver.cdk"

      logical periodx_L
      integer i,istat,kind,nko,pndd,pnqq,pnqr,gridset,ig2
      integer nbit(0:Outd_var_max(set)+1),filt(0:Outd_var_max(set)+1)
      integer, dimension(:), allocatable :: indo
      real  coef(0:Outd_var_max(set)+1)
      real, dimension(:    ), allocatable:: rf
      real, dimension(:,:,:), allocatable:: uu_pres,vv_pres,cible, &
                                            div,vor,qr
!_______________________________________________________________________
!
      pndd=0 ; pnqq=0 ; pnqr=0
      coef(0)= 0.0 ; filt(0)= 0 ; nbit(0)= 0

      do i=1,Outd_var_max(set)
        if (Outd_var_S(i,set).eq.'DD') pndd=i
        if (Outd_var_S(i,set).eq.'QQ') pnqq=i
        if (Outd_var_S(i,set).eq.'QR') pnqr=i
        nbit(i)=Outd_nbit    (i,set)
        filt(i)=Outd_filtpass(i,set)
        coef(i)=Outd_filtcoef(i,set)
      enddo

      if (pndd+pnqq+pnqr.eq.0)return

      istat = gmm_get(gmmk_ut1_s,ut1)
      istat = gmm_get(gmmk_vt1_s,vt1)

      periodx_L = .false.
      if (.not.G_lam .and. (Grid_x1(Outd_grid(set))- &
            Grid_x0(Outd_grid(set))+1).eq. G_ni ) periodx_L=.true.

      if (Level_typ_S(levset) .eq. 'M') then
         kind=Level_kind_ip1
         allocate (indo( min(Level_max(levset),Level_momentum) ))
         call out_slev ( Level(1,levset), Level_max(levset), &
                         Level_momentum,indo,nko )         
         call rpn_comm_xch_halo (ut1,l_minx,l_maxx,l_miny,l_maxy,&
            l_niu,l_nj,G_nk,G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
         call rpn_comm_xch_halo (vt1,l_minx,l_maxx,l_miny,l_maxy,&
            l_ni,l_njv,G_nk,G_halox,G_haloy,G_periodx,G_periody,l_ni,0)

         allocate ( div(l_minx:l_maxx,l_miny:l_maxy,G_nk),&
                    vor(l_minx:l_maxx,l_miny:l_maxy,G_nk),&
                     qr(l_minx:l_maxx,l_miny:l_maxy,G_nk) )

         call cal_ddqq (div, vor, qr, ut1, vt1                     ,&
                        filt(pndd),coef(pndd),filt(pnqq),coef(pnqq),&
                        l_minx,l_maxx,l_miny,l_maxy, G_nk)
      else
         kind= 2
         nko = Level_max(levset)
         allocate ( indo(nko), rf(nko)                    ,&
                    cible(l_minx:l_maxx,l_miny:l_maxy,nko),&
                  uu_pres(l_minx:l_maxx,l_miny:l_maxy,nko),&
                  vv_pres(l_minx:l_maxx,l_miny:l_maxy,nko) )
         do i = 1, nko
            indo(i)= i
            rf  (i)= Level(i,levset)
            cible(:,:,i)= log(rf(i) * 100.0)
         enddo

         call vertint ( uu_pres,cible,nko, ut1,F_wlnph_m,G_nk     ,&
                        l_minx,l_maxx,l_miny,l_maxy, 1,l_ni,1,l_nj,&
                        'linear', .false. )
         call vertint ( vv_pres,cible,nko, vt1,F_wlnph_m,G_nk     ,&
                        l_minx,l_maxx,l_miny,l_maxy, 1,l_ni,1,l_nj,&
                        'linear', .false. )

         call rpn_comm_xch_halo (uu_pres,l_minx,l_maxx,l_miny,l_maxy,&
            l_niu,l_nj,nko,G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
         call rpn_comm_xch_halo (vv_pres,l_minx,l_maxx,l_miny,l_maxy,&
            l_ni,l_njv,nko,G_halox,G_haloy,G_periodx,G_periody,l_ni,0)

         allocate ( div(l_minx:l_maxx,l_miny:l_maxy,nko),&
                    vor(l_minx:l_maxx,l_miny:l_maxy,nko),&
                     qr(l_minx:l_maxx,l_miny:l_maxy,nko) )

         call cal_ddqq (div,vor,qr, uu_pres,vv_pres                ,&
                        filt(pndd),coef(pndd),filt(pnqq),coef(pnqq),&
                        l_minx,l_maxx,l_miny,l_maxy, nko)

         deallocate (uu_pres,vv_pres,cible)
      endif

      if (pndd.gt.0) then

         if (Level_typ_S(levset) .eq. 'M') then
            call ecris_fst2 ( div, l_minx,l_maxx,l_miny,l_maxy, &
                              Ver_hyb%m, 'DD  ', 1.0,0.0,kind , &
                              nk, indo, nko, nbit(pndd) )
         else
            call ecris_fst2 ( div, l_minx,l_maxx,l_miny,l_maxy, &
                              rf, 'DD  ', 1.0,0.0, kind       , &
                              nko, indo, nko, nbit(pndd) )
         endif

      endif

      if ((pnqq.gt.0).or.(pnqr.gt.0)) then
         gridset = Outd_grid(set)
         ig2     = Grid_ig2(gridset) + 3
         call out_sgrid2( Grid_x0 (gridset),Grid_x1 (gridset), &
                          Grid_y0 (gridset),Grid_y1 (gridset), &
                          Grid_ig1(gridset),ig2              , &
                          periodx_L, Grid_stride(gridset)    , &
                          Grid_etikext_s(gridset) )
         call out_href2  ( 'F_point' )

      endif

      if (pnqq.gt.0) then

         if (Level_typ_S(levset) .eq. 'M') then
            call ecris_fst2 ( vor, l_minx,l_maxx,l_miny,l_maxy, &
                              Ver_hyb%m, 'QQ  ', 1.0,0.0,kind , &
                              nk, indo, nko, nbit(pndd) )
         else
            call ecris_fst2 ( vor, l_minx,l_maxx,l_miny,l_maxy, &
                              rf, 'QQ  ', 1.0,0.0, kind       , &
                              nko, indo, nko, nbit(pndd) )
         endif

      endif

      if (pnqr.gt.0) then

         if (Level_typ_S(levset) .eq. 'M') then
            call ecris_fst2 ( qr, l_minx,l_maxx,l_miny,l_maxy, &
                              Ver_hyb%m, 'QR  ', 1.0,0.0,kind , &
                              nk, indo, nko, nbit(pndd) )
         else
            call ecris_fst2 ( qr, l_minx,l_maxx,l_miny,l_maxy, &
                              rf, 'QR  ', 1.0,0.0, kind       , &
                              nko, indo, nko, nbit(pndd) )
         endif

      endif

      deallocate (div,vor,qr,indo)
      if (Level_typ_S(levset) .ne. 'M') deallocate (rf)
! ___________________________________________________________________
!
      return
      end
