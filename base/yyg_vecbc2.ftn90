!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
!**s/r yyg_vecbc2 - to interpolate and exchange V wind
!
#include "model_macros_f.h"

      Subroutine yyg_vecbc2(tab_dst,tabv_src,tabu_src,DIST_DIM,NK)
      implicit none
!
!author
!           Abdessamad Qaddouri/V.Lee - October 2009
!
!     include 'mpif.h'
#include "ptopo.cdk"
#include "glb_ld.cdk"
#include "geomn.cdk"
#include "geomg.cdk"
#include "glb_pil.cdk"
#include "yyg_pil.cdk"

      integer DIST_DIM,Ni,Nj,NK,numproc
      real  tabu_src (DIST_SHAPE,Nk), tabv_src (DIST_SHAPE,Nk)
      real  tab_dst (DIST_SHAPE,Nk)
      real*8  tabu_src_8(DIST_SHAPE,NK)
      real*8  tabv_src_8(DIST_SHAPE,NK)
      integer ierr,i,j,k,kk,kk_proc,m,mm
      integer Pil_vrecvlen(Ptopo_numproc),Pil_vsendlen(Ptopo_numproc)
      real, dimension (:,:), allocatable :: recv_pil,send_pil
      real sent,recv
!     integer status(MPI_STATUS_SIZE)
!     integer stat(MPI_STATUS_SIZE,Ptopo_numproc)
      integer status
      integer request(Ptopo_numproc*2)
      real*8  send_pil_8,tabu_8,tabv_8
      integer tag2,recvlen,sendlen,tag1,ireq
      tag2=14
      tag1=13
      
      sendlen=0
      recvlen=0
      ireq=0
      do kk=1,Ptopo_numproc
         Pil_vsendlen(kk)= Pil_vsendw_len(kk)+Pil_vsende_len(kk) &
                         +Pil_vsends_len(kk)+Pil_vsendn_len(kk)
         sendlen=max(sendlen,Pil_vsendlen(kk))
         Pil_vrecvlen(kk)= Pil_vrecvw_len(kk)+Pil_vrecve_len(kk) &
                         +Pil_vrecvs_len(kk)+Pil_vrecvn_len(kk)
         recvlen=max(recvlen,Pil_vrecvlen(kk))
      enddo
      

!     print *,'sendlen=',sendlen,' recvlen=',recvlen
      if (sendlen.gt.0) then
          allocate(send_pil(sendlen*NK,Ptopo_numproc))
!         assume rpn_comm_xch_halo already done on tab_src
          tabu_src_8(:,:,:)=dble(tabu_src(:,:,:))
          tabv_src_8(:,:,:)=dble(tabv_src(:,:,:))
      endif
      if (recvlen.gt.0) then
          allocate(recv_pil(recvlen*NK,Ptopo_numproc))
      endif
 
!
      do 100 kk=1,Ptopo_numproc
!
!        For each processor (in other colour)
         if (Ptopo_couleur.eq.0) then
             kk_proc = kk+Ptopo_numproc-1
         else
             kk_proc = kk-1
         endif

!        prepare to send to other colour processor
         if (Pil_vsendlen(kk).gt.0) then
!            prepare something to send

             mm=0

! make for west
             do m=1,Pil_vsendw_len(kk)
!$omp parallel private (mm,tabu_8,tabv_8) &
!$omp          shared (tabu_src_8,tabv_src_8,send_pil)
!$omp do
                do k=1,NK
!                  mm=mm+1
                   mm=(m-1)*NK+k
                   call int_cub_lagv(tabv_8,tabv_src_8(l_minx,l_miny,k),  &
                             Pil_vsendw_imx1(m,kk),Pil_vsendw_imy1(m,kk), &
                             LDIST_DIM,                                   & 
                             Pil_vsendw_xxr(m,kk),Pil_vsendw_yyr(m,kk))
                   call int_cub_lagu(tabu_8,tabu_src_8(l_minx,l_miny,k),  &
                             Pil_vsendw_imx2(m,kk),Pil_vsendw_imy2(m,kk), &
                             LDIST_DIM,                                   &
                             Pil_vsendw_xxr(m,kk),Pil_vsendw_yyr(m,kk))
                   send_pil(mm,KK)=                                       &
                   real(Pil_vsendw_s1(m,kk)*tabv_8 + Pil_vsendw_s2(m,kk)*tabu_8)
                enddo
!$omp enddo
!$omp end parallel
             enddo
! make for east
             do m=1,Pil_vsende_len(kk)
!$omp parallel private (mm,tabu_8,tabv_8) &
!$omp          shared (tabu_src_8,tabv_src_8,send_pil)
!$omp do
                do k=1,NK
                   mm=(Pil_vsendw_len(kk)+m-1)*NK+k
                   call int_cub_lagv(tabv_8,tabv_src_8(l_minx,l_miny,k), &
                             Pil_vsende_imx1(m,kk),Pil_vsende_imy1(m,kk),&
                             LDIST_DIM,                                  &
                             Pil_vsende_xxr(m,kk),Pil_vsende_yyr(m,kk))
                   call int_cub_lagu(tabu_8,tabu_src_8(l_minx,l_miny,k), &
                             Pil_vsende_imx2(m,kk),Pil_vsende_imy2(m,kk),&
                             LDIST_DIM,                                  &
                             Pil_vsende_xxr(m,kk),Pil_vsende_yyr(m,kk))
                   send_pil(mm,KK)=                                      &
                   real(Pil_vsende_s1(m,kk)*tabv_8 + Pil_vsende_s2(m,kk)*tabu_8)
                enddo
!$omp enddo
!$omp end parallel
             enddo
! make for south
             do m=1,Pil_vsends_len(kk)
!$omp parallel private (mm,tabu_8,tabv_8) &
!$omp          shared (tabu_src_8,tabv_src_8,send_pil)
!$omp do
                do k=1,NK
                   mm=(Pil_vsendw_len(kk)+Pil_vsende_len(kk)+m-1)*NK+k
                   call int_cub_lagv(tabv_8,tabv_src_8(l_minx,l_miny,k), &
                             Pil_vsends_imx1(m,kk),Pil_vsends_imy1(m,kk),&
                             LDIST_DIM,                                  &
                             Pil_vsends_xxr(m,kk),Pil_vsends_yyr(m,kk))
                   call int_cub_lagu(tabu_8,tabu_src_8(l_minx,l_miny,k), &
                             Pil_vsends_imx2(m,kk),Pil_vsends_imy2(m,kk),&
                             LDIST_DIM,                                  &
                             Pil_vsends_xxr(m,kk),Pil_vsends_yyr(m,kk))
                   send_pil(mm,KK)=                                      & 
                   real(Pil_vsends_s1(m,kk)*tabv_8 + Pil_vsends_s2(m,kk)*tabu_8)
                enddo
!$omp enddo
!$omp end parallel
             enddo
! make for north
             do m=1,Pil_vsendn_len(kk)
!$omp parallel private (mm,tabu_8,tabv_8) &
!$omp          shared (tabu_src_8,tabv_src_8,send_pil)
!$omp do
                do k=1,NK
                   mm=(Pil_vsendw_len(kk)+Pil_vsende_len(kk)+Pil_vsends_len(kk)+m-1)*NK+k
                   call int_cub_lagv(tabv_8,tabv_src_8(l_minx,l_miny,k), &
                             Pil_vsendn_imx1(m,kk),Pil_vsendn_imy1(m,kk),&
                             LDIST_DIM,                                  &
                             Pil_vsendn_xxr(m,kk),Pil_vsendn_yyr(m,kk))
                   call int_cub_lagu(tabu_8,tabu_src_8(l_minx,l_miny,k), &
                             Pil_vsendn_imx2(m,kk),Pil_vsendn_imy2(m,kk),&
                             LDIST_DIM,                                  &
                             Pil_vsendn_xxr(m,kk),Pil_vsendn_yyr(m,kk))
                   send_pil(mm,KK)=                                      &
                   real(Pil_vsendn_s1(m,kk)*tabv_8 + Pil_vsendn_s2(m,kk)*tabu_8)
                enddo
!$omp enddo
!$omp end parallel
             enddo

             ireq = ireq+1
!            print *,'vecbc2: sending',Pil_vsendlen(kk)*NK,' to ',kk_proc
!            call MPI_ISend (send_pil(1,KK),Pil_vsendlen(kk)*NK,MPI_REAL, &
!                                        kk_proc,tag2+Ptopo_world_myproc, &
!                                        MPI_COMM_WORLD,request(ireq),ierr)
             call RPN_COMM_ISend (send_pil(1,KK),Pil_vsendlen(kk)*NK, &
                                  'MPI_REAL',kk_proc,tag2+Ptopo_world_myproc, &
                                  'MULTIGRID',request(ireq),ierr)
         endif
!
!        check to receive from other colour processor
!
         if (Pil_vrecvlen(kk).gt.0) then
!            detect something to receive

             ireq = ireq+1
!            print *,'vecbc2: receiving',Pil_vrecvlen(kk)*NK,' from ',kk_proc
!            call MPI_IRecv(recv_pil(1,KK),Pil_vrecvlen(kk)*NK,MPI_REAL, &
!                   kk_proc,tag2+kk_proc,MPI_COMM_WORLD,request(ireq),ierr)
             call RPN_COMM_IRecv(recv_pil(1,KK),Pil_vrecvlen(kk)*NK,'MPI_REAL',&
                    kk_proc,tag2+kk_proc,'MULTIGRID',request(ireq),ierr)
         endif

 100  continue

!Wait for all done sending and receiving

!     call mpi_waitall(ireq,request,stat,ierr)
      call RPN_COMM_waitall_nostat(ireq,request,ierr)

! Now fill my results if I have received something

      if (recvlen.gt.0) then

          do 200 kk=1,Ptopo_numproc
! fill my west
             mm=0
             do m=1,Pil_vrecvw_len(kk)
             do k=1,NK
                mm=mm+1
                tab_dst(Pil_vrecvw_i(m,kk),Pil_vrecvw_j(m,kk),k)=recv_pil(mm,KK)
             enddo
             enddo
! fill my east
             do m=1,Pil_vrecve_len(kk)
             do k=1,NK
                mm=mm+1
                tab_dst(Pil_vrecve_i(m,kk),Pil_vrecve_j(m,kk),k)=recv_pil(mm,KK)
             enddo
             enddo
! fill my south
             do m=1,Pil_vrecvs_len(kk)
             do k=1,NK
                mm=mm+1
                tab_dst(Pil_vrecvs_i(m,kk),Pil_vrecvs_j(m,kk),k)=recv_pil(mm,KK)
             enddo
             enddo
! fill my north
             do m=1,Pil_vrecvn_len(kk)
             do k=1,NK
                mm=mm+1
                tab_dst(Pil_vrecvn_i(m,kk),Pil_vrecvn_j(m,kk),k)=recv_pil(mm,KK)
             enddo
             enddo

 200  continue

       
      endif
      if (recvlen.gt.0)deallocate(recv_pil)
      if (sendlen.gt.0) deallocate(send_pil)

!
!
      return
      end

