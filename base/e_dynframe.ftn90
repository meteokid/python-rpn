!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r e_dynframe - Distributes time frame computation amongts 
!                   MPI processes
!
      subroutine e_dynframe
      implicit none
#include <arch_specific.hf>
!AUTHOR  M. Desgagne    April 2002
!
!revision 
! v3_21 - Desgagne M. - dayfrac calc displaced
! v3_30 - Desgagne/Lee - new LAM I/O interface
! v3_31 - Lee V.      - bugfix: eliminate save_bmf key
! v4_03 - Lee/Desgagne - ISST
! v4_05 - Desgagne M. - implement tailjob launcher
! v4_05 - Lee V. - bugfix: save Pil_bcs_hollow_L after e_specanal/ac_posi
!

#include "e_fu.cdk"
#include "e_cdate.cdk"
#include "e_topo.cdk"
#include "e_grids.cdk"
#include "bmf.cdk"
#include "lun.cdk"
#include "step.cdk"
#include "pilot.cdk"
#include "filename.cdk"
#include "ptopo.cdk"

      character*16 date1, date2, msg
      character*16, dimension(:), allocatable :: lesdates
      integer i, cnt, mpx, ldni, irest, istart, nframe
      integer, dimension(:), allocatable :: err, errt
      real*8 dayfrac, sec_in_day
      parameter (sec_in_day=86400.0d0)
!
!---------------------------------------------------------------------
!
      bmf_dtyp = 41 ; ipilf = 1
      dayfrac  = dble(Step_nesdt) / sec_in_day

! Counting the total number of time frame to process

      cnt=0
      date1= Pil_jobstrt_S
      do while (date1.le.Pil_jobend_S)
         cnt= cnt+1
         call incdatsd (date2,date1,dayfrac)
         date1= date2
      enddo

      nframe= cnt
      allocate (lesdates(nframe), err(nframe), errt(nframe))

      cnt=0
      date1= Pil_jobstrt_S
      do while (date1.le.Pil_jobend_S)
         cnt= cnt+1
         lesdates(cnt)= date1
         call incdatsd (date2,date1,dayfrac)
         date1= date2
      enddo

! Splitting the total number of time frame to process into
! Ptopo_numproc MPI processes and obtaining local partition

      mpx    = mod( Ptopo_myproc, Ptopo_numproc )
      ldni   = nframe / Ptopo_numproc
      irest  = nframe - ldni * Ptopo_numproc
      istart = mpx * ldni + 1
      if ( mpx .lt. irest ) then
         ldni   = ldni + 1
         istart = istart + mpx
      else
         istart = istart + irest
      end if

! Computing start and end dates for local partition

      date1= Pil_jobstrt_S
      call incdatsd (date2,date1,(istart-1)*dayfrac)
      date1= date2
      call incdatsd (date2,date1,(ldni-1)*dayfrac)
      Pil_jobend_S= date2

! Fetching orography if needed

      err= 0
      if (Pil_bmf_L .and. (ldni.gt.0)) then
         allocate ( topo (nifi*njfi) )
         call e_gettopo (topo, nifi, njfi, err)
      endif
      call handle_error(err,'e_dynframe','Probleme with e_gettopo')

! Looping around time frame for local partition

      err= 0 ;       cnt=0
      do while (date1.le.Pil_jobend_S)

         cnt = cnt+1
         call e_dynfld (date1, err(cnt+istart-1))

         call incdatsd (date2, date1, dayfrac)
         date1= date2

         call gemtim4 ( Lun_out, 'END OF e_dynfld', .false. )

      end do

      call rpn_comm_REDUCE ( err, errt, nframe, "MPI_INTEGER",&
                                       "MPI_SUM",0,"grid",err )
      err= 0
      if (Ptopo_myproc.eq.0) then
         write (Lun_out, 1001)
         do i=1, nframe
            msg='OK'
            if (errt(i).lt.0) then
               msg='ABORT'
               err(1) = -1
            endif
            write (Lun_out, 1002) lesdates(i),trim(msg)
         end do
         write (Lun_out, 1003)
      endif

      call handle_error(err,'e_dynframe','Probleme with some time frames')

 1001 format (/50('#')/6x,'GEMNTR REPORT ON PROCESSED TIME FRAMES:')
 1002 format (3x,'TIMEFRAME ',a,' status is: ',a)
 1003 format (50('#')/)
!
!---------------------------------------------------------------------
      return
      end
