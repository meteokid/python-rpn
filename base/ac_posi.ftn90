!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r ac_posi - find the positional points to extract cascade grid
!                from the current model grid configuration
#include "model_macros_f.h"
!     
      subroutine ac_posi (xp,yp,dimgx,dimgy,prout)
      implicit none
#include <arch_specific.hf>
!     
      logical prout
      integer dimgx,dimgy
      real*8 xp(dimgx), yp(dimgy)
!
!author
!        Michel Desgagne - 2001 (from MC2)
!revision
! v3_30 - Lee V.       - initial version for GEMDM
! v3_30 - McTaggart-Cowan R.- Allow for user-defined domain tag extensions
! v4_03 - Lee/Desgagne - ISST
!
!*
#include "dcst.cdk"
#include "grd.cdk"
#include "grdc.cdk"
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "rstr.cdk"
#include "tr3d.cdk"
#include "lun.cdk"
!
      integer  stretch_axis2
      external stretch_axis2
      integer i,k,cnt,ierx,dum1,dum2,gidi,gifi,gjfi
      integer is,nis,js,njs,iw,ie,niw,jw,jn,njw
      real x0, xl, y0, yl, dum, n1, n2, b1, b2
      real*8 ac_xp(max(1,Grdc_ni)), ac_yp(max(1,Grdc_nj)), &
             xpx(dimgx), ypx(dimgy), rad2deg_8,xgi_8(G_ni),ygi_8(G_ni)
!
!---------------------------------------------------------------------
!
      rad2deg_8 = 180.0d0/Dcst_pi_8
      xpx = xp * rad2deg_8
      ypx = yp * rad2deg_8
!
      Grdc_gid = 0
      Grdc_gjd = 0
      Grdc_gif = 0
      Grdc_gjf = 0
      Grdc_gjdi= 0
!
      if ( (Grdc_ndt.lt.0) .or. (Grd_yinyang_S .eq. 'YAN') .or. &
           (Grdc_ni .eq.0) .or. (Grdc_nj.eq.0) ) then
         Grdc_ndt = -1
         return
      endif
!
!     *** Positional parameters for f and q points
!
      x0   = Grdc_lonr - (Grdc_iref-1) * Grdc_dx
      y0   = Grdc_latr - (Grdc_jref-1) * Grdc_dx
      xl   = x0 + (Grdc_ni  -1) * Grdc_dx
      yl   = y0 + (Grdc_nj  -1) * Grdc_dx
!
      ierx = stretch_axis2 ( ac_xp, Grdc_dx, x0, xl, dum1, Grdc_ni, &
                 Grdc_ni, dum, .false.,Lun_debug_L,360., dum2, .false.)
      ierx = stretch_axis2 ( ac_yp, Grdc_dx, y0, yl, dum1, Grdc_nj, &
                 Grdc_nj, dum, .false.,Lun_debug_L,180., dum2, .false.)
!
      Grdc_xp1 = ac_xp(1)
      Grdc_yp1 = ac_yp(1)
!
      do i=1,dimgx
         if (xpx(i).le.ac_xp(1)) Grdc_gid=i
         if (xpx(i).le.ac_xp(Grdc_hblen+Grdc_pil+1)) gidi=i
         if (xpx(i).le.ac_xp(Grdc_ni)) Grdc_gif=i
         if (xpx(i).le.ac_xp(Grdc_ni-Grdc_hblen-Grdc_pil)) gifi=i
      enddo
      if (Grdc_gid.ge.Grdc_gif) Grdc_gid = 0
!
      do i=1,dimgy
         if (ypx(i).le.ac_yp(1)) Grdc_gjd=i
         if (ypx(i).le.ac_yp(Grdc_hblen+Grdc_pil+1)) Grdc_gjdi=i
         if (ypx(i).le.ac_yp(Grdc_nj)) Grdc_gjf=i
         if (ypx(i).le.ac_yp(Grdc_nj-Grdc_hblen-Grdc_pil)) gjfi=i
      enddo
      if (Grdc_gjd.ge.Grdc_gjf) Grdc_gjd = 0
!
      if ((Grdc_gid.gt.0).and.(Grdc_gjd.gt.0)) then
         if ( (Grdc_gid-2.gt.0) .and. (Grdc_gif+3.lt.dimgx) .and. &
              (Grdc_gjd-2.gt.0) .and. (Grdc_gjf+3.lt.dimgy) ) then
            Grdc_gid = Grdc_gid - 2
            Grdc_gjd = Grdc_gjd - 2
            Grdc_gif = Grdc_gif + 3
            Grdc_gjf = Grdc_gjf + 3
         else
            Grdc_gid = 0
            Grdc_gjd = 0
         endif
      else
         Grdc_gid = 0
         Grdc_gjd = 0
      endif
!
      if ((Grdc_gid.gt.Glb_pil_w).and.(Grdc_gjd.gt.Glb_pil_s)) then
         if (prout) then
            write (6,1006) Grdc_gid,Grdc_gif,Grdc_gjd,Grdc_gjf,Grdc_ndt,Grdc_start,Grdc_end
         endif
      else
         if (prout) write (6,1004)
         Grdc_ndt    = -1
         return
      endif
!
      if ( (Grdc_ndt.gt.0) .and. (.not.Rstri_rstn_L) )  then
!
         call out_sgrid (Grdc_gid, Grdc_gif, Grdc_gjd, Grdc_gjf, &
                                       0, 0, .false., 1, '', '')
      endif
!
      if (Grdc_trnm_S(1).eq.'@#$%') then
         do i=1,Tr3d_ntr
            Grdc_trnm_S(i) = Tr3d_name_S(i)
	 end do
         Grdc_ntr = Tr3d_ntr
      else
         cnt = 0
         do k=1,max_trnm
            if (Grdc_trnm_S(k).eq.'@#$%') goto 89
            do i=1,Tr3d_ntr
               if (trim(Grdc_trnm_S(k)).eq.trim(Tr3d_name_S(i))) then
                  cnt=cnt+1
                  Grdc_trnm_S(cnt) = Tr3d_name_S(i)
               endif
            end do
         end do
 89      Grdc_trnm_S(cnt+2) = '@#$%'
! And add humidity
         cnt=cnt+1
         do i=cnt,2,-1
            Grdc_trnm_s(i) = Grdc_trnm_s(i-1)
         enddo
         Grdc_trnm_s(1) = 'HU  '
         Grdc_ntr = cnt
      endif

      if (prout) then
          write (6,1001)
          write (6,'(5(x,a))') Grdc_trnm_S(1:Grdc_ntr)
          write (6,1010)
      endif
!
 1001 format ( ' Cascade grid: Tracers to be written for cascade run are: ')
 1004 format (/' Cascade grid: Is too large, NO SELF CASCADE DATA will be produced')
 1006 format (/'################ SELF CASCADE DATA WILL BE PRODUCED ################'/&
               ' Cascade grid: Grdc_gid,Grdc_gif=',2I5, ';    Grdc_gjd,Grdc_gjf=',2I5/&
               ' Cascade grid: Grdc_ndt,Grdc_start,Grdc_end=',3i5)
 1010 format ( '####################################################################')
!--------------------------------------------------------------------
      return
      end

