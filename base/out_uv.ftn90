!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r out_uv - output winds
!
#include "model_macros_f.h"
!
      subroutine out_uv (F_wlnph_m, Minx,Maxx,Miny,Maxy, nk, levset, set)
      implicit none
#include <arch_specific.hf>

      integer Minx,Maxx,Miny,Maxy,nk,levset,set
      real F_wlnph_m(Minx:Maxx,Miny:Maxy,nk+1)
!
!author
!     james caveen/andre methot - rpn july/nov 1995
!
!revision
! v2_00 - Lee V.            - initial MPI version (from out_uv v1_03)
! v2_21 - J. P. Toviessi    - set dieze (#) slab output and rename
! v2_21                       truncate model output names to 4 characters
! v2_30 - Lee V.            - reorganize slab output to be more efficient;
! v2_30                       there are 3 kinds of grid output here: U,V,PHI
! v2_32 - Lee V.            - reduce dynamic allocation size
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_00 - Tanguay M.        - true winds adjoint
! v3_03 - Tanguay M.        - introduce V4dg_imguv_L
! v3_20 - Lee V.            - output in block topology, standard file
! v3_21 - Lee V.            - Output Optimization
! v3_30 - Bilodeau/Tanguay  - Cancel knots conversion when AD
! v3_30 - Tanguay M.        - Remove lastdt .ne. Lctl_step
! v4_05 - Lee V.            - adaptation to GMM
! v4_40 - Lee V.            - change in argument call for this routine & prgen
! v4_50 - Lee V.            - Exchange winds between Yin and Yang in pilot area
! v4.7  - Gaudreault S.     - Removing wind images

#include "gmm.hf"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "out3.cdk"
#include "geomg.cdk"
#include "out.cdk"
#include "vt1.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "lctl.cdk"
#include "ver.cdk"
#include "grd.cdk"
#include "schm.cdk"

      integer i,j,k,ii,istat,psum, kind,nko,nkof,l_ninj
      integer i0,in,j0,jn,i0v,inv,j0v,jnv,pnuu,pnvv,pnuv
      integer nbit(0:Outd_var_max(set)+1),filt(0:Outd_var_max(set)+1)
      integer, dimension(:), allocatable::indo
      integer, save :: lastdt = -1

      real coef(0:Outd_var_max(set)+1),prmult
      real uv(l_minx:l_maxx,l_miny:l_maxy,nk+1)
      real, dimension(:    ), allocatable::prprlvl,rf
      real, dimension(:,:,:), allocatable:: uv_pres,uu_pres,vv_pres,cible
      real, dimension(:,:,:), pointer, save :: uu,vv
      real*8 c1_8(l_nj)
!
!-------------------------------------------------------------------
!
      prmult =  1.0 / Dcst_knams_8
      pnuu=0 ; pnvv=0 ; pnuv=0

      coef(0:Outd_var_max(set)) = 0.
      filt(0:Outd_var_max(set)) = 0 ; nbit(0:Outd_var_max(set)) = 0

      do ii=1,Outd_var_max(set)
         if (Outd_var_S(ii,set).eq.'UU')then
            pnuu=ii
         endif
         if (Outd_var_S(ii,set).eq.'VV')then
            pnvv=ii
         endif
         if (Outd_var_S(ii,set).eq.'UV')then
            pnuv=ii
         endif
         nbit(ii)=Outd_nbit(ii,set)
         filt(ii)=Outd_filtpass(ii,set)
         coef(ii)=Outd_filtcoef(ii,set)
      enddo

      psum=pnuu+pnuv+pnvv
      if (psum.eq.0)return

      If (lastdt .eq. -1) then
         allocate ( uu(minx:maxx,miny:maxy,G_nk+1) )
         allocate ( vv(minx:maxx,miny:maxy,G_nk+1) )
      endif

      if (lastdt .ne. Lctl_step) then

         istat = gmm_get(gmmk_ut1_s,ut1)
         if (GMM_IS_ERROR(istat)) print *,'out_dyn ERROR at gmm_get(ut1)'
         istat = gmm_get(gmmk_vt1_s,vt1)
         if (GMM_IS_ERROR(istat)) print *,'out_dyn ERROR at gmm_get(vt1)'

         call uv_acg2g (uu ,ut1 ,1,0,l_minx,l_maxx,l_miny,l_maxy,G_nk ,i0 ,in ,j0 ,jn )
         call uv_acg2g (vv ,vt1 ,2,0,l_minx,l_maxx,l_miny,l_maxy,G_nk ,i0v,inv,j0v,jnv)

         if (G_lam) then
!         Borders need to be filled for LAM configuration
            do k=1,G_nk
               do i=1,i0-1
                  do j=1,l_nj
                     uu(i,j,k)=uu(i0,j,k)
                  enddo
               enddo
               do i=in+1,l_ni
                  do j=1,l_nj
                     uu(i,j,k)=uu(in,j,k)
                  enddo
               enddo
               do j=1,j0-1
                  do i=1,l_ni
                     uu(i,j,k)=uu(i,j0,k)
                  enddo
               enddo
               do j=jn+1,l_nj
                  do i=1,l_ni
                     uu(i,j,k)=uu(i,jn,k)
                  enddo
               enddo
               do i=1,i0v-1
                  do j=1,l_nj
                     vv(i,j,k)=vv(i0v,j,k)
                  enddo
               enddo
               do i=inv+1,l_ni
                  do j=1,l_nj
                     vv(i,j,k)=vv(inv,j,k)
                  enddo
               enddo
               do j=1,j0v-1
                  do i=1,l_ni
                     vv(i,j,k)=vv(i,j0v,k)
                  enddo
               enddo
               do j=jnv+1,l_nj
                  do i=1,l_ni
                     vv(i,j,k)=vv(i,jnv,k)
                  enddo
               enddo
            enddo
         endif

      endif

      uu(:,:,l_nk+1) = uu(:,:,l_nk)
      vv(:,:,l_nk+1) = vv(:,:,l_nk)
      if (Schm_phyms_L) then
         call itf_phy_sfcdiag (uu(l_minx,l_miny,l_nk+1),l_minx,l_maxx,&
                                                l_miny,l_maxy,'UDIAG')
         call itf_phy_sfcdiag (vv(l_minx,l_miny,l_nk+1),l_minx,l_maxx,&
                                                l_miny,l_maxy,'VDIAG')
      endif

      lastdt = Lctl_step

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj

      if (Level_typ_S(levset) .eq. 'M') then  ! Output on model levels

         kind=Level_kind_ip1
!       Setup the indexing for output
         allocate (indo(G_nk+1))
         call out_slev(Level(1,levset), Level_max(levset), &
                       Level_momentum,indo,nko)
         nkof= nko
         if (nko .eq. G_nk) then
            nkof= G_nk + 1
            indo(nkof)= nkof
         endif

         if (pnuu.ne.0) &
              call ecris_fst2(uu,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                 'UU  ',prmult,0.0,kind,G_nk+1, indo, nkof, nbit(pnuu) )

         if (pnvv.ne.0) &
              call ecris_fst2(vv,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                 'VV  ',prmult,0.0,kind,G_nk+1, indo, nkof, nbit(pnvv) )
         if (pnuv.ne.0) then
            do k = 1,G_nk+1
               do j = j0, jn
                  do i = i0, in
                     uv(i,j,k) = sqrt(uu(i,j,k)*uu(i,j,k)+ &
                                      vv(i,j,k)*vv(i,j,k))
                  enddo
               enddo
            enddo
            call ecris_fst2(uv,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                 'UV  ',prmult,0.0,kind,G_nk+1, indo, nkof, nbit(pnuv) )
         endif
         deallocate(indo)

      else   ! Output on pressure levels

!       Set kind to 2 for pressure output
         kind=2
!       Setup the indexing for output
         nko=Level_max(levset)
         allocate ( indo(nko), rf(nko) , prprlvl(nko), &
                    cible(l_minx:l_maxx,l_miny:l_maxy,nko) )
         do i = 1, nko
            indo(i)=i
            rf(i)= Level(i,levset)
            prprlvl(i) = rf(i) * 100.0
            cible(:,:,i) = log(prprlvl(i))
         enddo
         allocate(uu_pres(l_minx:l_maxx,l_miny:l_maxy,nko))
         allocate(vv_pres(l_minx:l_maxx,l_miny:l_maxy,nko))
         allocate(uv_pres(l_minx:l_maxx,l_miny:l_maxy,nko))

!        Vertical interpolation

         call vertint ( uu_pres,cible,nko, uu,F_wlnph_m,G_nk+1    ,&
                        l_minx,l_maxx,l_miny,l_maxy, 1,l_ni,1,l_nj,&
                        'linear', .false. )
         call vertint ( vv_pres,cible,nko, vv,F_wlnph_m,G_nk+1    ,&
                        l_minx,l_maxx,l_miny,l_maxy, 1,l_ni,1,l_nj,&
                        'linear', .false. )

         if(pnuv.ne.0) then
!        Compute UV
            do k =  1, nko
               do j = j0, jn
                  do i = i0, in
                     uv_pres(i,j,k) = sqrt(uu_pres(i,j,k)*uu_pres(i,j,k)+ &
                                          vv_pres(i,j,k)*vv_pres(i,j,k))
                  enddo
               enddo
            enddo
            if (filt(pnuv).gt.0) &
               call filter(uv_pres,filt(pnuv),coef(pnuv),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
            call ecris_fst2(uv_pres,l_minx,l_maxx,l_miny,l_maxy,rf, &
                 'UV  ',prmult,0.0, kind,nko, indo, nko, nbit(pnuv) )
         endif

         if (pnuu.ne.0) then
            if (filt(pnuu).gt.0) &
                call filter(uu_pres,filt(pnuu),coef(pnuu),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
            call ecris_fst2(uu_pres,l_minx,l_maxx,l_miny,l_maxy,rf, &
                 'UU  ',prmult,0.0, kind,nko, indo, nko, nbit(pnuu) )
         endif

         if (pnvv.ne.0) then
            if (filt(pnvv).gt.0) &
                 call filter(vv_pres,filt(pnvv),coef(pnvv),'G', .false., &
                             l_minx,l_maxx,l_miny,l_maxy, nko)
            call ecris_fst2(vv_pres,l_minx,l_maxx,l_miny,l_maxy,rf, &
                 'VV  ',prmult,0.0, kind,nko, indo, nko, nbit(pnvv) )
         endif

         deallocate(indo,rf,prprlvl,uu_pres,vv_pres,uv_pres,cible)

      endif
!
!-------------------------------------------------------------------
!
      return
      end subroutine out_uv
