!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r out_uv - output winds
!
#include "model_macros_f.h"
!
      subroutine out_uv (F_wlnph_m,DIST_DIM, nk,levset,set)
!
      implicit none
!
      integer nk,DIST_DIM,levset,set

!     NOTE that F_wlnph_m does not have level "0" here
      real F_wlnph_m(DIST_SHAPE,nk+1)
!
!author
!     james caveen/andre methot - rpn july/nov 1995
!
!revision
! v2_00 - Lee V.            - initial MPI version (from out_uv v1_03)
! v2_21 - J. P. Toviessi    - set dieze (#) slab output and rename 
! v2_21                       truncate model output names to 4 characters
! v2_30 - Lee V.            - reorganize slab output to be more efficient;
! v2_30                       there are 3 kinds of grid output here: U,V,PHI
! v2_32 - Lee V.            - reduce dynamic allocation size
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_00 - Tanguay M.        - true winds adjoint
! v3_03 - Tanguay M.        - introduce V4dg_imguv_L 
! v3_20 - Lee V.            - output in block topology, standard file
! v3_21 - Lee V.            - Output Optimization
! v3_30 - Bilodeau/Tanguay  - Cancel knots conversion when AD 
! v3_30 - Tanguay M.        - Remove lastdt .ne. Lctl_step 
! v4_05 - Lee V.            - adaptation to GMM
! v4_40 - Lee V.            - change in argument call for this routine & prgen
!
!object
!     output the wind images or wind components or wind module.
!	
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! F_dostep     I    - array containing indices corresponding to the
!                     timestep sets that requires output at this time step.
! F_dostep_max I    - size of F_dostep array
!
!
!implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "out3.cdk"
#include "geomg.cdk"
#include "out.cdk"
#include "vt1.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "lctl.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
       include "v4dg.inc"
!
      integer i,j,k,ii,jj,jjj,kk
      integer pnerr, psum, kind,nko
      integer :: lastdt = -1
      real find
      integer i0,in,j0,jn,i0v,inv,j0v,jnv,gridi,grido
      logical fla,flb
      real*8 cu_8(l_nj),cv_8(l_nj),c1_8(l_nj)
      real*8 inv_rayt_8
      integer, dimension(:), allocatable::indo
      real ,dimension(:,:,:), allocatable:: uv_pres,uu_pres,vv_pres
      real ,dimension(:), allocatable::prprlvl,rf
      real uv(minx:maxx,miny:maxy,nk+1)
      real t3(minx:maxx,miny:maxy,G_nk+1), t4(minx:maxx,miny:maxy,G_nk+1)
      real, dimension(:,:,:), pointer :: uu,vv
      save lastdt,uu,vv
!     variables to point to gmm variables:
      real uu_temp,vv_temp
      pointer (pauutmp, uu_temp(minx:maxx,miny:maxy,G_nk+1) )
      pointer (pavvtmp, vv_temp(minx:maxx,miny:maxy,G_nk+1) ) 
      real uu_temp1(minx:maxx,miny:maxy),vv_temp1(minx:maxx,miny:maxy)

! ___________________________________________________________________
!
!     1.0     initialization of data
!_______________________________________________________________________
!
      integer pnuu,pnvv,pnuv
      integer nbit(0:Outd_var_max(set)+1),filt(0:Outd_var_max(set)+1)
      real    coef(0:Outd_var_max(set)+1)
!
!     initialize conversion of units
!
      real prmult
!
      prmult =  1.0 / Dcst_knams_8
      if (V4dg_ad_L) prmult = 1.0
!_______________________________________________________________________
!
      pnuu=0
      pnvv=0
      pnuv=0

      do ii=0,Outd_var_max(set)
         coef(ii)=0.0
         filt(ii)=0
         nbit(ii)=0
      enddo

      do ii=1,Outd_var_max(set)
        if (Outd_var_S(ii,set).eq.'UU')then
           pnuu=ii
        endif
        if (Outd_var_S(ii,set).eq.'VV')then
           pnvv=ii
        endif
        if (Outd_var_S(ii,set).eq.'UV')then
           pnuv=ii
        endif
        nbit(ii)=Outd_nbit(ii,set)
        filt(ii)=Outd_filtpass(ii,set)
        coef(ii)=Outd_filtcoef(ii,set)
      enddo
      psum=pnuu+pnuv+pnvv
      if (psum.eq.0)return
      If (lastdt .eq. -1) then
          allocate ( uu(minx:maxx,miny:maxy,G_nk+1) )
          allocate ( vv(minx:maxx,miny:maxy,G_nk+1) )
      endif
!_______________________________________________________________________
!
!     Output of derived winds on Phi grid
!_______________________________________________________________________
!
!     4.0    Load and Get required fields
!_______________________________________________________________________
!
!
!     Transfer u,v in t3,t4 if not specific 4D-Var case   
!     -------------------------------------------------
      if (lastdt .ne. Lctl_step) then
          gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
          if (GMM_IS_ERROR(gmmstat)) print *,'out_dyn ERROR at gmm_get(ut1)'
          gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
          if (GMM_IS_ERROR(gmmstat)) print *,'out_dyn ERROR at gmm_get(vt1)'
          fla = V4dg_ad_L.and.V4dg_imguv_L

          if (V4dg_ad_L.and..not.V4dg_imguv_L) call handle_error(-1,'out_uv','STOP IN OUT_UV: ADJOINT not certified')
          flb = ( (V4dg_di_L.or.V4dg_tl_L) .and. .not.V4dg_imguv_L )  &
                  .or. V4dg_ad_L
          if ( (V4dg_conf.eq.0) .or. (.not.fla.and..not.flb) ) then
              pauutmp = loc(ut1)
              pavvtmp = loc(vt1)
          else
!        -----------------------------------------------------------------
!        When NL-TL: First cu_8 used for conversion from true wind to image wind
!        When AD   : First cu_8 used for conversion from adjoint image wind to adjoint true wind
!        When AD   :Second cu_8 used to  compensate for scaling done later on in OUT_UV
!        -----------------------------------------------------------------
              pauutmp = loc(t3)
              pavvtmp = loc(t4)
              inv_rayt_8 =  1.0 / Dcst_rayt_8
              do j= 1, l_nj
                 cu_8(j) = Geomg_cy_8 (j) * inv_rayt_8
                 cv_8(j) = Geomg_cyv_8(j) * inv_rayt_8
              end do
              if (fla.and.flb) then
                  cu_8 = cu_8 * cu_8
                  cv_8 = cv_8 * cv_8
              endif
              do k =1, G_nk+1
              do j= 1, l_nj
              do i= 1, l_ni
                 uu_temp(i,j,k) = cu_8(j) * ut1(i,j,k)
                 vv_temp(i,j,k) = cv_8(j) * vt1(i,j,k)
              end do
              end do
              end do
          endif
      
!_______________________________________________________________________
!
!     5.0     Compute real wind from image wind
!_______________________________________________________________________
!         Horizontal interpolation of image winds into PHI output grid.
!
          do j= 1, l_nj
             c1_8(j) = Dcst_rayt_8 / geomg_cy_8(j)
          end do
!
          call uv_acg2g (uu ,uu_temp ,1,0,LDIST_DIM,G_nk+1 ,i0 ,in ,j0 ,jn )
          call uv_acg2g (vv ,vv_temp ,2,0,LDIST_DIM,G_nk+1 ,i0v,inv,j0v,jnv)
!
          if (.not.G_lam) then
!         Compute real wind components from wind images.
              do k=1,G_nk+1
              do j= 1, l_nj
              do i= 1, l_ni
                 uu(i,j,k) = c1_8(j) * uu(i,j,k)
                 vv(i,j,k) = c1_8(j) * vv(i,j,k)
              end do
              end do
              end do
          else
!         Borders need to be filled for LAM configuration
              do k=1,G_nk+1
                do i=1,i0-1
                do j=1,l_nj
                   uu(i,j,k)=uu(i0,j,k)
                enddo
                enddo      
                do i=in+1,l_ni
                do j=1,l_nj
                   uu(i,j,k)=uu(in,j,k)
                enddo
                enddo
                do j=1,j0-1
                do i=1,l_ni
                   uu(i,j,k)=uu(i,j0,k)
                enddo
                enddo     
                do j=jn+1,l_nj
                do i=1,l_ni
                   uu(i,j,k)=uu(i,jn,k)
                enddo
                enddo
                do i=1,i0v-1
                do j=1,l_nj
                   vv(i,j,k)=vv(i0v,j,k)
                enddo
                enddo     
                do i=inv+1,l_ni
                do j=1,l_nj
                   vv(i,j,k)=vv(inv,j,k)
                enddo
                enddo
                do j=1,j0v-1
                do i=1,l_ni
                   vv(i,j,k)=vv(i,j0v,k)
                enddo
                enddo      
                do j=jnv+1,l_nj
                do i=1,l_ni
                   vv(i,j,k)=vv(i,jnv,k)
                enddo
                enddo
              enddo
! NOW     Compute real wind components from wind images.
              do k=1,G_nk+1
              do j= 1, l_nj
              do i= 1, l_ni
                 uu(i,j,k) = c1_8(j) * uu(i,j,k)
                 vv(i,j,k) = c1_8(j) * vv(i,j,k)
              end do
              end do
              end do
          endif
!
      endif
! IF LASTDT end
      lastdt = Lctl_step
!
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
!
      if (Level_typ_S(levset) .eq. 'M') then
!_______________________________________________________________________
!
!     6.0a    Output of (UU,VV,UV) Variables on ETA levels
!_______________________________________________________________________
!
        kind=Level_kind_ip1
!       Setup the indexing for output
        allocate (indo( min(Level_max(levset),Level_momentum) ))
        call out_slev(Level(1,levset), Level_max(levset), &
                      Level_momentum,indo,nko)

        if (pnuu.ne.0) &
            call ecris_fst2(uu,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                 'UU  ',prmult,0.0,kind,nk+1, indo, nko, nbit(pnuu) )
            
        if (pnvv.ne.0) &
            call ecris_fst2(vv,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                 'VV  ',prmult,0.0,kind,nk+1, indo, nko, nbit(pnvv) )
        if (pnuv.ne.0) then
            do k = 1,G_nk+1
            do j = j0, jn 
            do i = i0, in
               uv(i,j,k) = sqrt(uu(i,j,k)*uu(i,j,k)+ &
                          vv(i,j,k)*vv(i,j,k))
            enddo
            enddo
            enddo
            call ecris_fst2(uv,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                 'UV  ',prmult,0.0,kind,nk+1, indo, nko, nbit(pnuv) )
        endif
        deallocate(indo)

      else
!_______________________________________________________________________
!
!     7.0B   Output UU,VV,UV on PRESSURE levels
!_______________________________________________________________________
!
!       Set kind to 2 for pressure output
        kind=2
!       Setup the indexing for output
        nko=Level_max(levset)
        allocate ( indo(nko), rf(nko) , prprlvl(nko) )
        do i = 1, nko
           indo(i)=i
           rf(i)= Level(i,levset)
           prprlvl(i) = rf(i) * 100.0
        enddo
        allocate(uu_pres(LDIST_SHAPE,nko))
        allocate(vv_pres(LDIST_SHAPE,nko))
        allocate(uv_pres(LDIST_SHAPE,nko))

!        Compute vertical derivative of UU,VV with respect to wlnph

         call verder (t3, uu, F_wlnph_m,2.0,2.0, &
                      LDIST_DIM, G_nk+1,i0,in,j0,jn)
         call verder (t4, vv, F_wlnph_m,2.0,2.0, &
                      LDIST_DIM, G_nk+1,i0,in,j0,jn)
!
!        Compute UU
         call prgen( uu_pres,uu, t3,F_wlnph_m,prprlvl,nko, &
                     Out3_cubuv_L, LDIST_DIM,G_nk+1,&
                     1,l_ni,1,l_nj)
!        Compute VV
         call prgen( vv_pres,vv, t4, F_wlnph_m,prprlvl,nko, &
                     Out3_cubuv_L, LDIST_DIM,G_nk+1,&
                     1,l_ni,1,l_nj)
         if(pnuv.ne.0) then
!        Compute UV
             do k =  1, nko
             do j = j0, jn
             do i = i0, in
                uv_pres(i,j,k) = sqrt(uu_pres(i,j,k)*uu_pres(i,j,k)+ &
                vv_pres(i,j,k)*vv_pres(i,j,k))
             enddo
             enddo
             enddo
             if (filt(pnuv).gt.0) &
               call filter(uv_pres,filt(pnuv),coef(pnuv),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
             call ecris_fst2(uv_pres,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'UV  ',prmult,0.0, kind,nko, indo, nko, nbit(pnuv) )
         endif
!
         if (pnuu.ne.0) then
             if (filt(pnuu).gt.0) &
               call filter(uu_pres,filt(pnuu),coef(pnuu),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
             call ecris_fst2(uu_pres,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'UU  ',prmult,0.0, kind,nko, indo, nko, nbit(pnuu) )
         endif
!
         if (pnvv.ne.0) then
             if (filt(pnvv).gt.0) &
               call filter(vv_pres,filt(pnvv),coef(pnvv),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
             call ecris_fst2(vv_pres,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'VV  ',prmult,0.0, kind,nko, indo, nko, nbit(pnvv) )
         endif
                     
         deallocate(indo,rf,prprlvl,uu_pres,vv_pres,uv_pres)
      endif
!     
      return
      end
