!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**   s/r set_dync - initialize the dynamics model configuration
!
      subroutine set_dync(F_t,F_fis,Minx,Maxx,Miny,Maxy,F_nk)
      use matvec_mod, only: matvec_init
      implicit none
#include <arch_specific.hf>

      !Arguments
      !---------
      integer,                                   intent(in) :: Minx,Maxx,Miny,Maxy !I, Dimension H
      integer,                intent(in) :: F_nk     !I, Number of vertical levels 
      real, dimension(Minx:Maxx,Miny:Maxy,F_nk), intent(in) :: F_t                 !I: Temperature
      real, dimension(Minx:Maxx,Miny:Maxy),   intent(inout) :: F_fis               !I: Terrain


!author
!     M. Desgagne - V. Lee ( after version v1_03 of setdync )
!
!revision
! v2_00 - Desgagne/Lee       - initial MPI version
! v2_10 - Lee V.             - correction to call to pstune
! v2_20 - Desgagne M.        - fnom on Wafiles now in p_set
! v2_30 - Desgagne M.        - entry vertical interpolator in gemdm
! v3_00 - Desgagne & Lee     - Lam configuration
! v3_30 - Desgagne M.        - Add calls to: set_opr and adw_set
! v4_00 - Plante & Girard    - Log-hydro-pressure coord on Charney-Phillips grid
! v4_05 - Girard C.          - Open top

#include "cstv.cdk"
#include "dcst.cdk"
#include "glb_ld.cdk"
#include "geomg.cdk"
#include "lam.cdk"
#include "lun.cdk"
#include "schm.cdk"
#include "sol.cdk"
#include "ver.cdk"

      integer k,err,istat,k0,i,j
      real tmean(G_nk)
      real*8  w1, w2
      real*8, parameter :: zero=0.d0, one=1.d0
!
!     ---------------------------------------------------------------

      if (lun_out.gt.0) then
          write(Lun_out,*)'SETTING up OPR,ADW,...(S/R SET_DYNC)'
          write(Lun_out,*)'===================================='
      endif

      k0=1+Lam_gbpil_T

      Cstv_tau_8   = Cstv_dt_8 * Cstv_bA_8
      Cstv_invT_8  = one/Cstv_tau_8
      Cstv_Beta_8  = (one-Cstv_bA_8)/Cstv_bA_8

      Ver_igt_8    = Cstv_invT_8/Dcst_grav_8
      Ver_ikt_8    = Cstv_invT_8/Dcst_cappa_8
      if(Schm_hydro_L) Ver_igt_8=zero
      Ver_igt2_8   = Ver_igt_8**2

      if( Cstv_Tstr_8 .lt. 0. .or. Cstv_Tstr_8.gt.1000. ) then
         ! TSTAR variable at least in the vertical
         call estimate_tmean (tmean,F_t,l_minx,l_maxx,l_miny,l_maxy,G_nk)
         Ver_Tstr_8(1:G_nk) = tmean(1:G_nk)
      else
         do k=1,G_nk
            Ver_Tstr_8(k) = Cstv_Tstr_8
         enddo
      endif

      Ver_fistr_8(G_nk+1)= 0.d0
      do k = G_nk, 1, -1
         Ver_fistr_8(k) = Ver_fistr_8(k+1)-Dcst_Rgasd_8*Ver_Tstr_8(k)*(Ver_z_8%m(k)-Ver_z_8%m(k+1))
      enddo

      do k=1,G_nk
         Ver_epsi_8(k)=Dcst_Rgasd_8*Ver_Tstr_8(k)*Ver_igt2_8
         Ver_gama_8(k)=Cstv_invT_8**2/ &
              (Dcst_Rgasd_8*Ver_Tstr_8(k)*(Dcst_cappa_8+Ver_epsi_8(k)))
      enddo

      Cstv_hco0_8 = Dcst_rayt_8**2
      Cstv_hco1_8 = zero
      Cstv_hco2_8 = one

      Ver_alfat_8 = one
      Ver_cst_8   = zero
      Ver_cstp_8  = zero

      if(Schm_opentop_L) then
         w1 = Ver_wm_8%m(k0)*(Ver_idz_8%t(k0-1) &
                 +(one-Dcst_cappa_8)*Ver_epsi_8(k0-1)*Ver_wm_8%t(k0-1))
         w2 = one/(Ver_idz_8%t(k0-1)+Ver_epsi_8(k0-1)*Ver_wm_8%t(k0-1))
         Ver_alfat_8 = (Ver_idz_8%t(k0-1) &
                         - Ver_epsi_8(k0-1)*Ver_wp_8%t(k0-1)) * w2
         Ver_cst_8   =                 one / Ver_gama_8(k0-1) * w2
         Ver_cstp_8  = (Ver_idz_8%t(k0-1)*Ver_idz_8%m(k0)-w1) * w2
      endif

      w1 = Ver_wp_8%m(G_nk)*(Ver_idz_8%t(G_nk) &
          -(one-Dcst_cappa_8)*Ver_epsi_8(G_nk)*Ver_wp_8%t(G_nk))
      w2 = one/(Ver_idz_8%t(G_nk)+Dcst_cappa_8*Ver_wp_8%t(G_nk))
      Ver_alfas_8 = (Ver_idz_8%t(G_nk) &
                            - Dcst_cappa_8*Ver_wm_8%t(G_nk)) * w2
      Ver_css_8   =                   one / Ver_gama_8(G_nk) * w2
      Ver_cssp_8  = (Ver_idz_8%t(G_nk)*Ver_idz_8%m(G_nk)+w1) * w2

      Cstv_bar0_8 = zero
      Cstv_bar1_8 = one
      if(Schm_autobar_L) then
         Cstv_bar0_8 = Cstv_invT_8**2/Ver_FIstr_8(1)
         Cstv_bar1_8 = zero
         Ver_alfas_8 = one
         Ver_css_8   = zero
         Ver_cssp_8  = zero
         Cstv_hco1_8 = Dcst_cappa_8/(Cstv_Zsrf_8-Ver_z_8%m(1))
         Cstv_hco2_8 = zero
      endif

      call set_opr

      call itf_adx_set

      call grid_area_mask (Geomg_area_8, Geomg_mask_8, l_ni,l_nj)

      if (Sol_type_S == 'ITERATIVE_3D') then
         call matvec_init()
     end if
!
!     ---------------------------------------------------------------
!
      return
      end
