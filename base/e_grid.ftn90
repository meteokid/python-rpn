!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r e_grid - compute the grid of the model
#include "model_macros_f.h"
!
      subroutine e_grid 
      implicit none
#include <arch_specific.hf>
!
!author  unknown
!
!revision
! v2_30 - Dugas B.          - use real*8 rotation matrices and 
! v2_30                       cartesian coordinates
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_11 - Tanguay M.        - Introduce Grd_gauss_L 
! v3_30 - Desgagne M.       - Check that LAM grid does not extend to
!                             global coverage and eliminated Grd_roule
!
!implicits
#include "e_grids.cdk"
#include "e_geomg.cdk"
#include "dcst.cdk"
#include "hgc.cdk"
#include "grd.cdk"
!
      integer  ezgdef_fmem
      external ezgdef_fmem
!
      logical global_extend
      integer i, j, ierx, iery
      real*8 x_8(0:Grd_ni+1), y_8(0:Grd_nj+1)
      real*8 pt5,epsilon,deg2rad_8,ONE_8,CLXXX_8
      parameter ( pt5    = 0.5d0, epsilon = 1.0d-5)
      parameter ( ONE_8  = 1.0  , CLXXX_8 = 180.0 )
!
!----------------------------------------------------------------------
!
      write(6,1001)

      deg2rad_8 = acos( -ONE_8 )/CLXXX_8

      global_extend = (abs(1.0d0-abs(Grd_xl-Grd_x0)/360.d0).lt.epsilon) &
                 .or. (abs(1.0d0-abs(Grd_yl-Grd_y0)/180.d0).lt.epsilon)

      if (lam .and. global_extend) then
         write (6,9000) 
         call handle_error(-1,'e_grid','')
      endif

      allocate (xfi(Grd_ni+1),yfi (Grd_nj),xu  (Grd_ni+1),yv   (Grd_nj-1))
      allocate (xdx(Grd_ni+1),xdy (Grd_nj),xdxu(Grd_ni+1),xdyv (Grd_nj-1))
      allocate (              xdcy(Grd_nj),               xdcyv(Grd_nj-1))
      allocate (xdhx(Grd_ni) ,xdhy(Grd_nj), xdhxu(0:Grd_ni), xdhyv(0:Grd_nj))

      call set_gemHgrid ( x_8(1), y_8(1), Grd_ni, Grd_nj, Grd_dx, Grd_dy,     & 
                          Grd_x0, Grd_xl, Grd_left, Grd_y0, Grd_yl, Grd_belo, &
                          Grd_nila, Grd_njla, Grd_dxmax, Grd_dymax,           &
                          Grd_gauss_L, lam, ierx, iery, .true. )

      if (lam) then
         x_8(    0   ) = x_8(1)      - Grd_dx
         x_8(Grd_ni+1) = x_8(Grd_ni) + Grd_dx
         y_8(    0   ) = y_8(1)      - Grd_dy
         y_8(Grd_nj+1) = y_8(Grd_nj) + Grd_dy
      else
         x_8(    0   ) =   x_8(Grd_ni) - 360.
         y_8(    0   ) = - 90.
         y_8(Grd_nj+1) =   90.
      endif

      do i=1,Grd_ni
         xu(i) = pt5 * ( x_8(i) + x_8(i+1) )
      enddo
      xu(Grd_ni+1) = 0.
      if (.not.LAM) xu(Grd_ni+1) = pt5 * ( x_8(1) + x_8(2) ) + 360. 

      do i=1,Grd_nj-1
         yv(i) = pt5 * ( y_8(i) + y_8(i+1) )
      enddo

      xfi(1:Grd_ni+1) = x_8(1:Grd_ni+1)
      yfi(1:Grd_nj  ) = y_8(1:Grd_nj  )

      xdx  (1:Grd_ni+1) = xfi(1:Grd_ni+1) * deg2rad_8
      xdxu (1:Grd_ni+1) = xu (1:Grd_ni+1) * deg2rad_8
      xdy  (1:Grd_nj  ) = yfi(1:Grd_nj  ) * deg2rad_8
      xdyv (1:Grd_nj-1) = yv (1:Grd_nj-1) * deg2rad_8
      xdcy (1:Grd_nj  ) = cos( xdy (1:Grd_nj  ) )
      xdcyv(1:Grd_nj-1) = cos( xdyv(1:Grd_nj-1) )

      do i=1,Grd_ni
         xdhx (i) = xdx (i+1) - xdx (i)
         xdhxu(i) = xdxu(i+1) - xdxu(i)
      enddo
      do j=1,Grd_nj-1
         xdhy(j) = xdy(j+1) - xdy(j)
      enddo
      do j=1,Grd_nj-2
         xdhyv(j) = xdyv(j+1) - xdyv(j)
      enddo
      xdhy(Grd_nj) = xdhy(Grd_nj-1)

      if (lam) then
         xdhxu (0) = xdhxu(1)
         xdhyv (0) = xdhyv(1)
         xdhyv(Grd_nj-1) = xdhyv(Grd_nj-1)
         nifi = Grd_ni
         niu  = nifi-1
         pni  = nifi
         pniu = niu
      else
         xdhxu(    0   ) = xdxu (1) + 2.0 * Dcst_pi_8 - xdxu(Grd_ni)
         xdhxu(Grd_ni  ) = xdhxu(0)
         xdhyv(    0   ) = xdyv (1) + ( Dcst_pi_8 / 2.0 )
         xdhyv(Grd_nj-1) = ( Dcst_pi_8 / 2.0 ) - xdyv(Grd_nj-1)
         nifi = Grd_ni+1
         niu  = nifi
         pni  = nifi-1
         pniu = pni
      endif

      niv  = nifi
      njfi = Grd_nj
      nju  = Grd_nj
      njv  = Grd_nj-1
      pnj  = njfi
      pnjv = njv
!
      dstf_gid = ezgdef_fmem (nifi , Grd_nj , 'Z', 'E', Hgc_ig1ro, &
                     Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
      dstu_gid = ezgdef_fmem (niu  , Grd_nj , 'Z', 'E', Hgc_ig1ro, &
                     Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xu  , yfi )
      dstv_gid = ezgdef_fmem (nifi , njv    , 'Z', 'E', Hgc_ig1ro, &
                     Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yv  )

 1001 format (/1x,'COMPUTE MODEL GRID (S/R E_GRID)', &
              /1x,34('='))
 9000 format (/' LAM grid extends to global coverage on at least ', &
              /' one axis ---- ABORT -----'/)
!
!----------------------------------------------------------------------
!
      return
      end
