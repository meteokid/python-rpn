!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!** casc_hvi - Horizontal & vertical interpolation of lo-res input data
!              from 3df files to the hi-res destination grid
!
#include "model_macros_f.h"
!
      subroutine casc_hvi (trname_a,xpq1,ypq1,xpu1,ypv1,xpaq1,ypaq1,xpau1,ypav1, &
                           uu1,vv1,tt1,zd1,ssq1,qq1,ww1,tr1,topo1,               &
                           uun,vvn,ttn,zdn,meqn,ssqn,qqn,wwn,trn,                &
                           F_ni,F_nj,lnk,nia,nja,nka_m,nka_t,presstype,ntra)
      implicit none
#include <arch_specific.hf>
!
      integer :: F_ni,F_nj,lnk,nia,nja,nka_m,nka_t,presstype,ntra
      character(len=*) :: trname_a(ntra)
      real*8 xpq1 (*),ypq1 (*),xpu1 (*),ypv1 (*)
      real*8 xpaq1(*),ypaq1(*),xpau1(*),ypav1(*)
      real uun(*),vvn(*),ttn(*),zdn(*),meqn(*),ssqn(*), &
           qqn(*),wwn(*),trn(*),topo1(*)
      real uu1(F_ni,F_nj,lnk+1), vv1(F_ni,F_nj,lnk+1), &
           tt1(F_ni,F_nj,lnk+2), zd1(F_ni,F_nj,lnk+1), &
           qq1(F_ni,F_nj,lnk+2), ww1(F_ni,F_nj,lnk+1), &
          ssq1(F_ni,F_nj)      , tr1(F_ni,F_nj,lnk+2,* )
!
!author    M. Desgagne  2001
!
!revision
! v3_30 - Lee V.       - initial version for GEMLAM
! v4_03 - Lee V.       - Adapt to using new pressure functions
! v4_05 - Plante A.    - top nesting
! v4_05 - Lee V.       - force vertical interpolation all the time unless ACID
! v4_14 - Desgagne M.  - Major revision
!
!nka_m - number of momentum levels
!nka_t - number of true thermo levels
!presstype:
! 0 - pressure
! 1 - sigma
! 2 - etasef
! 3 - eta (rcoef=1.0)
! 4 - hybrid
! 5 - ecmwf
! 6 - staggered hybrid
!
! ? - ecmwf - not available

#include "glb_ld.cdk"
#include "bcsgrds.cdk"
#include "lam.cdk"
#include "geomg.cdk"
#include "schm.cdk"
#include "pres.cdk"
#include "tr3d.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
#include "ptopo.cdk"
#include "lun.cdk"
#include "acid.cdk"

      integer,external ::  get_px

      logical Vertint_L
      integer i,j,k,n,nga,err,jj,mustvinterp,mustvinterp_g
      integer nid1,njd1,ngd,ngd1,nidu,njdv
      integer, dimension (:      ), allocatable :: idx,idu,idy
      real s1,s2
      real   , dimension (:      ), allocatable :: rna
      real   , dimension (:,:    ), allocatable :: ssqr,ssur,ssvr,ssq0,ssu0,ssv0
      real   , dimension (:,:    ), allocatable :: ssq0x,pres,ssqx
      real   , dimension (:,:,:  ), allocatable :: dstlev,srclev,uur,vvr,ttr,zdr,qqr,wwr,meqx,ttx,vtx,hutx
      real   , dimension (:,:,:,:), allocatable :: trr
      real*8 , dimension (:      ), allocatable :: cxa,cxb,cxc,cxd,cua,cub,cuc,cud,cya,cyb,cyc,cyd
      real*8 lnpis_8,lnpref_8,r1,r2
!
!-----------------------------------------------------------------------
!
      lnpref_8  = log(Cstv_pref_8)

      nid1 = l_ni+1-(east *1)
      njd1 = l_nj+1-(north*1)

      nga  = nia  * nja
      ngd  = F_ni * F_nj
      ngd1 = nid1 * njd1

      if (ngd.le.0) return
!
      allocate ( idx(nid1), idy(njd1), idu(max(F_ni,F_nj)) )
      allocate ( cxa(nid1),cxb(nid1),cxc(nid1),cxd(nid1),  &
                 cua(max(nid1,njd1)),cub(max(nid1,njd1)),  &
                 cuc(max(nid1,njd1)),cud(max(nid1,njd1)),  &
                 cya(njd1),cyb(njd1),cyc(njd1),cyd(njd1)   )
!
      allocate ( uur(F_ni,F_nj,nka_m), vvr(F_ni,F_nj,nka_m  ), zdr(F_ni,F_nj,nka_t-1), &
                 ttr(F_ni,F_nj,nka_t), qqr(F_ni,F_nj,nka_m+1), wwr(F_ni,F_nj,nka_t-1), &
                 trr(F_ni,F_nj,nka_t,ntra),                                            &
                 ssur(F_ni,F_nj), ssvr(F_ni,F_nj), ssqr(F_ni,F_nj),                    &
                 ssq0(F_ni,F_nj), ssu0(F_ni,F_nj), ssv0(F_ni,F_nj) )

      allocate ( ttx  (nid1,njd1,nka_t),  meqx(nid1,njd1,nka_m), &
                 ssqx (nid1,njd1)      ,  ssq0x(nid1,njd1) )
!
! Perform horizontal interpolations for ttx, meqx and ssqx on extended (nid1,njd1) grid
!
      call grid_to_grid_coef(xpq1,nid1,xpaq1,nia,idx,cxa,cxb,cxc,cxd, Lam_hint_S)
      call grid_to_grid_coef(ypq1,njd1,ypaq1,nja,idy,cya,cyb,cyc,cyd, Lam_hint_S)

      call hinterpo ( ttx,nid1,njd1, ttn,nia,nja,nka_t, &
                      idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      ttr(1:F_ni,1:F_nj,:) = ttx(1:F_ni,1:F_nj,:)

      if (presstype.eq.0) then !pressure levels
          call hinterpo ( meqx,nid1,njd1, meqn,nia,nja,nka_m, &
                          idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
          ssqx=0.0
      else
          call hinterpo ( meqx,nid1,njd1, meqn,nia,nja,   1, &
                          idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
          call hinterpo ( ssqx,nid1,njd1, ssqn,nia,nja,   1, &
                          idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
          ssqr(1:F_ni,1:F_nj) = ssqx (1:F_ni,1:F_nj)
      endif
!
! Perform horizontal interpolations for all other variables on regular (F_ni,F_nj) grid
!
      if (.not.Schm_hydro_L.and.ana_q_L)                  &
      call hinterpo ( qqr,F_ni,F_nj, qqn,nia,nja,nka_m+1, &
                      idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      if (ana_zd_L)                                       &
      call hinterpo ( zdr,F_ni,F_nj, zdn,nia,nja,nka_t-1, &
                      idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      if (ana_w_L)                                        &
      call hinterpo ( wwr,F_ni,F_nj, wwn,nia,nja,nka_t-1, &
                      idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      do k=1,ntra
         if (trname_a(k).ne.'!@@NOT@@')                                          &
         call hinterpo (trr(1,1,1,k),F_ni,F_nj,trn((k-1)*nga*(nka_t)+1),nia,nja, &
                        nka_t,idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,Lam_hint_S)
      end do

! Horizontal interpolation ===> U point (xpu1,ypq1)
! unn=>uur (xpau1,ypaq1) ===> (xpu1,ypq1)
      call grid_to_grid_coef (xpu1,F_ni,xpau1,nia,idu,cua,cub,cuc,cud,Lam_hint_S)
      call hinterpo (uur,F_ni,F_nj,uun,nia,nja,nka_m, &
                     idu,idy,cua,cub,cuc,cud,cya,cyb,cyc,cyd,Lam_hint_S)

! ssqn=>ssur (xpaq1,ypaq1) ===> (xpu1,ypq1)
      call grid_to_grid_coef (xpu1,F_ni,xpaq1,nia,idu,cua,cub,cuc,cud,Lam_hint_S)
      call hinterpo (ssur,F_ni,F_nj,ssqn,nia,nja,1, &
                     idu,idy,cua,cub,cuc,cud,cya,cyb,cyc,cyd,Lam_hint_S)

! Horizontal interpolation ===> V point (xpq1,ypv1)
! vvn=>vvr (xpaq1,ypav1) ===> (xpq1,ypv1)
      call grid_to_grid_coef (ypv1,F_nj,ypav1,nja,idu,cua,cub,cuc,cud,Lam_hint_S)
      call hinterpo (vvr,F_ni,F_nj,vvn,nia,nja,nka_m, &
                     idx,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,Lam_hint_S)

      call grid_to_grid_coef (ypv1,F_nj,ypaq1,nja,idu,cua,cub,cuc,cud,Lam_hint_S)
! ssqn=>ssvr (xpaq1,ypaq1) ===> (xpq1,ypv1)
      call hinterpo (ssvr,F_ni,F_nj,ssqn,nia,nja,1, &
                     idx,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud,Lam_hint_S)

      deallocate (idx,idy,idu,cxa,cxb,cxc,cxd,cua,cub,cuc,cud, &
                                              cya,cyb,cyc,cyd)
!
! Prepare destination ssq1,ssu0,ssv0 surface conditions for vertical interpolation
!
      Vertint_L = .true.

!     Obtain pressure S
      if (presstype.eq.0) then ! Analysis is on pressure coordinates
          allocate (rna(nka_m))
          do i=1,nka_m
             rna(i)=ana_am_8(i)
          enddo
          call gz2p0(ssq0x,meqx,topo1,rna,ngd1,nka_m)
          deallocate (rna)
          ssq0x(1:nid1,1:njd1) =ssq0x(1:nid1,1:njd1)-lnpref_8
      else
!       Analysis NOT on pressure coordinates, obtain surface pressure
!        whether or not there is vertical interpolation

         allocate (pres(ngd1,nka_t))
         err = get_px(pres,ssqx,ngd1,ana_at_8,ana_bt_8,nka_t,presstype,.false.)
         call handle_error(err,'casc_hvi','casc_hvi:get_px')
         jj=-1
         do k=1,ntra
               if (trname_a(k)(1:4).eq.'HU  ') jj=k
         enddo
         !call handle_error(jj,'casc_hvi','casc_hvi: no HU')
         allocate(vtx(nid1,njd1,nka_t),hutx(nid1,njd1,nka_t))
         if (ana_vt_l) then
             vtx(:,:,:) = ttx(:,:,:)
         else
             do k=1,nka_t
                call mfotvt (vtx(1,1,k),ttx(1,1,k),hutx(1,1,k), &
                             ngd1,1,ngd1)
             enddo
         endif
         call adj_ss2topo(ssq0x, topo1,pres,meqx,vtx,ngd1,nka_t)
         deallocate (vtx,hutx)
         deallocate (pres)

         if ((presstype.eq.Ver_code).and.(G_nk+2.eq.nka_t)) then
            Vertint_L   = .false.
            mustvinterp = 0
            do k=1,G_nk+2
               r1=ana_at_8(k)
               r2=Ver_a_8%t(k)
               if (abs((r1-r2)/r1).gt.1.e-10) mustvinterp=mustvinterp+1
               r1=ana_bt_8(k)
               r2=Ver_b_8%t(k)
               if (abs((r1-r2)/r1).gt.1.e-10) mustvinterp=mustvinterp+1
            end do
            do k=1,G_nk+1
               r1=ana_am_8(k)
               r2=Ver_a_8%m(k)
               if (abs((r1-r2)/r1).gt.1.e-10) mustvinterp=mustvinterp+1
               r1=ana_bm_8(k)
               r2=Ver_b_8%m(k)
               if (abs((r1-r2)/r1).gt.1.e-10) mustvinterp=mustvinterp+1
            end do
            do j=1,njd1
            do i=1,nid1
               s1=ssq0x(i,j)
               s2=exp(ssqx (i,j))*Cstv_pref_8 
               if (abs((s1-s2)/s1).gt.1.e-5) mustvinterp=mustvinterp+1
            enddo
            enddo
            call rpn_comm_allreduce ( mustvinterp,mustvinterp_g,1, &
                               "MPI_integer","MPI_SUM","grid",err)
            if ( mustvinterp_g .gt. 0 ) Vertint_L = .true.
         endif
         ssq0x(1:nid1,1:njd1) = log(ssq0x(1:nid1,1:njd1)/Cstv_pref_8)
      endif

! Compute ssq1,ssu0 and ssv0 and a first set of srclev,dstlev

      if (Vertint_L) then
         ssq1(1:F_ni,1:F_nj) = ssq0x(1:F_ni,1:F_nj)
         nidu=F_ni
         njdv=F_nj
         if (l_east) nidu=F_ni-1
         if (l_north)njdv=F_nj-1
         do j=1,F_nj
         do i=1,nidu
            ssu0(i,j)= (ssq0x(i,j)+ssq0x(i+1,j  ))*.5
         enddo
         enddo
         if (l_east) then
            do j=1,F_nj
               ssu0(F_ni,j)= ssq0x(F_ni,j)
            enddo 
         endif
         do j=1,njdv
         do i=1,F_ni
            ssv0(i,j)= (ssq0x(i,j)+ssq0x(i  ,j+1))*.5
         enddo
         enddo
         if (l_north) then
            do i=1,F_ni
               ssv0(i,F_nj)= ssq0x(i,F_nj)
             enddo 
         endif

         allocate (dstlev(F_ni,F_nj,G_nk+2),srclev(F_ni,F_nj,max(nka_t,nka_m+1)))

         err = get_px(srclev,ssqr,ngd,ana_at_8,ana_bt_8,nka_t,presstype,.true.)
         call handle_error(err,'casc_hvi','casc_hvi:get_px')
         err = get_px(dstlev,ssq1,ngd,Ver_a_8%t,Ver_b_8%t,G_nk+2,Ver_code,.true.)
         call handle_error(err,'casc_hvi','casc_hvi:get_px')

      else

         ssq1(1:F_ni,1:F_nj) = ssqx (1:F_ni,1:F_nj)

      endif

      deallocate (ttx, meqx, ssqx, ssq0x)

! VERTICAL INTERPOLATION (in log(pressure))
!
! Interpolate ZD,W 
!
      if (ana_zd_L) then
         if (Vertint_L) then
             call vte_intvertx3(zd1,zdr,srclev,dstlev, ngd, nka_t-1,G_nk+1,'ZD','cubic') 
         else
             zd1(:,:,1:G_nk+1) = zdr(:,:,1:G_nk+1)
         endif
      else
         zd1 = 0.
      endif
!
! Interpolate W 
!
      if (ana_w_L) then
         if (Vertint_L) then
             call vte_intvertx3(ww1,wwr,srclev,dstlev, ngd, nka_t-1,G_nk+1,'WW','cubic') 
         else
             ww1(:,:,1:G_nk+1) = wwr(:,:,1:G_nk+1)
         endif
      else
         ww1 = 0.
      endif
!
! Interpolate TT
!
      if (Vertint_L) then
         call vte_intvertx3(tt1,ttr,srclev,dstlev, ngd, nka_t,G_nk+2,'VT','cubic') 
      else 
         tt1(:,:,1:G_nk+2) = ttr(:,:,1:G_nk+2)
      endif
!
! Interpolate Tracers and place in either bcs or local space
! Use the same srclev,dstlev as calculated in TT
!
      do 100 n=1,Tr3d_ntr
         jj=-1
         do k=1,ntra
            if (Tr3d_name_S(n).eq.trname_a(k)(1:4)) jj=k
         end do
         if (jj.gt.0) then
            if (Vertint_L) then
                call vte_intvertx3(tr1(1,1,1,n),trr(1,1,1,jj),srclev,dstlev,ngd,nka_t,G_nk+2,'HU','cubic')
                tr1(:,:,1:G_nk+2,n) = max(tr1(:,:,1:G_nk+2,n),0.0)
            else
                tr1(:,:,1:G_nk+2,n) = trr(:,:,1:G_nk+2,jj)
            endif
         else
            tr1(:,:,:,n) = 0.
         endif
 100  continue
!
! Interpolate Q
!
      if (.not.Schm_hydro_L) then
          if(ana_q_L) then
             if (Vertint_L) then
                err = get_px(dstlev,ssq1,ngd,Ver_a_8%m(1),Ver_b_8%m(1),G_nk,Ver_code,.true.)
                call handle_error(err,'casc_hvi','casc_hvi:get_px')
                do j=1,F_nj
                do i=1,F_ni
                   lnpis_8 = ssq1(i,j) + Cstv_Zsrf_8
                   dstlev(i,j,G_nk+1) = lnpis_8
                enddo
                enddo
!find pressure levels for qqr(2:nka_m) = qt1(1:G_nk)
                err = get_px(srclev(1,1,2),ssqr,ngd,ana_am_8,ana_bm_8,nka_m-1,presstype,.true.)
                call handle_error(err,'casc_hvi','casc_hvi:get_px')
!set pressure level for qqr(1) = qt1(0)= 0
!set pressure level for qqr(nka_m+1) = qt1(G_nk+1)= psurf
                do j=1,F_nj
                do i=1,F_ni
                   srclev(i,j,1) = ana_at_8(1)
                   lnpis_8 = ssqr(i,j) + Cstv_Zsrf_8
                   srclev(i,j,nka_m+1) = lnpis_8
                enddo
                enddo
                call vte_intvertx3(qq1(1,1,2),qqr,srclev,dstlev, ngd, nka_m+1,G_nk+1,'QQ','cubic') 
                qq1(:,:,1) = 0.
             else
                qq1(:,:,1:G_nk+2) = qqr(:,:,1:G_nk+2)
             endif
          else
             qq1 = 0.
          endif
      endif
!
!     Interpolate UT1 and VT1
!
      if (Vertint_L) then
         err = get_px(srclev,ssur,ngd,ana_am_8,ana_bm_8,nka_m,presstype,.true.)
         call handle_error(err,'casc_hvi','casc_hvi:get_px')
         err = get_px(dstlev,ssu0,ngd,Ver_a_8%m(1),Ver_b_8%m(1),G_nk+1,Ver_code,.true.)
         call handle_error(err,'casc_hvi','casc_hvi:get_px')

         call vte_intvertx3(uu1,uur,srclev,dstlev, ngd, nka_m,G_nk+1,'UU','cubic') 

         err = get_px(srclev,ssvr,ngd,ana_am_8,ana_bm_8,nka_m,presstype,.true.)
         call handle_error(err,'casc_hvi','casc_hvi:get_px')
         err = get_px(dstlev,ssv0,ngd,Ver_a_8%m(1),Ver_b_8%m(1),G_nk+1,Ver_code,.true.)
         call handle_error(err,'casc_hvi','casc_hvi:get_px')

         call vte_intvertx3(vv1,vvr,srclev,dstlev, ngd, nka_m,G_nk+1,'VV','cubic') 

         deallocate (dstlev,srclev)

      else
         uu1(:,:,1:G_nk+1) = uur(:,:,1:G_nk+1)
         vv1(:,:,1:G_nk+1) = vvr(:,:,1:G_nk+1) 
      endif
!
      deallocate (ssur,ssvr,ssqr,ssq0,ssu0,ssv0)
      deallocate (uur,vvr,zdr,ttr,qqr,wwr,trr)
!
!-----------------------------------------------------------------------
!
      return
      end
!
