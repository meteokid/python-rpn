!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r out_qc0 - perform qc output at timestep 0
!
#include "model_macros_f.h"
!
      subroutine out_qc0 ()
      use out_vref_mod, only: out_vref
!
!implicits
!
      implicit none
#include <arch_specific.hf>
!
!
!author 
!     V. Lee    - rpn - july 2004
!
!revision
! v3_20 - Lee V.            - initial MPI version (from blocqc0 v3_12)
! v3_30 - McTaggart-Cowan R.- allow for user-defined domain tag extensions
! v3_31 - Lee V.            - bugfix for requested QC but does not exist in PHY
! v4_03 - Lee V.            - modification of Out_etik_S in out_sgrid only
! v4_05 - Lepine M.         - VMM replacement with GMM
! v4_06 - Lee V.            - out_sgrid,out_href interface changed
! v4_40 - Lee V.            - change in argument call for  prgen
!
!object
!     the output of the QC at timestep 0
!
!arguments
!  NONE
!
!implicits
#include "gmm.hf"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "lun.cdk"
#include "geomn.cdk"
#include "schm.cdk"
#include "pres.cdk"
#include "init.cdk"
#include "rstr.cdk"
#include "out3.cdk"
#include "out.cdk"
#include "grid.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "ptopo.cdk"
#include "tr3d.cdk"
#include "grd.cdk"
#include "lctl.cdk"
#include "vt1.cdk"
#include "cstv.cdk"
#include "type.cdk"
#include "ver.cdk"
!
!*
      integer,external :: doout, longueur
!
      type(gmm_metadata) :: mymeta
      integer err,nrec,dostep(MAXSET),dostep_max,step,key0,key1, &
              i,j,k,trkey1(Tr3d_ntr),qcset(MAXSET),qcset_max,istat
      character*4 ext_S
      integer i0,in,j0,jn,ii,jj,kk,levset,n,ip3,pnerr,nko,gridset
      integer qcnbit,qcfilt,kind
      integer,   dimension(:), allocatable :: indo
      real, dimension(:,:,:), allocatable :: w5
      real, dimension(:), allocatable :: prprlvl,rf
      real wlnpi_m(LDIST_SHAPE,0:G_nk+1), wlnpi_t(LDIST_SHAPE,G_nk+2)
      real px_ta(LDIST_SHAPE,G_nk+2),qc(LDIST_SHAPE,G_nk+2)
      real deg2rad,qccoef
      real p0(LDIST_SHAPE)
      real, pointer , dimension(:,:,:) :: qct1
      logical periodx_L

!*
!
!     check if output is required and initialize control tables
!     ---------------------------------------------------------------
!
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
      dostep_max = doout(dostep,1)
      deg2rad    = acos( -1.0)/180.

      if (dostep_max .le. 0) return

!     CHECK IF QC AT TIMESTEP 0 is requested

      ext_S=""
      qcset_max = 0
      do jj=1,dostep_max
      do kk=1, Outd_sets
         if ( Outd_step(kk).eq.dostep(jj) ) then
            do ii =1,Outd_var_max(kk)
               if (Outd_var_S(ii,kk).eq.'QC') then
                   qcset_max = qcset_max + 1
                   qcset(qcset_max) = kk
                   qcnbit = Outd_nbit(ii,kk)
                   qcfilt = Outd_filtpass(ii,kk)
                   qccoef = Outd_filtcoef(ii,kk)
               endif
            enddo
         endif
      enddo
      enddo

      nullify(qct1)
      istat = gmm_get('TR/'//'QC'//':P',qct1,mymeta)
 
!     if QC is not available, forget it
      if (GMM_IS_ERROR(istat).or.qcset_max.le.0) return 

!     PREPARATION of wlnpi_t for out_qc0 
!    ---------------------------

      istat = gmm_get(gmmk_st1_s,st1,mymeta)
      if (GMM_IS_ERROR(istat)) print *,'out_qc0 ERROR at gmm_get(st1)'
!
!        Log-pressure on momentum and thermo levels,
!        with extra momentum levels at top (k=0) and surface (k=G_nk+1)
!        and with an extra thermo level at surface (k=G_nk+2)
!
         wlnpi_m(:,:,0)= Cstv_Ztop_8
         do k=1,G_nk+1
            do j=1,l_nj
            do i=1,l_ni
               wlnpi_m(i,j,k) = Ver_a_8%m(k) &
                              + Ver_b_8%m(k)*st1(i,j)
               wlnpi_t(i,j,k)=.5d0*(wlnpi_m(i,j,k)+wlnpi_m(i,j,k-1))
            enddo
            enddo
         enddo

         do j=1,l_nj
         do i=1,l_ni
            wlnpi_t(i,j,G_nk+2)=wlnpi_m(i,j,G_nk+1)
         enddo
         enddo

!     setup of ip3

      ip3 = 0
      if (Out3_ip3.eq.-1) ip3 = Lctl_step
      if (Out3_ip3.gt.0 ) ip3 = Out3_ip3

      do j= 1, l_nj
      do i= 1, l_ni
         qct1(i,j,G_nk+2) = qct1(i,j,G_nk+1)
      enddo
      enddo

!     output loop on the number of "sortie" sets

      do 100 n=1, qcset_max
          kk = qcset(n)
          periodx_L=.false.
          gridset = Outd_grid(kk)
          levset = Outd_lev(kk)
          if (.not.G_lam .and.  &
               (Grid_x1(gridset)-Grid_x0(gridset)+1) .eq. G_ni ) periodx_L=.true.
          call out_sgrid(Grid_x0(gridset),Grid_x1(gridset), &
               Grid_y0(gridset),Grid_y1(gridset), &
               Grid_ig1(gridset),Grid_ig2(gridset), &
               periodx_L, Grid_stride(gridset), &
               Grid_etikext_s(gridset),' ' )
          Out_prefix_S(1:1) = 'd'
          Out_prefix_S(2:2) = Level_typ_S(levset)
          call out_sfile(Out3_closestep,Lctl_step,ip3,ext_S)
          call out_href(Geomn_longs,Geomn_latgs)
 
          if (Level_typ_S(levset).eq.'M') then
!_______________________________________________________________________
!
!     4.0   Output QC on ETA levels (thermo)
!_______________________________________________________________________
!
              kind=Level_kind_ip1
              call out_vref(p0,l_minx,l_maxx,l_miny,l_maxy)
!             Setup the indexing for output
              allocate (indo( min(Level_max(levset),Level_thermo) ))
              call out_slev(Level(1,levset), Level_max(levset), &
                        Level_thermo,indo,nko)

              if ( Out3_cliph_L ) then
                   allocate(w5(LDIST_SHAPE,G_nk+2))
                   do k= 1, G_nk+2
                   do j= 1, l_nj
                   do i= 1, l_ni
                      w5(i,j,k) = amax1( qct1(i,j,k), 0. )
                   enddo
                   enddo
                   enddo
                   call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy, &
                      Ver_hyb%t, 'QC  ',1.0,0.0,  kind,G_nk+2,  &
                      indo, nko, qcnbit )
                   deallocate(w5)
              else
                   call ecris_fst2(qct1,l_minx,l_maxx,l_miny,l_maxy, &
                      Ver_hyb%t, 'QC  ',1.0,0.0,  kind,G_nk+2,  &
                      indo, nko, qcnbit )
              endif
              deallocate (indo)
          else
!_______________________________________________________________________
!
!     5.0    Output QC on PRESSURE levels
!_______________________________________________________________________
!
!             Set kind to 2 for pressure output
              kind=2
!
!             Setup the indexing for output
              nko=Level_max(levset)
              allocate ( indo(nko), rf(nko) , prprlvl(nko) )
              do i = 1, nko
                 indo(i)=i
                 rf(i)= Level(i,levset)
                 prprlvl(i) = rf(i) * 100.0
              enddo
              call verder(px_ta, qct1, wlnpi_t, 2.0,2.0, &
                            l_minx,l_maxx,l_miny,l_maxy, G_nk+2, &
                            1,l_ni,1,l_nj)

!             Calculate QC (w5=qc_pres,px=vert.der)
              allocate(w5(LDIST_SHAPE,nko))
              call prgen( w5, qct1, px_ta, wlnpi_t, prprlvl,nko, &
                          Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy, G_nk+2,&
                          1,l_ni,1,l_nj)
              if ( Out3_cliph_L ) then
                   do k= 1, nko
                   do j= 1, l_nj
                   do i= 1, l_ni
                      w5(i,j,k) = amax1( w5(i,j,k), 0. )
                   enddo
                   enddo
                   enddo
              endif

              if (qcfilt.gt.0) &
                  call filter(w5,qcfilt,qccoef,'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
              call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,Level(1,levset), &
                    'QC  ',1.0,       0.0, kind,nko, indo, nko, qcnbit )

              deallocate(indo,rf,prprlvl,w5)

          endif


          call out_cfile

 100  continue

      return
      end

