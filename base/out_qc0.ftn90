!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r out_qc0 - perform qc output at timestep 0
!
#include "model_macros_f.h"
!
      subroutine out_qc0 ()
      use out_vref_mod, only: out_vref
!
!implicits
!
      implicit none
!
!
!author 
!     V. Lee    - rpn - july 2004
!
!revision
! v3_20 - Lee V.            - initial MPI version (from blocqc0 v3_12)
! v3_30 - McTaggart-Cowan R.- allow for user-defined domain tag extensions
! v3_31 - Lee V.            - bugfix for requested QC but does not exist in PHY
! v4_03 - Lee V.            - modification of Out_etik_S in out_sgrid only
! v4_05 - Lepine M.         - VMM replacement with GMM
! v4_06 - Lee V.            - out_sgrid,out_href interface changed
!
!object
!     the output of the QC at timestep 0
!
!arguments
!  NONE
!
!implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "lun.cdk"
#include "geomn.cdk"
#include "schm.cdk"
#include "pres.cdk"
#include "init.cdk"
#include "rstr.cdk"
#include "out3.cdk"
#include "out.cdk"
#include "grid.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "ptopo.cdk"
#include "tr3d.cdk"
#include "grd.cdk"
#include "lctl.cdk"
#include "vt1.cdk"
#include "cstv.cdk"
#include "type.cdk"
#include "ver.cdk"
!
!*
      integer doout, longueur
      external doout, longueur
!
      integer err,nrec,dostep(MAXSET),dostep_max,step,key0,key1, &
              i,j,k,trkey1(Tr3d_ntr),qcset(MAXSET),qcset_max
      character*4 ext_S
      integer i0,in,j0,jn,ii,jj,kk,levset,n,ip3,pnerr,nk_o,nk_ot,gridset
      integer qcnbit,qcfilt
      integer,   dimension(:), allocatable :: ind_o
      real, dimension(:,:,:), allocatable :: w5
      real, dimension(:), allocatable :: prprlvl
      real wlnpi_m(LDIST_SHAPE,0:G_nk+1), wlnpi_t(LDIST_SHAPE,G_nk+2)
      real px_ta(LDIST_SHAPE,G_nk+2),qc(LDIST_SHAPE,G_nk+2)
      real deg2rad,qccoef
      real p0(LDIST_SHAPE)
      real, pointer , dimension(:,:,:) :: qct1
      logical periodx_L

!*
!
!     check if output is required and initialize control tables
!     ---------------------------------------------------------------
!
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
      dostep_max = doout(dostep,1)
      deg2rad    = acos( -1.0)/180.

      if (dostep_max .le. 0) return

!     CHECK IF QC AT TIMESTEP 0 is requested

      ext_S=""
      qcset_max = 0
      do jj=1,dostep_max
      do kk=1, Outd_sets
         if ( Outd_step(kk).eq.dostep(jj) ) then
            do ii =1,Outd_var_max(kk)
               if (Outd_var_S(ii,kk).eq.'QC') then
                   qcset_max = qcset_max + 1
                   qcset(qcset_max) = kk
                   qcnbit = Outd_nbit(ii,kk)
                   qcfilt = Outd_filtpass(ii,kk)
                   qccoef = Outd_filtcoef(ii,kk)
               endif
            enddo
         endif
      enddo
      enddo

      nullify(qct1)
      gmmstat = gmm_get('TR/'//'QC'//':P',qct1,meta3d)
 
!     if QC is not available, forget it
      if (GMM_IS_ERROR(gmmstat).or.qcset_max.le.0) return 

!     PREPARATION of wlnpi_t for out_qc0 
!    ---------------------------

      gmmstat = gmm_get(gmmk_st1_s,st1,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'out_qc0 ERROR at gmm_get(st1)'
!
!        Log-pressure on momentum and thermo levels,
!        with extra momentum levels at top (k=0) and surface (k=G_nk+1)
!        and with an extra thermo level at surface (k=G_nk+2)
!
         wlnpi_m(:,:,0)= Cstv_Ztop_8
         do k=1,G_nk+1
            do j=1,l_nj
            do i=1,l_ni
               wlnpi_m(i,j,k) = Ver_a_8%m(k) &
                              + Ver_b_8%m(k)*st1(i,j)
               wlnpi_t(i,j,k)=.5d0*(wlnpi_m(i,j,k)+wlnpi_m(i,j,k-1))
            enddo
            enddo
         enddo

         do j=1,l_nj
         do i=1,l_ni
            wlnpi_t(i,j,G_nk+2)=wlnpi_m(i,j,G_nk+1)
         enddo
         enddo

!     setup of ip3

      ip3 = 0
      if (Out3_ip3.eq.-1) ip3 = Lctl_step
      if (Out3_ip3.gt.0 ) ip3 = Out3_ip3

      do j= 1, l_nj
      do i= 1, l_ni
         qct1(i,j,G_nk+2) = qct1(i,j,G_nk+1)
      enddo
      enddo

!     output loop on the number of "sortie" sets

      do 100 n=1, qcset_max
          kk = qcset(n)
          periodx_L=.false.
          gridset = Outd_grid(kk)
          levset = Outd_lev(kk)
          if (.not.G_lam .and.  &
               (Grid_x1(gridset)-Grid_x0(gridset)+1) .eq. G_ni ) periodx_L=.true.
          call out_sgrid(Grid_x0(gridset),Grid_x1(gridset), &
               Grid_y0(gridset),Grid_y1(gridset), &
               Grid_ig1(gridset),Grid_ig2(gridset), &
               periodx_L, Grid_stride(gridset), &
               Grid_etikext_s(gridset),' ' )
          nk_o   = Level_max(levset)
          allocate (ind_o(nk_o+2))
          call out_slev(Level_types(Level_typ_indx(levset)),Level(1,levset), &
                          ind_o,nk_o,nk_ot,G_nk,Level_kind_ip1,'d')
          call out_sfile(Out3_closestep,Lctl_step,ip3,ext_S)
          call out_href(Geomn_longs,Geomn_latgs)
 
          if (Out_levtyp_S.eq.'M') then
              call out_vref(p0,l_minx,l_maxx,l_miny,l_maxy)
              if ( Out3_cliph_L ) then
                   allocate(w5(LDIST_SHAPE,G_nk+2))
                   do k= 1, G_nk+2
                   do j= 1, l_nj
                   do i= 1, l_ni
                      w5(i,j,k) = amax1( qct1(i,j,k), 0. )
                   enddo
                   enddo
                   enddo
              call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy, &
                      Ver_hyb%t, 'QC  ',1.0,0.0,  Out_kind,G_nk+2,  &
                      ind_o, nk_ot, qcnbit )
              deallocate(w5)
              else
              call ecris_fst2(qct1,l_minx,l_maxx,l_miny,l_maxy, &
                      Ver_hyb%t, 'QC  ',1.0,0.0,  Out_kind,G_nk+2,  &
                      ind_o, nk_ot, qcnbit )
              endif
          else
              call verder(px_ta, qct1, wlnpi_t, 2.0,2.0, &
                            l_minx,l_maxx,l_miny,l_maxy, G_nk+2, &
                            1,l_ni,1,l_nj)

              allocate(w5(LDIST_SHAPE,nk_o))
              allocate( prprlvl(nk_o) )

              do i=1,nk_o
                 prprlvl(i) = Level(i,levset) * 100.0
              enddo

!             Calculate QC (w5=qc_pres,px=vert.der)
              call prgen( w5, qct1, px_ta, wlnpi_t, prprlvl,nk_o, &
                          Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy, G_nk+2)
              if ( Out3_cliph_L ) then
                   do k= 1, nk_o
                   do j= 1, l_nj
                   do i= 1, l_ni
                      w5(i,j,k) = amax1( w5(i,j,k), 0. )
                   enddo
                   enddo
                   enddo
              endif

              if (qcfilt.gt.0) &
                  call filter(w5,qcfilt,qccoef,'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nk_o)
              call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,Level(1,levset), &
                    'QC  ',1.0,       0.0, Out_kind,nk_o, ind_o, nk_o, qcnbit )

              deallocate(w5,prprlvl)

          endif

          deallocate(ind_o)

          call out_cfile

 100  continue

      return
      end

