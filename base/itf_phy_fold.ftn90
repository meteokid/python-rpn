!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!/**
subroutine itf_phy_xhfold_3d2(F_name_S,F_horiz_interp_S,F_bus,F_data,F_busidx,F_busnik,F_busnj,F_minx,F_maxx,F_miny,F_maxy,F_k0,F_nk)
   implicit none
   !@Objective  Pre-Proc then Transfer data to p_runlgt space
   !@Arguments
   character(len=*),intent(in) :: F_name_S !- Provisional to do conditional 3d preproc
   character(len=*),intent(in) :: F_horiz_interp_S !- Provisional to do conditional 3d preproc
   integer,intent(in) :: F_busidx,F_busnik,F_busnj,F_minx,F_maxx,F_miny,F_maxy,F_k0,F_nk
   real,intent(inout) :: F_bus(F_busnik,F_busnj)
   real,intent(in) :: F_data(F_minx:F_maxx,F_miny:F_maxy,F_k0:F_nk)
   !**/
#include "grd.cdk"
   integer :: j
   ! ---------------------------------------------------------------------
   if (Grd_yinyang_L) then
       call yyg_scalgeo2(F_data,F_minx,F_maxx,F_miny,F_maxy,&
                         F_nk-F_k0+1,F_horiz_interp_S,F_name_S)
   endif

   do j=1,F_busnj
      call itf_phy_fold(F_bus(F_busidx,j),F_data,j,F_k0,F_nk,F_minx,F_maxx,F_miny,F_maxy)
   enddo
   ! ---------------------------------------------------------------------
   return
end subroutine itf_phy_xhfold_3d2


!**s/r itf_phy_fold
!
      subroutine itf_phy_fold (d, s, F_jdo, k0, nk, minx, maxx, miny, maxy)
      implicit none
#include <arch_specific.hf>
!
      integer F_jdo, k0, nk, minx, maxx, miny, maxy
      real d(*), s(minx:maxx, miny:maxy, nk)
!
!author 
!     Michel Desgagne  -  sping 2010
!
!revision
! v4_14 - Desgagne M.       - initial version
!
!object
!	Transfer data to p_runlgt space
!
#include "itf_phy_buses.cdk"
!
      integer i,k,ijp,imod,jmod,indx,cnt,nphy
      integer,dimension(nk) :: cntarr
!
!     ---------------------------------------------------------------
!
      cntarr=(/(i,i=1,nk)/)
      nphy = (F_jdo-1) * p_ni
      cnt  = 0
!
!$omp parallel private(i,ijp,imod,jmod,indx)shared(s,d)
!$omp do
      do k= k0, Nk
         cnt = cntarr(k-k0+1)
         do i= 1, p_ni
            ijp = min (nphy+i,p_doni*p_donj)
            jmod= ijp/p_doni + min(1,mod(ijp,p_doni))
            imod= ijp - (jmod-1)*p_doni + p_offi
            jmod= jmod + p_offj
            indx= (cnt-1)*p_ni+i
            d(indx) = s(imod,jmod,k)
         end do
      end do
!$omp end do
!$omp end parallel
!
!     ---------------------------------------------------------------
!
      return
      end

!**s/r itf_phy_unfold
!
      subroutine itf_phy_unfold (d, s, F_jdo, k0, nk, minx, maxx, miny, maxy)
      implicit none
#include <arch_specific.hf>
!
      integer F_jdo, k0, nk, minx, maxx, miny, maxy
      real s(*), d(minx:maxx, miny:maxy, nk)
!
!author 
!     Michel Desgagne  -  sping 2010
!
!revision
! v4_14 - Desgagne M.       - initial version
!
!object
!	Transfer data from p_runlgt space
!
#include "gmm.hf"
#include "itf_phy_buses.cdk"
!
      integer i,k,ijp,imod,jmod,indx,cnt,nphy
!
!     ---------------------------------------------------------------
!
      nphy = (F_jdo-1) * p_ni
      cnt  = 0
!
      do k= k0, Nk
         cnt = cnt + 1
         do i= 1, p_ni
            ijp = min (nphy+i,p_doni*p_donj)
            jmod= ijp/p_doni + min(1,mod(ijp,p_doni))
            imod= ijp - (jmod-1)*p_doni + p_offi
            jmod= jmod + p_offj
            indx= (cnt-1)*p_ni+i
            d(imod,jmod,k) = s(indx)
         end do
      end do
!
!     ---------------------------------------------------------------
!
      return
      end

!**s/r itf_phy_fold_sfc
!
      subroutine itf_phy_fold_sfc (d, s, l_ni, l_nj)
      implicit none
#include <arch_specific.hf>
!
      integer l_ni,l_nj
      real d(*), s(l_ni,l_nj)
!
!author 
!     Michel Desgagne  -  sping 2010
!
!revision
! v4_14 - Desgagne M.       - initial version
!
!object
!	Transfer surface data from (l_ni,l_nj) space to p_runlgt space
!
#include "gmm.hf"
#include "itf_phy_buses.cdk"
!
      integer i,j,cnt
!
!     ---------------------------------------------------------------
!
      cnt = 0
      do j= 1, p_donj
      do i= 1, p_doni
         cnt = cnt + 1
         d(cnt) = s(i+p_offi, j+p_offj)
      end do
      end do
      d(cnt+1:p_ni*p_nj) = d(cnt)
!
!     ---------------------------------------------------------------
!
      return
      end

!**s/r itf_phy_unfold_sfc
!
      subroutine itf_phy_unfold_sfc (d, s, l_ni,l_nj)
      implicit none
#include <arch_specific.hf>
!
      integer l_ni,l_nj
      real d(*), s(l_ni,l_nj)
!
!author 
!     Bernard Dugas  -  autumn 2010
!
!revision
! v4_1x - Dugas B.     - initial version
!
!object
!	Transfer surface data from p_runlgt space to (l_ni,l_nj) space 
!
#include "gmm.hf"
#include "itf_phy_buses.cdk"
!
      integer i,j,cnt,maxcnt
!
!     ---------------------------------------------------------------
!
      maxcnt = min( l_ni*l_nj, p_doni*p_donj )
      cnt = 0
      do j= 1, p_donj
      do i= 1, p_doni
         cnt = min( cnt + 1, maxcnt )
         s(i+p_offi, j+p_offj) = d(cnt)
      end do
      end do
!
      if (p_doni < l_ni) then
         if (p_offi > 0) then
            do j=1+p_offj,p_donj+p_offj
            do i=1,p_offi
               s(i,j) = s(1+p_offi,j)
            enddo
            enddo
         endif
         if (p_doni+p_offi < l_ni) then
            do j=1+p_offj,p_donj+p_offj
            do i=p_doni+p_offi+1,l_ni
               s(i,j) = s(p_doni+p_offi,j)
            enddo
            enddo
         endif
      endif
!
      if (p_donj < l_nj) then
         if (p_offj > 0) then
            do j=1,p_offj
            do i=1,l_ni
               s(i,j) = s(i,1+p_offj)
            enddo
            enddo
         endif
         if (p_donj+p_offj < l_nj) then
            do j=p_donj+p_offj+1,l_nj
            do i=1,l_ni
               s(i,j) = s(i,p_donj+p_offj)
            enddo
            enddo
         endif
      endif
!
!     ---------------------------------------------------------------
!
      return
      end

!**s/r itf_phy_unfold_td
!
      subroutine itf_phy_unfold_td ( F_obusval, F_bus, F_indn, F_j, Ni, Nj )
      implicit none
#include <arch_specific.hf>
!
      integer F_indn, F_j, Ni, Nj
      real F_bus(*), F_obusval(Ni, Nj, *)
!
!author 
!     Michel Desgagne  --  Spring 2010
!
!revision
! v4_14 - Desgagne M.       - initial version
! v4_40 - Lee V             - Add mosaic structure
!
!object
!     Transfer physic slices output into F_obusval
!	
#include "gmm.hf"
#include "itf_phy_buses.cdk"
#include "obus.cdk"
!
      integer mult, i, k, ijp, imod, jmod, nphy
!
!     ---------------------------------------------------------------
!
      nphy = (F_j-1) * p_ni
      do mult= 1, obus_mult(F_indn)*(obus_mosaic(F_indn)+1)
      do    k= 1, obus_shp (F_indn)
      do    i= 1, p_ni
         ijp = min (nphy+i,p_doni*p_donj)
         jmod= ijp/p_doni + min(1,mod(ijp,p_doni))
         imod= ijp - (jmod-1)*p_doni + p_offi
         jmod= jmod + p_offj
         F_obusval(imod, jmod, k*mult) = F_bus((k*mult-1)*p_ni + i)
      enddo
      enddo
      enddo
!
!     ---------------------------------------------------------------
!
      return
      end
