!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r casc_3df_dynp2 - Reads 3DF pilot files where
!                       3DF01 files were written after advection and
!                       3DF02 files were written after physics by
!                       the previous driving model.
!
#include "model_macros_f.h"
!
      subroutine casc_3df_dynp2 ( F_u, F_v, F_w, F_t, F_zd, F_s, F_q, F_topo, F_dtopo,  &
                                  Mminx,Mmaxx,Mminy,Mmaxy,dimgx,dimgy,unf,F_datev)
      use nest_blending, only: nest_blend
      implicit none
!
      character* (*) F_datev
      integer Mminx,Mmaxx,Mminy,Mmaxy,dimgx,dimgy,unf
      real F_u (Mminx:Mmaxx,Mminy:Mmaxy,  *), F_v(Mminx:Mmaxx,Mminy:Mmaxy,*), &
           F_w (Mminx:Mmaxx,Mminy:Mmaxy,  *), F_t(Mminx:Mmaxx,Mminy:Mmaxy,*), &
           F_zd(Mminx:Mmaxx,Mminy:Mmaxy,  *), F_s(Mminx:Mmaxx,Mminy:Mmaxy  ), &
           F_q (Mminx:Mmaxx,Mminy:Mmaxy,0:*),                                 &
           F_topo (Mminx:Mmaxx,Mminy:Mmaxy) , F_dtopo(Mminx:Mmaxx,Mminy:Mmaxy)
!
!author
!     M. Desgagne  April 2006 (MC2 casc_3df_dynp)
!
!revision
! v3_30 - Lee V.         - initial version for GEMDM
! v3_30 - McTaggart-Cowan R. - implement variable orography
! v4_03 - Lee/Desgagne   - ISST
! v4_05 - Desgagne M.    - Add P_pbl_icelac_L, Lam_cascsfc_L 
!                          and Lam_blendoro_L options
! v4_05 - Lee V.         - Ind_u,Ind_v vectors are filled incorrectly
! v4_06 - McTaggart-Cowan R. - Nesajr correction
! v4_06 - Lee V.         - Predat is called outside of this routine
!*
#include "gmm.hf"
#include "glb_ld.cdk"
#include "bcsgrds.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "ifd.cdk"
#include "lam.cdk"
#include "ptopo.cdk"
#include "schm.cdk"
#include "tr3d.cdk"
#include "vt1.cdk"
#include "lun.cdk"
#include "itf_phy_buses.cdk"
#include "lctl.cdk"
#include "itf_phy_config.cdk"
#include "vtopo.cdk"
#include "path.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
#include "step.cdk"
#include "nest.cdk"
#include "p_geof.cdk"
#include "filename.cdk"
!
!        presstype
!            0 => p =    A                         (B=0),  prs-anal
!            1 => p =    A+B*   ps       , F_p0=ps (A=0),  sig-anal
!            2 => p =    A+B*   ps       , F_p0=ps      ,  etasef-anal
!            3 => p =    A+B*   ps       , F_p0=ps      ,  eta-anal
!            4 => p =    A+B*   ps       , F_p0=ps      ,  hyb-anal
!        ?   5 => p =    A+B*   ps       , F_p0=ps      ,  ecm-anal
!            6 => p =exp(A+B*ln(ps/pref)), F_p0=ps      ,  stg-anal
!
      integer,external :: sid3df2

      type(gmm_metadata) :: mymeta
      character*2  md
      character*4  nomvar
      character*8  dynophy,vn,hint
      character(len=GMM_MAXNAMELENGTH), dimension (:), pointer :: trname_a
      character*4, dimension (:), pointer :: phynm
      character*15 datev
      character*256 fn
      logical done,dyn_done,phy_done,same_topo_L,temp_same_L,flag
      logical dyn_init,phy_init,initial_data
      integer i,j,k,jj,jjj,kk,nia,nja,nk0,nka_m,nka_t,ntra,ntra_tmp, &
              ni1,nj1,nk1,n,err,presstype,nbits, &
              errop,ofi,ofj,l_in,l_jn,nvar, &
              cnt,nkphy,errdyn,errphy,cumerr,pid,gid,nfphy, &
              wowp,nij,ijk,istat

      integer i0,in,j0,jn,ni2,nj2
      integer idd,jdo,mult,shp,bigk,offbb,offbo,offg,ng,nga
      integer, dimension (:  ), pointer :: idx,idy,nks
      real topo_temp(l_ni,l_nj), xi,xf,yi,yf,htopa, &
           psmin, psmax, psmin_glob, psmax_glob, pr1,pr2
      real  , dimension (:  ), pointer :: phybr
      real*8, dimension (:  ), pointer ::  &
                    xpaq,ypaq,xpau,ypav,xpuu,ypvv, &
                    cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd
!
      real, dimension (:,:), pointer :: uun,vvn,zdn,ttn,   &
                                        ssqn,meqn,qqn,wwn, &
                                        meqr, topo_temp1, phybn, ss1
!
      real, dimension (:,:,:  ), pointer :: uu1,vv1,zd1,ttt1, &
                                            qq1,ww1,trn,trp
      real, dimension (:,:,:,:), pointer :: tr1

!
      real ssq_temp(LDIST_SHAPE)
      real*8 xpxext(0:dimgx+1), ypxext(0:dimgy+1),lnpis_8
      data nfphy,nkphy /0,0/
!
!-----------------------------------------------------------------------
!
      if (Lun_out.gt.0) write(lun_out,9000) trim(F_datev)

      bcs_nia = ifd_niaf - ifd_niad + 1
      bcs_nja = ifd_njaf - ifd_njad + 1
      nia     = bcs_nia
      nja     = bcs_nja
      nga     = nia*nja
      ntra    = 0
      ng      = l_ni * l_nj
      ofi     = l_i0 - 1
      ofj     = l_j0 - 1
      err     = 0
!
! Positional parameters on extended global mass point grid
!
      do i=1,dimgx
         xpxext(i) = G_xg_8(i)
      end do
      xpxext(0) = xpxext(1) - (xpxext(2)-xpxext(1))
      xpxext(dimgx+1) = xpxext(dimgx) + (xpxext(dimgx)-xpxext(dimgx-1))
!
      do i=1,dimgy
         ypxext(i) = G_yg_8(i)
      end do
      ypxext(0) = ypxext(1) - (ypxext(2)-ypxext(1))
      ypxext(dimgy+1) = ypxext(dimgy) + (ypxext(dimgy)-ypxext(dimgy-1))
!
! Positional parameters of model target u and v grids (xpuu and ypvv).
!
      allocate (xpuu(l_ni),ypvv(l_nj))
      do i=1,l_ni
         xpuu(i) = 0.5d0 * (xpxext(ofi+i+1)+xpxext(ofi+i))
      end do
      do j=1,l_nj
         ypvv(j) = 0.5d0 * (ypxext(ofj+j+1)+ypxext(ofj+j))
      end do
!
      datev = F_datev
      initial_data = trim(datev).eq.trim(Step_runstrt_S)
!
! Read all needed files and construct the source domain for
! the horizontal interpolation
!
!     wowp = 2 ===> input data has seen the physics
!     wowp = 1 ===> input data just after dynamics (no physics)
!     We prefer to initialize uup, vvp etc... with wowp=2 status.
!
      allocate (xpaq(nia), ypaq(nja), xpau(nia), ypav(nja))
!
      wowp = 3
      if (.NOT.initial_data) wowp = 2
 48   wowp = wowp - 1
      if (wowp.lt.1) then
         write (6,204)
         err = -1
         goto 999
      endif
!
      write (md,'(i2.2)') wowp
      done     = .false.
      dyn_init = .false.
      phy_init = .false.
!
      do n=1,ifd_nf
!
         ofi = ifd_minx(n)-1
         ofj = ifd_miny(n)-1
         if (ifd_needit(n)) then
!
            errdyn   = -1
            errphy   = -1
            dyn_done = .false.
            phy_done = .false.
!
            fn = trim(Path_ind_S)//'/3df'//'_'//datev//'_'//ifd_fnext(n)
            open (unf,file=trim(fn),access='SEQUENTIAL', &
                      form='UNFORMATTED',status='OLD',iostat=errop)
!
            if (errop.ne.0) goto 33
!
! Use first file to establish 3D grid dimensions and geo-references
! of all input staggered grids (xpaq, ypaq, xpau and ypva).
!
 55         if (dyn_done.and.phy_done) goto 33
            err = sid3df2(xpaq,ypaq,xpau,ypav,unf,done,nia,nja, &
                               nka_m,nka_t,presstype)
            if (err.lt.0) then
                if (err == -2) exit
                if (dyn_done) then
!               Assumes no physics data are available
                    err=0
                    phy_done = .true.
                    errphy   = 0
                endif
!               Continue to next file
                goto 33
            endif
!
            read (unf,end=1010,err=1010) dynophy,nvar,ntra_tmp
!
            if (dynophy.eq.'PHYSICSS') then
               nfphy = nvar
!
               if (.not.phy_init) then
                  if (associated(phybn)) deallocate(phybn)
                  if (associated(phynm)) deallocate(phynm)
                  if (associated(nks  )) deallocate(nks  )
                  allocate (phynm(nfphy),nks(nfphy))
               endif
               read(unf,end=1010,err=1010)(phynm(i),nks(i),i=1,nfphy)

               nkphy=0
               do i=1,nfphy
                  nkphy=nkphy+nks(i)
               enddo
               if (.not.phy_init) allocate(phybn(nga,nkphy))
               phy_init = .true.
               cumerr = 0

               nkphy=0
               do i=1,nfphy
                 read (unf,end=1010,err=1010) nomvar,ni1,nj1,nk1,nbits
                 call filmup (nomvar,phybn(1,nkphy+1),ifd_niad,ifd_niaf,ifd_njad, &
                              ifd_njaf,nks(i),unf,ofi,ofj,cumerr,ni1,nj1,nk1,nbits)
                 nkphy=nkphy+nks(i)
               enddo
               errphy=cumerr
               phy_done = .true.
               if (.not. dyn_done) goto 55
!
            else if (dynophy.eq.'DYNAMICS') then
               ntra=ntra_tmp
!
               if (.not.dyn_init) then
                  if (associated( uun)) deallocate( uun)
                  if (associated( vvn)) deallocate( vvn)
                  if (associated( zdn)) deallocate( zdn)
                  if (associated( ttn)) deallocate( ttn)
                  if (associated( qqn)) deallocate( qqn)
                  if (associated( wwn)) deallocate( wwn)
                  if (associated(ssqn)) deallocate(ssqn)
                  if (associated(meqn)) deallocate(meqn)
                  if (associated( trn)) deallocate( trn)
                  if (associated( topo_temp1)) deallocate( topo_temp1)
                  if (associated(trname_a)) deallocate(trname_a)
                  allocate (  uun(nga,nka_m), vvn (nga,nka_m), &
                              zdn(nga,nka_t-1), ttn (nga,nka_t), &
                             ssqn(nga,1  )  , &
                             topo_temp1(l_ni+1-(east*1),l_nj+1-(north*1)), &
                              qqn(nga,nka_m+1), wwn(nga,nka_t-1), &
                             trn (nga,nka_t,ntra), trname_a(ntra) )
                  if (presstype.eq.0) then ! presstype= pressure
                      allocate (meqn(nga,nka_m))
                  else
                      allocate (meqn(nga,1))
                  endif
                  uun=0.; vvn=0.; zdn=0.; ttn=0.; ssqn=0.; trn=0.;
                  wwn=0.; qqn=0.; meqn=0.;
                  dyn_init = .true.
               endif
!
               cumerr=0
               call read_3df(unf,uun,vvn,zdn,ttn,ssqn,meqn,qqn,wwn,trn, &
                        trname_a,nvar,ntra,nga,nka_m,nka_t,ofi,ofj,cumerr)
               errdyn   = cumerr
               dyn_done = .true.
               if ((.not.phy_done).and.(Schm_phyms_L)) goto 55
!
            else
               write (6,205) dynophy
               goto 1010
            endif
!
 33         close (unf)
!
            if ((errdyn.lt.0).and.(wowp.gt.1)) goto 48
!
            if (.not.Schm_phyms_L) errphy = 0
            err  = err + errdyn + errphy
            done = .true.
            if (err.lt.0) then
               write (6,203) trim(fn),Ptopo_myproc
               goto 999
            endif
         endif
      end do
!
 999  call handle_error(err,'casc_3df_dynp','casc_3df_dynp')
!
      if (initial_data) then
         allocate ( meqr(l_ni,l_nj))
         allocate (idx(l_ni), idy(l_nj), &
                   cxa(l_ni), cxb(l_ni), cxc(l_ni) ,cxd(l_ni), &
                   cya(l_nj), cyb(l_nj), cyc(l_nj), cyd(l_nj) )
         hint = 'LINEAR'
         call grid_to_grid_coef (xpxext(l_i0),l_ni, &
                                 xpaq,nia,idx,cxa,cxb,cxc,cxd,hint)
         call grid_to_grid_coef (ypxext(l_j0),l_nj, &
                                 ypaq,nja,idy,cya,cyb,cyc,cyd,hint)

         call hinterpo ( meqr,l_ni,l_nj, meqn,nia,nja,    1,idx,idy, &
                         cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,hint)

         call get_topo    (topo_temp,l_ni,l_nj)

         call adjust_topo ( F_topo, F_dtopo, topo_temp, meqr    , &
                           ((presstype.ne.0).and.Lam_blendoro_L), &
                            l_minx,l_maxx,l_miny,l_maxy,l_ni,l_nj )

         deallocate (idx,idy,cxa,cxb,cxc,cxd,cya,cyb,cyc,cyd,meqr)
      endif
!
! topo is inflated!
      call rpn_comm_xch_halo ( F_topo, LDIST_DIM,l_ni,l_nj,1, &
                    G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
!
      do j=1,l_nj+1-(north*1)
      do i=1,l_ni+1-(east*1)
         topo_temp1(i,j) = F_topo(i,j)
      enddo
      enddo
!
      allocate(uu1 (l_ni,l_nj,G_nk+1), vv1 (l_ni,l_nj,  G_nk+1), &
               ttt1(l_ni,l_nj,G_nk+2), zd1 (l_ni,l_nj,  G_nk+1), &
               ss1 (l_ni,l_nj       ), qq1 (l_ni,l_nj,0:G_nk+1), &
               ww1 (l_ni,l_nj,G_nk+1), tr1 (l_ni,l_nj,  G_nk+2,Tr3d_ntr) )

      call casc_hvi (trname_a, xpxext(l_i0),ypxext(l_j0),xpuu,ypvv,xpaq,ypaq,xpau,ypav, &
                     uu1,vv1,ttt1,zd1,ss1,qq1,ww1,tr1,topo_temp1,                       &
                     uun,vvn,ttn,zdn,meqn,ssqn,qqn,wwn,trn,                             &
                     l_ni,l_nj,G_nk,nia,nja,nka_m,nka_t,presstype,ntra)

      F_u (1:l_ni,1:l_nj,1:G_nk+1) = uu1
      F_v (1:l_ni,1:l_nj,1:G_nk+1) = vv1
      F_t (1:l_ni,1:l_nj,1:G_nk+2) = ttt1
      F_zd(1:l_ni,1:l_nj,1:G_nk+1) = zd1
      F_s (1:l_ni,1:l_nj         ) = ss1
      F_w (1:l_ni,1:l_nj,1:G_nk+1) = ww1
      if (.not. Schm_hydro_L) then
        F_q(1:l_ni,1:l_nj,0:G_nk+1) = qq1
      endif
!
      do n=1,Tr3d_ntr
         nullify (trp)
         if (initial_data) then
            istat = gmm_get('TR/'//trim(Tr3d_name_S(n))//':P',trp,mymeta)
         else
            istat = gmm_get('NEST/'//trim(Tr3d_name_S(n))//':F',trp,mymeta)
         endif
         trp(1:l_ni,1:l_nj,1:G_nk+2) = tr1(1:l_ni,1:l_nj,1:G_nk+2,n)
      end do
!
      deallocate (xpuu,ypvv,xpaq,ypaq,xpau,ypav)
      deallocate (uun,vvn,zdn,ttn,qqn,wwn,ssqn,meqn)
      deallocate (trn,topo_temp1,trname_a)
      deallocate (uu1,vv1,ttt1,zd1,qq1,ww1,tr1)
      if (associated(phybn)) deallocate(phybn)
      if (associated(phynm)) deallocate(phynm)
      if (associated(nks  )) deallocate(nks  )
!
      do j=1,l_nj
      do i=1,l_ni
         ss1(i,j) = Cstv_pref_8*exp(ss1(i,j))
      enddo
      enddo
!
      if (initial_data) then
         psmin = ss1(1,1)
         psmax = ss1(1,1)
         do j=1,l_nj
         do i=1,l_ni
            psmin = min( psmin, ss1(i,j) )
            psmax = max( psmax, ss1(i,j) )
         enddo
         enddo
!
         call rpn_comm_allreduce(psmin,psmin_glob,1,"MPI_REAL","MPI_MIN", &
                                                              "grid",err)
         call rpn_comm_allreduce(psmax,psmax_glob,1,"MPI_REAL","MPI_MAX", &
                                                              "grid",err)
         psmin=psmin_glob
         psmax=psmax_glob
!     
         if ( Ptopo_myproc.eq.0 ) then
            write(6,*)'PSMIN = ',PSMIN,' PSMAX = ',PSMAX, &
                           ' PSMINMAX = ',0.5*(PSMIN+PSMAX),' (PASCAL)'
         endif
      endif
!
      deallocate (ss1)
!
 100  format (' ',65('*'))
 101  format (' (CASC_3DF_DYNP) JUST READ INIT DATA FOR DATE: ',a15,1x,i3)
 203  format (/' PROBLEM WITH FILE: ',a,', PROC#:',i4,' --ABORT--'/)
 204  format (/' NO DATA IN CASC_3DF_DYNP --ABORT--'/)
 205  format (/' Unrecognizable tag found: ',a,'?'/)
 9000 format(/,' TREATING INPUT DATA VALID AT: ',a,&
             /,' ===============================================')
!
!-----------------------------------------------------------------------
      return

 1010 write (6,203) trim(fn),Ptopo_myproc

      call handle_error(-1,'casc_3df_dynp','casc_3df_dynp')
      return
      end
!
