!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r itf_phy_step - Apply the physical processes: CMC/RPN package
!
#include "model_macros_f.h"

      subroutine itf_phy_step (F_stepno, F_lctl_step)
      implicit none
#include <arch_specific.hf>
!
      integer, intent(IN) :: F_stepno, F_lctl_step
!
!author 
!     Michel roch - rpn - april 1994
!
!revision
! v2_00 - Desgagne M.       - initial MPI version
! v2_21 - Desgagne/Methot/Bilodeau - dzmin calculation
! v2_31 - Desgagne          - clean up and introduce h2o tracers
! v2_32 - Lee V.            - call genslabp here, add "HY" record to slabs
! v3_00 - Laroche S.        - adapted for simplified physics
! v3_02 - Tanguay M.        - Add V4dg_oktr_L for v4d_rwtraj_kmkt 
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v3_11 - Dugas B.          - Correct DUMPBUS mechanism for OpenMP
! v3_12 - Leduc A-M         - Add variables gzm and topo
! v3_20 - Lee & Kallaur     - Add coding to support chemistry modules. (may/june 2005)
! v3_21 - Valcke, S.        - Bugfix: no call to itf_phy_apply in offline mode
! v3_30 - Tanguay M.        - adapt TL/AD to pvptr
! v3_30 - McTaggart-Cowan R.- Allow for user-defined domain tag extensions
! v4_03 - Spacek L.         - Staggered version
! v4_04 - Plante A.         - Remove offline mode
! v4_05 - Desgagne M.       - Update AIX binding rules
! v4_13 - Spacek L.         - Allocate geofld as entry analogy to Phy_busper3D
! v4_14 - Dugas B.          - Account for increment forcings
!                           - dumpbus3 is now all done here
!   
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! F_stepno      O           step number
!----------------------------------------------------------------
!
#include <rmnlib_basics.hf>
#include <gmm.hf>
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "lun.cdk"
#include "ptopo.cdk"
#include "out3.cdk"
#include "cstv.cdk"
#include "rstr.cdk"
#include "modconst.cdk"
#include "path.cdk"
#include "grd.cdk"
#include "obus.cdk"
#include "itf_phy_buses.cdk"

      include "phy_itf.inc"

      integer,external :: itf_phy_prefold_opr

      integer,parameter :: MAX_COMMBLOC_SWAP = 10

      character(len=512),save :: geofilename_S = ' '
      logical,save :: init_L = .false.
      integer,save :: lcore_phy_gid = -1, l_phy_gid = -1, g_phy_gid = -1
      integer,save :: dateo = -1
      integer,save :: phydim_nj=0, phydim_nk=0
      integer,save :: reduc_core(4), reduc_free(4)
      real,pointer,save :: BUSENT3d(:,:) => null()
      real,pointer,save :: BUSPER3d(:,:) => null()
      real,pointer,save :: BUSVOL3d(:,:) => null()

      integer :: j, n, obussiz, err
      real :: gxfi(G_ni+1), gyfi(G_nj), prip2
      real, dimension(:,:), allocatable :: obusval
!
!     ---------------------------------------------------------------
!
      if (itf_phy_busper_init_L.and.(F_stepno.eq.0)) return

      call timing_start ( 40, 'PHYSTEP')

      if (Lun_out.gt.0) write (Lun_out,1001) F_lctl_step

      call pw_shuffle
      call pw_update_UV
      call pw_update_T
      call pw_update_GPW
!      call pw_glbstat

      if (.not.init_L) then
         call itf_phy_gdef2(lcore_phy_gid, l_phy_gid, g_phy_gid, gxfi, gyfi)
         call datp2f(dateo,Mod_runstrt_S)
         geofilename_S = 'GEOPHY/Gem_geophy.fst'
         init_L = .true.
         call phy_opti('NJ',phydim_nj,1,'GET',.false.,err)
         call phy_opti('NK',phydim_nk,1,'GET',.false.,err)
         err =     gmm_get ('BUSPER_3d',BUSPER3d)
         err = min(gmm_get ('BUSENT_3d',BUSENT3d),err)
         err = min(gmm_get ('BUSVOL_3d',BUSVOL3d),err)
         call handle_error(err,'itf_phy_step','Probleme getting buses') 
         reduc_core = (/ Grd_left+ 1 + Lam_pil_w         , &
                         Grd_left + Grd_nila  - Lam_pil_e, &
                         Grd_belo + 1         + Lam_pil_s, &
                         Grd_belo + Grd_njla  - Lam_pil_n /)
         if (.not.itf_phy_busper_init_L) call itf_phy_geom3 (l_phy_gid, err)
      endif

      !TODO: find other solution for inbloc - rpn_comm_bloc creates new 
      ! communicator every call - we hit a limit after about 500 on AIX

      if (F_stepno < MAX_COMMBLOC_SWAP) &
           call rpn_comm_bloc(Ptopo_ninblocx,Ptopo_ninblocy)

      err = phy_input2(itf_phy_prefold_opr,dateo, nint(cstv_dt_8)      , &
                       F_stepno,lcore_phy_gid,l_phy_gid,Path_phyincfg_S, &
                       Path_phy_S,geofilename_S)

      if (F_stepno < MAX_COMMBLOC_SWAP) &
           call rpn_comm_bloc(Ptopo_nblocx  ,Ptopo_nblocy  )

      call itf_phy_fillbus ()

      call pe_rebind (Ptopo_nthreads_phy,(Ptopo_myproc.eq.0).and. &
                                         (F_stepno    .eq.0)  )
      call phy_step2 (F_stepno,F_lctl_step)

      call pe_rebind (Ptopo_nthreads_dyn,(Ptopo_myproc.eq.0).and. &
                                         (F_stepno    .eq.0) )

      call itf_phy_update3 ( F_stepno > 0 )

      if (out3_newout_L) then
         err = phy_output(dateo,nint(cstv_dt_8),F_stepno,l_phy_gid,g_phy_gid,reduc_core,trim(Path_outcfg_S),Path_output_S)

      else
         call iniobus (obussiz)
         allocate (obusval(l_ni*l_nj,obussiz))
         obusval = 999999.
         do n=1,Obus_top
            call phy_unfold (obusval(1,obus_offset(n)), obus_var_S(n), &
                             obus_bus_S(n), 1, obus_shp(n),            &
                             1,l_ni,1,l_nj,obus_shp(n) )
         end do
         call itf_phy_output (obusval,l_ni,l_nj,F_lctl_step)
         deallocate (obusval)
      endif

      call timing_stop ( 40, 'PHY      ' )

 1001 format(/,'PHYSICS : PERFORMING TIMESTEP #',I9, &
             /,'========================================')
!
!     ---------------------------------------------------------------
!
      return
      end subroutine itf_phy_step
