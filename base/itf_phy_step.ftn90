!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r itf_phy_step - Apply the physical processes: CMC/RPN package
!
#include "model_macros_f.h"
!
      subroutine itf_phy_step (F_stepno)

      Use itf_phy_iface  , Only : itf_phy_geti, itf_phy_inincr
      Use phy_input_iface, Only : phy_acquire_data
      implicit none
!
      integer, INTENT(IN) :: F_stepno
Interface
Subroutine itf_phy_slb (geofld, Phy_busdyn3D, Phy_busper3D, Phy_busvol3D, &
                    esiz, dsiz, fsiz, vsiz,   &
                    dt, kount, phy_timing, ni, nj, nk, pslic) 

         Real, Dimension(:), Pointer :: geofld, Phy_busdyn3D, Phy_busper3D, &
                                        Phy_busvol3D
         Integer :: esiz, dsiz, fsiz, vsiz, kount, ni,nj,nk, pslic
         Real    :: dt, phy_timing(ni,nj)
End Subroutine itf_phy_slb
End Interface
!
!author 
!     Michel roch - rpn - april 1994
!
!revision
! v2_00 - Desgagne M.       - initial MPI version
! v2_21 - Desgagne/Methot/Bilodeau - dzmin calculation
! v2_31 - Desgagne          - clean up and introduce h2o tracers
! v2_32 - Lee V.            - call genslabp here, add "HY" record to slabs
! v3_00 - Laroche S.        - adapted for simplified physics
! v3_02 - Tanguay M.        - Add V4dg_oktr_L for v4d_rwtraj_kmkt 
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v3_11 - Dugas B.          - Correct DUMPBUS mechanism for OpenMP
! v3_12 - Leduc A-M         - Add variables gzm and topo
! v3_20 - Lee & Kallaur     - Add coding to support chemistry modules. (may/june 2005)
! v3_21 - Valcke, S.        - Bugfix: no call to itf_phy_apply in offline mode
! v3_30 - Tanguay M.        - adapt TL/AD to pvptr
! v3_30 - McTaggart-Cowan R.- Allow for user-defined domain tag extensions
! v4_03 - Spacek L.         - Staggered version
! v4    - Chamberland-Spacek - Staggered version
! v4_04 - Plante A.         - Remove offline mode
! v4_05 - Desgagne M.       - Update AIX binding rules
! v4_13 - Spacek L.         - Allocate geofld as entry analogy to Phy_busper3D
! v4_1x - Dugas B.          - Account for increment forcings
!                           - dumpbus3 is now all done here
!   
!object
!	Computes the physical processes and apply the resulting
!	tendencies to the dynamic variables of the model:
!	CMC/RPN package
!
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! F_stepno      O           step number
!----------------------------------------------------------------
!
!implicits
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "lun.cdk"
#include "ptopo.cdk"
#include "itf_phy_buses.cdk"
#include "itf_phy_config.cdk"
#include "out3.cdk"
#include "cstv.cdk"
#include "rstr.cdk"
#include "clim.cdk"
!
      integer*8 time_base
      external  time_base
!
      integer PG_ni,PG_nj
      logical P_timing_L
      integer, save :: pslic
      integer j, obussiz, err
      integer*8 ticks_deb, ticks_fin
      character*512 fn
      real, dimension(:,:), allocatable :: obusval
      real dt,Lphy_timing(l_ni,l_nj),Gphy_timing(G_ni,G_nj),phy_timing(p_ni,p_nj)
      logical dumpbus_L, dyndump_L, entdump_L
!
      real busent, busdyn, busper, busvol, hold(2)
      pointer (pabusent,busent(*))
      pointer (pabusdyn,busdyn(*))
      pointer (pabusper,busper(*))
      pointer (pabusvol,busvol(*))
!
!     ---------------------------------------------------------------
!
      pabusent = loc( hold(1) )
      P_timing_L = .false.
!
      call iniobus(obussiz)
      allocate (obusval(l_ni*l_nj,obussiz))
      obusval = 999999.
!
      if (F_stepno.eq.0) then
         allocate (geofld(p_bent_siz*p_nj))
         geofld=0.0
      endif
      call tmg_start0(94,'PHYSPRE')
      call itf_phy_prep ()
      call tmg_stop0(94)
!
!C    Load data into Phy_busper3D
!               ------------------------------------------------
      err = 0
      if (F_stepno == 0) then
         call phy_acquire_data (itf_phy_geti,Phy_busper3D,p_ni,p_nj,p_nk, &
                                p_bper_siz,F_stepno, Rstri_sdon,Lun_out.gt.0,err)
      else
         if (Clim_inincr_L) &
            call phy_acquire_data (itf_phy_inincr,Phy_busper3D,p_ni,p_nj,p_nk, &
                                   p_bper_siz,F_stepno, Rstri_sdon,Lun_out.gt.0,err)
      endif
      call handle_error(err,'itf_phy_step','itf_phy_step')      
!
!C       4.	compute physics tendencies
!		--------------------------
!
      call pe_rebind (Ptopo_smtphy,(Ptopo_myproc.eq.0).and. &
                                   (F_stepno    .eq.0)  )

      if (Lun_out.gt.0) write(Lun_out,1000) F_stepno
!
      if (G_lam) then
        PG_ni  = G_ni - 4
        PG_nj  = G_nj - 4
      else
        PG_ni  = G_ni
        PG_nj  = G_nj
      endif
!
      dumpbus_L = .false.
      entdump_L = .false.
      dyndump_L = .false.
      if (P_dumpbus > 0) then
          dumpbus_L = (mod( F_stepno,P_dumpbus ) == 0)
          entdump_L = ((P_dumpbus_S == 'ALL') .and. (F_stepno == 0 ))
          dyndump_L = ((P_dumpbus_S == 'ALL') .or. (index(P_dumpbus_S,'D') > 0))
          call dumpini3( p_bent_siz,p_bdyn_siz,p_bper_siz,p_bvol_siz, &
                         Ptopo_numproc,p_ni,p_nj, PG_ni,PG_nj, P_dumpbus_S )
      endif
!
      if (dyndump_L) then
!$omp parallel do
         do j = 1, p_nj
            pabusdyn = loc (Phy_busdyn3D((j-1)*p_bdyn_siz+1))
            call dumpbusd( busdyn, j )
         end do
!$omp end parallel do
         call dumpwritd( Lun_out, F_stepno, Ptopo_myproc )
      endif
!
      ticks_deb = time_base()
!
      pslic= 0
      dt   = Cstv_dt_8
      call tmg_start0(91,'PHYSICS')
!$omp parallel
      call itf_phy_slb ( geofld ,Phy_busdyn3D ,Phy_busper3D ,Phy_busvol3D , &
                             p_bent_siz, p_bdyn_siz, p_bper_siz, p_bvol_siz   , &
                             dt, F_stepno, phy_timing, p_ni, p_nj, p_nk, pslic )
!$omp end parallel
      call tmg_stop0(91)
      call tmg_start0(92,'PHYSEXT')
!$omp parallel do
      do j = 1, p_nj
         pabusvol = loc (Phy_busvol3D((j-1)*p_bvol_siz+1))
         pabusper = loc (Phy_busper3D((j-1)*p_bper_siz+1))
         pabusdyn = loc (Phy_busdyn3D((j-1)*p_bdyn_siz+1))
         if (F_stepno == 0) pabusent = loc( geofld((j-1)*p_bent_siz+1) )
         if (dumpbus_L) call dumpbus3( busent,busdyn,busper,busvol, j, entdump_L )
         call itf_phy_extract( busent, busper, busvol, obusval, F_stepno, j, p_nk )
         if (P_timing_L) call itf_phy_unfold (Lphy_timing, phy_timing(1,j), j, 1, 1, 1, l_ni, 1, l_nj)
      end do
!$omp end parallel do
      call tmg_stop0(92)
!
      ticks_fin = time_base()
!
      if (P_timing_L) then
         write(6,'("TIME_BASE:PHY_SLB: STEP=",i4," WCTIME=",g16.10)') F_stepno, &
                                             (ticks_fin-ticks_deb)*8.0d0/1.9d9
         call glbcolc (Gphy_timing,G_ni,G_nj,Lphy_timing,1,l_ni,1,l_nj,1)
         fn = '..//phy_timing.fst'
         if ((F_stepno.eq.0).or.(mod(F_stepno-1,4).eq.0)) fn = '..//phyR_timing.fst'
         if (Lun_out.gt.0) &
         call r_rawfstw2 (Gphy_timing,1,g_ni,1,g_nj,1,1,'TIMI',1,g_ni,1,g_nj,1,1,&
                          F_stepno,int(Cstv_dt_8),Out3_date,-1,-1,fn)
         fn = 'TIM1'
         if ((F_stepno.eq.0).or.(mod(F_stepno-1,4).eq.0)) fn = 'TIM2'
         call glbstat2 (Lphy_timing,trim(fn),'', 1,l_ni,1,l_nj,1,1, &
                                                 1,g_ni,1,g_nj,1,1)
      endif
!
      call pe_rebind (Ptopo_smtdyn,(Ptopo_myproc.eq.0).and. &
                                   (F_stepno    .eq.0) )
!
      call v4d_rwtraj(22)
!
      call out_phy (obusval,l_ni,l_nj,F_stepno)
!
      deallocate (obusval)
!
      if (dumpbus_L) call dumpwrit3( Lun_out, F_stepno, Ptopo_myproc, entdump_L )
!
!C   6.	Apply physics tendencies to the appropriate dynamic fields
!C      and insure consistency with other dynamic variables
!       ----------------------------------------------------------
!
      call tmg_start0(93,'PHYSAPP')
      call itf_phy_apply ( F_stepno.gt.0 )
      call tmg_stop0(93)
!
 1000 format(/'PERFORM A PHYSICS STEP: stepno= ',i6, &
              ' (S/R itf_phy_step)'/57('='))
!
!     ---------------------------------------------------------------
!
      return
      end
