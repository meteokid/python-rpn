!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r psadj - Adjust surface pressure for conservation
!
      subroutine psadj
      implicit none
#include <arch_specific.hf>

!author
!     Andre Plante from hzd_main      
!
!revision
! v4_05 - Lepine M.         - VMM replacement with GMM
! v4_50 - Qaddouri-PLante   - YY version
! v4_70 - Tanguay M.        - dry air pressure conservation

#include "gmm.hf"
#include "glb_ld.cdk"
#include "cstv.cdk"
#include "geomg.cdk"
#include "schm.cdk"
#include "vt0.cdk"
#include "vt1.cdk"
#include "ptopo.cdk"
#include "grd.cdk"

      integer i,j, istat, offi, offj, isize, ierr
      real wk0(l_minx:l_maxx,l_miny:l_maxy), wk1(l_minx:l_maxx,l_miny:l_maxy)
      real, dimension(l_minx:l_maxx,l_miny:l_maxy,l_nk):: pr_m1,pr_t1,pr_m0,pr_t0
      real, dimension(l_minx:l_maxx,l_miny:l_maxy)     :: pr_p0_1,pr_p0_0
      real*8 :: bbb_8,avg_8(3),savg_8(3),total_surface_pressure, area
      real*8, parameter :: ZERO_8 = 0.0, ONE_8 = 1.d0
!     _________________________________________________________________
!
      if (Schm_psadj_S=='NIL') return

      istat= gmm_get(gmmk_st0_s,st0)
      istat= gmm_get(gmmk_st1_s,st1)

      if (Schm_psadj_S=='DRY') then
         ! Compute pressure
         call calc_pressure ( pr_m1, pr_t1, pr_p0_1, st1, l_minx,l_maxx, l_miny,l_maxy, l_nk )
         call calc_pressure ( pr_m0, pr_t0, pr_p0_0, st0, l_minx,l_maxx, l_miny,l_maxy, l_nk )

         ! Compute dry surface pressure
         call dry_sfc_pressure (wk0, pr_m0, pr_p0_0, l_minx,l_maxx,l_miny,l_maxy,l_nk, 'M')
         call dry_sfc_pressure (wk1, pr_m1, pr_p0_1, l_minx,l_maxx,l_miny,l_maxy,l_nk, 'P')
      else
!$omp parallel private(i) shared(st0,st1)
!$omp do
         do j= 1+pil_s, l_nj-pil_n 
         do i= 1+pil_w, l_ni-pil_e
            wk0(i,j)= (exp(st0(i,j)) - 1.) * Cstv_pref_8
            wk1(i,j)= (exp(st1(i,j)) - 1.) * Cstv_pref_8
         end do
         end do
!$omp enddo
!$omp end parallel
      endif

      if (Grd_yinyang_L) then

         offi = Ptopo_gindx(1,Ptopo_myproc+1)-1
         offj = Ptopo_gindx(3,Ptopo_myproc+1)-1
         
         avg_8= ZERO_8 ; isize=3
         do j=1+pil_s,l_nj-pil_n
         do i=1+pil_w,l_ni-pil_e
            area= Geomg_area_8(i,j)*Geomg_mask_8(i,j)
            avg_8(1)= avg_8(1) + area * wk0(i,j)
            avg_8(2)= avg_8(2) + area
            avg_8(3)= avg_8(3) + area * wk1(i,j)
         enddo
         enddo

         call RPN_COMM_allreduce(avg_8,savg_8,isize,&
              "MPI_DOUBLE_PRECISION","MPI_SUM","MULTIGRID",ierr)

         avg_8(2)= savg_8(3)/savg_8(2)
         avg_8(1)= savg_8(1)/savg_8(2)

         bbb_8   = avg_8(2) - avg_8(1)

         call RPN_COMM_bcast(bbb_8,1,'MPI_DOUBLE_PRECISION',0,'GRID',ierr)

      else
         call horwavg ( bbb_8, wk1, wk0, l_minx,l_maxx,l_miny,l_maxy)
      endif

!     Redistribute the average mass loss at the surface, ...

!$omp parallel private(i,total_surface_pressure) shared(st0,bbb_8)
!$omp do
      do j= 1+pil_s, l_nj-pil_n 
      do i= 1+pil_w, l_ni-pil_e
         total_surface_pressure = (exp(st0(i,j)) - 1.) * Cstv_pref_8
         st0(i,j)= log(ONE_8+ (total_surface_pressure + bbb_8) / Cstv_pref_8)
      end do
      end do
!$omp enddo
!$omp end parallel
    
!     _________________________________________________________________
!
      return
      end
