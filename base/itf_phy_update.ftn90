!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
!/**
      subroutine itf_phy_update3 (F_apply_L)
      use phy_itf, only: phy_get
      implicit none
#include <arch_specific.hf>

      logical,intent(in) :: F_apply_L

!authors 
!     Desgagne, McTaggart-Cowan, Chamberland -- Spring 2014
!
!revision
! v4_70 - authors          - initial version
   
#include <gmm.hf>
#include "glb_ld.cdk"
#include "grd.cdk"
#include "vt1.cdk"
#include "tr3d.cdk"
#include "pw.cdk"
#include "itf_phy.cdk"

      character(len=GMM_MAXNAMELENGTH) :: trname_S
      integer nelements, init, busidx, istat, k, cnt
      real, dimension(:,:,:), pointer :: data3d,minus,ptr3d
!
!-----------------------------------------------------------------
!

   APPLY: if (F_apply_L) then

      do k= 1, Tr3d_ntr
         trname_S = 'TR/'//trim(Tr3d_name_S(k))//':P'
         istat = gmm_get(trim(trname_S),data3d)
         ptr3d => data3d(p_li0:p_li1,p_lj0:p_lj1,1:l_nk)
         istat = phy_get(ptr3d,trim(trname_S),F_npath='V',F_bpath='D',F_end=(/-1,-1,l_nk/))
      enddo

      istat = gmm_get (gmmk_pw_uu_plus_s,data3d)
      ptr3d => data3d(p_li0:p_li1,p_lj0:p_lj1,1:l_nk)
      istat = phy_get(ptr3d,gmmk_pw_uu_plus_s,F_npath='V',F_bpath='D',F_end=(/-1,-1,l_nk/))

      istat = gmm_get (gmmk_pw_vv_plus_s,data3d)
      ptr3d => data3d(p_li0:p_li1,p_lj0:p_lj1,1:l_nk)
      istat = phy_get(ptr3d,gmmk_pw_vv_plus_s,F_npath='V',F_bpath='D',F_end=(/-1,-1,l_nk/))

      istat = gmm_get (gmmk_pw_tt_plus_s,data3d)
      ptr3d => data3d(p_li0:p_li1,p_lj0:p_lj1,1:l_nk)
      istat = phy_get(ptr3d,gmmk_pw_tt_plus_s,F_npath='V',F_bpath='D',F_end=(/-1,-1,l_nk/))

      call itf_phy_apply2 ()

   else

      cnt = 0
      do k= 1, Tr3d_ntr
         if (trim(Tr3d_name_S(k)) == 'HU' .or.                          &
             any(Tr3d_username_S(1:Tr3d_userntr)==trim(Tr3d_name_S(k))))&
             cycle
         trname_S = 'TR/'//trim(Tr3d_name_S(k))//':P'
         istat = gmm_get(trim(trname_S),data3d)
         ptr3d => data3d(p_li0:p_li1,p_lj0:p_lj1,1:l_nk)
         istat = phy_get(ptr3d,trim(trname_S),F_npath='V',F_bpath='D',F_end=(/-1,-1,l_nk/))
         trname_S = 'TR/'//trim(Tr3d_name_S(k))//':M'
         if (Grd_yinyang_L) &
         call yyg_xchng (data3d, l_minx,l_maxx,l_miny,l_maxy, &
                         G_nk,.true., 'CUBIC')
         
         istat = gmm_get(trim(trname_S),minus)
         minus = data3d
         cnt   = cnt + 1
      end do

      if (cnt.gt.0) then
         istat = gmm_get(gmmk_tt1_s, tt1)
         call tt2virt2 (tt1, .true., l_minx,l_maxx,l_miny,l_maxy,l_nk)
         if (Grd_yinyang_L) then
            call yyg_xchng (tt1, l_minx,l_maxx,l_miny,l_maxy, &
                            G_nk, .false., 'CUBIC')
            call pw_update_T  ('P')
         endif
         call pw_update_GPW ()
      endif

   endif APPLY
!
!-----------------------------------------------------------------
!
   return
   end subroutine itf_phy_update3
