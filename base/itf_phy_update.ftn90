!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!/**
function itf_phy_update2(F_apply_L) result(F_istat)
   implicit none
   !@objective
   !@arguments
   logical,intent(in) :: F_apply_L
   !@return
   integer :: F_istat
   !@author  Michel Desgagne  -  Spring 2012
   !@revisions
   !  2012-06, S.Chamberland: use bus_fold
   !**/
#include <arch_specific.hf>
#include <rmnlib_basics.hf>
#include <gmm.hf>
#include <msg.h>
   include "phy_itf.inc"
   integer,parameter :: MAXNTR = 1024
   integer,parameter :: NVARS = 3
   character(len=*),parameter :: VARLIST_S(NVARS) = &
        (/'PW_TT:P','PW_UU:P','PW_VV:P'/)
   character(len=*),parameter :: FOLD_BUS_S = 'Dd'
   character(len=*),parameter :: FOLD_BUS0_S = 'Dt'

   logical,save :: init_L = .false.
   integer,save :: ntr = 0
   character(len=GMM_MAXNAMELENGTH),save :: trlist_S(MAXNTR)

   character(len=GMM_MAXNAMELENGTH) :: prefix_S,basename_S,time_S,ext_S,trname_S
   integer :: ivar, ignore
   !---------------------------------------------------------------
   F_istat = RMN_OK
   if (.not.init_L) then
      trlist_S = ' '
      ntr = gmm_keys(trlist_S,'TR/')
      init_L = .true.
   endif

   APPLY: if (F_apply_L) then
      ! Update tracers
      do ivar = 1,ntr
         call gmmx_name_parts(trlist_S(ivar),prefix_S,basename_S,time_S,ext_S)
         if (time_S /= ':P') cycle
         call msg(MSG_INFOPLUS,'(itf_phy_update2) '//trim(trlist_S(ivar)))
         ignore = phy_bus2gmm(trlist_S(ivar),trlist_S(ivar),FOLD_BUS_S)
      enddo
      ! Update state vars
      do ivar = 1,NVARS
         call msg(MSG_INFOPLUS,'(itf_phy_update2) '//trim(VARLIST_S(ivar)))
         F_istat = min(phy_bus2gmm(VARLIST_S(ivar),VARLIST_S(ivar),FOLD_BUS_S),F_istat)
      enddo
   else
      !# Note: Secial case at step=0, tracers are not updated at surface
      do ivar = 1,ntr
         call gmmx_name_parts(trlist_S(ivar),prefix_S,basename_S,time_S,ext_S)
         if (basename_S == 'HU' .or. time_S /= ':P') cycle
         trname_S = trim(prefix_S)//trim(basename_S)//':P'//ext_S
         call msg(MSG_INFOPLUS,'(itf_phy_update2) '//trim(trname_S))
         ignore = phy_bus2gmm(trname_S,trlist_S(ivar),FOLD_BUS0_S)
         !TODO: would it be best/faster to do a gmm 3d copy?
         trname_S = trim(prefix_S)//trim(basename_S)//':M'//ext_S
         ignore = phy_bus2gmm(trname_S,trlist_S(ivar),FOLD_BUS0_S)
      enddo
   endif APPLY

   !---------------------------------------------------------------
   return
end function itf_phy_update2
