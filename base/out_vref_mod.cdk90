!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!*module out_vref_mod - output vertical coordinate tags
!
module out_vref_mod

  private

  public :: out_vref

  interface out_vref
     module procedure out_vref_model
     module procedure out_vref_pres
  end interface

#include "model_macros_f.h"

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine out_vref_model(F_ref,minx,maxx,miny,maxy,ig1,ig2)
    use vGrid_Descriptors, only: vgrid_descriptor,vgd_new,vgd_write,vgd_print,VGD_OK,vgd_get
    ! Write the vertical coordinate descriptor (model levels)

    implicit none

    real, dimension(minx:maxx,miny:maxy), intent(in) :: F_ref !reference (surface) field
    integer, intent(in) :: minx,maxx,miny,maxy          !bounds for reference field
    integer, intent(in), optional :: ig1,ig2            !override 'out.cdk' values of ig1,ig2

    !author
    !     v.lee - rpn march 2008
    !
    !revision
    ! v4_03 - Lee V.            - initial MPI version (from wrvref MC2)
    ! 
    !implicits

#include "glb_ld.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
#include "dimout.cdk"
#include "grd.cdk"
#include "level.cdk"
#include "grid.cdk"
#include "lun.cdk"
#include "out.cdk"

    ! Internal variables
    integer :: err,my_ig1,my_ig2
    type(vgrid_descriptor) :: vgd

    ! Set default values
    my_ig1 = Out_ig1
    if (present(ig1)) my_ig1 = ig1
    my_ig2 = Out_ig2
    if (present(ig2)) my_ig2 = ig2

    ! Write coordinate descriptor

    if (writeDescriptor()) then
       err = vgd_new(vgd,               &
            kind     = Level_kind_ip1,  &
            version  = Level_version,   &
            nk       = G_nk,            &
            ip1      = my_ig1,          &
            ip2      = my_ig2,          &
            ptop_8   = Cstv_ptop_8,     &
            pref_8   = Cstv_pref_8,     &
            rcoef1   = Grd_rcoef(1),    &
            rcoef2   = Grd_rcoef(2),    &
            a_m_8    = Ver_a_8%m,       &
            b_m_8    = Ver_b_8%m,       &
            a_t_8    = Ver_a_8%t,       &
            b_t_8    = Ver_b_8%t,       &
            ip1_m    = Ver_ip1%m,       &
            ip1_t    = Ver_ip1%t)

       if (report(Out_ig1,Out_ig2)) err = vgd_print(vgd,Lun_out)
       err = vgd_write(vgd,unit=Out_unf,format='fst')

    endif

    return

  end subroutine out_vref_model

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine out_vref_pres(F_rf,ig1,ig2)
    use vGrid_Descriptors, only: vgrid_descriptor,vgd_new,vgd_write,vgd_print,VGD_OK
    ! Write the vertical coordinate descriptor (pressure levels)

    implicit none

    real, dimension(:), intent(in) :: F_rf              !List of pressure levels to output
    integer, intent(in), optional :: ig1,ig2            !override 'out.cdk' values of ig1,ig2

    !author
    !     R. McTaggart-Cowan - Aug 2009
    !
    !revision
    !
    !object
    !     Write vertical coordinate descriptor for pressure-coordinate data
    !
    !implicits
#include "out.cdk"
#include "dimout.cdk"
#include "grd.cdk"
#include "level.cdk"
#include "lun.cdk"

    ! Local variables
    integer :: k,err,my_ig1,my_ig2
    integer, dimension(size(F_rf)) :: ip1s
    real*8, dimension(size(F_rf)) :: zero
    type(vgrid_descriptor) :: vgd
    logical, save :: reported=.false.

    ! Set default values
    my_ig1 = Out_ig1
    if (present(ig1)) my_ig1 = ig1
    my_ig2 = Out_ig2
    if (present(ig2)) my_ig2 = ig2

    ! Set initializing values
    zero = 0.d0
    do k=1,size(F_rf)
       call convip(ip1s(k),F_rf(k),2,Level_mode_ip1,'',.false.)
    enddo

    ! Write coordinate descriptor
    if (writeDescriptor()) then

       err = vgd_new(vgd,               &
            kind     = 2,               &
            version  = 1,               &
            nk       = size(F_rf),      &
            ip1      = my_ig1,          &
            ip2      = my_ig2,          &
            a_m_8    = dble(F_rf*100.), &
            b_m_8    = zero,            &
            ip1_m    = ip1s)

       if (report(Out_ig1,Out_ig2)) err = vgd_print(vgd,Lun_out)
       err = vgd_write(vgd,unit=Out_unf,format='fst')

    endif
    
  end subroutine out_vref_pres

  logical function writeDescriptor()
    ! Decide whether or not to write descriptor based on local tile
    implicit none
#include "out.cdk"
    writeDescriptor = (Out_blocme == 0).and.(Out_nisl > 0).and.(Out_njsl > 0)
    return
  end function writeDescriptor

  logical function report(ig1,ig2)
    ! Decide whether or not to report output from the descriptor
    implicit none
#include "lun.cdk"
#include "dimout.cdk"
#include "grid.cdk"
#include "level.cdk"
    integer :: ig1,ig2
    integer :: i
    integer, save :: report_count=0
    integer, dimension(MAXGRID1*LEVEL_NTYP,2), save :: reported
    logical :: found
    report = .false.
    if (.not.Lun_debug_L) return
    i = 1; found = .false.
    do while (.not.found .and. i<=report_count)
       if (ig1 == reported(i,1) .and. ig2 == reported(i,2)) found = .true.
       i = i+1
    enddo
    if (.not.found) then
       report_count = min(report_count+1,size(reported,dim=1))
       reported(report_count,:) = (/ig1,ig2/)
       report = .true.
    endif
    return
  end function report

end module out_vref_mod
