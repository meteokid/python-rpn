!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r  bacp_2 - backsubstitution: obtain new values of the variables:
!                                                   u,v,w,t,q,s,zd,fip 
!                   from new P , the right-hand sides (Ru,Rv,Rt,Rw,Rf)
!                                and non-linear terms (Nu,Nv,Nt,Nw,Nf)
!
#include "model_macros_f.h"
!
      subroutine bacp_2 ( F_itr , F_itnlh , F_p   , F_fis , &
                          F_u   , F_v     , F_w   , F_t   , &
                          F_s   , F_zd    , F_q   , F_fip , F_nest_q, &
                          F_ru  , F_rv    , F_rt  , F_rw  , F_rf , F_rb, &
                          F_nu  , F_nv    , F_nt  , F_nw  , F_nf , F_nb, &
                          DIST_DIM, Nk )
!
      implicit none
#include <arch_specific.hf>
!
      integer  F_itr, F_itnlh, DIST_DIM, Nk 
! 
      real     F_p     (DIST_SHAPE,0:Nk+1),  F_fis  (DIST_SHAPE)       , &
               F_u     (DIST_SHAPE,  Nk)  ,  F_v    (DIST_SHAPE,  Nk)  , &
               F_w     (DIST_SHAPE,  Nk+1),  F_t    (DIST_SHAPE,  Nk+1), &
               F_s     (DIST_SHAPE)       ,  F_zd   (DIST_SHAPE,  Nk+1), &
               F_q     (DIST_SHAPE,0:Nk+1),  F_fip  (DIST_SHAPE,0:Nk+1), &
               F_nest_q(DIST_SHAPE,0:Nk+1), &
               F_ru    (DIST_SHAPE,  Nk)  ,  F_rv   (DIST_SHAPE,  Nk)  , &
               F_rt    (DIST_SHAPE,  Nk+1),  F_rw   (DIST_SHAPE,Nk+1)  , &
               F_rf    (DIST_SHAPE,  Nk+1),  F_rb   (DIST_SHAPE), &
               F_nu    (DIST_SHAPE,  Nk)  ,  F_nv   (DIST_SHAPE,  Nk)  , &
               F_nt    (DIST_SHAPE,  Nk+1),  F_nw   (DIST_SHAPE,  Nk+1), &
               F_nf    (DIST_SHAPE,  Nk+1),  F_nb   (DIST_SHAPE)
!
!author
!     Alain Patoine - split from bac.ftn
!
!revision
! v2_00 - Desgagne M.       - initial MPI version (from rhs v1_03)
! v2_21 - Lee V.            - modifications for LAM version
! v2_30 - Edouard  S.       - adapt for vertical hybrid coordinate
! v2_31 - Desgagne M.       - removed treatment of Hu and Qc
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v3_21 - Desgagne M.       - Revision Openmp
! v4_00 - Plante & Girard   - Log-hydro-pressure coord on Charney-Phillips grid
! v4_05 - Girard            - Open top
! v4_14 - Plante & Desgagne - Lam acid test with top piloting (lid nesting)
!       - Girard & Plante   - PIOR
!
!object
!     see documentation in s/r bac.
!
!arguments: see documentation of appropriate comdecks 
!
!implicits
#include "glb_ld.cdk"
#include "lam.cdk"
!
      integer i, j, k, i0, j0, k0, in, jn, nij

      i0 = 1+pil_w
      in = l_ni-pil_e
      j0 = 1+pil_s
      jn = l_nj-pil_n
      k0 = 1+Lam_gbpil_T


      call  bacp_2_2 ( F_itr , F_itnlh , F_p   , F_fis , &
                       F_u   , F_v     , F_w   , F_t   , &
                       F_s   , F_zd    , F_q   , F_fip , F_nest_q, &
                       F_ru  , F_rv    , F_rt  , F_rw  , F_rf , F_rb , &
                       F_nu  , F_nv    , F_nt  , F_nw  , F_nf , F_nb , &
                       DIST_DIM, Nk, i0, j0, k0, in, jn )
      return
      end
!
! 2e etage pour OpenMP
!

      subroutine bacp_2_2 ( F_itr , F_itnlh , F_p  , F_fis , &
                            F_u   , F_v     , F_w  , F_t   , &
                            F_s   , F_zd    , F_q  , F_fip , F_nest_q, &
                            F_ru  , F_rv    , F_rt , F_rw  , F_rf , F_rb, &
                            F_nu  , F_nv    , F_nt , F_nw  , F_nf , F_nb, &
                            DIST_DIM, Nk, i0, j0, k0, in, jn )
!
      implicit none
#include <arch_specific.hf>
!
      integer  F_itr, F_itnlh, DIST_DIM, Nk , i0, j0, k0, in, jn
      real     F_p     (DIST_SHAPE,0:Nk+1),  F_fis  (DIST_SHAPE)       , &
               F_u     (DIST_SHAPE,  Nk)  ,  F_v    (DIST_SHAPE,  Nk)  , &
               F_w     (DIST_SHAPE,  Nk+1),  F_t    (DIST_SHAPE,  Nk+1), &
               F_s     (DIST_SHAPE)       ,  F_zd   (DIST_SHAPE,  Nk+1), &
               F_q     (DIST_SHAPE,0:Nk+1),  F_fip  (DIST_SHAPE,0:Nk+1), &
               F_nest_q(DIST_SHAPE,0:Nk+1), &
               F_ru    (DIST_SHAPE,  Nk)  ,  F_rv   (DIST_SHAPE,  Nk)  , &
               F_rt    (DIST_SHAPE,  Nk+1),  F_rw   (DIST_SHAPE,Nk+1)  , &
               F_rf    (DIST_SHAPE,  Nk+1),  F_rb   (DIST_SHAPE), &
               F_nu    (DIST_SHAPE,  Nk)  ,  F_nv   (DIST_SHAPE,  Nk)  , &
               F_nt    (DIST_SHAPE,  Nk+1),  F_nw   (DIST_SHAPE,  Nk+1), &
               F_nf    (DIST_SHAPE,  Nk+1),  F_nb   (DIST_SHAPE)
!
!
!implicits
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "cori.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "lun.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
#include "ptopo.cdk"
#include "acid.cdk"
#include "lam.cdk"
!
      integer i, j, k, nij, kminzd
      real*8  zero, one, xxx, yyy, zzz, p1, p2, p3, p4, pr0_8, qbar
      parameter( zero=0.d0, one=1.d0 )
      real*8, dimension(i0:in,j0:jn):: xtmp_8, ytmp_8
      real*8 Pbar(DIST_SHAPE,Nk+1)
      logical finbac
!*
      pr0_8=zero
      if(Schm_pior_L) pr0_8=one
      finbac=.false.
      if ( .not. (F_itr .lt. F_itnlh) )finbac=.true.
!     __________________________________________________________________
!
      nij = (in - i0 + 1)*(jn - j0 + 1)

      if ( (Cori_cornl_L) .or. (F_itr .lt. F_itnlh) ) &
         call rpn_comm_xch_halo( F_p  , LDIST_DIM,l_ni,l_nj,G_nk+2, &
                       G_halox,G_haloy,G_periodx,G_periody,l_ni,0)

      p1 = Cstv_tau_8*Cstv_RTstr_8/Dcst_grav_8
      p2 = one/Cstv_RTstr_8
      p3 = one/Dcst_grav_8
      p4 = one/Dcst_rayt_8**2  
!
!$omp parallel private(xxx,yyy,zzz,qbar,xtmp_8,ytmp_8,kminzd)
!
!     Compute P at top and bottom
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!$omp do
      do j= j0, jn
      do i= i0, in
         if ( .not.(Lam_acidtest_L.and.Schm_opentop_L) ) then
            F_p(i,j,k0-1) = Ver_alfat_8 * F_p(i,j,k0) &
                          + Ver_cst_8*(F_rb(i,j)-F_nb(i,j))
         endif
         F_p(i,j,l_nk+1)  = Ver_alfas_8 * F_p(i,j,l_nk)  &
                          - Ver_css_8*(F_rt(i,j,l_nk+1)-F_nt(i,j,l_nk+1)) 
      end do
      end do
!$omp enddo
!
!$omp single
      call rpn_comm_xch_halo(F_p,LDIST_DIM,l_ni,l_nj,G_nk+2, &
           G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
!$omp end single
!
!     Compute U & V
!     ~~~~~~~~~~~~~
!
      if(Acid_test_L) &
           print *,'bacp_2:Cori_cornl,finbac=',Cori_cornl_L,finbac
!
      if (Cori_cornl_L .or. (finbac.and..not.Cori_cornl_L)) then
!$omp do
         do k=k0,l_nk
            do j= j0, jn
            do i= i0, l_niu-pil_e

               F_u(i,j,k)= Cstv_tau_8*( F_ru(i,j,k)-F_nu(i,j,k) - &
                           p4*(F_p(i+1,j,k)-F_p(i,j,k)) &
                             *geomg_invDXu_8(i) )
            end do
            end do
!
            do j= j0, l_njv-pil_n
            do i= i0, in
               F_v(i,j,k)= Cstv_tau_8*( F_rv(i,j,k)-F_nv(i,j,k) - &
                           p4*(F_p(i,j+1,k) - F_p(i,j,k)) &
                             *geomg_invDYv_8(j) )
            end do
            end do

         enddo
!$omp enddo
         if(Acid_test_L)call acid_stat_bacp_2(F_u,1)
!
      endif
!     
!     Compute w
!     ~~~~~~~~~
!
!$omp do
      do k=k0,l_nk+1
         do j= j0, jn
         do i= i0, in
            Pbar(i,j,k) = Ver_wp_8%t(k)*F_p(i,j,k)+Ver_wm_8%t(k)*F_p(i,j,k-1)
            F_w(i,j,k)  = p1 * ( F_rf(i,j,k) - F_nf(i,j,k) &
             + Ver_gokt2RT_8 * ( (F_p(i,j,k)-F_p(i,j,k-1))*Ver_idz_8%t(k) &
                                     + Dcst_cappa_8 * Pbar(i,j,k) ) )
         end do
         end do
      end do
!$omp enddo
!
      if(.not.Schm_hydro_L) then
!
!        Compute q
!        ~~~~~~~~~
!
!        N.B.  Top Boundary condition:
!                 Closed Top:  F_q(i,j,0) = 0
!                   Open Top:  F_q(i,j,k0-1) is externally specified
!
         if (Schm_opentop_L) then
            do j= j0, jn
            do i= i0, in               
               F_q(i,j,k0-1)=F_nest_q(i,j,k0-1)
            end do
            end do
         endif
!
!        Note : we cannot use omp on loop k 
!               due to vertical dependency F_q(i,j,k-1)
         do k=k0,l_nk+1
            zzz = one/(one+pr0_8*Ver_wp_8%t(k)*Ver_dz_8%t(k))
            yyy = (one-pr0_8*Ver_wm_8%t(k)*Ver_dz_8%t(k))*zzz
            xxx = p3*Ver_dz_8%t(k)*zzz
!$omp do
            do j= j0, jn
            do i= i0, in
               F_q(i,j,k) = yyy * F_q(i,j,k-1) &
                          - xxx * ( F_rw(i,j,k) - F_nw(i,j,k) &
                                  - Cstv_invT_8 *F_w(i,j,k)  )
            end do
            end do
!$omp enddo
         end do
!
         if (Lam_acidtest_L) call sol_from_file (F_q,DIST_DIM,0,l_nk+1 )         
!
      endif
!
!     Compute s
!     ~~~~~~~~~
!
!$omp do
      do j= j0, jn 
      do i= i0, in 
         F_s(i,j) = p2*(Ver_wp_8%t(l_nk+1)*F_p(i,j,l_nk+1) &
                       +Ver_wm_8%t(l_nk+1)*F_p(i,j,l_nk)-F_fis(i,j))
      end do
      end do
!$omp enddo
!
      if (.not. Schm_hydro_L) then 
!$omp do
         do j= j0, jn 
         do i= i0, in 
            F_s(i,j) = F_s(i,j) - Ver_wp_8%t(l_nk+1)*F_q(i,j,l_nk+1) &
                                - Ver_wm_8%t(l_nk+1)*F_q(i,j,l_nk)
         end do
         end do
!$omp enddo
      endif 
!
!     Compute zd
!     ~~~~~~~~~~
!
      if(.not.Schm_autobar_L) then  ! safer for autobar
!
!        N.B.  Top Boundary condition:
!                 Closed Top:  F_zd(i,j,1) = 0
!                   Open Top:  F_zd(i,j,k0) is computed
!
         kminzd=2
         if(Schm_opentop_L) kminzd=k0
!
!$omp do
         do k=kminzd,l_nk
            xxx=Ver_gokt2RT_8*Ver_idz_8%t(k)
            yyy=Ver_gokt2RT_8*Ver_epsilon_8
            zzz=Ver_b_8%t(k)*Cstv_invT_8
            if(Schm_autobar_L) zzz=0.d0
            do j= j0, jn 
            do i= i0, in 
               F_zd(i,j,k)=-Cstv_tau_8*( F_rt(i,j,k)- F_nt(i,j,k) &
                          + xxx * ( F_p(i,j,k)-F_p(i,j,k-1) ) &
                          - yyy * Pbar(i,j,k) ) &
                          - zzz * F_s(i,j)
            enddo
            enddo
         enddo   
!$omp enddo
!
         if (.not. Schm_hydro_L) then
!$omp do
            do k=kminzd,l_nk
               do j= j0, jn 
               do i= i0, in 
                  qbar=(Ver_wp_8%t(k)*F_q(i,j,k)+Ver_wm_8%t(k)*F_q(i,j,k-1))
                  F_zd(i,j,k)=F_zd(i,j,k)-Cstv_invT_8*qbar
               enddo
               enddo
            enddo
!$omp enddo
         endif
!
      endif
!
!     Compute FI'
!     ~~~~~~~~~~~

!$omp do
      do k=k0-1,l_nk
         if(k.eq.0) then
            xxx=0.d0
         else
            xxx=Cstv_RTstr_8*Ver_b_8%m(k)
         endif
         do j= j0, jn 
         do i= i0, in          
            F_fip(i,j,k)=F_p(i,j,k)-xxx*F_s(i,j)
         enddo
         enddo
      enddo
!$omp enddo
      if (.not. Schm_hydro_L) then
!$omp do
         do k=k0-1,l_nk
            do j= j0, jn 
            do i= i0, in          
               F_fip(i,j,k)=F_fip(i,j,k)-Cstv_RTstr_8*F_q(i,j,k)       
            enddo
            enddo
         enddo
!$omp enddo
      endif    
!
      do j= j0, jn 
      do i= i0, in          
         F_fip(i,j,l_nk+1)=F_fis(i,j)
      enddo
      enddo
!
!     Compute T
!     ~~~~~~~~~
!
      if(.not.Schm_autobar_L) then            ! safer for autobar
!$omp do
      do k=k0,l_nk+1
         if(.not.Schm_hydro_L.and.Schm_pior_L) then
            do j= j0, jn
            do i= i0, in
               qbar=(Ver_wp_8%t(k)*F_q(i,j,k)+Ver_wm_8%t(k)*F_q(i,j,k-1))
               ytmp_8(i,j)=-qbar
            enddo
            enddo
            call vexp( xtmp_8, ytmp_8, nij )
            do j= j0, jn 
            do i= i0, in          
               xtmp_8(i,j)=xtmp_8(i,j)*(one+Ver_dbdz_8%t(k)*F_s(i,j))
            enddo
            enddo
         else
            do j= j0, jn
            do i= i0, in
               xtmp_8(i,j)=one+Ver_dbdz_8%t(k)*F_s(i,j)
            enddo
            enddo
         endif
         call vrec ( ytmp_8, xtmp_8, nij )
         xxx=p2*Ver_idz_8%t(k)
         do j= j0, jn 
         do i= i0, in          
            F_t(i,j,k)=Cstv_Tstr_8*ytmp_8(i,j) &
                 *(one-xxx*(F_fip(i,j,k)-F_fip(i,j,k-1)))
         enddo
         enddo
      enddo
!$omp enddo
      endif
!
      if(Schm_opentop_L) then
!     Note for Lam_acidtest_L: F_fip will not validate for levels k0-1 to 1 if
!                              physics is not called but rest of model will validate
!                              
!$omp do 
         do j=j0,jn
            do k= k0-1,1,-1
            yyy=Cstv_RTstr_8*Ver_dz_8%t(k)/Cstv_Tstr_8
            do i=i0,in
               xxx=one+Ver_dbdz_8%t(k)*F_s(i,j)
               F_fip(i,j,k-1)=F_fip(i,j,k)+yyy*(F_t(i,j,k)*xxx-Cstv_Tstr_8)
            end do
            end do
         end do
!$omp enddo
      endif
!
!$omp end parallel

!     __________________________________________________________________
!
      return
      end

