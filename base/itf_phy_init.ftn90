!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r itf_phy_init - Initializes physics parameterization package
!
#include "model_macros_f.h"
!
      subroutine itf_phy_init
      implicit none

!author
!     Michel Desgagne    -   Summer 2006
!
!revision
! v3_30 - Desgagne M.        - Initial version
! v3_30 - Tanguay M.         - adapt TL/AD to itf
! v3_30 - Bilodeau B.        - add call to phy_opt for offline mode
! v3_30 - Dugas B.           - correction to P_out_moyhr, add Out3_satues_L
! v4_05 - Plante A.          - add iceline option (ICELAC)
! v4_14 - Dugas B.           - define ININCR (via call to phy_optl)
! v4_40 - Lee V.             - add VSTAG flag to inform vertical coordinate
! v4_44 - Plante A.          - Add standard pressure profil std_p_prof for non orographic gwd

#include <arch_specific.hf>
#include <WhiteBoard.hf>
#include <msg.h>
#include "glb_ld.cdk"
#include "lun.cdk"
#include "grd.cdk"
#include "schm.cdk"
#include "out3.cdk"
#include "cstv.cdk"
#include "p_serg.cdk"
#include "itf_cpl.cdk"
#include "itf_phy_buses.cdk"
#include "itf_phy_config.cdk"
#include "ver.cdk"
#include "path.cdk"

      integer, parameter :: COMPATIBILITY_LVL = 3
      integer, parameter :: DIM_ERR = 14

      logical,external :: set_dcst
      integer,external :: fnom, phy_nml, phy_init3, phy_compatibility
      external :: getijlalo, itf_phy_rdfile

      character*3 bus
      logical prout,cond_satu_L
      integer nrec, phycompa, n, lght, soit, phy_offset
      integer err(DIM_ERR),i,offi2,offj2
      real, dimension(:), pointer :: std_p_prof
!
!     ---------------------------------------------------------------
!
!   General rules:
!    1) .ftn & .cdk with prefix itf_phy_ are the actual interface routines
!    2) Those with prefix phy_ belong to the physics package

      if (Lun_out.gt.0) write(Lun_out,1000)

      prout  = Lun_out.gt.0 ! for print/write statements in stdout

      Schm_phyms_L=.false.
      if ( Schm_theoc_L) then
         if (Lun_out.gt.0) write(Lun_out,9500)
         return
      endif

! Important compatibility level check

      phycompa = phy_compatibility ()
      if ( phycompa .ne. COMPATIBILITY_LVL ) then
         if (Lun_out.gt.0) write(Lun_out,9001) COMPATIBILITY_LVL, phycompa
         phycompa = -1
      else
         if (Lun_out.gt.0) write(Lun_out,1002) COMPATIBILITY_LVL
      endif
      call handle_error ( phycompa,'itf_phy_init', &
                         'Wrong physics compatibility level')

! Initialize physics configuration with default values and read 
! user configuration in namelist from file 'model_settings'

      err(1) = phy_nml (trim(Path_nml_S), set_dcst, Schm_phyms_L, Lun_out)
      call handle_error(err(1),'itf_phy_init','phy_nml')

      if (.not.Schm_phyms_L) return ! NO PHYSICS REQUIRED

      err=0

! We set mandatory variables that cannot be set via the namelist

      call phy_optl('VSTAG'   , .true.      , 1,'SET',prout,err(1))
      call phy_opti('TLIFT'   , Schm_Tlift  , 1,'SET',prout,err(2))
      call phy_optl('COUPLING', C_coupling_L, 1,'SET',prout,err(3))
      call phy_optl('NOTOP'   , .true.      , 1,'SET',prout,err(4))
      call handle_error(minval(err(1:4)),'itf_phy_init','phy_opt set')

! Because of horizontal de-staggering of the wind components
! we will lose 2 points around the global domain of a LAM config.
! In LAM config, data will therefore be available to the physics
! with the global scope (3,G_ni-2) (3,G_nj-2)

      phy_offset = 0
      if (G_lam) phy_offset = 2
      err(1) = wb_put('itf_phy/PHY_OFFSET', phy_offset)
      p_offi = phy_offset*west  ; offi2 = phy_offset*east
      p_offj = phy_offset*south ; offj2 = phy_offset*north
      
! Complete physics initialization (see phy_init for interface content)

      p_nk  = G_nk + 1
      err(1)= phy_init3 ( Out3_date,real(Cstv_dt_8),1+p_offi,l_ni-offi2, &
                          1+p_offj, l_nj-offj2, p_nk, getijlalo        , &
                          itf_phy_rdfile )
      call handle_error(err(1),'itf_phy_init','phy_init3')

! The current physics interface operate on an arbitrary number of
! columns p_ni containing p_nk levels. Here p_ni is defined as a
! whole row of points 'j' and there will be p_nj rows to compute
! P_ni & p_nj are a function of the running length p_runlgt

      call phy_opti('NI'      ,p_ni    ,1,'GET',.false.,err(1))
      call phy_opti('NJ'      ,p_nj    ,1,'GET',.false.,err(2))
      call phy_opti('P_RUNLGT',p_runlgt,1,'GET',.false.,err(3))

      p_doni = l_ni - p_offi - offi2
      p_donj = l_nj - p_offj - offj2

      !TODO: pass std_p_prof as phy_init arg
      ! Pass standard pressure profil to physics.
      allocate(std_p_prof(p_nk))
      std_p_prof= Ver_std_p_prof%m
      call phy_com_r('STD_P_PROF',std_p_prof,p_nk, 'SET')
      deallocate(std_p_prof)

      err = 0
      call phy_optl('SATUCO'    ,cond_satu_L  , 1, 'GET',prout,err(1))
      call phy_optl('SATUCO'    ,P_cond_satu_L, 1, 'GET',prout,err(2))
      call phy_opti('MOYHR'     ,P_out_moyhr  , 1, 'GET',prout,err(3))
      call handle_error(minval(err),'itf_phy_init','phy_opt get')

      ! Consistency check for saturation calculations
      if (Out3_satues_L .and. .not.cond_satu_L) then
          Out3_satues_L = .false.
          if (Lun_out.gt.0) write(Lun_out,9600)
      endif

      P_out_moyhr = ( P_out_moyhr * Cstv_dt_8 ) / 3600.
!
! Pre-establish BUS index for coupling
!
      if (C_coupling_L) then
         bus = 'DYN'
         call getindx2 ('MCCPL'     ,  bus, cpl_mcp     , lght, soit)
         call getindx2 ('TMICECPL'  ,  bus, cpl_i7      , lght, soit)
         call getindx2 ('TWATERCPL' ,  bus, cpl_tm      , lght, soit)
         call getindx2 ('GLCPL'     ,  bus, cpl_gl      , lght, soit)
         call getindx2 ('ICEDPCPL'  ,  bus, cpl_i8      , lght, soit)
         bus = 'PER'
         call getindx2 ('FLUSOLIS'  ,  bus, cpl_flusolis, lght, soit)
         call getindx2 ('FDSI'      ,  bus, cpl_fdsi    , lght, soit)
         bus = 'VOL'
         call getindx2 ('RT'        ,  bus, cpl_rt      , lght, soit)
      endif
!
!     ---------------------------------------------------------------
 1000 format(/,'INITIALIZATION OF PHYSICS PACKAGE (S/R itf_phy_init)', &
             /,'====================================================')
 1002 format(/,'PHYSICS COMPATIBILITY LEVEL IS OK: (level=',i2,')')
 9000 format(/'==> STOP IN ITF_PHY_INIT: MAXBUS TOO SMALL IN BUSESD.CDK'/ &
              '==> REQUIRED: ',i10/)
 9001 format(/'==> STOP IN ITF_PHY_INIT: INCOMPATIBLE PHYSICS INTERFACE'/ &
              '    physics interface compatibility level= ',i2/&
              '    physics package compatibility level= ',i2/)
 9500 format(/,' PHYSICS NOT SUPPORTED FOR NOW IN THEORETICAL CASE')
 9600 format(/ 'Out3_satues_L reset to .false. as SATUCO eq false')
!     ---------------------------------------------------------------
!
      return
      end
