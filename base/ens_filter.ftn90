!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r ens_filter - Fourier filter
!
#include "model_macros_f.h"
      subroutine ens_filter (F_ugwdt1,F_vgwdt1,F_difut1,F_difvt1, F_ut1,F_vt1,F_tt1, DIST_DIM, Nk)
      implicit none
#include <arch_specific.hf>
!
      integer DIST_DIM, Nk
      real    F_ugwdt1(DIST_SHAPE,Nk), F_vgwdt1(DIST_SHAPE,Nk)
      real    F_difut1(DIST_SHAPE,Nk), F_difvt1(DIST_SHAPE,Nk)
      real    F_ut1(DIST_SHAPE,Nk), F_vt1(DIST_SHAPE,Nk), F_tt1(DIST_SHAPE,Nk)
!
!author 
!     Lubos Spacek - rpn - apr 2005
!
!revision
! v4_12 - Spacek L.         - staggered + gmm version
! v4.1.3 -N. Gagnon         - Change name of some parameters from NAMELIST
!
!object
!	
!arguments
!	none
!
!implicits
#include "gmm.hf"
#include "var_gmm.cdk"

#include "glb_ld.cdk"
#include "geomg.cdk"
#include "dcst.cdk"
#include "grd.cdk"

#include "ens_gmm_var.cdk"
#include "ens_param.cdk"
!
!variables
      integer ix,iy,iz,iz_local,kx,ky,kz, E_nk
      integer np, rank, ierr, keys(8), npartiel
      integer i, j, k, i0, j0, in, jn, nij, inn, trx
      real    pi, err, deltax, cpdi
      real*8  dpi, aaa2
!     Arrays
      real  , dimension(:,:,:), allocatable  :: dsp_local, fgem
      real  , dimension(:,:,:), allocatable  :: dsp_dif, dsp_gwd
      real  , dimension(:,:,:), allocatable  :: dvrg

      type(gmm_metadata) :: meta3d
      integer :: gmmstat

      E_nk = Nk
!
      dpi=4.d0*atan(1.0d0)
      cpdi=1./real(Dcst_cpd_8)
      aaa2= 1.d0/Dcst_rayt_8**2
      deltax=sqrt(((2.0*dpi/real(G_ni))*Dcst_rayt_8)* &
                     ((dpi/real(G_nj))*Dcst_rayt_8))
!
!     Get needed fields in memory
!
      gmmstat = gmm_get(gmmk_mcsph1_s ,mcsph1,meta3d)
      if (GMM_IS_ERROR(gmmstat))write(*,6000)'mcsph11'
!
!     Markov chain step and if Ens_skeb_conf=.false. return
!
      call ens_marfield_cg (mcsph1,E_nk)

      if (.not.Ens_skeb_conf) then
         return
      endif
!
      allocate( dsp_local(LDIST_SHAPE,E_nk))
      allocate( dsp_dif(LDIST_SHAPE,E_nk))
      allocate( dsp_gwd(LDIST_SHAPE,E_nk))
      allocate( dvrg(LDIST_SHAPE,E_nk))

      call rpn_comm_xch_halo (F_ut1,LDIST_DIM,l_niu,l_nj,E_nk, &
                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
      call rpn_comm_xch_halo (F_vt1,LDIST_DIM,l_ni,l_njv,E_nk, &
                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
      call rpn_comm_xch_halo (F_difut1,LDIST_DIM,l_niu,l_nj,E_nk, &
                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
      call rpn_comm_xch_halo (F_difvt1,LDIST_DIM,l_ni,l_njv,E_nk, &
                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
      call rpn_comm_xch_halo (F_ugwdt1,LDIST_DIM,l_ni,l_nj,E_nk, &
                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0) 
      call rpn_comm_xch_halo (F_vgwdt1,LDIST_DIM,l_ni,l_nj,E_nk, &
                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
 
!
!     Calculate kinetic energy of diffusion tendency
!     ===============================================

      i0 = 1
      in = G_ni
      j0 = 1
      jn = G_nj
      inn= 0
      if (G_lam) then
           inn=1
      endif
!
!     Diffusion backscatter
!
      if(Ens_stat)then
         call glbstat2 (F_ut1,'UT1','AT BEG', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
         call glbstat2 (F_vt1,'VT1','AT BEG', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
         call glbstat2 (F_difut1,'DUT1','AT BEG', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
         call glbstat2 (F_difvt1,'DVT1','AT BEG', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
         call glbstat2 (F_ugwdt1,'UGW1','AT BEG', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
         call glbstat2 (F_vgwdt1,'VGW1','AT BEG', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
      endif

      dsp_dif=0.0
      if(Ens_skeb_dif)then
        F_difut1=F_ut1*F_difut1 ; F_difvt1=F_vt1*F_difvt1
        call ens_uvduv (dsp_dif, F_difut1, F_difvt1, LDIST_DIM, E_nk )
      endif

      if(Ens_stat)then
         call glbstat2 (F_difut1,'DUT1','DIFF', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
         call glbstat2 (F_difvt1,'DVT1','DIFF', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
      endif
!
!     Gravity wave drag backscatter
!
      dsp_gwd=0.0
      if(Ens_skeb_gwd)then
        F_difut1=F_ut1*F_ugwdt1 ; F_difvt1=F_vt1*F_vgwdt1
        call ens_uvgwd (dsp_gwd, F_difut1, F_difvt1, LDIST_DIM, E_nk )
      endif
!
      if(Ens_stat)then
         call glbstat2 (F_difut1,'DUT1','GWD', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
         call glbstat2 (F_difvt1,'DVT1','GWD', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
      endif

      dsp_local=dsp_dif+dsp_gwd

!
!     Apply 2D Gaussian filter
!     ===================================================================
      if(Ens_stat)then
          call glbstat2 (dsp_dif,'DSP','DIF', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
          call glbstat2 (dsp_gwd,'DSP','GWD', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
          call glbstat2 (dsp_local,'DSP','TOT', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
      endif

      if(Grd_yinyang_L) then
         call ens_filter_ggauss(dble(Ens_skeb_bfc),dble(Ens_skeb_lam),dsp_local)
      else
         call ens_filter_gauss(dble(Ens_skeb_bfc),dble(Ens_skeb_lam),dsp_local)
      endif

      if(Ens_stat)then 
         call glbstat2 (dsp_local,'DSP','FLTTOT', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
      endif

      if(Ens_skeb_alpt/=0.0)then
         F_tt1(1:l_ni,1:l_nj,1:E_nk)=F_tt1(1:l_ni,1:l_nj,1:E_nk)+&
         Ens_skeb_alpt*cpdi* &
         dsp_local(1:l_ni,1:l_nj,:)*mcsph1(1:l_ni,1:l_nj,1:E_nk)
      endif
!
       dsp_local(1:l_ni,1:l_nj,:)=sqrt(dsp_local(1:l_ni,1:l_nj,:))* &
                                 mcsph1(1:l_ni,1:l_nj,1:E_nk)

      if(Ens_stat)then 
         call glbstat2 (dsp_local,'DSP','FLTTO2', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
      endif

      call rpn_comm_xch_halo (dsp_local,LDIST_DIM,l_ni,l_nj,E_nk, &
                      G_halox,G_haloy,G_periodx,G_periody,l_ni,0)

!      call rpn_comm_Barrier("grid", ierr)

!     Compute gradient of filtered field
!     ==================================

      i0 = 1
      in = l_niu
      j0 = 1
      jn = l_njv

      if ((G_lam).and.(l_west)) i0 = 2
      if (l_south) j0 = 2

      F_difut1(:,:,E_nk)=0.0;F_difvt1(:,:,E_nk)=0.0;
      do k=1,G_nk
         do j= j0, jn 
            do i= i0, l_niu
               F_difut1(i,j,k)= aaa2*(dsp_local(i,j,k)-dsp_local(i-1,j,k)) / geomg_hxu_8(i)
               F_difut1(i,j,k)=Ens_skeb_alph*deltax*F_difut1(i,j,k)
               F_vt1(i,j,k) = F_vt1(i,j,k)+F_difut1(i,j,k)
            enddo
         enddo
!
         do j= j0, l_njv !-pil_n
            do i= i0, in 
               F_difvt1(i,j,k)= aaa2*(dsp_local(i,j+1,k) - dsp_local(i,j,k))*geomg_invDY_8(j)
               F_difvt1(i,j,k)= -Ens_skeb_alph*deltax*F_difvt1(i,j,k)
               F_ut1(i,j,k) = F_ut1(i,j,k)+F_difvt1(i,j,k)
            enddo
         enddo
         if (.not.G_lam) then
            if (l_south) then
            do i = i0, in
               F_difut1(i,1,k)= 0.0
               F_difvt1(i,1,k)= 0.0
            end do
            endif

            if (l_north) then
            do i = i0, in
               F_difut1(i,l_nj,k)= 0.0
               F_difvt1(i,l_nj,k)= 0.0
            end do
            endif
         endif
      enddo

      if(Ens_stat)then
         call glbstat2 (F_ut1,'UT1','AT END', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
         call glbstat2 (F_vt1,'VT1','AT END', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
         call glbstat2 (F_difut1,'DUT1','AT END', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
         call glbstat2 (F_difvt1,'DVT1','AT END', &
           LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
      endif

      if(Ens_skeb_div)then
         call rpn_comm_xch_halo (F_difut1,LDIST_DIM,l_niu,l_nj,E_nk, &
                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
         call rpn_comm_xch_halo (F_difvt1,LDIST_DIM,l_ni,l_njv,E_nk, &
                   G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
!
        call caldiv_2 ( dvrg, F_difut1, F_difvt1, DIST_DIM, E_nk )
          if (G_lam) then
             if (l_west) then
                dvrg(1,j0:l_njv,:) = dvrg(2,j0:l_njv,:)
             endif
             if (l_east) then
                dvrg(l_ni,j0:l_njv,:) = dvrg(l_niu,j0:l_njv,:)
             endif
             if (l_south) then
                dvrg(:,1,:) = dvrg(:,2,:)
             endif
             if (l_north) then
                dvrg(:,l_nj,:) = dvrg(:,l_njv,:)
             endif
          endif
        if(Ens_stat)then
           call glbstat2 (dvrg,'DVRG','FRCING', &
             LDIST_DIM,1,E_nk,1,G_ni,1,G_nj,1,E_nk)
        endif
      endif

      deallocate(dsp_dif,dsp_gwd,dsp_local)
      deallocate(dvrg)

 6000 format('ens_filter at gmm_get(',A,')')
      end subroutine ens_filter
