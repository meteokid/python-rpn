!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r itf_phy_inincr - read/interpolate physics surface forcing targets
!
#include "model_macros_f.h"
Integer function itf_phy_inincr( vd,opt )

    Use phy_input_types
    implicit none
#include <arch_specific.hf>

    Type(variable),  Pointer  :: vd
    Type(input_options)       :: opt

!author   
!     Bernard Dugas - july 97
!
!revision
! v2_21 - Bernard Dugas     - Adaption to GEM DM v2.2 and to physics v3.67:
!                             1) change all includes and variables to DM specs;
!                             2) each PE does the interpolations for its own area;
!                             3) INCRTS is only used for water points (TWATER);
!                             4) INCRTG is only used for glacier points (TGLACIER(2));
!                             5) INCRTP is only used for deep soil points when the
!                                force-restore surface scheme is selected (TSOIL(2));
!                             6) INCRICD is added for sea ice depht increments (ICEDP);
!                             7) INCRGL is now used with GLSEAS0, as GLSEA can be
!                                modified to account for lake ice evolution;
!                             8) INCRAL is no longer defined, since CALCALB
!                                is used instead (called by CLIMPHS2).
! v2_31 - Desgagne M.       - remove stkmemw
! v2_31 - Bernard Dugas     - adapt to new climatological file descriptors
! v2_32 - Bernard Dugas     - correct exit condition codes
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_01 - Bernard Dugas     - add call to INTOZON
! v3_02 - Lubos Spacek      - remplacer l_ni et l_nj par p_ni et p_nj
! v3_02 - Bernard Dugas     - remettre le code de controle d'interpolation O3
!                           - toujours initialiser incrtp (independamment de soli_L)
! v3_10 - Lee V.            - RPN_bcastc for bcast on MPI_CHARACTER
! v3_11 - Bernard Dugas     - use glacier AND (maybe) sea ice SNODP to define INCRNE
!                           - Account for P_pbl_iceme_L = .true.
! v3_22 - Bernard Dugas     - add check for Done_inincr and correct xncibl(5) = 12
! v3_22 - Katja Winger      - make sure that BC are read twice in first month
!                             (at Lctl_step=2 and in the middle of the month)
! v3_30 - Dugas B.          - new itf_phy interface
! v3_32 - Winger K.         - allow minutely SST and sea ice BC's
!                             IP3:YYYY, IP2:MM, IP1:DDhhmm
!                           - assume monthly values at middle of month instead of 15th 12h
! v3_32 - Winger K.         - Change 'xnflds' -> 'Cfld_nbr' and 'clim_S' -> 'Cfld_list_S'.
!                             Put 'Cfld_nbr', 'Cfld_list_S', and 'Cfld_date' (coded 'Done_Inincr')
!                             in 'cfld.cdk' to write/read them in/from restart files.
! v3_32 - Dugas B.          - add support for multi-level forcing fields
!                           - IP1 no longer used for DDhhmm info. DATEO used instead
! v4_1x - Dugas B.          - adapt to a physics-neutral interface using the vd argument
!                           - move call to intozon to physics itself
! v4_40 - Dugas B.          - small adjustments to the last (major) update 
!                             
!
!object
!
!       Reads and interpolates the climatological target fields that
!       are used to define the forcing increments found in the permanent
!       physics bus. The calling routine (presumable phy_inincr) should
!       define these increments. The vd structure contains all of the
!       information as to what and where to look for, and how to
!       perform the interpolations. It is also used to return
!       all results, namely all of the variables that were
!       read and their corresponding time of validity.

!       When first called the routine scans the input files
!       to determine what variables/times are available. This
!       is used in subsequent calls.

! ***   It is important to note that the physics package is
! ***   supposed to have been initialized by a previous call
! ***   to phy_init.
!
!       Climatology and analysed climatology file:
!       IP2 is always supposed to contain the month MM
!
!       Analysed climatology file:
!       IP3 is always supposed to contain the year YYYY
!       If there is more than 1 date per month day, hour and minute 
!       are to be found is the decoded DATEO descriptor
!       
!
!implicits
#include "lun.cdk"
#include "mem.cdk"
#include "path.cdk"
#include "ptopo.cdk"
#include "lctl.cdk"
#include "step.cdk"
#include "rstr.cdk"
#include "modconst.cdk"
#include "cstv.cdk"
#include "glb_ld.cdk"
#include "cfld.cdk"

!modules
    Type(variable),  Pointer  :: temp

    INTEGER      newdate,fnom,fclos,wkoffit,fstopc,ip1_all
    EXTERNAL     newdate,fnom,fclos,wkoffit,fstopc,ip1_all
    INTEGER      fstouv,fstinf,fstsui,fstlir,fstlirx,fstprm,fstfrm,fstnbr
    EXTERNAL     fstouv,fstinf,fstsui,fstlir,fstlirx,fstprm,fstfrm,fstnbr
    INTEGER      ezgdef_fmem,ezdefset,ezsetopt,ezsint
    EXTERNAL     ezgdef_fmem,ezdefset,ezsetopt,ezsint
    EXTERNAL     Get_LeapYear_Status

    INTEGER      dgid,sgid,dstf_gid
    REAL         xfi(G_ni+1),yfi(G_nj), Aucun(1)
    REAL(8)      days_8
    character(16) xndate

    REAL(8)      scal_8
    INTEGER      xnf, Nbr2D
    CHARACTER(4),allocatable,dimension(:) :: Cfld_list_S
    CHARACTER,   allocatable,dimension(:) :: gtyp_S,gtypz_S
    INTEGER,     allocatable,dimension(:) :: xnig1, xnig2, xnig3  
    INTEGER,     allocatable,dimension(:) :: xnzig1,xnzig2,xnzig3
    INTEGER,     allocatable,dimension(:) :: xnig4, xnzig4,xPos3D
    INTEGER,     allocatable,dimension(:) :: xnilu, xnjlu,xnkerr
    INTEGER,     allocatable,dimension(:) :: ip2,ip3,datev

    real,        allocatable,dimension(:,:) :: xrclim
    real,        allocatable,dimension(:,:) :: xrtic,xrtac,localf
    INTEGER(8),  allocatable,dimension(:,:), save :: dates
    INTEGER(8),  allocatable,dimension(:) :: DoneInincr, DoInincr
    INTEGER,     allocatable,dimension(:),save :: nrec, xnzm, xnmxfld
    LOGICAL,     allocatable,dimension(:),save :: acli_L, monthly_L

    LOGICAL,     save :: DoingInitialCall_L=.true.
    LOGICAL,     save :: NoLeapYears_L=.false.

    INTEGER      xniz,xnjz, xnmxfld_max,xnzm_max, maxnk
    INTEGER      Lun_clim,Lun_acli,Lun_activ,ppjour,goff
    INTEGER      xnerr,xncle,xnhold, xni,xnj,xnk,xnim,xnjm
    LOGICAL      open_acli_L, open_clim_L
    CHARACTER    typvar_S,Vide_S,hold_S*12
    CHARACTER(256) clima_S,anclima_S

    INTEGER(8)   CurrentDate
    INTEGER      curyy,curmo,curdd,curhh,curmm,curss,cursign
    INTEGER      handle, iip2,iip3,nrec_clim,nrec_acli,nrec_max
    INTEGER      year, month, day, zulu, i,j,k,n,x, NbrField
    INTEGER      dateo, date1,time1, mo1, nbr, p_ni,p_nj
    INTEGER      momid_day(12), momid_day_leap(12), rx

!*  Variables used to manipulate the INTEGER(8) dates
    INTEGER(8),  PARAMETER :: factor10=10000000000_8, &
                              factor8 =100000000_8,   &
                              factor6 =1000000_8,     &
                              factor4 =10000_8

    DATA         momid_day      / 1612,1500,1612,1600,1612,1600,&
                                  1612,1612,1600,1612,1600,1612 /
    DATA         momid_day_leap / 1612,1512,1612,1600,1612,1600,&
                                  1612,1612,1600,1612,1600,1612 /

!***********************************************************************
!***********************************************************************

    itf_phy_inincr = 0

!*  Don't do anything at timestep 0
    if ( Lctl_step  <=  0 ) return

    goff=0 ; If(G_lam) goff=2

!*     -------------------------------------------------
!*  1. Get the current date and time, initialize, etc
!*     -------------------------------------------------


    days_8 = ( Lctl_step * (Cstv_dt_8 / 3600._8 ) ) / 24._8
    call incdatsd( xndate,Mod_runstrt_S,days_8 )

!*  internal dates are saved in a YYYY/MO/DD/HH/MM/SS format
    call prsdate( curyy,curmo,curdd,curhh,curmm,curss,cursign, xndate )
    CurrentDate = curyy*factor10 + curmo*factor8 &
                + curdd*factor6  + curhh*factor4 &
                + curmm*100      + curss

    temp => vd ! Save start of vd linked list

 10 if ( .Not. Associated( Cfld_list ) ) then
       
!*     Scan vd to determine Cfld_nbr and allocate
!*     Cfld_date, Cfld_levs and Cfld_list

       Cfld_nbr = 0 ; do
          Cfld_nbr = Cfld_nbr+1
          If ( .Not. Associated( vd%next_value ) ) Exit
          vd => vd%next_value
       end do

       if ( Cfld_nbr <= 0 ) return

       Allocate( Cfld_date(Cfld_nbr), Cfld_levs(Cfld_nbr), Cfld_list(Cfld_nbr), stat=xnerr )
       if ( xnerr > 0 ) then ; itf_phy_inincr = -1 ; return ; end if

       Cfld_date = 0 ; Cfld_levs = -1

!*     define Cfld_list and Cfld_date from values in the vd list

       vd => temp

       i = 0 ; do
          i = i+1
          Cfld_date(i) = vd%datev
          Cfld_levs(i) = vd%p_nu
          read(vd%nomvar,'(A4)') Cfld_list(i)
          If ( .Not. Associated( vd%next_value ) ) Exit
          vd => vd%next_value
       end do

    else

!*     Check that the vd linked list and the Cfld variables agree
       
       i = 0 ; Check_List_Coherence : do

          If (i+1 <= Cfld_nbr) then

             read(vd%nomvar,'(A4)') xnhold
             If (Cfld_levs(i+1) /= vd%p_nu  .or. &
                 Cfld_list(i+1) /= xnhold) exit Check_List_Coherence
             i = i+1
             vd%datev = Cfld_date(i)

             If ( .Not. Associated( vd%next_value ) ) Exit Check_List_Coherence
             vd => vd%next_value

          else

!*           They do not. There are more entries in the vd list
!*           than in the Cfld ones. The dates of the common enties
!*           have been saved in vd and we will now re-create the
!*           Cfld data as well as the inincr control data
             Deallocate( Cfld_date, Cfld_levs, Cfld_list )
             if (.not.DoingInitialCall_L) deallocate( acli_L, nrec, xnzm , xnmxfld, monthly_L )

             DoingInitialCall_L = .true. ; vd => temp

             goto 10

          endif

       end do Check_List_Coherence

       if (Cfld_nbr < i) then

!*        Again, they do not and we need to re-create the
!*        Cfld data as well as the inincr control data
          Deallocate( Cfld_date, Cfld_levs, Cfld_list )
          if (.not.DoingInitialCall_L) deallocate( acli_L, nrec, xnzm , xnmxfld, monthly_L )

          DoingInitialCall_L = .true. ; vd => temp

          goto 10

       endif

    end if

    maxnk = maxval( Cfld_levs(1:Cfld_nbr) )+1

    allocate( gtyp_S(Cfld_nbr),gtypz_S(Cfld_nbr),                  &
              xnzig1(Cfld_nbr), xnzig2(Cfld_nbr),xnzig3(Cfld_nbr), &
              xnig1 (Cfld_nbr),  xnig2(Cfld_nbr), xnig3(Cfld_nbr), &
              xnig4 (Cfld_nbr), xnzig4(Cfld_nbr),xPos3D(Cfld_nbr), &
              xnilu (Cfld_nbr),  xnjlu(Cfld_nbr),   xnkerr(maxnk), &
              ip2   (Cfld_nbr),    ip3(Cfld_nbr), datev(Cfld_nbr), &
              DoneInincr(Cfld_nbr), DoInincr(Cfld_nbr),            &
              Cfld_list_s(Cfld_nbr), stat=xnerr )

    if ( xnerr > 0 ) then ; itf_phy_inincr = -2 ; return ; end if

    do i=1,Cfld_nbr
       write(Cfld_list_s(i),'(A4)') Cfld_list(i)
    enddo

!*  At very first time step initialize DoneInincr to start of run
    if ( Lctl_step  ==  1 ) then
       call prsdate( curyy,curmo,curdd,curhh,curmm,curss,cursign, Mod_runstrt_S )
       DoneInincr = curyy*factor10 + curmo*factor8 &
                  + curdd*factor6  + curhh*factor4 &
                  + curmm*100      + curss
!*  At all other time steps set DoneInincr to decoded value of Cfld_date
    else
       do x=1,Cfld_nbr
!*        Decode date from 'Cfld_date' in 'DoneInincr'
          if ( Cfld_date(x) > 0 ) then
             xnerr = newdate( Cfld_date(x), date1, time1, -3 )
             if ( xnerr > 0 ) then ; itf_phy_inincr = -3 ; return ; end if
             DoneInincr(x) = date1*factor6 + time1/100
          else
             DoneInincr(x) = -1
          end if
       end do
    end if

    if(DoingInitialCall_L) then

!*     initialize permanent (saved) variables

       DoingInitialCall_L = .false.

       allocate( acli_L   (Cfld_nbr) , nrec   (Cfld_nbr),        &
                 xnzm     (Cfld_nbr) , xnmxfld(Cfld_nbr),        &
                 monthly_L(Cfld_nbr) , stat=xnerr )

       if ( xnerr > 0 ) then ; itf_phy_inincr = -4 ; return ; end if

       xnzm = 0 ; xnmxfld = 0 ; acli_L = .false. ; nrec = 0

       call Get_LeapYear_Status( NoLeapYears_L )

    endif


!*     -------------------------------------------------
!*  2. If 'Rstri_sdon=1' processor 0 reads all dates 
!*     in BC files imclima and imanclima
!*     -------------------------------------------------


    RSTRI_SDON_1 : if ( Rstri_sdon == 1 .or. maxval( xnmxfld(:) ) == 0 ) then

       PTOPO_MYPROC_0_1 : if ( Ptopo_myproc == 0 ) then

          if (Lun_out > 0) write( Lun_out,'(/A/)') &
          ' ITF_PHY_ININCR: checking content of forcing files'// &
          ' ============================'

          xnim    = 0
          xnjm    = 0

          Lun_clim = 0
          Lun_acli = 0

          nrec_clim = 0
          nrec_acli = 0

!*        Open climatological analysis file
          anclima_S =  trim(Path_input_S)//'/ANCLIMA'

          xnerr = wkoffit( anclima_S )

          if ( xnerr == 1 .or. xnerr == 33 ) then

             xnerr = fnom( Lun_acli, anclima_S , 'STD+RND+OLD+R/O', 0 )
             xnerr = fstouv( Lun_acli, 'RND' )

             if ( xnerr >= 0 ) then

                if (Lun_out > 0) write( Lun_out,* ) &
                'Opening file: ', trim( anclima_S )

!*              Get total number of records in file
                nrec_acli = fstnbr (Lun_acli)

             end if
          end if


!*        Open climatology file
          clima_S = trim(Path_input_S)//'/CLIMATO'

          xnerr = wkoffit( clima_S )

          if ( xnerr == 1 .or. xnerr == 33 ) then

             xnerr = fstopc( 'MSGLVL','INFORM', 0 )
             xnerr = fstopc( 'TOLRNC','INFORM', 0 )
             xnerr = fnom( Lun_clim, clima_S , 'STD+RND+OLD+R/O', 0 )
             xnerr = fstouv( Lun_clim, 'RND' )

             if ( xnerr >= 0 ) then

                if (Lun_out > 0) write( Lun_out,* ) &
                'Opening file: ', trim( clima_S )

!*              Get total number of records in file
                nrec_clim = fstnbr (Lun_clim)

             end if
          end if

!*        Get maximum number of records/date in files for allocation
          nrec_max = max( nrec_acli,nrec_clim )

       end if PTOPO_MYPROC_0_1

       call RPN_COMM_bcast( nrec_max, 1,"MPI_INTEGER",0,"grid", xnerr )
       if ( nrec_max == 0 ) then ; itf_phy_inincr = -5 ; return ; end if

!*     All processors allocate 'dates'
       allocate( dates(Cfld_nbr,nrec_max), stat=xnerr )
       if ( xnerr > 0 ) then ; itf_phy_inincr = -6 ; return ; end if

!*     Processor 0 reads all dates
       PTOPO_MYPROC_0_2 : if ( Ptopo_myproc == 0 ) then

!*        Read dates of records in file imanclimat
          if ( nrec_acli > 0 ) then

             do i=1,Cfld_nbr

                nrec(i) = 0

                if (Cfld_levs(i) == 1) then
                   handle = fstinf( Lun_acli,xni,xnj,xnk,              &
                                  -1,' ',-1,-1,-1,' ',Cfld_list_S(i) )
                else
                   handle = fstinf( Lun_acli,xni,xnj,xnk,              &
                                  -1,' ',ip1_all(1.0,3),-1,-1,' ',     &
                                  Cfld_list_S(i) )
                endif

                do while ( handle >= 0 )

                   xnim  = max( xnim,xni )
                   xnjm  = max( xnjm,xnj )

                   xnerr = fstprm( handle,dateo,xnhold,xnhold,         &
                                   xnhold,xnhold,xnhold,               &
                                   xnhold,xnhold,xnhold,iip2,iip3,     &
                                   hold_S,hold_S,hold_S,               &
                                   hold_S,xnhold,xnhold,xnhold,xnhold, &
                                   xnhold,xnhold,xnhold,xnhold,        &
                                   xnhold,xnhold,xnhold )

                   nrec(i) = nrec(i) + 1

                   year = iip3 ; month = iip2
                   day  = 0    ; zulu  = 0

                   xnerr = newdate( dateo,date1,time1,-3 )

                   if (     date1/10000     == year  .and. &
                       mod( date1/100,100 ) == month) then
                      day  = mod( date1,100 )
                      zulu = time1/factor6
                   endif

!*                 Check if file contains monthly data (where
!*                 each monthly value is ordered consecutively)
                   if ( nrec(i) == 1 ) then
                      mo1 = month
                      monthly_L(i) = .true.
                   elseif ( monthly_L(i) ) then
                      if ( mod(mo1,12)+1 /= month ) monthly_L(i) = .false.
                      mo1 = month
                   end if

                   dates(i,nrec(i)) = iip3*factor10 + iip2*factor8    &
                                    + day *factor6  + zulu*factor4

                   handle = fstsui( Lun_acli, xni,xnj,xnk )

                enddo

                if (nrec(i) > 0) acli_L(i) = .true.

                xnmxfld(i) = xnim*xnjm
                xnzm(i)    = max( xnim,xnjm )

!*              For monthly data set date to the middle of the month
                if ( monthly_L(i) ) then
                   do n=1,nrec(i)
                      year  = int(  dates(i,n) / factor10 )
                      month = int( (dates(i,n) - year*factor10) / factor8 )

!*                    If leap year
                      if ( .not. NoLeapYears_L     .and.              &
                          ( mod( year,4 )   == 0   .and.              &
                            mod( year,100 ) /= 0 ) .or.               &
                            mod( year,400 ) == 0 ) then
                         dates(i,n) = year*factor10 + month*factor8   &
                                    + momid_day_leap(month)*factor4
!*                    If non-leap year
                      else
                         dates(i,n) = year*factor10 + month*factor8   &
                                    +      momid_day(month)*factor4
                      end if

                   end do
                end if

             end do 

             xnerr = fstfrm( Lun_acli )
             xnerr = fclos ( Lun_acli )

          end if

!*        Read dates of records in file imclimat
          if ( nrec_clim > 0 ) then

             do i=1,Cfld_nbr

!*              Only try to read variable if not already found in imanclimat
!*              Don't need to read dates since it is a climatological file.
                if ( .not. acli_L(i) ) then

                   if (Cfld_levs(i) == 1) then
                      handle = fstinf( Lun_clim,xni,xnj,xnk, -1,' ',  &
                                        -1,-1,-1,' ',Cfld_list_S(i) )
                   else
                      handle = fstinf( Lun_clim,xni,xnj,xnk, -1,' ',  &
                            ip1_all(1.0,3),-1,-1,' ',Cfld_list_S(i) )
                   endif

                   do while ( handle >= 0 )

                      xnim  = max( xnim,xni )
                      xnjm  = max( xnjm,xnj )

                      handle = fstsui( Lun_clim, xni,xnj,xnk )

                   enddo

                   xnmxfld(i) = xnim*xnjm
                   xnzm(i)    = max( xnim,xnjm )

                end if
             end do

             xnerr = fstfrm( Lun_clim )
             xnerr = fclos ( Lun_clim )

          end if   

       end if PTOPO_MYPROC_0_2


!*     Broadcast a few variables
       call RPN_COMM_bcast( nrec    ,Cfld_nbr           ,"MPI_INTEGER",0,"grid",xnerr )
       call RPN_COMM_bcast( xnmxfld ,Cfld_nbr           ,"MPI_INTEGER",0,"grid",xnerr )
       call RPN_COMM_bcast( xnzm    ,Cfld_nbr           ,"MPI_INTEGER",0,"grid",xnerr )
       call RPN_COMM_bcast( dates   ,Cfld_nbr*nrec_max*2,"MPI_INTEGER",0,"grid",xnerr )
       call RPN_COMM_bcast( acli_L  ,Cfld_nbr           ,"MPI_LOGICAL",0,"grid",xnerr )
       call RPN_COMM_bcast( monthly_L,Cfld_nbr          ,"MPI_LOGICAL",0,"grid",xnerr )

    end if RSTRI_SDON_1


!*     -------------------------------------------------
!*  3. Check for each variable if a new date needs to be read
!*     -------------------------------------------------
!*
!*     DoneInincr: Last date read
!*     DoInincr  : Next date to be read
!*     in a YYYY/MO/DD/HH/MM/SS format
!*


    open_acli_L = .false.
    open_clim_L = .false.
    DoInincr    = DoneInincr

!*  Loop over all variables
    LOOP_OVER_ALL_VARIABLES : do i=1,Cfld_nbr

!*     If next date got already read do nothing
       if ( DoInincr(i) >= CurrentDate     &
      .and. Lctl_step   /= 1 ) cycle

!*     Find next date in analysed climatology imanclimat
       if ( acli_L(i) ) then

!*        Find the next date to read
          do n=1,nrec(i)
             if ( DoInincr(i) < dates(i,n) ) then
                DoInincr(i) = dates(i,n)
                exit
             end if
          end do

!*        Error return if new date was not found
          if ( DoInincr(i) < CurrentDate ) then
             if ( Lun_out >  0 ) write( Lun_out,1009 ) CurrentDate
             itf_phy_inincr = -7 ; return
          end if

!*        Set DATEV,IP2-3 to date to be read
          ip3(i) =   DoInincr(i) /        factor10
          ip2(i) = ( DoInincr(i) - ip3(i)*factor10 ) / factor8

          if ( monthly_L(i) ) then
             datev(i) = -1
          else
             date1 =      DoInincr(i)/factor6
             time1 = mod( DoInincr(i),factor6 )*100
             xnerr = newdate( datev(i),date1,time1,+3 )
          endif

!*        Set flag that imanclimat needs to be opened
          open_acli_L = .true.

!*     Set next date to be read in climatology imclimat
       else

          year  =   DoInincr(i) / factor10
          month = ( DoInincr(i) - year*factor10 ) / factor8

!*        Set day and time
!*        If leap year
 50       if ( .not. NoLeapYears_L     .and.              &
              ( mod( year,4 )   == 0   .and.              &
                mod( year,100 ) /= 0 ) .or.               &
                mod( year,400 ) == 0 ) then
             DoInincr(i) = year*factor10 + month*factor8  &
                         + momid_day_leap(month)*factor4
!*        If non-leap year
          else
             DoInincr(i) = year*factor10 + month*factor8  &
                              + momid_day(month)*factor4
          end if

!*        Increment DoInincr if < CurrentDate
          if ( DoInincr(i) < CurrentDate ) then
             month = month + 1
             if ( month  ==  13 ) then
                month = 01
                year = year + 1
             end if
             goto 0050
          end if

!*        Set DATEV,IP2-3 to date to be read
          datev(i) = -1
          ip3(i)   = -1
          ip2(i)   = month

!*        Set flag that imclimat needs to be opened
          open_clim_L = .true.

       end if

    end do LOOP_OVER_ALL_VARIABLES

!c  if ( Rstri_sdon ==  15 ) then
!c  if ( Rstri_sdon == 408 ) then
!c  if ( Rstri_sdon == 408 ) then
!c     return  
!c  end if


!*  Return if no new fields need to be read
    if ( .not. open_acli_L .and. .not. open_clim_L ) return


!*     -------------------------------------------------
!*  4. Processor 0 opens imanclimat and/or imclimat
!*     -------------------------------------------------


    PTOPO_MYPROC_0_3 : if ( Ptopo_myproc  ==  0 ) then

       if (Lun_out > 0) write( Lun_out,'(/A/)')    &
       ' ITF_PHY_ININCR: reading new physics forcing increments'// &
       ' ======================='

!*     Open analysied climatology imanclima if needed
       if ( open_acli_L ) then

          Lun_acli = 0

          anclima_S = trim(Path_input_S)//'/ANCLIMA'

          xnerr = wkoffit( anclima_S )

          if ( xnerr == 1 .or. xnerr == 33 ) then

             xnerr = fnom( Lun_acli, anclima_S , 'STD+RND+OLD+R/O', 0 )
             xnerr = fstouv( Lun_acli, 'RND' )

             if ( xnerr >= 0 ) then
                if (Lun_out > 0) write( Lun_out,* )    &
                'Opening file: ', trim( anclima_S )
             else
                if (Lun_out > 0) write( Lun_out,1002 )
                Lun_acli = 0
             end if

          else
             if (Lun_out > 0) write( Lun_out,1002 )
             Lun_acli = 0
          end if

       end if

!*     Open climatology imclima if needed
       if ( open_clim_L ) then

          Lun_clim = 0

          clima_S = trim(Path_input_S)//'/CLIMATO'

          xnerr = wkoffit( clima_S )

          if ( xnerr == 1 .or. xnerr == 33 ) then

             xnerr = fnom( Lun_clim, clima_S , 'STD+RND+OLD+R/O', 0 )
             xnerr = fstouv( Lun_clim, 'RND' )

             if ( xnerr >= 0 ) then
                if (Lun_out > 0) write( Lun_out,* )    &
                'Opening file: ', trim( clima_S )
             else
                if (Lun_out > 0) write( Lun_out,1001 ) trim( clima_S )
                Lun_clim = 0
             end if

          else
             if (Lun_out > 0) write( Lun_out,1001 ) trim( clima_S )
             Lun_clim = 0
          end if

       end if

    end if PTOPO_MYPROC_0_3

!*  Broadcast a few variables
    call RPN_COMM_bcast( Lun_acli    ,1,"MPI_INTEGER",0,"grid",xnerr )
    call RPN_COMM_bcast( Lun_clim    ,1,"MPI_INTEGER",0,"grid",xnerr )

!*  Stop run if one of the files could not be opened
    if (( open_acli_L .and. Lun_acli == 0 ) .or.  &
        ( open_clim_L .and. Lun_clim == 0 )) then
       itf_phy_inincr = -8 ; return
    end if


!*     -------------------------------------------------
!*  5. Read fields for new dates
!*     -------------------------------------------------


!*  Every one allocates the Cfld_nbr 2D climatology fields
    xnzm_max    = maxval( xnzm(1:Cfld_nbr) )
    xnmxfld_max = maxval( xnmxfld(1:Cfld_nbr) )

    allocate ( xrtic(xnzm_max,Cfld_nbr), xrtac(xnzm_max,Cfld_nbr), stat=xnerr )
    if ( xnerr > 0 ) then ; itf_phy_inincr = -9 ; return ; end if

    Nbr2D = 0 ; NbrField =0 ; xPos3D = 0
    do i=1,Cfld_nbr
       if ( DoneInincr(i) >= CurrentDate .and. Lctl_step /= 1 ) cycle
       xPos3D(i) = Nbr2D+1 ! this means that the variable will be processed
       Nbr2D = Nbr2D+Cfld_levs(i) ! number of records that need to be read
       NbrField = NbrField+1
    end do

    if ( Nbr2D > 0 ) allocate ( xrclim(xnmxfld_max,Nbr2D), stat=xnerr )
    if ( xnerr > 0 ) then ; itf_phy_inincr = -10 ; return ; end if

!*  Processor 0 reads fields for new date
    PTOPO_MYPROC_0_4 : if ( Ptopo_myproc  ==  0 ) then

      xnerr = fstopc( 'MSGLVL','INFORM', 0 )
      xnerr = fstopc( 'TOLRNC','INFORM', 0 )

!*     Loop over all variables
       do i=1,Cfld_nbr

!*        Only read new date if needed
          if ( xPos3D(i) < 1 ) cycle

          xncle = -1

!*        Read fields from analysed climatology imanclimat
          if ( acli_L(i) ) then

             if (Cfld_levs(i) == 1) then
                xncle = fstlir( xrclim(1,xPos3D(i)), Lun_acli,   &
                                xni,xnj,xnk,  datev(i),' ',      &
                                -1,ip2(i),ip3(i),'A',            &
                                Cfld_list_S(i) )
             else
                xncle = fstlir( xrclim(1,xPos3D(i)), Lun_acli,   &
                                xni,xnj,xnk,  datev(i),' ',      &
                                ip1_all(1.0,3),ip2(i),ip3(i),    &
                                'A',Cfld_list_S(i) )
             endif

             if ( xncle < 0 ) then
                if (Lun_out > 0) write( Lun_out,1005 ) Cfld_list_S(i),1
                goto 40
             endif

             do k=2,Cfld_levs(i)
                xncle = fstlirx( xrclim(1,xPos3D(i)+k-1), xncle, &
                             Lun_acli,xni,xnj,xnk,  datev(i),' ',&
                             ip1_all(float(k),3),ip2(i),ip3(i),  &
                                'A',Cfld_list_S(i) )

                if ( xncle < 0 ) then
                   write( Lun_out,1005 ) Cfld_list_S(i),k
                   goto 40
                endif

             enddo

!*        Read fields from climatology imclimat
          else

             if (Cfld_levs(i) == 1) then
                xncle = fstlir( xrclim(1,xPos3D(i)), Lun_clim,   &
                                xni,xnj,xnk,  -1,' ',-1,ip2(i),  &
                                -1,'C',Cfld_list_S(i) )
             else
                xncle = fstlir( xrclim(1,xPos3D(i)), Lun_clim,   &
                                xni,xnj,xnk,  -1,' ',            &
                                ip1_all(1.0,3),ip2(i),-1,        &
                                'C',Cfld_list_S(i) )
             endif

             if ( xncle <  0 ) then
                write( Lun_out,1005 ) Cfld_list_S(i),1
                goto 40
             endif

             do k=2,Cfld_levs(i)
                xncle = fstlirx( xrclim(1,xPos3D(i)+k-1), xncle, &
                                 Lun_clim,xni,xnj,xnk,  -1,' ',  &
                                 ip1_all(float(k),3),ip2(i),     &
                                 -1,'C',Cfld_list_S(i) )

                if ( xncle < 0 ) then
                   write( Lun_out,1005 ) Cfld_list_S(i),k
                   goto 40
                endif

             enddo

          end if


!*        Save the grid description parameters
          xnerr = fstprm( xncle, xnhold,xnhold,xnhold,           &
                          xnilu(i),xnjlu(i),xnk,                 &
                          xnhold,xnhold,xnhold,xnhold,xnhold,    &
                          typvar_S,Cfld_list_S(i),hold_S,        &
                          gtyp_S(i),xnig1(i),xnig2(i),           &
                                    xnig3(i),xnig4(i),           &
                          xnhold,xnhold,xnhold,xnhold,           &
                          xnhold,xnhold,xnhold )

!*        Retreive necessary Z-grid descriptors
          if (gtyp_S(i) == 'Z') then

             if ( acli_L(i) ) then
                Lun_activ = Lun_acli
             else
                Lun_activ = Lun_clim
             endif

             xncle = fstlir( xrtic(1,i), Lun_activ,              &
                             xniz,xnjz,xnhold, -1,' ',           &
                             xnig1(i),xnig2(i),xnig3(i),         &
                             typvar_S,'>>')

             if ( xncle < 0 .or.                                 &
                  xniz   /=  xnilu(i) ) then
                write( Lun_out,1006 ) Lun_activ,xnig1(i),xnig2(i)
                xncle = -1
                goto 40
             endif

             xncle = fstlir( xrtac(1,i), Lun_activ,              &
                             xniz,xnjz,xnhold, -1,' ',           &
                             xnig1(i),xnig2(i),xnig3(i),         &
                             typvar_S,'^^')

             if ( xncle <  0                                     &
            .or.  xnjz  /= xnjlu(i) ) then
                write( Lun_out,1007 ) Lun_activ,xnig1(i),xnig2(i)
                xncle = -1
                goto 40
             endif

             xnerr = fstprm( xncle, xnhold,xnhold,xnhold,        &
                             xnhold,xnhold,xnhold,               &
                             xnhold,xnhold,xnhold,xnhold,xnhold, &
                             hold_S,hold_S,hold_S,               &
                             gtypz_S(i),xnzig1(i),xnzig2(i),     &
                                        xnzig3(i),xnzig4(i),     &
                             xnhold,xnhold,xnhold,xnhold,        &
                             xnhold,xnhold,xnhold )

!*        end retreive necessary Z-grid descriptors

          else if (gtyp_S(i) == 'Y' .or. gtyp_S(i) == '#') then

             write( Lun_out,1008 ) gtyp_S(i)
             xncle = -1
             goto 40

          endif

!*     end loop over all variables
       end do

       xnerr = fstopc( 'MSGLVL','SYSTEM', 0 )
       xnerr = fstopc( 'TOLRNC','SYSTEM', 0 )

       if ( open_acli_L ) then
          xnerr = fstfrm( Lun_acli )
          xnerr = fclos ( Lun_acli )
       end if
       if ( open_clim_L ) then
          xnerr = fstfrm( Lun_clim )
          xnerr = fclos ( Lun_clim )
       end if

    end if PTOPO_MYPROC_0_4


!*  Broadcast a few variables
 40 call RPN_COMM_bcast (xncle  ,1           ,"MPI_INTEGER"  ,0,"grid",xnerr)
    if ( xncle < 0 ) then ; itf_phy_inincr = -11 ; return ; end if

    call RPN_COMM_bcast (xrclim ,Nbr2D*xnmxfld_max,"MPI_REAL",0,"grid",xnerr)
    call RPN_COMM_bcast (xrtic  ,Cfld_nbr*xnzm_max,"MPI_REAL",0,"grid",xnerr)
    call RPN_COMM_bcast (xrtac  ,Cfld_nbr*xnzm_max,"MPI_REAL",0,"grid",xnerr)
    call RPN_COMM_bcast (xnilu  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
    call RPN_COMM_bcast (xnjlu  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
    call RPN_COMM_bcast (xnig1  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
    call RPN_COMM_bcast (xnig2  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
    call RPN_COMM_bcast (xnig3  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
    call RPN_COMM_bcast (xnig4  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
    call RPN_COMM_bcastc(gtyp_S ,Cfld_nbr    ,"MPI_CHARACTER",0,"grid",xnerr)
    call RPN_COMM_bcast (xnzig1 ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
    call RPN_COMM_bcast (xnzig2 ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
    call RPN_COMM_bcast (xnzig3 ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
    call RPN_COMM_bcast (xnzig4 ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
    call RPN_COMM_bcastc(gtypz_S,Cfld_nbr    ,"MPI_CHARACTER",0,"grid",xnerr)


!*     -------------------------------------
!*  6. Interpolate the fields that were read
!*     -------------------------------------


!   Define the (local physics) destination grid
    call itf_phy_gdef( dgid, dstf_gid, xfi, yfi )

    read (Lctl_rxstat_S(5:),*) rx
    allocate( localf(l_ni,l_nj) )

!*  Loop over all variables
    do x=1,Cfld_nbr

          
!*     Only update increment if new data was read
       if ( xPos3D(x) < 1 ) cycle

       vd => temp
       SCAN_VD_AND_INTERPOLATE : do

          if ( vd%nomvar == Cfld_list_S(x) ) then

             ! Array size from table
             p_ni=size(vd%values,dim=1)
             p_nj=size(vd%values,dim=2)

             if ( gtyp_S(x) == 'Z' ) then
                sgid = ezgdef_fmem( xnilu(x), xnjlu(x), gtyp_S(x),    &
                     gtypz_S(x), xnzig1(x),xnzig2(x),xnzig3(x),       &
                     xnzig4(x), xrtic(1,x), xrtac(1,x) )
             else
                sgid = ezgdef_fmem( xnilu(x), xnjlu(x), gtyp_S(x),    &
                     Vide_S, xnig1(x),xnig2(x),xnig3(x),xnig4(x),     &
                     Aucun,Aucun )
             endif

             xnerr = ezdefset( dgid, sgid )
             xnerr = ezsetopt( 'INTERP_DEGREE', vd%interp )

             xnkerr = 0
             if (vd%p_nu > 1) then
!$omp parallel do private ( k, localf )
                do k=1,vd%p_nu
                   xnkerr(k) = ezsint( localf, xrclim(1,xPos3D(x)+k-1) )
                   Call itf_phy_fold_sfc( vd%values(1:p_ni,1:p_nj,k), localf,l_ni,l_nj )
                enddo
!$omp end parallel do
                xnerr = maxval( xnkerr(1:vd%p_nu) )
             else
                xnerr = ezsint( localf, xrclim(1,xPos3D(x)) )
                Call itf_phy_fold_sfc( vd%values(1:p_ni,1:p_nj,1), localf,l_ni,l_nj )
             endif

!*           Set flag that new date got read
             if ( xnerr == 0 ) then
                DoneInincr(x) = DoInincr(x)
!*              Encode date from 'DoneInincr' in 'Cfld_date'
                date1 =   DoneInincr(x) / factor6
                time1 = ( DoneInincr(x) - date1*factor6 ) * 100
                xnerr = newdate( Cfld_date(x), date1, time1, 3 )
             endif

             if ( xnerr /= 0 ) then ; itf_phy_inincr = -12 ; return ; end if

             vd%datev  = Cfld_date(x) ; vd%newdate_L = .true.

             if (Lctl_debug_L) then
                do k=1,vd%p_nu
                   call itf_phy_unfold_sfc( vd%values(1:p_ni,1:p_nj,k), localf, l_ni,l_nj )
                   call statf_dm3 (localf,vd%nomvar,k,'ININCR',1,l_ni, &
                     1,l_nj,1,1,1+goff,1+goff,1,G_ni-goff,G_nj-goff,1,rx)
                enddo
             endif
                
             vd%gminmax(1) = minval( xrclim(1:xnilu(x)*xnjlu(x),xPos3D(x):xPos3D(x)+vd%p_nu-1) )
             vd%gminmax(2) = maxval( xrclim(1:xnilu(x)*xnjlu(x),xPos3D(x):xPos3D(x)+vd%p_nu-1) )

             exit SCAN_VD_AND_INTERPOLATE

          endif

          If ( .Not. Associated( vd%next_value ) ) Exit
          vd => vd%next_value

       end do SCAN_VD_AND_INTERPOLATE

    end do

    vd => temp ! Restore initial vd position in list

!*  De-allocate working memory
    deallocate( xrclim, xrtic, xrtac,                   &
                gtyp_S, gtypz_S,xnzig1, xnzig2, xnzig3, &
                xnig1 , xnig2,  xnig3,  xnig4 , xnzig4, &
                xnilu , xnjlu,  ip2   , ip3,    datev,  &
                DoneInincr, DoInincr, xPos3D,   xnkerr, &
                Cfld_list_s, stat=xnerr )

    if ( xnerr > 0 ) then ; itf_phy_inincr = -13 ; return ; end if
                
!*  De-allocate all other saved variable at the end of a job
    if ( Lctl_step == Step_total )        &
    deallocate( monthly_L, dates,  nrec,  &
                xnmxfld,   acli_L, xnzm, stat=xnerr )

    if ( allocated( localf )) deallocate( localf )

    if ( xnerr > 0 ) then ; itf_phy_inincr = -14 ; return ; end if

    itf_phy_inincr = NbrField

 1001 format(' Unable to open climatological file ',A)
 1002 format(' Analysed/climatological file not opened')
 1005 format(' Unable to read climatological ',A4,' at level number ',I3)
 1006 format(' Unable to read >> record on unit ',I3,' for IP1,IP2= ',2I10)
 1007 format(' Unable to read ^^ record on unit ',I3,' for IP1,IP2= ',2I10)
 1008 format(' Unsupported grid type found : ',A)
 1009 format(' Date ',I14,' not found in analysed file')

 end function itf_phy_inincr
 block data itf_phy_inincr_data

#include "cfld.cdk"

    data Cfld_nbr / 0 /

 end block data itf_phy_inincr_data

