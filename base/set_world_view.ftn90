!---------------------------------- LICENCE BEGIN -------------------------------

! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r set_world_view
!

!
      subroutine set_world_view
!
      implicit none
#include <arch_specific.hf>
!
!author
!     Michel Desgagne
!
!revision
! v2_00 - Desgagne M.       - initial MPI version
! v2_10 - Lee V.            - added watch_pid mechanism (returnpid)
! v2_10 - Desgagne M.       - Add partitioning checks
! v2_20 - Desgagne M.       - remove watch_dog (MPISUSPEND=ON)
! v2_21 - Dugas B.          - possibly initialize convip
! v2_21 - Lee V.            - modifications for LAM version and slab outputs
! v2_30 - Dugas B.          - add call to gemtim
! v2_30 - Desgagne M.       - entry vertical interpolator in gemdm
! v2_32 - Desgagne M.       - option for FST2000 encoding of ip1
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_03 - Desgagne M.       - new procedure for call to set_dcst8
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v3_11 - Lee V.            - place output in local PE directory
! v3_21 - Desgagne M.       - using RMNLIB to access constants
! v3_30 - Desgagne M.       - Cleaner approach to model startup
! v3_30 - Desgagne & Winger - Initialize variable for VMM files
! v4_04 - Tanguay M.        - Williamson's cases
! v4_05 - Plante A.         - Open top
! v4_10 - Lepine M.         - VMM replacement with GMM
! v4_40 - Lee/Qaddouri      - add call to define PE topology for YinYang
!
#include <WhiteBoard.hf>
#include "lun.cdk"
#include "ptopo.cdk"
#include "grd.cdk"
#include "schm.cdk"
#include "glb_ld.cdk"
#include "out3.cdk"
#include "step.cdk"
#include "path.cdk"
#include "wil_williamson.cdk"
#include "wil_nml.cdk"

      integer, external :: gem_nml,gemdm_config,grid_nml2, &
                           adx_nml,adx_config            , &
                           RPN_COMM_bloc,step_nml,bin2com
      character*50 LADATE,dumc1_S
      integer ierr,err(8),f1,f2,f3,f4,n1,n2,n3,n4,n5,n6,n7
!
!-------------------------------------------------------------------
!
      err = RPN_COMM_bloc ( Ptopo_nblocx, Ptopo_nblocy )
      call handle_error(err,'pe_all_topo','rpn_comm_bloc')

      call RPN_COMM_carac ( Ptopo_npex,Ptopo_npey,Ptopo_myproc, &
                            n1,n2,n3,n4,n5,n6,n7 ,Ptopo_mybloc, &
              Ptopo_myblocx,Ptopo_myblocy,Ptopo_blocme,dumc1_S )

      if (Grd_yinyang_L) then         
         Path_ind_S=trim(Path_input_S)//'/MODEL_INPUT/'//trim(Grd_yinyang_S)
      else
         Path_ind_S=trim(Path_input_S)//'/MODEL_INPUT'
      endif
      Path_phy_S=trim(Path_input_S)//'/'

      err(:) = 0
      if ( Schm_theoc_L ) then

         call theo_cfg

      else
!
! Read namelists from file Path_nml_S
!
         err(1) = grid_nml2   (Path_nml_S,G_lam)
         err(2) = bin2com ()
         err(3) = step_nml    (Path_nml_S)
         err(4) = gem_nml     (Path_nml_S)
         err(5) = adx_nml     (Path_nml_S)

      endif
      call handle_error(minval(err(:)),'set_world_view','Error reading nml')
!
! Establish final configuration
!
      err(1) = gemdm_config ( )
      err(2) = adx_config   ( )
      call handle_error(min(err(1),err(2)),'set_world_view','config')

      ierr = grid_nml2   ('print',G_lam)
      ierr = step_nml    ('print')
      ierr = gem_nml     ('print')

      if ( Schm_cub_traj_L .and. (.not.G_lam) ) &
           call handle_error(-1,'set_world_view','Schm_cub_traj_L=.true. cannot be used with non LAM grid')
      if ( (Schm_psadj_S=='DRY') .and. (.not.Schm_wload_L) ) &
           call handle_error(-1,'set_world_view','Scmh_wload_L must be true if Schm_psadj_S=DRY')

      call adx_nml_print ()

      if (Williamson_case.ne.0.and.Lun_out.gt.0) write (Lun_out, nml=williamson) 
!
! Establish domain decomposition (mapping subdomains and processors)
!
      call domain_decomp2 (Ptopo_npex, Ptopo_npey, .false.)

      if (lun_out.gt.0) then
         f1 = G_ni/Ptopo_npex + min(1,mod(G_ni,Ptopo_npex))
         f2 = G_ni-f1*(Ptopo_npex-1)
         f3 = G_nj/Ptopo_npey + min(1,mod(G_nj,Ptopo_npey))
         f4 = G_nj-f3*(Ptopo_npey-1)
         write (lun_out,1001) Grd_typ_S,G_ni,G_nj,G_nk,f1,f3,f2,f4
         LADATE='RUNSTART='//Step_runstrt_S(1:8)//Step_runstrt_S(10:11)
         call write_status_file3 (trim(LADATE))
         call write_status_file3 ('communications_established=YES' )
         if (Grd_yinyang_L)    &
         call write_status_file3 ('GEM_YINYANG=1')
         if (Out3_fullplane_L) &
         call write_status_file3 ('Out3_fullplane_L=1')
         if (Out3_uencode_L)   &
         call write_status_file3 ('Out3_uencode_L=1')
      endif
!
! Master output PE for all none distributed components
!
      f1= 0
      ierr= wb_put('model/outout/pe_master', f1)
!
! Initializes schemes control comdeck
!
      call set_schm
!
! Initializes GMM
!
      call set_gmm

 1001 format (' GRID CONFIG: GRTYP=',a,5x,'GLB=(',i5,',',i5,',',i5,')    maxLCL(',i4,',',i4,')    minLCL(',i4,',',i4,')')
!
!-------------------------------------------------------------------
!
      return
      end
