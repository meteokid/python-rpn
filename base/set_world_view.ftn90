!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r set_world_view
!
#include "model_macros_f.h"
!
      subroutine set_world_view
!
      implicit none
#include <arch_specific.hf>
!
!author
!     Michel Desgagne
!
!revision
! v2_00 - Desgagne M.       - initial MPI version
! v2_10 - Lee V.            - added watch_pid mechanism (returnpid)
! v2_10 - Desgagne M.       - Add partitioning checks
! v2_20 - Desgagne M.       - remove watch_dog (MPISUSPEND=ON)
! v2_21 - Dugas B.          - possibly initialize convip
! v2_21 - Lee V.            - modifications for LAM version and slab outputs
! v2_30 - Dugas B.          - add call to gemtim
! v2_30 - Desgagne M.       - entry vertical interpolator in gemdm
! v2_32 - Desgagne M.       - option for FST2000 encoding of ip1
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_03 - Desgagne M.       - new procedure for call to set_dcst8
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v3_11 - Lee V.            - place output in local PE directory
! v3_21 - Desgagne M.       - using RMNLIB to access constants
! v3_30 - Desgagne M.       - Cleaner approach to model startup
! v3_30 - Desgagne & Winger - Initialize variable for VMM files
! v4_04 - Tanguay M.        - Williamson's cases
! v4_05 - Plante A.         - Open top
! v4_10 - Lepine M.         - VMM replacement with GMM
! v4_40 - Lee/Qaddouri      - add call to define PE topology for YinYang
!
#include "gmm.hf"
#include "lun.cdk"
#include "cst_lis.cdk"
#include "dcst.cdk"
#include "ptopo.cdk"
#include "grd.cdk"
#include "schm.cdk"
#include "glb_ld.cdk"
#include "path.cdk"
#include "vmmlist.cdk"
#include "itf_cpl.cdk"
#include "wil_williamson.cdk"
#include "wil_nml.cdk"
#include "adw_nml.cdk"
#include <clib_interface.cdk>
!
      logical  set_dcst_8
      integer  gem_nml,v4d_nml,v4d_config,gemdm_config,grid_nml2,  &
               itf_cpl_nml,series_nml,adw_nml,adw_config,step_nml,&
               rpn_comm_init_multigrid,    &
               bin2com
      external pe_zero_topo, set_dcst_8, gem_nml, v4d_nml,       &
               v4d_config, gemdm_config, grid_nml2, itf_cpl_nml,  &
               series_nml,adw_nml,adw_config,init_ndoms,step_nml,&
               rpn_comm_init_multigrid,   &
               bin2com

      integer ierr,err(8),cte_ok,mydomain,f1,f2,f3,f4
      character(len=256) :: my_dir
!
!-------------------------------------------------------------------
!
! Initializing domain and working directory
!
      call rpn_comm_mydomain (init_ndoms, mydomain)

      write(my_dir,'(a,i4.4)') 'cfg_',mydomain

      ierr = clib_getenv ('TASK_INPUT' ,Path_input_S )
      ierr = clib_getenv ('TASK_OUTPUT',Path_output_S)
      ierr = clib_getenv ('TASK_WORK'  ,Path_work_S  )

      Path_input_S  = trim(Path_input_S ) // '/' // trim(my_dir)
      Path_output_S = trim(Path_output_S) // '/' // trim(my_dir)
      Path_work_S   = trim(Path_work_S  ) // '/' // trim(my_dir)
 
      ierr = clib_chdir (trim(Path_work_S))
!
! Initializing MPI and processor topology (pe_zero_topo called on PE #0 only)
!
      if (Grd_yinyang_L) then
         call yy_init ( pe_zero_topo, Ptopo_myproc, Ptopo_numproc,       &
                        Ptopo_npex, Ptopo_npey,                          &
                        Ptopo_intracomm, Ptopo_intercomm, Ptopo_couleur, &
                        Ptopo_world_myproc, Ptopo_world_numproc, Grd_ndomains )

         if (Ptopo_couleur.eq.0) Grd_yinyang_S = 'YIN'
         if (Ptopo_couleur.eq.1) Grd_yinyang_S = 'YAN'
         ierr= clib_mkdir(trim(Grd_yinyang_S))
         ierr= clib_chdir(trim(Grd_yinyang_S))
      else
         ierr = rpn_comm_init_multigrid (pe_zero_topo,Ptopo_myproc,Ptopo_numproc,&
                                            Ptopo_npex, Ptopo_npey, Grd_ndomains )
         Ptopo_couleur = 0
      endif

      call msg_set_can_write (Ptopo_myproc == 0)

      call handle_error (clib_isdir(Path_input_S),'set_world_view','task_input')

      call gemtim4 ( 6, '', .false. )

      if (Grd_yinyang_L) then         
         Path_ind_S=trim(Path_input_S)//'/MODEL_INPUT/'//trim(Grd_yinyang_S)
      else
         Path_ind_S=trim(Path_input_S)//'/MODEL_INPUT'
      endif
      Path_phy_S=trim(Path_input_S)//'/'
!
! Continue initialization steps
!
      call pe_all_topo

      cte_ok = 0
      if ( .not. set_dcst_8 ( Dcst_cpd_8,liste_S,cnbre, &
                              Lun_out,Ptopo_numproc ) ) cte_ok=-1
      call handle_error(cte_ok,'set_world_view','set_dcst_8')
!
      if ( Schm_theoc_L ) then
!
         call theo_cfg
!
      else
!
! Read namelist gem_cfgs, var4d, coupling and series from file Path_nml_S
!
         err(1) = grid_nml2   (Path_nml_S,G_lam)
         err(2) = bin2com ()
         err(3) = step_nml    (Path_nml_S)
         err(4) = gem_nml     (Path_nml_S)
         err(5) = itf_cpl_nml (Path_nml_S)
         err(6) = v4d_nml     (Path_nml_S)
         err(7) = series_nml  (Path_nml_S)
         err(8) = adw_nml     (Path_nml_S)

         ierr = min(err(1),err(2),err(3),err(4), &
                    err(5),err(6),err(7),err(8))
         call handle_error(ierr,'set_world_view','Error reading nml')

      endif
!
! Establish final configuration
!
      err(1) = gemdm_config ( )
      err(2) = adw_config   ( )
      err(3) = v4d_config   ( )
      call handle_error(min(err(1),err(2),err(3)),'set_world_view','')
!
      ierr = grid_nml2   ('print',G_lam)
      ierr = step_nml    ('print')
      ierr = gem_nml     ('print')
      ierr = itf_cpl_nml ('print') 
      ierr = series_nml  ('print')

      call adw_nml_print ()

      if (Williamson_case.ne.0.and.Lun_out.gt.0) write (Lun_out, nml=williamson) 
!
! Establish domain decomposition (mapping subdomains and processors)
!
      call domain_decomp2 (Ptopo_npex, Ptopo_npey, .false.)
!
      if (lun_out.gt.0) then
         f1 = G_ni/Ptopo_npex + min(1,mod(G_ni,Ptopo_npex))
         f2 = G_ni-f1*(Ptopo_npex-1)
         f3 = G_nj/Ptopo_npey + min(1,mod(G_nj,Ptopo_npey))
         f4 = G_nj-f3*(Ptopo_npey-1)
         write (lun_out,1001) Grd_typ_S,G_ni,G_nj,G_nk,f1,f3,f2,f4
      endif
!
! Initializes schemes control comdeck
!
      call set_schm
!
! Initializes GMM
!
      call set_gmm
!
      Schm_notop=0
      if(Schm_NoTopThL_L)then
         if(Schm_opentop_L)&
              call handle_error(-1,'set_world_view','Schm_NoTopThL_L cannot be use with Schm_opentop_L')
         if(.not.Adw_useadx_L)&
              call handle_error(-1,'set_world_view','Schm_NoTopThL_L cannot be use with Adw_useadx_L=.false.')
         Schm_notop=1
      endif
!
 1001 format (' GRID CONFIG: GRTYP=',a,5x,'GLB=(',i5,',',i5,',',i5,')    maxLCL(',i4,',',i4,')    minLCL(',i4,',',i4,')')
!
!-------------------------------------------------------------------
!
      return
      end
