!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!opyright (C) 2001  MSC-RPN COMM  %%%MC2%%%
!**s/r out_dyn_3df - output in the form of 3DF files
!
#include "model_macros_f.h"
!
      subroutine out_dyn_3df ( datev, gid, gif, gjd, gjf )
      implicit none
#include <arch_specific.hf>
!
      character* (*) datev
      integer gid, gif, gjd, gjf
!
!author M.Desgagne ( MC2 2001)
!
!revision
! v3_30 - V.Lee - initial version for GEM LAM (new I/O)
! v4_05 - Lepine M.         - VMM replacement with GMM
!
#include "gmm.hf"
#include "glb_ld.cdk"
#include "geomg.cdk"
#include "out.cdk"
#include "p_geof.cdk"
#include "vt1.cdk"
#include "schm.cdk"
#include "grdc.cdk"
#include "tr3d.cdk"
#include "lctl.cdk"
#include "ptopo.cdk"
!
      logical,save :: done = .false.

      type(gmm_metadata) :: mymeta
      character* 512 filen
      integer i,j,k,nis,njs,ind_o(G_nk+2),cnt,unf,key(21), &
              nvar,err,ofi,ofj,istat
      integer outindx(4),outindx_g(4,Ptopo_numproc)
      real, pointer, dimension(:,:,:) :: tr1
!
!------------------------------------------------------------------
!
      if (.not.done) then
         outindx = 0
         if (Ptopo_blocme.eq.0) then
            outindx(1) = out_idg
            outindx(2) = out_jdg
            outindx(3) = out_nisl
            outindx(4) = out_njsl
         endif
         call RPN_COMM_gather (outindx  , 4,"MPI_INTEGER"  ,outindx_g, &
                                    4, "MPI_INTEGER"  ,0,"GRID", err)

         if (Ptopo_myproc.eq.0) then
            filen=trim(Out_dirname_S)//'/3df_filemap.txt'
            open (9,file=filen,access='SEQUENTIAL',form='FORMATTED')
            do i=1,Ptopo_numproc
              if ( (outindx_g(3,i).gt.0).and.(outindx_g(4,i).gt.0) ) then
               ofi=Grdc_gid+outindx_g(1,i)-1
               ofj=Grdc_gjd+outindx_g(2,i)-1
               write (9,'(2i8,4e15.7,2i10)')  &
                     outindx_g(1,i),outindx_g(2,i), &
                     G_xg_8(ofi),G_xg_8(ofi+outindx_g(3,i)-1), &
                     G_yg_8(ofj),G_yg_8(ofj+outindx_g(4,i)-1), &
                     outindx_g(3,i),outindx_g(4,i)
              endif
            end do
            close (9)
         endif
      endif
      done = .true.
!
      if ((out_nisl.le.0).or.(out_njsl.le.0)) return
!
      nis = out_ifg - out_idg + 1
      njs = out_jfg - out_jdg + 1
      do k=1,G_nk+2
         ind_o(k) = k
      end do
!
      istat = gmm_get(gmmk_ut1_s ,ut1 ,mymeta)
      istat = gmm_get(gmmk_vt1_s ,vt1 ,mymeta)
      istat = gmm_get(gmmk_zdt1_s,zdt1,mymeta)
      istat = gmm_get(gmmk_tt1_s ,tt1 ,mymeta)
      istat = gmm_get(gmmk_st1_s ,st1 ,mymeta)
      istat = gmm_get(gmmk_fis0_s,fis0,mymeta)
      istat = gmm_get(gmmk_wt1_s ,wt1 ,mymeta)
      nvar = 7
!
      if (.not.Schm_hydro_L) then
         istat = gmm_get(gmmk_qt1_s,qt1,mymeta)
         nvar = 8
      endif
!
      if (Out_blocme.eq.0)  &
           call out_sfile_3df2( datev, unf, gid, gif, gjd, gjf,&
                                         nvar, Grdc_ntr, filen )
!
! tt1,st1,topo are usually written from e_intthm
      call write_3df (  tt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2, &
                             'TT  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df (  st1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,1     , &
                             'S   ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df ( fis0,l_minx,l_maxx,l_miny,l_maxy,nis,njs,1     , &
                             'GZ  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
! wt1,zdt1, maybe qt1 from the model
      call write_3df (  wt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1, &
                             'W   ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df ( zdt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1, &
                             'ZD  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
!
      if (.not.Schm_hydro_L) then
      call write_3df (qt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2, &
                             'Q   ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      endif

! tracers written from model
       do k=1,Grdc_ntr
          nullify (tr1)
          istat=gmm_get('TR/'//trim(Grdc_trnm_S(k))//':P',tr1,mymeta)
          if (.not.GMM_IS_ERROR(istat)) then
             call write_3df (tr1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+2, &
                       Grdc_trnm_S(k),gid, gif, gjd, gjf,1.0,ind_o,unf )
          endif
       end do
!
! wind from model
      call write_3df (  ut1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1, &
                             'UU  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
      call write_3df (  vt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk+1, &
                             'VV  ',gid, gif, gjd, gjf,1.0,ind_o,unf )
!
      if (Out_blocme.eq.0) then
         close (unf)
      endif
!
!------------------------------------------------------------------
      return
      end
!
