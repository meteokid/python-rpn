!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r out_dyn_3df - model output in 3DF files for cascade
!
      subroutine out_dyn_3df ( datev, gid, gif, gjd, gjf )
      implicit none
#include <arch_specific.hf>

      character* (*) datev
      integer gid, gif, gjd, gjf

!author M.Desgagne ( MC2 2001)
!
!revision
! v3_30 - V.Lee             - initial version for GEM LAM (new I/O)
! v4_05 - Lepine M.         - VMM replacement with GMM
! v4_70 - Desgagne M.       - update to new vertical shape
!
#include "gmm.hf"
#include "glb_ld.cdk"
#include "out.cdk"
#include "p_geof.cdk"
#include "vt1.cdk"
#include "schm.cdk"
#include "step.cdk"
#include "grdc.cdk"
#include "tr3d.cdk"
#include "ptopo.cdk"

      character* 512 filen
      logical, save :: done=.false.
      integer i,j,k,nis,njs,cnt,unf,nvar,err,ofi,ofj,istat
      integer outindx(4),outindx_g(4,Ptopo_numproc)
      real, pointer, dimension(:,:,:) :: tr1,tr2
!
!------------------------------------------------------------------
!
      nullify (tr1,tr2)

      outindx = 0
      if (Ptopo_blocme.eq.0) then
         outindx(1) = out_idg
         outindx(2) = out_jdg
         outindx(3) = out_nisl
         outindx(4) = out_njsl
      endif
      call RPN_COMM_gather (outindx  , 4,"MPI_INTEGER"  ,outindx_g, &
                                  4, "MPI_INTEGER"  ,0,"GRID", err)

      if (Ptopo_myproc.eq.0) then
         filen=trim(Out_dirname_S)//'/3df_'//trim(datev)//'_filemap.txt'
         open (9,file=filen,access='SEQUENTIAL',form='FORMATTED')
         do i=1,Ptopo_numproc
            if ( (outindx_g(3,i).gt.0).and.(outindx_g(4,i).gt.0) ) then
               ofi=Grdc_gid+outindx_g(1,i)-1
               ofj=Grdc_gjd+outindx_g(2,i)-1
               write (9,'(2i8,4e15.7,2i10,l4)') &
                    outindx_g(1,i),outindx_g(2,i)           , &
                    G_xg_8(ofi),G_xg_8(ofi+outindx_g(3,i)-1), &
                    G_yg_8(ofj),G_yg_8(ofj+outindx_g(4,i)-1), &
                    outindx_g(3,i),outindx_g(4,i), .false.
            endif
         end do
         close (9)
      endif

      if ((out_nisl.le.0).or.(out_njsl.le.0)) return

      nis = out_ifg - out_idg + 1
      njs = out_jfg - out_jdg + 1

      istat = gmm_get(gmmk_ut1_s ,ut1 )
      istat = gmm_get(gmmk_vt1_s ,vt1 )
      istat = gmm_get(gmmk_zdt1_s,zdt1)
      istat = gmm_get(gmmk_tt1_s ,tt1 )
      istat = gmm_get(gmmk_st1_s ,st1 )
      istat = gmm_get(gmmk_fis0_s,fis0)
      istat = gmm_get(gmmk_wt1_s ,wt1 )
      nvar = 7

      if (.not.Schm_hydro_L) then
         istat = gmm_get(gmmk_qt1_s,qt1)
         nvar = 8
      endif

      if (Out_blocme.eq.0)  &
           call out_sfile_3df3 ( datev, unf, gid, gif, gjd, gjf,&
                                               Grdc_ntr, filen )

      call write_3df3 (  tt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk, &
                             'VT  ',gid, gif, gjd, gjf, unf, done )
      call write_3df3 (  st1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,1   , &
                             'S   ',gid, gif, gjd, gjf, unf, done )
      call write_3df3 ( fis0,l_minx,l_maxx,l_miny,l_maxy,nis,njs,1   , &
                             'GZ  ',gid, gif, gjd, gjf, unf, done )
      call write_3df3 (  wt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk, &
                             'W   ',gid, gif, gjd, gjf, unf, done )
      call write_3df3 ( zdt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk, &
                             'ZD  ',gid, gif, gjd, gjf, unf, done )

      if (.not.Schm_hydro_L) then
      call write_3df3 (  qt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk, &
                             'Q   ',gid, gif, gjd, gjf, unf, done )
      endif

      call write_3df3 (  ut1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk, &
                             'UU  ',gid, gif, gjd, gjf, unf, done )
      call write_3df3 (  vt1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,G_nk, &
                             'VV  ',gid, gif, gjd, gjf, unf, done )

      do k=1,Grdc_ntr
         nullify (tr2)
         istat=gmm_get('TR/'//trim(Grdc_trnm_S(k))//':P',tr2)
         if (.not.GMM_IS_ERROR(istat)) then
            call write_3df3 (tr2,l_minx,l_maxx,l_miny,l_maxy,nis,njs,&
                 G_nk, Grdc_trnm_S(k), gid, gif, gjd, gjf, unf, done )
         endif
      end do

      if ( Schm_phyms_L )then
         allocate(tr1(l_minx:l_maxx,l_miny:l_maxy,4))
         if (Step_kount.eq.0) then
            istat=gmm_get('TR/HU:P',tr2)
            tr1(:,:,1) = tt1(:,:,G_nk)
            tr1(:,:,2) = tr2(:,:,G_nk)
            tr1(:,:,3) = ut1(:,:,G_nk)
            tr1(:,:,4) = vt1(:,:,G_nk)
         else
            call itf_phy_sfcdiag(tr1(l_minx,l_miny,1),&
                   l_minx,l_maxx,l_miny,l_maxy,'TDIAG')
            call itf_phy_sfcdiag(tr1(l_minx,l_miny,2),&
                   l_minx,l_maxx,l_miny,l_maxy,'QDIAG')
            call itf_phy_sfcdiag(tr1(l_minx,l_miny,3),&
                   l_minx,l_maxx,l_miny,l_maxy,'UDIAG')
            call itf_phy_sfcdiag(tr1(l_minx,l_miny,4),&
                   l_minx,l_maxx,l_miny,l_maxy,'VDIAG')
         endif
         call write_3df3 (tr1,l_minx,l_maxx,l_miny,l_maxy,nis,njs,4,&
                               'DIAG',gid, gif, gjd, gjf, unf, done )
         deallocate (tr1)
      endif

      if (Out_blocme.eq.0) then
         close (unf)
      endif

      done= .true.
!
!------------------------------------------------------------------
!
      return
      end

