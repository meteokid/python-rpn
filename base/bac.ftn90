!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END --------------------------------

!**s/r  bacp - backsubstitution: obtain new values of the variables:
!                                                   u,v,w,t,q,s,zd
!                from new P , the right-hand sides (Ru,Rv,Rt,Rw,Rf)
!                             and non-linear terms (Nu,Nv,Nt,Nw,Nf)
!revision
! v4_50 - Qaddouri/Lee      - Yin-Yang, to exchange ZD, winds,T,S,Q
! v4.7  - Gaudreault S.     - Reformulation in terms of real winds (removing wind images)
!
#include "model_macros_f.h"

      subroutine bac ( F_lhs_sol, F_fis , &
                       F_u   , F_v     , F_w  , F_t       , &
                       F_s   , F_zd    , F_q  , F_nest_q  , &
                       F_ru  , F_rv    , F_rt , F_rw  , F_rf , F_rb, &
                       F_nu  , F_nv    , F_nt , F_nw  , F_nf , F_nb, &
                       DIST_DIM, ni,nj,Nk, i0, j0, k0, in, jn )
      implicit none
#include <arch_specific.hf>
!
      integer  DIST_DIM, ni,nj,Nk , i0, j0, k0, in, jn
      real*8   F_lhs_sol (ni,nj,Nk)
      real     F_fis (DIST_SHAPE)                                    , &
               F_u   (DIST_SHAPE,  Nk)  , F_v     (DIST_SHAPE,  Nk)  , &
               F_w   (DIST_SHAPE,  Nk)  , F_t     (DIST_SHAPE,  Nk)  , &
               F_s   (DIST_SHAPE)       , F_zd    (DIST_SHAPE,  Nk)  , &
               F_q   (DIST_SHAPE,2:Nk+1), F_nest_q(DIST_SHAPE,2:Nk+1), &
               F_ru  (DIST_SHAPE,  Nk)  , F_rv    (DIST_SHAPE,  Nk)  , &
               F_rt  (DIST_SHAPE,  Nk)  , F_rw    (DIST_SHAPE,  Nk)  , &
               F_rf  (DIST_SHAPE,  Nk)  , F_rb    (DIST_SHAPE)       , &
               F_nu  (DIST_SHAPE,  Nk)  , F_nv    (DIST_SHAPE,  Nk)  , &
               F_nt  (DIST_SHAPE,  Nk)  , F_nw    (DIST_SHAPE,  Nk)  , &
               F_nf  (DIST_SHAPE,  Nk)  , F_nb    (DIST_SHAPE)
!
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "lun.cdk"
#include "grd.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
#include "ptopo.cdk"
#include "lam.cdk"
#include "wil_williamson.cdk"
!
      integer i, j, k, kq, nij, k0t, istat
      real*8  xxx, yyy, zzz, p1, p2, p3, p4, Pbar, qbar
      real*8, dimension(i0:in,j0:jn):: xtmp_8, ytmp_8
      real  , dimension(:,:,:), allocatable :: GP
      real*8, parameter :: zero=0.d0, one=1.d0
!     __________________________________________________________________
!
      if (Schm_autobar_L.and.Williamson_case.eq.1) return

      if (Lun_debug_L) write(Lun_out,1000)

      allocate (GP(DIST_SHAPE,Nk+1))

      nij = (in - i0 + 1)*(jn - j0 + 1)

      p1 = Cstv_tau_8*Cstv_RTstr_8/Dcst_grav_8
      p2 = one/Cstv_RTstr_8
      p3 = Dcst_grav_8*Ver_epsilon_8*Cstv_tau_8*Cstv_tau_8/Cstv_RTstr_8
      p4 = one/Dcst_rayt_8

      k0t=k0
      if(Schm_opentop_L) k0t=k0-1

      do k=k0,l_nk
         do j= j0, jn
         do i= i0, in
            GP(i,j,k) = sngl(F_lhs_sol(i,j,k))
         enddo
         enddo
      end do
!
!$omp parallel private(xxx,yyy,zzz,qbar,Pbar,kq,xtmp_8,ytmp_8)
!
!     Compute P at top and bottom
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
      if ( Schm_opentop_L ) then
!$omp do
         do j= j0, jn
         do i= i0, in
            GP(i,j,k0-1) = Ver_alfat_8 * F_lhs_sol(i,j,k0) &
                         + Ver_cst_8*(F_rb(i,j)-F_nb(i,j))
         end do
         end do
!$omp enddo
      endif
!$omp do
      do j= j0, jn
      do i= i0, in
         GP(i,j,l_nk+1)  = Ver_alfas_8 * F_lhs_sol(i,j,l_nk)  &
                         - Ver_css_8*(F_rt(i,j,l_nk)-F_nt(i,j,l_nk))
      end do
      end do
!$omp enddo

!$omp single
      call rpn_comm_xch_halo(GP,LDIST_DIM,l_ni,l_nj,G_nk+1, &
                  G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
!$omp end single

!     Compute U & V
!     ~~~~~~~~~~~~~
      if (G_lam) then
!$omp do
         do k=k0,l_nk
            do j= j0, jn
               do i= i0, l_niu-pil_e
                  F_u(i,j,k) = ( Cstv_tau_8*(F_ru(i,j,k)-F_nu(i,j,k) - (GP(i+1,j,k) - GP(i,j,k)) * geomg_invDXu_8(i,j)) )
               end do
            end do

            do j= j0, l_njv-pil_n
               do i= i0, in
                  F_v(i,j,k) = ( Cstv_tau_8*( F_rv(i,j,k)-F_nv(i,j,k) - (GP(i,j+1,k) - GP(i,j,k)) * geomg_invDYv_8(j)) )
               end do
            end do
         enddo
!$omp enddo
      else
!$omp do
         do k=k0,l_nk
            do j= j0, jn
               do i= i0, l_niu-pil_e
                  F_u(i,j,k)= Cstv_tau_8*( F_ru(i,j,k)-F_nu(i,j,k) - &
                              p4/Dcst_rayt_8*(GP(i+1,j,k)-GP(i,j,k)) &
                              *geomg_invDXu_8(i,j)  * (geomg_cy_8(j) * Dcst_rayt_8))
               end do
            end do
            
            do j= j0, l_njv-pil_n
               do i= i0, in
                  F_v(i,j,k)= Cstv_tau_8*( F_rv(i,j,k)-F_nv(i,j,k) - &
                              p4/Dcst_rayt_8*(GP(i,j+1,k) - GP(i,j,k)) &
                              *geomg_invDYv_8(j)  * (geomg_cyv_8(j) * Dcst_rayt_8) )
               end do
            end do
         enddo
!$omp enddo
      end if

!     Compute w
!     ~~~~~~~~~

!$omp do
      do k=k0t,l_nk
         do j= j0, jn
         do i= i0, in
            Pbar= Ver_wp_8%t(k)*GP(i,j,k+1)+Ver_wm_8%t(k)*GP(i,j,k)
            F_w(i,j,k) = p1 * ( F_rf(i,j,k) - F_nf(i,j,k) &
            + Ver_gokt2RT_8 * ( (GP(i,j,k+1)-GP(i,j,k))*Ver_idz_8%t(k) &
                                     + Dcst_cappa_8 * Pbar ) )
         end do
         end do
      end do
!$omp enddo

      if(.not.Schm_hydro_L) then

!        Compute q
!        ~~~~~~~~~
!
!        N.B.  Top Boundary condition:
!                 Closed Top(k0.eq.1):  F_q(i,j,k0) = 0
!                   Open Top(k0.ne.1):  F_q(i,j,k0-1) is externally specified

         if (Schm_opentop_L) then
!$omp do
            do j= j0, jn
            do i= i0, in
               F_q(i,j,k0-1)=F_nest_q(i,j,k0-1)
            end do
            end do
!$omp enddo
         endif
!
!        Note : we cannot use omp on loop k
!               due to vertical dependency F_q(i,j,k)
         do k=k0t,l_nk
            kq=max(k,2)
            zzz = one/(one+Ver_wp_8%t(k)*Ver_dz_8%t(k))
            yyy = (one-Ver_wm_8%t(k)*Ver_dz_8%t(k))*zzz
            xxx = p3*Ver_dz_8%t(k)*zzz
!$omp do
            do j= j0, jn
            do i= i0, in
               F_q(i,j,k+1) = yyy * F_q(i,j,kq)*Ver_onezero(k) &
                            - xxx * ( F_rw(i,j,k) - F_nw(i,j,k) &
                                  - Cstv_invT_8 *F_w(i,j,k)  )
            end do
            end do
!$omp enddo
         end do

      endif

!     Compute s
!     ~~~~~~~~~

!$omp do
      do j= j0, jn
      do i= i0, in
         F_s(i,j) = p2*(Ver_wp_8%t(l_nk)*GP(i,j,l_nk+1) &
                       +Ver_wm_8%t(l_nk)*GP(i,j,l_nk)-F_fis(i,j))
      end do
      end do
!$omp enddo

      if (.not. Schm_hydro_L) then
!$omp do
         do j= j0, jn
         do i= i0, in
            F_s(i,j) = F_s(i,j) - Ver_wp_8%t(l_nk)*F_q(i,j,l_nk+1) &
                                - Ver_wm_8%t(l_nk)*F_q(i,j,l_nk)
         end do
         end do
!$omp enddo
      endif

!     Compute zd
!     ~~~~~~~~~~

!        N.B.  Top Boundary condition:
!                 Closed Top(k0.eq.1):  F_zd(i,j,k0-1) = 0
!                   Open Top(k0.ne.1):  F_zd(i,j,k0-1) is computed

!$omp do
      do k=k0t,l_nk-1
         xxx=Ver_gokt2RT_8*Ver_idz_8%t(k)
         yyy=Ver_gokt2RT_8*Ver_epsilon_8
         zzz=Ver_b_8%t(k)*Cstv_invT_8
         if(Schm_autobar_L) zzz=0.d0
         do j= j0, jn
         do i= i0, in
            Pbar= Ver_wp_8%t(k)*GP(i,j,k+1)+Ver_wm_8%t(k)*GP(i,j,k)
            F_zd(i,j,k)=-Cstv_tau_8*( F_rt(i,j,k)- F_nt(i,j,k) &
                       + xxx * ( GP(i,j,k+1)-GP(i,j,k) ) &
                       - yyy * Pbar ) &
                       - zzz * F_s(i,j)
         enddo
         enddo
      enddo
!$omp enddo

      if (.not. Schm_hydro_L) then
!$omp do
         do k=k0t,l_nk-1
            kq=max(k,2)
            do j= j0, jn
            do i= i0, in
               qbar=(Ver_wp_8%t(k)*F_q(i,j,k+1)+Ver_wm_8%t(k)*F_q(i,j,kq)*Ver_onezero(k))
               F_zd(i,j,k)=F_zd(i,j,k)-Cstv_invT_8*qbar
            enddo
            enddo
         enddo
!$omp enddo
      endif

!     Compute FI' (into GP)
!     ~~~~~~~~~~~

!$omp do
      do k=k0t,l_nk
         kq=max(k,2)
         xxx=Cstv_RTstr_8*Ver_b_8%m(k)
         do j= j0, jn
         do i= i0, in
            GP(i,j,k)=GP(i,j,k)-xxx*F_s(i,j)
         enddo
         enddo
         if (.not. Schm_hydro_L) then
            do j= j0, jn
            do i= i0, in
               GP(i,j,k)=GP(i,j,k)-Cstv_RTstr_8*F_q(i,j,kq)*Ver_onezero(k)       
            enddo
            enddo
         endif
         enddo
!$omp enddo

      do j= j0, jn
      do i= i0, in
         GP(i,j,l_nk+1)=F_fis(i,j)
      enddo
      enddo

!     Compute T
!     ~~~~~~~~~

!$omp do
      do k=k0t,l_nk
         kq=max(k,2)
         if(.not.Schm_hydro_L) then
         do j= j0, jn
         do i= i0, in
            qbar=(Ver_wp_8%t(k)*F_q(i,j,k+1)+Ver_wm_8%t(k)*F_q(i,j,kq)*Ver_onezero(k))
            ytmp_8(i,j)=-qbar
         enddo
         enddo
         call vexp( xtmp_8, ytmp_8, nij )
         do j= j0, jn
         do i= i0, in
            xtmp_8(i,j)=xtmp_8(i,j)*(one+Ver_dbdz_8%t(k)*F_s(i,j))
         enddo
         enddo
         else
         do j= j0, jn
         do i= i0, in
            xtmp_8(i,j)=one+Ver_dbdz_8%t(k)*F_s(i,j)
         enddo
         enddo
         endif
         call vrec ( ytmp_8, xtmp_8, nij )
         xxx=p2*Ver_idz_8%t(k)
         do j= j0, jn
            do i= i0, in
               F_t(i,j,k)=Cstv_Tstr_8*ytmp_8(i,j) &
                    *(one-xxx*(GP(i,j,k+1)-GP(i,j,k)))
            enddo
         enddo
      enddo
!$omp enddo

      if(Schm_autobar_L) then
         F_t=Cstv_Tstr_8 ; F_zd=0. ! not necessary but safer
      endif

!$omp end parallel
!
      deallocate (GP)

      if (Grd_yinyang_L) then
         call yyg_nestuv(F_u,F_v, l_minx,l_maxx,l_miny,l_maxy, G_nk)
         call yyg_xchng (F_t , l_minx,l_maxx,l_miny,l_maxy, G_nk,&
                         .false., 'CUBIC')
         call yyg_xchng (F_zd, l_minx,l_maxx,l_miny,l_maxy, G_nk,&
                         .false., 'CUBIC')
         call yyg_xchng (F_s , l_minx,l_maxx,l_miny,l_maxy, 1   ,&
                         .false., 'CUBIC')
         if (.not. Schm_hydro_L) &
         call yyg_xchng (F_q , l_minx,l_maxx,l_miny,l_maxy, G_nk,&
                         .false., 'CUBIC')
      endif

1000  format (5X,'BACK SUBSTITUTION: (S/R BAC)')
!     __________________________________________________________________
!
      return
      end

