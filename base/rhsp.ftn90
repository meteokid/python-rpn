!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!*s/r rhsp_2 - compute the right-hand sides: Ru, Rv, Rc, Rt, Rw, Rf,
!              save the results for next iteration in the o's
!
#include "model_macros_f.h"
!
      subroutine rhsp_2 ( F_oru, F_orv, F_orc,F_ort,F_orw,   F_orf, &
                          F_ruw1,F_rvw1,F_ru, F_rv, F_nest_u,F_nest_v, &
                          F_u,   F_v,   F_w,  F_t,  F_s,     F_zd, &
                          F_BsPq,F_fip, F_mu, &
                          DIST_DIM, Nk )
!
      implicit none
!
      integer DIST_DIM, Nk
!
      real F_oru   (DIST_SHAPE,  Nk)  ,F_orv   (DIST_SHAPE,  Nk)  , &
           F_orc   (DIST_SHAPE,  Nk)  ,F_ort   (DIST_SHAPE,  Nk+1), &
           F_orw   (DIST_SHAPE,  Nk+1),F_orf   (DIST_SHAPE,  Nk+1), &
           F_ruw1  (DIST_SHAPE,  Nk)  ,F_rvw1  (DIST_SHAPE,  Nk)  , &
           F_ru    (DIST_SHAPE,  Nk)  ,F_rv    (DIST_SHAPE,  Nk)  , &
           F_nest_u(DIST_SHAPE,  Nk)  ,F_nest_v(DIST_SHAPE,  Nk)  , &
           F_u     (DIST_SHAPE,  Nk)  ,F_v     (DIST_SHAPE,  Nk)  , &
           F_w     (DIST_SHAPE,  Nk+1),F_t     (DIST_SHAPE,  Nk+1), &
           F_s     (DIST_SHAPE)       ,F_zd    (DIST_SHAPE,  Nk+1), &
           F_BsPq  (DIST_SHAPE,0:Nk+1),F_fip   (DIST_SHAPE,0:Nk+1), &
           F_mu    (DIST_SHAPE,  Nk+1)
!
!author
!     Alain Patoine
!
!revision
! v2_00 - Desgagne M.       - initial MPI version (from rhs v1_03)
! v2_21 - Lee V.            - modifications for LAM version
! v2_30 - Edouard  S.       - adapt for vertical hybrid coordinate 
!                             (Change to Rcn)
! v2_31 - Desgagne M.       - remove treatment of hut1 and qct1
! v3_00 - Qaddouri & Lee    - For LAM, Change Ru, Rv values on the boundaries 
! v3_00                       of the LAM grid with values from Nesting data
! v3_02 - Edouard S.        - correct bug in Ru and Rv in the non hydrostatic version
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v4_00 - Plante & Girard   - Log-hydro-pressure coord on Charney-Phillips grid
!
!object
!     see rhs
!
!arguments
!
!implicits
#include "glb_ld.cdk"
#include "cori.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "schm.cdk"
#include "intuv.cdk"
#include "inuvl.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "lun.cdk"
#include "that.cdk"
!
      integer i, j, k, i0, j0, in, jn, nij 
!     real*8  tdiv
      real    tdiv
      real*8  one, c1,c2,c3, BsPqbarz, fipbarz, &
              wk1(DIST_SHAPE), wk2(DIST_SHAPE), barz, barzp, ww1, &
              xtmp_8(l_ni,l_nj), ytmp_8(l_ni,l_nj), verbm_8(0:l_nk+1)

      parameter( one=1.d0 )
!     - - - - - - - - - - - - - - - - 
      verbm_8(0)=0.d0
      verbm_8(1:l_nk+1)=Ver_b_8%m(1:l_nk+1)
!*
!     __________________________________________________________________
!
!     Common coefficients 

      c1  = Cstv_Beta_8 * Dcst_rgasd_8 / ( Dcst_rayt_8 * Dcst_rayt_8 )
      c2  = Cstv_Beta_8 / ( Dcst_rayt_8 * Dcst_rayt_8 )
!
      if (Cori_cornl_L) then
         c3 = Cstv_Beta_8
      else
         c3 = Cstv_Beta_8 - one
      endif
!
!     Exchanging halos for derivatives & interpolation 
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call rpn_comm_xch_halo( F_u , LDIST_DIM,l_niu,l_nj,G_nk, &
                  G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo( F_v , LDIST_DIM,l_ni,l_njv,G_nk, &
                  G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo( F_t , LDIST_DIM,l_ni,l_nj,G_nk+1, &
                  G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo(F_BsPq,LDIST_DIM,l_ni,l_nj,G_nk+2, &
                  G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo( F_fip, LDIST_DIM,l_ni,l_nj,G_nk+2, &
                  G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      if (.not. Schm_hydro_L) then
         call rpn_comm_xch_halo( F_mu, LDIST_DIM,l_ni,l_nj,G_nk+1, &
                     G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      endif 
!
      nij = l_ni*l_nj
!
!
!$omp parallel private(i,j,i0,j0,jn,in, &
!$omp      BsPqbarz,fipbarz,tdiv, &
!$omp      xtmp_8,ytmp_8,wk1,wk2,ww1,barz,barzp)
!
!$omp do 
      do 1000 k = 1,l_nk 
!
!********************************
! Compute Ru: RHS of U equation *
!********************************

!     Set wk1 to 1 in the hydrostatic case as mu=0
      if (Schm_hydro_L) then
         do j = 1, l_nj
         do i = 1, l_ni
            wk1(i,j) = one
         end do
         end do
      endif

!     Set indices to compute Ru
      i0 = 1
      in = l_niu
      j0 = 1
      jn = l_nj

!     Compute (1 + mu) barXZ in wk1
      if (.not.Schm_hydro_L) then
         do j= j0, jn
         do i= i0, in
            barz  = Ver_wp_8%m(k)*F_mu(i  ,j,k+1) &
                   +Ver_wm_8%m(k)*F_mu(i  ,j,k)
            barzp = Ver_wp_8%m(k)*F_mu(i+1,j,k+1) &
                   +Ver_wm_8%m(k)*F_mu(i+1,j,k)
            wk1(i,j) = one + ( one - intuv_c0xxu_8(i) ) * barz &
                                   + intuv_c0xxu_8(i)   * barzp
         end do
         end do
      endif
!
      if ( abs(c3) .lt. 1.0e-6 ) then

!        Compute Ru without the Coriolis factor
         do j= j0, jn
         do i= i0, in
            barz  = Ver_wp_8%m(k)*F_t(i  ,j,k+1) &
                   +Ver_wm_8%m(k)*F_t(i  ,j,k)
            barzp = Ver_wp_8%m(k)*F_t(i+1,j,k+1) &
                   +Ver_wm_8%m(k)*F_t(i+1,j,k)
            F_oru(i,j,k) = Cstv_invT_8 * F_u(i,j,k) &
                     - c1 * ( ( one - intuv_c0xxu_8(i) ) * barz &
                                    + intuv_c0xxu_8(i)   * barzp ) &
                          * ( F_BsPq(i+1,j,k) - F_BsPq(i,j,k) )  &
                          * geomg_invDXu_8(i) &
                     - c2 * wk1(i,j) * ( F_fip(i+1,j,k) - F_fip(i,j,k) ) &
                          * geomg_invDXu_8(i)
         end do
         end do
 
      else

!        Compute Ru with the Coriolis factor
 
         if (G_lam) then
!           Reset indices
            if (l_west ) i0 = 2
            if (l_east ) in = l_niu-1
            if (l_south) j0 = 3
            if (l_north) jn = l_njv-1
         endif
 
!        Compute V barX in wk2
!        ~~~~~~~~~~~~~~~~~~~~~
         do j = j0, jn
         do i = i0-1, in+2
            wk2(i,j)  = inuvl_wyvy3_8(j,1) * F_v(i,j-2,k)  &
                      + inuvl_wyvy3_8(j,2) * F_v(i,j-1,k)  &
                      + inuvl_wyvy3_8(j,3) * F_v(i,j  ,k)  &
                      + inuvl_wyvy3_8(j,4) * F_v(i,j+1,k)          
         end do
         end do
 
!        Ru with the Coriolis factor
!        ~~~~~~~~~~~~~~~~~~~~~~~~~~~
         do j= j0, jn
         do i= i0, in
            barz  = Ver_wp_8%m(k)*F_t(i  ,j,k+1) &
                   +Ver_wm_8%m(k)*F_t(i  ,j,k)
            barzp = Ver_wp_8%m(k)*F_t(i+1,j,k+1) &
                   +Ver_wm_8%m(k)*F_t(i+1,j,k)
            F_oru(i,j,k) = Cstv_invT_8 * F_u(i,j,k) &
                     - c1 * ( ( one - intuv_c0xxu_8(i) )* barz &
                                    + intuv_c0xxu_8(i)  * barzp ) &
                          * ( F_BsPq(i+1,j,k) - F_BsPq(i,j,k) ) &
                          * geomg_invDXu_8(i) &
                     - c2 * wk1(i,j) * ( F_fip(i+1,j,k) - F_fip(i,j,k) ) &
                          * geomg_invDXu_8(i) &
                     + c3 * Cori_fcoru_8(i,j) &
                          * ( inuvl_wxxu3_8(i,1)*wk2(i-1,j) &
                            + inuvl_wxxu3_8(i,2)*wk2(i  ,j) &
                            + inuvl_wxxu3_8(i,3)*wk2(i+1,j) &
                            + inuvl_wxxu3_8(i,4)*wk2(i+2,j) )
         end do
         end do
!
      endif
!
!********************************
! Compute Rv: RHS of V equation *
!********************************
 
!     Set indices for computing Rv
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_njv
 
!     Compute (1 + mu) barYZ in wk1
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if (.not. Schm_hydro_L) then
         do j = j0, jn
         do i = i0, in
            barz  = Ver_wp_8%m(k)*F_mu(i,j  ,k+1) &
                   +Ver_wm_8%m(k)*F_mu(i,j  ,k)
            barzp = Ver_wp_8%m(k)*F_mu(i,j+1,k+1) &
                   +Ver_wm_8%m(k)*F_mu(i,j+1,k)
            wk1(i,j) = one + ( one - intuv_c0yyv_8(j) ) * barz  &
                                   + intuv_c0yyv_8(j)   * barzp
         end do
         end do
      endif
 
      if ( abs(c3) .lt. 1.0e-6 ) then

!        Compute Rv without the Coriolis factor
!        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         do j= j0, jn
         do i= i0, in
            barz  = Ver_wp_8%m(k)*F_t(i,j  ,k+1) &
                   +Ver_wm_8%m(k)*F_t(i,j  ,k)
            barzp = Ver_wp_8%m(k)*F_t(i,j+1,k+1) &
                   +Ver_wm_8%m(k)*F_t(i,j+1,k)
            F_orv(i,j,k) = Cstv_invT_8 * F_v(i,j,k) &
                     - c1 *( ( one - intuv_c0yyv_8(j) ) * barz &
                                   + intuv_c0yyv_8(j)   * barzp ) &
                          * ( F_BsPq (i,j+1,k) - F_BsPq (i,j,k) ) &
                          * geomg_invDYv_8(j) &
                     - c2 * wk1(i,j) * ( F_fip(i,j+1,k) - F_fip(i,j,k) ) &
                          * geomg_invDYv_8(j)
         end do
         end do

      else

!        Compute Rv with the Coriolis factor
!        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
         if (G_lam) then
!           Reset indices to compute Rv
            if (l_west ) i0 = 3
            if (l_east ) in = l_niu-1
            if (l_south) j0 = 2
            if (l_north) jn = l_njv-1
         endif
 
!        Compute U barY in wk2
!        ~~~~~~~~~~~~~~~~~~~~~
         do j = j0-1, jn+2
         do i = i0, in
            wk2(i,j)  = inuvl_wxux3_8(i,1)*F_u(i-2,j,k)  &
                      + inuvl_wxux3_8(i,2)*F_u(i-1,j,k)  &
                      + inuvl_wxux3_8(i,3)*F_u(i  ,j,k)  &
                      + inuvl_wxux3_8(i,4)*F_u(i+1,j,k) 
         end do
         end do
!
!        Rv with the Coriolis factor
         do j = j0, jn
         do i = i0, in
            barz  = Ver_wp_8%m(k)*F_t(i,j  ,k+1) &
                   +Ver_wm_8%m(k)*F_t(i,j  ,k)
            barzp = Ver_wp_8%m(k)*F_t(i,j+1,k+1) &
                   +Ver_wm_8%m(k)*F_t(i,j+1,k)
            F_orv(i,j,k) = Cstv_invT_8 * F_v(i,j,k) &
                     - c1 *( ( one - intuv_c0yyv_8(j) ) * barz &
                                   + intuv_c0yyv_8(j)   * barzp ) &
                          * ( F_BsPq(i,j+1,k) - F_BsPq (i,j,k) ) &
                          * geomg_invDYv_8(j) &
                     - c2 * wk1(i,j) * ( F_fip(i,j+1,k) - F_fip(i,j,k) ) &
                          * geomg_invDYv_8(j) &
                     - c3 * Cori_fcorv_8(i,j) &
                          * ( inuvl_wyyv3_8(j,1)*wk2(i,j-1) &
                            + inuvl_wyyv3_8(j,2)*wk2(i,j  ) &
                            + inuvl_wyyv3_8(j,3)*wk2(i,j+1) &
                            + inuvl_wyyv3_8(j,4)*wk2(i,j+2) )
         end do
         end do
!
      endif
!
 1000 continue
!$omp enddo
 
!     Indices for computing all fields on mass grid at routine output
      i0 = 1
      j0 = 1
      in = l_ni
      jn = l_nj
      if (G_lam) then
         if (l_west)  i0 = 4
         if (l_east)  in = l_niu-2
         if (l_south) j0 = 4
         if (l_north) jn = l_njv-2
      endif
!
!$omp do 
      do 2000 k = 1,l_nk+1 
!
!********************************************
! Compute Rt: RHS of thermodynamic equation *         
! Compute Rf: RHS of FI equation            *
!********************************************
!
      ww1 = one / Cstv_tstr_8
      do j = j0, jn
      do i = i0, in
         xtmp_8(i,j) = F_t(i,j,k) * ww1
      end do
      end do
      call vlog( ytmp_8, xtmp_8, nij )
!
                         ww1=Dcst_cappa_8
      if(Schm_autobar_L) ww1=0.d0
      do j= j0, jn
      do i= i0, in
         BsPqbarz = Ver_wp_8%t(k)*F_BsPq(i,j,k)+Ver_wm_8%t(k)*F_BsPq(i,j,k-1)
         fipbarz  = Ver_wp_8%t(k)* F_fip(i,j,k)+Ver_wm_8%t(k)* F_fip(i,j,k-1)
         F_ort (i,j,k) = Cstv_invT_8 * ( ytmp_8(i,j)-ln_that%t(k) - ww1 * BsPqbarz ) &
                       + Cstv_Beta_8 * (Dcst_cappa_8-dln_that%t(k)) * F_zd(i,j,k)
         F_orf (i,j,k) = Cstv_invT_8 * fipbarz  &
                       + Cstv_Beta_8 * Cstv_RTstr_8 * F_zd(i,j,k) &
                       + Cstv_Beta_8 * Dcst_grav_8 * F_w(i,j,k)
      end do
      end do         
!
!*********************************
! Compute Rw: RHS of  w equation *
!*********************************
!
      if (.not. Schm_hydro_L) then
         do j= j0, jn
         do i= i0, in
            F_orw(i,j,k) = Cstv_invT_8 * F_w(i,j,k) &
                         + Cstv_Beta_8 * Dcst_grav_8 * F_mu(i,j,k)
         end do
         end do
      endif 
!
 2000 continue
!$omp enddo
!
!*****************************************
! Compute Rc: RHS of Continuity equation *
!*****************************************
!
!$omp do
      do 3000 k = 1,l_nk
      do j = j0, jn
      do i = i0, in
         xtmp_8(i,j) = one + Ver_dbdz_8%m(k) * F_s(i,j)
      end do
      end do
      call vlog( ytmp_8, xtmp_8, nij)
!
                         ww1=one
      if(Schm_autobar_L) ww1=0.d0
!
      if(Schm_pior_L) then
         do j = j0, jn 
         do i = i0, in 
            xtmp_8(i,j) = (Ver_wp_8%m(k)*(Ver_wp_8%t(k+1)*verbm_8(k+1)  &
                                         +Ver_wm_8%t(k+1)*verbm_8(k  )) &
                        + Ver_wm_8%m(k)*( Ver_wp_8%t(k)  *verbm_8(k  )  &
                                         +Ver_wm_8%t(k)  *verbm_8(k-1)))*F_s(i,j)
         end do
         end do
      else
         do j = j0, jn 
         do i = i0, in 
            xtmp_8(i,j) = Ver_wp_8%m(k)*(Ver_wp_8%t(k+1)*F_BsPq(i,j,k+1) &
                                        +Ver_wm_8%t(k+1)*F_BsPq(i,j,k)) &
                        + Ver_wm_8%m(k)*(Ver_wp_8%t(k)*F_BsPq(i,j,k) &
                                        +Ver_wm_8%t(k)*F_BsPq(i,j,k-1))
         end do
         end do
      endif
      do j= j0, jn
      do i= i0, in
         tdiv = geomg_invcy2_8(j) * ( &
                (F_u(i,j,k)-F_u(i-1,j,k))*geomg_invDX_8(i) &
              + (F_v(i,j,k)-F_v(i,j-1,k))*geomg_invDY_8(j) )
         tdiv = tdiv      &
              + ( F_zd(i,j,k+1) - F_zd(i,j,k) ) * Ver_idz_8%m(k) &
              + Ver_wp_8%m(k) * F_zd(i,j,k+1) &
              + Ver_wm_8%m(k) * F_zd(i,j,k)
         F_orc (i,j,k) = Cstv_invT_8 * ( ww1 * xtmp_8(i,j) + ytmp_8(i,j) ) &
                       - Cstv_Beta_8 * tdiv   
      end do
      end do
 3000 continue
!$omp enddo
!
!$omp single
!
!******************************************************
! Interpolate Ru, Rv from U-, V-grid to G-grid, resp. *
!******************************************************

      call rpn_comm_xch_halo ( F_oru, LDIST_DIM,l_niu,l_nj,G_nk, &
                    G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo ( F_orv, LDIST_DIM,l_ni,l_njv,G_nk, &
                    G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
!$omp end single
!
!$omp do
      do k=1,l_nk
         do j = j0, jn
         do i = i0, in
            F_ruw1(i,j,k) =  inuvl_wxux3_8(i,1) * F_oru(i-2,j,k) &
                           + inuvl_wxux3_8(i,2) * F_oru(i-1,j,k) &
                           + inuvl_wxux3_8(i,3) * F_oru(i  ,j,k) &
                           + inuvl_wxux3_8(i,4) * F_oru(i+1,j,k)
            F_rvw1(i,j,k) =  inuvl_wyvy3_8(j,1) * F_orv(i,j-2,k) &
                           + inuvl_wyvy3_8(j,2) * F_orv(i,j-1,k) &
                           + inuvl_wyvy3_8(j,3) * F_orv(i,j  ,k) &
                           + inuvl_wyvy3_8(j,4) * F_orv(i,j+1,k)         
         end do
         end do
      end do
!$omp enddo
!
!**********************************************
! Apply HORIZONTAL BOUNDARY CONDITIONS if LAM *
!**********************************************
!
      if (G_lam) then
          if (l_west) then
!$omp do
             do k=1,l_nk
             do j= 1+pil_s, l_nj-pil_n
                F_ru (pil_w,j,k) = Cstv_invT_8 * F_nest_u(pil_w,j,k)
             enddo
             enddo
!$omp enddo
          endif
          if (l_east) then
!$omp do
             do k=1,l_nk
             do j= 1+pil_s, l_nj-pil_n
                F_ru (l_ni-pil_e,j,k) = Cstv_invT_8 * F_nest_u(l_ni-pil_e,j,k)
             enddo
             enddo
!$omp enddo
          endif
          if (l_south) then
!$omp do
             do k=1,l_nk
             do i= 1+pil_w, l_ni-pil_e
                F_rv (i,pil_s,k) = Cstv_invT_8 * F_nest_v(i,pil_s,k)
             enddo
             enddo
!$omp enddo
          endif
          if (l_north) then
!$omp do
             do k=1,l_nk
             do i= 1+pil_w, l_ni-pil_e
                F_rv (i,l_nj-pil_n,k) = Cstv_invT_8 * F_nest_v(i,l_nj-pil_n,k)
             enddo
             enddo
!$omp enddo
          endif
      endif
!
!$omp  end parallel
!
      return
      end
