!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r itf_phy_puti - 
!
#include "model_macros_f.h"
Integer Function itf_phy_puti(vd,opt) 

     Use phy_input_types
     Use phy_input_iface, Only : phy_simple_transforms
     Use itf_phy_iface  , Only : itf_phy_puti_casc
     Implicit None

     Type(variable), Pointer                  :: vd,temp,next
     Type(input_options)                      :: opt
     Type(input_dimensions), Dimension(nip1)  :: idim
     Character(len=1), Dimension(nip1)        :: grd,grref

      Integer, External :: fnom, fstouv, fstinf, fstprm, fstfrm, fclos, fstopc
      Integer, External :: fstluk, fstinl, wkoffit, ezgdef_fmem, ezdefset
      Integer, External :: ezsetopt, ip1_all, bmf_get, ezsint, newdate
      Logical, External :: samegrid
      Character, Parameter :: esc = Char( 27 )
!
!Author
!     Lubos Spacek - October 2009
!
!Revision
! v4_13 - Spacek, L.     - First revision
!
!Object
!     The function provides all arrays necessary for isba.
!     Different from itf_phy_puti_isba in that
!     the interpolation is done by local processors.
!
!Arguments
!          - Output -
! vd       Structure containing desired descriptors
!
!          - Input -
! opt      allowed options: geol_hsea,geol_poin,z0cst
!
!Implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "hgc.cdk"
#include "modconst.cdk"
#include "geomn.cdk"
#include "geomg.cdk"
#include "itf_phy_buses.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "path.cdk"
#include "ptopo.cdk"
#include "lun.cdk"
#include "lctl.cdk"
#include "p_geof.cdk"

      Integer :: i,j,k,ii,ij,ik,nf, nft, nr, iun=10, iok, ier,jer
      Integer :: target_file, tip
      Integer :: dte, det, ipas, p1, p2, p3, g1, g2, g3, g4, bit
      Integer :: dty, swa, lng, dlf, ubc, ex1, ex2, ex3
      Integer :: dum0,dum1,dum2,dum3,dum4,month,day,moa,jj
      Integer :: ni,nj,nk,nijk,sgid,dgid,kind,key,indx,indi,indj,offi,offj
      Integer, Parameter :: nmax=100, fmax=50, lenmax=150
      Integer, Dimension(nip1,4) :: keys,istat
      Logical :: found_L=.False.,interp_L, flag, ier_L
      Character(LEN=1) :: typ
      Character(LEN=4) :: var
      Character(LEN=12):: lab,cdum
      Character(LEN=lenmax), Dimension(fmax) :: file_found
      Character(LEN=lenmax+15):: command
      Real, Allocatable, Dimension(:,:) :: globalf,localf,field,field2,larr
      Real, Allocatable, Dimension(:,:) :: gmt,gfis
      Real, Allocatable, Dimension(:)   :: ax,ay,xfi,yfi
!
      Real :: zp1,poa,poam,sum,sumt
      Real :: busent, busper
      Real(kind=8)  :: rad2deg_8
      Pointer (pabusper,busper(*))
      Pointer (pabusent,busent(*))
!
temp=>vd
!
ier = fstopc('MSGLVL','SYSTEM',0)
ier = fstopc('TOLRNC','SYSTEM',0)
If(Lun_debug_L)ier = fstopc('MSGLVL','INFORM',0)
If(Lun_debug_L)ier = fstopc('TOLRNC','INFORM',0)
 Call prsdate (dum0,month,day,dum1,dum2,dum3,dum4,Mod_runstrt_S)
ier=Define_grids()
flag=.True.;itf_phy_puti=-1
!
If(Ptopo_myproc==0)&
Write(Lun_out,"(/,'PHYSICS ENTRY (S/R ITF_PHY_PUTI)',/,32('='),/)")
If(Lun_debug_L)Call Print_stack()
If(Ptopo_myproc==0)Allocate(globalf(G_ni,G_nj),Stat=ier)
     Allocate(localf(l_ni,l_nj),larr(l_minx:l_maxx,l_miny:l_maxy),Stat=ier)
!
Main1 : Do
! Initialization
  nft=Count_files()
!
If(nft/=0)Then
istat=0
Do target_file=1,nft
  idim=input_dimensions(-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1)
  If(Locate_key(keys)<0)Cycle
!
   Do tip=1,vd%p_nu

      Call RPN_COMM_bcast (idim(tip),11,"MPI_INTEGER"  ,0,"grid",ier)
      Call RPN_COMM_bcastc(grd(tip), 1,"MPI_CHARACTER",0,"grid",ier)

      nijk=idim(tip)%ni*idim(tip)%nj*idim(tip)%nk
      Allocate (field(idim(tip)%ni,idim(tip)%nj))
      Allocate(ax(idim(tip)%ni),ay(idim(tip)%nj))
!
      If(grd(tip)=='Z')Then
        If(Ptopo_myproc==0)Then
           interp_L=samegrid(iun,idim(tip)%ni,idim(tip)%nj, &
                    idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,&
                    Hgc_ig1ro,Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro,xfi,yfi)
        Endif
        Call RPN_COMM_bcast (interp_L,1,"MPI_LOGICAL"  ,0,"grid",ier)
        If(.Not.interp_L)Then
          ier=Read_Axes()
          Call RPN_COMM_bcastc(grref(tip), 1,"MPI_CHARACTER",0,"grid",ier)
          Call RPN_COMM_bcast (ax   ,idim(tip)%ni,"MPI_REAL"  ,0,"grid",ier)
          Call RPN_COMM_bcast (ay   ,idim(tip)%nj,"MPI_REAL"  ,0,"grid",ier)
          sgid = ezgdef_fmem(idim(tip)%ni,idim(tip)%nj,grd(tip),grref(tip),&
           idim(tip)%rig1,idim(tip)%rig2,idim(tip)%rig3,idim(tip)%rig4, ax, ay)
        Endif
     Else
        interp_L=.False.
        sgid = ezgdef_fmem(idim(tip)%ni,idim(tip)%nj, grd(tip),grref(tip),&
            idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,idim(tip)%ig4, ax, ay)

     Endif
!
     istat(tip,target_file)=Read_field()
        If(interp_L)Then
           Call glbdist (field,G_ni,G_nj, &
                            localf,1,l_ni,1,l_nj,1,0,0)
           If(Ptopo_myproc==0)Write(*,*)'SAMEGRID ',vd%nomvar,vd%ip1(tip)
        Else
           Call RPN_COMM_bcast (field,nijk   ,"MPI_REAL"  ,0,"grid",ier)
           ier = ezdefset ( dgid, sgid )
           ier = ezsetopt ('INTERP_DEGREE', vd%interp)
           ier = ezsint(localf, field)
        Endif
        ier=phy_simple_transforms(vd%phyvar,opt%z0cst,localf)
        vd%values(:,:,tip)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
        Deallocate(field,ax,ay)
   Enddo
   If(Ptopo_myproc==0)Then
      ier=fstfrm(iun);ier=fclos(iun)
   Endif
   If(Sum(istat(:,target_file))==vd%p_nu)Exit
Enddo
!
      if (.not.Final_check(.false.))Call itf_phy_puti_casc(vd,opt,istat(1,4))
      flag = Final_check(.true.)
!
   Elseif(NFT==0)Then
!
      If(vd%phyvar=='DLAT')localf=Geomn_latrx
      If(vd%phyvar=='DLON')localf=Geomn_lonrx
      If(vd%phyvar=='MF') Then
         gmmstat = gmm_get(gmmk_fis0_s,fis0,meta2d)
         if (GMM_IS_ERROR(gmmstat)) then
            write(*,*)'itf_phy_puti_isba: ERROR at gmm_get(fis0)'
            ier = -1
         endif
         Call handle_error_l(ier==0,'itf_phy_puti','put_info 1')
         localf=fis0(1:l_ni,1:nj)/Dcst_grav_8
      Endif
      If(vd%phyvar=='DXDY') Then
         Do j=1,l_nj
         Do i=1,l_ni
            localf(i,j)= geomg_hxu_8(i-1)*geomg_hyv_8(j-1)*     &
                         Dcst_rayt_8*Dcst_rayt_8*geomg_cy_8(j)
         Enddo
         Enddo
      Endif
      If(vd%phyvar=='EPONMOD')Then
          localf=1.0
          If(.not.G_lam)Call itf_phy_vlsp(localf)
      Endif
!
      ier=phy_simple_transforms(vd%phyvar,opt%z0cst,localf)
      vd%values(:,:,1)=localf(p_offi+1:p_ni+p_offi,p_offj+1:p_nj+p_offj)
!
      If(vd%phyvar=='ALVIS')Call itf_phy_puti_casc (vd,opt,istat(1,4))
   Endif
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
End Do Main1
!
Call handle_error_l(ier==0,'itf_phy_puti','put_info 2')
!
If(flag.And.Ptopo_myproc==0)Write(*,*)'All variables found!'
Call handle_error_l(flag,'itf_phy_puti','Missing variables, see the listing')
!
Call Cor_twater

If(Ptopo_myproc==0)Write(*,"(/a/72('='))")'PROCESSING ANCIENT GEOBUS'

vd=>temp
main2 : Do
   If(vd%inbus_L)Then    ! Do we put the variable in a bus?
   If(vd%bper_L) Then    ! Put into busper
      Do j=1,p_nj
         ij=vd%findx+(j-1)*p_bper_siz
         Do k=1,vd%p_nu
            ik=ij+(k-1)*p_ni
            Phy_busper3D(ik:ik+p_ni-1)=vd%values(:,j,k)
         Enddo
      Enddo
   Else                ! Put into the new busent
      Do j=1,p_nj
         ij=vd%findx+(j-1)*p_bent_siz
         Do k=1,vd%p_nu
            ik=ij+(k-1)*p_ni
            geofld(ik:ik+p_ni-1)=vd%values(:,j,k)
         Enddo
      Enddo
   Endif
   Endif            ! If not, next variable is treated
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
End Do main2
!
vd=>temp
!
Deallocate(localf,xfi,yfi)
If(Ptopo_myproc==0)Deallocate(globalf,Stat=ier)
itf_phy_puti=0
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Contains
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
Integer Function Locate_key(keys)
Implicit None
Integer,Dimension(30,4) :: keys
logical :: flag
!
Locate_key=-1 ; keys=-1 ; flag=.false.
!
If (Ptopo_myproc==0) Then

   ier = fnom   (iun,Trim(vd%file(target_file)),'RND+OLD+R/O',0)
   ier = fstouv (iun,'RND')

   Do tip=1,vd%p_nu
      If(vd%search(target_file)/='V')Then
         keys(tip,1) = Locate_ip1()
         Locate_key=Sign(1,keys(tip,1))
      Else
         If ( day .Gt. 15 ) Then
            jj = 32 - day
            If ( jj .Gt. 15 ) jj = 15
            moa = month + 1
            If ( month .Eq. 12 ) moa = 1
         Else
            jj  = day
            moa = month - 1
            If ( month .Eq. 1 ) moa = 12
         Endif
         poa = ( jj + 13 ) / 28.
         poam = 1. - poa

         vd%datev=-1
         Write(*,*)'    Interpolate ',vd%nomvar,' between months',moa,month

         vd%ip2=moa
         keys(tip,2) = Locate_ip1()
         If (keys(tip,2)<=0) Write(*,6000,advance='no')Trim(vd%nomvar),vd%ip2
         vd%ip2=month
         keys(tip,1) = Locate_ip1()
         If (keys(tip,1)<=0) Write(*,6000,advance='no')Trim(vd%nomvar),vd%ip2

         Locate_key=min(Sign(1,keys(tip,1)),Sign(1,keys(tip,2)))
      Endif
!
      If (Locate_key>=0) Then
         ier = fstprm (keys(tip,1),dte,det,ipas,&
                   idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,bit,dty, &
                   p1,p2, p3, typ, var, lab, grd(tip),&
                   idim(tip)%ig1, idim(tip)%ig2, idim(tip)%ig3, idim(tip)%ig4,&
                   swa, lng, dlf, ubc, ex1, ex2, ex3)
         If (grd(tip)=='Z') Then
            keys(tip,3) = fstinf (iun, ni,nj,nk,-1,' ',&
                          idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,' ','>>')
            keys(tip,4) = fstinf (iun, ni,nj,nk,-1,'',&
                          idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,'','^^')

            ier = fstprm (keys(tip,3),dte,det,ipas,ni,nj,nk,bit,dty,&
                      p1, p2, p3, typ, var, lab, grref(tip),&
                      idim(tip)%rig1, idim(tip)%rig2,&
                      idim(tip)%rig3, idim(tip)%rig4, swa,&
                      lng, dlf, ubc, ex1, ex2, ex3)
         Endif
      Else
         flag = .true.
      Endif
   Enddo
!
   if (flag) then
      ier=fstfrm(iun);ier=fclos(iun)
   endif
!
Endif
Call RPN_COMM_bcast (Locate_key,1,"MPI_INTEGER"  ,0,"grid",ier)
!
6000 Format(/,'!!! Error', 75('*'),/,'     Variable ',a,&
            ' not available at IP2: ',i5,/,'!!! Error',75('*'),/)
!
End Function Locate_key
!
!
!
Integer Function Locate_ip1()
If (vd%ip1(tip) .Eq. -1 .Or. vd%ip1(tip) .Eq. 0 ) Then
   Locate_ip1 = fstinf (iun, idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,vd%datev,vd%etk,&
                     vd%ip1(tip),vd%ip2,vd%ip3,vd%typvar,vd%nomvar )
  Else
   Call convip ( vd%ip1(tip), zp1, kind, -1, cdum, .False. )
   Locate_ip1 = fstinf (iun, idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,vd%datev,vd%etk,&
                     ip1_all(zp1,kind),vd%ip2,vd%ip3,vd%typvar,vd%nomvar )
Endif
End Function Locate_ip1
!
Integer Function Read_axes()
Read_axes=-1
If(Ptopo_myproc==0)Then
      If( keys(tip,3)>0)Then
          ier = fstluk( ax, keys(tip,3), idim(tip)%ni,1,      1)
          jer = fstluk( ay, keys(tip,4), 1,      idim(tip)%nj,1)
          Read_axes = ier*jer
      Endif
Endif
Call RPN_COMM_bcast (Read_axes,1,"MPI_INTEGER"  ,0,"grid",ier)
End Function Read_axes
!
Integer Function Read_field()
If(Ptopo_myproc==0)Then
Read_field=-1
ier = fstopc('MSGLVL','INFORM',0)
ier = fstopc('TOLRNC','INFORM',0)
   ier = fstluk( field, keys(tip,1), idim(tip)%ni,idim(tip)%nj,idim(tip)%nk)
   If( keys(tip,2)>0)Then
       Allocate(field2(idim(tip)%ni,idim(tip)%nj))
       ier = fstluk( field2, keys(tip,2), idim(tip)%ni,idim(tip)%nj,idim(tip)%nk)
       field = poa*field + poam*field2
       Deallocate(field2)
   Endif
Read_field=1
If(.Not.Lun_debug_L)ier = fstopc('MSGLVL','SYSTEM',0)
If(.Not.Lun_debug_L)ier = fstopc('TOLRNC','SYSTEM',0)
Endif
Call RPN_COMM_bcast (Read_field,1,"MPI_INTEGER"  ,0,"grid",ier)
!
End Function Read_field
!
Integer Function Define_grids()
!
Define_grids=0
!
!
! Local grid
!
If(.False.)Then
  Allocate(xfi(p_ni),yfi(p_nj))
   rad2deg_8 = 180.0d0/Acos(-1.d0)
  offi = Ptopo_gindx(1,Ptopo_myproc+1)-1
  offj = Ptopo_gindx(3,Ptopo_myproc+1)-1
  Do i=1,p_ni
     indx = p_offi + offi + i
     xfi(i) = G_xg_8(indx)*rad2deg_8
  End Do
  Do i=1,p_nj
     indx = p_offj + offj + i
     yfi(i) = G_yg_8(indx)*rad2deg_8
  End Do
  dgid = ezgdef_fmem (p_ni , p_nj , 'Z', 'E', Hgc_ig1ro,&
          Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
Deallocate(xfi,yfi)
Endif
  Allocate(xfi(l_ni),yfi(l_nj))
   rad2deg_8 = 180.0d0/Acos(-1.d0)
  offi = Ptopo_gindx(1,Ptopo_myproc+1)-1
  offj = Ptopo_gindx(3,Ptopo_myproc+1)-1
  Do i=1,l_ni
     indx = offi + i
     xfi(i) = G_xg_8(indx)*rad2deg_8
  End Do
  Do i=1,l_nj
     indx = offj + i
     yfi(i) = G_yg_8(indx)*rad2deg_8
  End Do
  dgid = ezgdef_fmem (l_ni , l_nj , 'Z', 'E', Hgc_ig1ro,&
          Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
Deallocate(xfi,yfi)
!
! Global grid
!
  Allocate(xfi(G_ni+1),yfi(G_nj))
   rad2deg_8 = 180.0d0/Acos(-1.d0)
  Do i=1,G_ni+1
     xfi(i) = G_xg_8(i)*rad2deg_8
  End Do
  Do i=1,G_nj
     yfi(i) = G_yg_8(i)*rad2deg_8
  End Do
  dstf_gid = ezgdef_fmem (G_ni , G_nj , 'Z', 'E', Hgc_ig1ro,&
          Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi , yfi )
End Function Define_grids
!
Integer Function Count_files()
Count_files=0
If(Ptopo_myproc==0)Then
   nf=0;nft=1;nr=0;
   file_found=''
! File names
      Do i=1,nfiles
         If(Len_trim(vd%file(i))/=0)Then
            nf=nf+1
            vd%file(nf)=Trim(Path_phy_S)//Trim(vd%file(i))
         Endif
      Enddo
   Do i=1,nreps
      If(Len_trim(vd%rep(i))/=0)nr=nr+1
   Enddo

   Do i = 1,nf
      Inquire (FILE=Trim(vd%file(i)),EXIST=found_L)
      If(.Not.found_L)Cycle
      ier=wkoffit(Trim(vd%file(i)))
      If((ier/=1).And.(ier/=2).And.(ier/=33).And.(ier/=34))Then
         Write (*,"('Format unknown',a)") Trim(vd%file(i))
         Cycle
      Endif
      file_found(nft)=vd%file(i)
      nft=nft+1
   Enddo
   Count_files=nft-1
Endif
Call RPN_COMM_bcast (Count_files,1,"MPI_INTEGER"  ,0,"grid",ier)
!
End Function Count_files
!
!
Logical Function Final_check (action)
Logical :: action

Logical           :: flag
Integer           :: i,j,k,ier,dtpr,tmpr
!
!     ---------------------------------------------------------------
!
If(Ptopo_myproc==0)Then
 flag=.true.
 ier = newdate(vd%datev,dtpr,tmpr,-3)
 Do j=1,vd%p_nu
    If(Sum(istat(j,:))==0)Then
       If(action)Write(*,6000)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j),dtpr,tmpr
       flag=.False..and.flag
    Else
       flag=.True..and.flag
       If(action)Then
          If(interp_L)Then
             Write(*,6010)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j),dtpr,tmpr
          Else
             Write(*,6020)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j),dtpr,tmpr
           Endif
       Endif
    Endif
 Enddo
Final_check=flag
If(action)write(*,'/')
Endif
!
Call RPN_COMM_bcast (Final_check,1,"MPI_LOGICAL"  ,0,"grid",ier)
!
 6000 Format(/,'!!! Error', 75('*'),/,'     Variable ',a,' alias ',a,&
             ' not available at LEVEL: ',i5,' DATEV: ',i8.8,1x,i8.8/,&
               '!!! Error',75('*'),/)
 6010 Format('     Variable ',a,' alias ',a,&
             '  distributed at LEVEL ',i5,' DATEV: ',i8.8,1x,i8.8)
 6020 Format('     Variable ',a,' alias ',a,&
             ' interpolated at LEVEL ',i5,' DATEV: ',i8.8,1x,i8.8)
!
!     ---------------------------------------------------------------
!
End Function Final_check
!
Subroutine Print_stack
temp=>vd
  Do
   Write(Lun_out,6000)
   Write(Lun_out,6010)vd%nomvar,vd%phyvar,vd%interp,vd%search,vd%etk,&
   vd%typvar,vd%findx
   Write(Lun_out,"('IP1',2(15i5,/,3x))")vd%ip1(1:vd%p_nu)
   Write(Lun_out,"('FILE ',2(a,/,5x))")(Trim(vd%file(i)),i=1,nfiles)
   Write(Lun_out,"('REPS ',2(a,/,5x))")(Trim(vd%rep(i)),i=1,nfiles)
   Write(Lun_out,"(72('='))")
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
End Do
vd=>temp
6000 Format('ENTRY NAME ','PHY NAME ',9x,'INTERP ',10x,'SEARCH ', &
'LABEL',3x,'TYPE',1x,'POSITION')
6010 Format(a4,7x,a16,2x,a16,2x,3a,3x,a8,2x,a2,i8)
End Subroutine Print_stack
!
!
Subroutine Cor_twater
Real :: grav,cpd,cor
grav = Dcst_grav_8
cpd  = Dcst_cpd_8
cor  = grav/cpd
vd=>temp
  Do
     If(vd%phyvar=='MF')Then
       Allocate(gfis(l_ni,l_nj))
       gfis=vd%values(:,:,1)
     Endif
     If(vd%phyvar=='MT')Then
       Allocate(gmt(l_ni,l_nj))
       gmt=vd%values(:,:,1)
     Endif
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
End Do
vd=>temp
If(Allocated(gfis).And.Allocated(gmt)) Then
  Do
     If(vd%phyvar=='TWATER')Then
       Where(gfis>gmt)vd%values(:,:,1)=vd%values(:,:,1)-(gfis-gmt)*cor
     Endif
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
  End Do
  vd=>temp
  Deallocate(gfis,gmt)
Endif
End Subroutine Cor_twater
!
End Function itf_phy_puti


