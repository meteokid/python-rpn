!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------


!**s/r itf_cpl_fillatm
!
#include "model_macros_f.h"
!
      subroutine itf_cpl_fillatm
      implicit none
!
!authors    Michel Desgagne - Spring 2008
! 
!revision
! v3_31 - Desgagne M.       - initial MPI version
! v4_06 - Lepine M.         - VMM replacement with GMM
!*
!implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "itf_cpl.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "geomn.cdk"
#include "cstv.cdk"
#include "lctl.cdk"
#include "ptopo.cdk"
#include "modconst.cdk"
#include "out3.cdk"
#include "rstr.cdk"
#include "pw.cdk"
!
      character*4 nomvar
      character*16 datev,datem
      logical flag,first
      integer err,i,j,send,recv,ii,jj,n
      real uug(l_ni,l_nj), vvg(l_ni,l_nj), tt(l_ni,l_nj), es(l_ni,l_nj)
      real, dimension (:,:,:), allocatable :: glbbus
      real*8  dayfrac,one,sid,rsid
      parameter(one=1.0d0, sid=86400.0d0, rsid=one/sid)
      data first/.true./
      save first
!     ________________________________________________________________
!
      call phycom ('COUPLING',.false.,1,'set')

      if (.not.C_coupling_L) return

      if (first) then
         if (Rstri_rstn_L.and.oce_hotstart) goto 1001
      endif

      atm_busin = 0.

      if (.not. ( (Lctl_step.ge.cpl_debut)   .and. &
                  (Lctl_step.le.cpl_fin)     .and. &
                  (mod(Lctl_step-cpl_debut,cpl_freq).eq.0) )) return
!
      nullify (pw_uu_plus,pw_vv_plus)
      gmmstat = gmm_get(gmmk_pw_uu_plus_s ,pw_uu_plus,meta3d)
      gmmstat = gmm_get(gmmk_pw_vv_plus_s ,pw_vv_plus,meta3d)

      uug(:,:) = pw_uu_plus(1:l_ni,1:l_nj,G_nk+2)
      vvg(:,:) = pw_vv_plus(1:l_ni,1:l_nj,G_nk+2)
!
      call wind_rot2ll (uug,vvg,Geomn_lonrx,Geomn_latrx,l_ni*l_nj)
!
      call diag_ttes (tt,es,l_ni,l_nj,G_nk+2)
!
      atm_local_busou(:,:,1) = tt
      atm_local_busou(:,:,2) = uug
      atm_local_busou(:,:,3) = vvg
      atm_local_busou(:,:,4) = es
!
      allocate (glbbus(G_ni,G_nj,max(n_fldou,n_fldin)))
      call glbcolc (glbbus, G_ni, G_nj, atm_Local_busou, &
                              1, l_ni, 1, l_nj, n_fldou)
!
      err = 0
      if (Ptopo_myproc.eq.0) then
!
         dayfrac = dble(Lctl_step)*Cstv_dt_8*rsid
         call incdatsd  (datev,Mod_runstrt_S,dayfrac)
         dayfrac = dble( max(Lctl_step-cpl_freq,0) )*Cstv_dt_8*rsid
         call incdatsd  (datem,Mod_runstrt_S,dayfrac)
!
         do n=1,n_fldou
            jj = 0
            do j=cpl_j0,cpl_jn
               jj= jj+1
               ii= 0
               do i=cpl_i0,cpl_in
                  ii=ii+1
                  atm_busou(ii,jj,n,1) = glbbus(i,j,n)
                  atm_busou(ii,jj,n,2) = 1.
               end do
            end do
         end do

         call cpl_exchg (datev(1:15),atm_busou, datem(1:15),atm_busin,  &
                                        cpl_ni, cpl_nj, 2, send, recv)

         if ((send.eq.-100).or.(recv.eq.-100)) THEN
            CALL itf_cpl_pseudoW (datev, Lctl_step, int(Cstv_dt_8), Out3_date, send)
            CALL itf_cpl_pseudoR (datev, Lctl_step, recv)
         ENDIF

         glbbus = 0.
         do n=1,n_fldin
            jj = 0
            do j=cpl_j0,cpl_jn
               jj=jj+1
               ii = 0
               do i=cpl_i0,cpl_in
                  ii=ii+1
                  glbbus(i,j,n) = atm_busin(ii,jj,n)
               end do
            end do
         end do

         if ((send.lt.0).or.(recv.lt.0)) then
            write (6,9900)
            C_coupling_L = .false.
            if (.not. C_continue_L) then
               err = -1
               goto 999
            endif
            write (6,9901)
         endif
!
         flag = (mod(Lctl_step,1).eq.0)
         flag = .false.
         if (flag) then
            do i=1,n_fldou
            nomvar = nv_writ(i)(5:7)
            if (nomvar.eq.'UDA') nomvar='UU'
            if (nomvar.eq.'VDA') nomvar='VV'
            call r_rawfstw2(atm_busou(1,1,i,1),1,cpl_ni,1,cpl_nj,1,1,     &
                                        nomvar,1,cpl_ni,1,cpl_nj,1,1,     &
                                      Lctl_step,int(Cstv_dt_8),Out3_date, &
                                             -1,-1,'..//gem_cpl_out.fst')
            call statfld3 (atm_busou(1,1,i,1),nomvar,Lctl_step, &
               "",1,cpl_ni,1,cpl_nj,1,1, 1,1,1,cpl_ni,cpl_nj,1,4)
            end do
            do i=1,n_fldin
            nomvar = nv_read(i)(5:7)
            if (nomvar.eq.'UDA') nomvar='UU'
            if (nomvar.eq.'VDA') nomvar='VV'
            call r_rawfstw2(  atm_busin(1,1,i),1,cpl_ni,1,cpl_nj,1,1,     &
                                        nomvar,1,cpl_ni,1,cpl_nj,1,1,     &
                                      Lctl_step,int(Cstv_dt_8),Out3_date, &
                                             -1,-1,'..//gem_cpl_in.fst')
            call statfld3 (atm_busin(1,1,i),nomvar,Lctl_step, &
             "",1,cpl_ni,1,cpl_nj,1,1, 1,1,1,cpl_ni,cpl_nj,1,4)
            end do
         endif
!
      endif
!
 999  call handle_error(err,'itf_cpl_fillatm','ITF_CPL_FILLATM')
      call RPN_COMM_bcast (C_coupling_L, 1, "MPI_LOGICAL", 0,"grid",err)
      if (.not.C_coupling_L) return

      call glbdist (glbbus, G_ni, G_nj, atm_local_busin, &
                        1, l_ni, 1, l_nj, n_fldin, 0, 0)
!
      atm_local_busin (1:l_ni,1:l_nj,2)=   &
         max(atm_local_busin (1:l_ni,1:l_nj,2),250.)

! Next IF line is used to simulate an NC in full CPL mode
! and to force (one-way coupled) the ROM model

!      IF (Lctl_step.eq.0) then
         call phycom ('COUPLING',.true.,1,'set')
!      endif

       deallocate (glbbus)
!
 1001 first = .false.

 9900 format (/,' PROBLEM WITH COUPLER')
 9901 format (/,' WILL CONTINUE WITHOUT'/)
!
!     ________________________________________________________________
!
      return
      end

