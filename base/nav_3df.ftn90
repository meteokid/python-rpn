!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r nav_3df
!
#include "model_macros_f.h"
!
      integer function nav_3df2 (unf)
      implicit none
#include <arch_specific.hf>
!
      integer unf
!
!author 
!     Michel Desgagne   - Summer 2006
!
!revision
! v3_30 - Desgagne M.     - initial version
!
#include "blk_input.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "grd.cdk"
#include "ptopo.cdk"
#include "ifd.cdk"
!
      logical needitx,needity,wb,eb,sb,nb
      integer i,j,nia,nja,i0,j0,npx,npy,m,n
      real xpos_debut,ypos_debut,xpos_fin,ypos_fin
      real xda,xfa,yda,yfa
      real*8 xd_8, xf_8, yd_8, yf_8
      real*8 xi,xf,yi,yf,xri,xrf,yri,yrf,deg2rad_8,resax,resay
!
!-----------------------------------------------------------------------
!
      nav_3df2= 0

      xd_8= blk_xg_8(0,1)
      xf_8= blk_xg_8(Ptopo_numpe_perb-1,2)
      yd_8= blk_yg_8(0,1)
      yf_8= blk_yg_8(Ptopo_numpe_perb-1,2)
!
! Considering data coverage of individual input files, determine
! which files are needed for local target data coverage of Ptopo_myproc 
! and verify that input data coverage is sufficient.
!
      ifd_nf     =  1
      ifd_cnt    =  0
      ifd_niad   =  200000 
      ifd_njad   =  200000
      ifd_niaf   = -200000  
      ifd_njaf   = -200000
      ifd_needit = .false.

      wb= .false. ; eb= .false. ; sb= .false. ; nb= .false.
!
! Determine input data resolution resax, resay
! (Best if this comes directly from the driving model)
!
      deg2rad_8  = Dcst_pi_8/180.d0
      npx        =      0
      npy        =      0
      xpos_debut =  1.e20
      ypos_debut =  1.e20
      xpos_fin   = -1.e20
      ypos_fin   = -1.e20
! 10   read (unf,304,end=20) i0, j0, xda, xfa, yda, yfa, nia, nja, ifd_overlap
 10   read (unf,*,end=20) i0, j0, xda, xfa, yda, yfa, nia, nja, ifd_overlap
      npx = max (npx, i0 + nia - 1)
      npy = max (npy, j0 + nja - 1)
      xpos_debut = min(xpos_debut,xda)
      ypos_debut = min(ypos_debut,yda)
      xpos_fin   = max(xpos_fin  ,xfa)
      ypos_fin   = max(ypos_fin  ,yfa)
      goto 10

 20   resax = 1.01*Grd_dx*deg2rad_8 + (xpos_fin-xpos_debut)/npx * 2.
      resay = 1.01*Grd_dy*deg2rad_8 + (ypos_fin-ypos_debut)/npy * 2.
!
! Limits of data coverage that must be satisfied for local grid
!
      xi  = xd_8 - resax
      yi  = yd_8 - resay
      xf  = xf_8 + resax
      yf  = yf_8 + resay

      resax = Grd_dx*deg2rad_8/1000.
      resay = Grd_dy*deg2rad_8/1000.

      xri = xd_8 + resax
      yri = yd_8 + resay
      xrf = xf_8 - resax
      yrf = yf_8 - resax
!
! Read the file again and compare data coverage
!
      rewind (unf)
! 1    read (unf,304,end=2) i0, j0, xda, xfa, yda, yfa, nia, nja, ifd_overlap
 1    read (unf,*,end=2) i0, j0, xda, xfa, yda, yfa, nia, nja, ifd_overlap

      needitx = .false.
      needity = .false.
      if (xda.lt.xi) then
         if (xfa.ge.xi) needitx=.true.
      else
         if (xda.le.xf) needitx=.true.
      endif
      if (yda.lt.yi) then
         if (yfa.ge.yi) needity=.true.
      else
         if (yda.le.yf) needity=.true.
      endif

      ifd_needit(ifd_nf) = .false.
      if (needitx.and.needity) then
         ifd_needit(ifd_nf) = .true.
         ifd_cnt          = ifd_cnt + 1
	 ifd_minx(ifd_nf) = i0
         ifd_miny(ifd_nf) = j0
         ifd_maxx(ifd_nf) = i0 + nia - 1
         ifd_maxy(ifd_nf) = j0 + nja - 1
         ifd_xia (ifd_nf) = xda
         ifd_yia (ifd_nf) = yda
         ifd_xfa (ifd_nf) = xfa
         ifd_yfa (ifd_nf) = yfa
         ifd_niad = min(ifd_niad,ifd_minx(ifd_nf))
         ifd_njad = min(ifd_njad,ifd_miny(ifd_nf))
         ifd_niaf = max(ifd_niaf,ifd_maxx(ifd_nf))
         ifd_njaf = max(ifd_njaf,ifd_maxy(ifd_nf))
         write (ifd_fnext(ifd_nf),'((i7.7),a1,(i7.7))') i0,'-',j0
         wb = wb .or. (ifd_xia(ifd_nf).le.xri)
         eb = eb .or. (ifd_xfa(ifd_nf).ge.xrf)
         sb = sb .or. (ifd_yia(ifd_nf).le.yri)
         nb = nb .or. (ifd_yfa(ifd_nf).ge.yrf)
      endif

      if (ifd_overlap .and. ifd_needit(ifd_nf)) then
         if ((wb).and.(eb).and.(sb).and.(nb)) then
            goto 66
         else
            ifd_needit(ifd_nf) = .false.
            ifd_cnt            = 0
            wb= .false. ; eb= .false. ; sb= .false. ; nb= .false.
         endif
      endif

      ifd_nf = ifd_nf + 1
      goto 1
 2    ifd_nf = ifd_nf - 1

      if (.not.((wb).and.(eb).and.(sb).and.(nb))) then
         write (6,202) wb,eb,sb,nb,Ptopo_mybloc
         nav_3df2 = -1
      endif

 202  format (/' INSUFFICIENT INPUT DATA COVERAGE - wb,eb,sb,nb:',4L4, &
               ', BLOCK#:',i4,' --ABORT--'/)
 304  format (2i8,4e15.7,2i10,l4)
!
!-----------------------------------------------------------------------
!
 66   close (unf)
      return
      end
