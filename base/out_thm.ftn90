!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r out_thm - output  temperature, humidity and mass fields
!
#include "model_macros_f.h"
!
      subroutine out_thm( wlnph_m,wlnph_ta, F_st1, DIST_DIM,nk,levset,set)
!
      implicit none
!
      integer nk,DIST_DIM,levset,set

      real  &
           F_st1(DIST_SHAPE), &
           wlnph_m(DIST_SHAPE,0:nk+1), wlnph_ta(DIST_SHAPE,nk+2)
   
!
!author
!     james caveen/andre methot  - rpn june/nov 1995
!
!revision
! v2_00 - Lee V.            - initial MPI version (from blocthm v1_03)
! v2_11 - Desgagne M.       - ptop producubility
! v2_21 - Desgagne M.       - new calling sequence for glbdist + correct
! v2_21                       calling sequence mfohra
! v2_21 - J. P. Toviessi    - set dieze (#) slab output and rename
! v2_21                       truncate model output names to 4 characters
! v2_30 - Lee V.            - reorganize slab output to be more efficient
! v2_30 - Edouard S.        - adapt for vertical hybrid coordinate
! v2_30                     - change call to p0vt2gz_hyb
! v2_32 - Lee V.            - reduce dynamic allocation size, add HU,ME output
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_01 - Lee V.            - Added output of ThetaW
! v3_01 - Morneau J.        - remove conversion to Celcius for TL or AD output
! v3_02 - Plante A.         - Water loading
! v3_02 - Lee V.            - LA and LO output (not physics), add QC output
! v3_03 - Lee V.            - correct bug for illegal access to all h2o tracers
! v3_03                       if Schm_phyms_L is false.
! v3_11   Tanguay M.        - Add TLM and ADJ increments TT and P0
!                           - Extend TRAJ for conversion for DYNOUT2
! v3_20   Lee V.            - Output in blocks, standard files
! v3_21 - Lee V.            - Output Optimization
! v3_22 - Tanguay M.        - pad fit1 (undefined values when Out3_vt2gz
! is F)
! v3_22 - Lee V.            - reduced args in calling sequence for calzz
! v3_30 - Bilodeau/Tanguay  - Output pair (TT,HU) for the adjoint
! v3_30 - Plante A.         - Correction for THETA (TH) output
! v4_04 - Tanguay M.        - Staggered version TL/AD
! v4_05 - Lee V.            - adaptation to GMM
! v4_40 - Lee V.            - change in argument call for this routine & prgen
!
!object
!     See above id.
!
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! dostep     I    - array containing indices corresponding to the
!                     timestep sets that requires output at this time step.
! dostep_max I    - size of dostep array
!
! Index vectors for level identifications
! ----------------------------------------
!
! =========== thermo levels  momentum levels    top 
! o o o o o o  =>  1   
! - - - - - - - - - - - - -    =>  1
!
! ===========  =>  2
!  
!    ...      
!
!
! ===========  =>  k 
!
! - - - - - - - - - - - - -    =>  k
!
!    ...         
!
! ===========  =>  G_nk 
!
! - - - - - - - - - - - - -    =>  G_nk
! o o o o o o  =>  G_nk+1
! ===========      G_nk+2      =>  G_nk+1      surface
!
!----------------------------------------------------------------------
! 
!implicits

#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "geomn.cdk"
#include "schm.cdk"
#include "vt1.cdk"
#include "vtx.cdk"
#include "p_geof.cdk"
#include "out.cdk"
#include "out3.cdk"
#include "grd.cdk"
#include "level.cdk"
#include "outd.cdk"
#include "ptopo.cdk"
#include "lctl.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "cstv.cdk"
#include "vinterpo.cdk"
!
!modules
!
!*
      type :: stg_i
         integer :: t,m,p
      end type stg_i

      real theta_p0,deg2rad

      parameter (theta_p0=100000.)

      integer i,j,k,kl,ii,l_ninj,nko,nko_t,nko_m
      integer, dimension(:), allocatable::indo,indo_t
      real wk1(G_ni,G_nj),wk2(G_ni,G_nj)
      real wk3(G_ni,G_nj+2),wk4(G_ni,G_nj+2)
      real w1(LDIST_SHAPE), w2(LDIST_SHAPE)
      real w3(LDIST_SHAPE,nk+2)
      real qh(LDIST_SHAPE,nk+2)
      real posit((l_maxx-l_minx+1)*(l_maxy-l_miny+1)*(G_nk+1)*6)
      real huv((l_maxx-l_minx+1)*(l_maxy-l_miny+1)*(G_nk+6)*2)
      real kbot(LDIST_SHAPE,G_nk+1),ktop(LDIST_SHAPE,G_nk+1)
      real ,dimension(:,:,:), allocatable::px_pres,hu_pres,td_pres,w5
      real ,dimension(:,:,:), allocatable::tt_pres,vt_pres
      real ,dimension(:), allocatable::prprlvl,rf
      real ptop(LDIST_SHAPE),p0(LDIST_SHAPE)
      real px_ta(LDIST_SHAPE,nk+2),px_m(LDIST_SHAPE,nk+1), th(LDIST_SHAPE,nk+2)
      real tt(LDIST_SHAPE,nk+2),hu(LDIST_SHAPE,nk+2),t8(LDIST_SHAPE,nk+2), &
           vt(LDIST_SHAPE,nk+2),gz(LDIST_SHAPE,nk), omega(LDIST_SHAPE,nk+2)
      real, pointer    , dimension(:,:,:) :: tr1,hut1,qct1
      character*2 h2o_liste_S(7)
      data h2o_liste_S / 'QC','QB','QL','QI','QN','QJ','QH'/
      integer n,kind
      integer :: lastdt = -1
      real, dimension(:,:,:), pointer :: gz_m_plus,gz_ta,ttx,htx
      real, dimension(:,:), pointer :: wlao
      save lastdt,gz_m_plus,gz_ta,htx,ttx,wlao
! ___________________________________________________________________
!
!     1.0     initialization of data
!_______________________________________________________________________
!
      integer      &
              pngz,pnvt,pntt,pnes,pntd, &
              pnhr,pnpx,pnhu,pntw,pnqc, &
              pnww,pnzz,pnth
      integer pnpn,pnp0,psum,pnpt,pnla,pnlo,pnme,pnmx

      integer nbit(0:Outd_var_max(set)+1),filt(0:Outd_var_max(set)+1)
      real    coef(0:Outd_var_max(set)+1)

!     initialize conversion of units

      real*8, parameter :: ZERO_8 = 0.0
      real    prmult_pngz, prmult_pnpx, prmult_pnme
      real    pradd_pnvt,  pradd_pntt,  pradd_pntd

      prmult_pngz  = 0.1 / Dcst_grav_8
      prmult_pnpx  = 0.01
      prmult_pnme  = 1.0 / Dcst_grav_8

      pradd_pnvt   = -Dcst_tcdk_8
      pradd_pntt   = -Dcst_tcdk_8
      pradd_pntd   = -Dcst_tcdk_8


      pnpn=0
      pnp0=0
      pnpt=0
      pnla=0
      pnlo=0
      pnme=0
      pnmx=0

      pngz=0
      pnvt=0
      pntt=0
      pnes=0
      pntd=0
      pnhr=0
      pnpx=0
      pnhu=0
      pntw=0
      pnqc=0
      pnww=0
      pnzz=0
      pnth=0

      do ii=0,Outd_var_max(set)
         coef(ii)=0.0
         filt(ii)=0
         nbit(ii)=0
      enddo
      
      do ii=1,Outd_var_max(set)
        if (Outd_var_S(ii,set).eq.'PN') pnpn=ii
        if (Outd_var_S(ii,set).eq.'P0') pnp0=ii
        if (Outd_var_S(ii,set).eq.'PT') pnpt=ii
        if (Outd_var_S(ii,set).eq.'LA') pnla=ii
        if (Outd_var_S(ii,set).eq.'LO') pnlo=ii
        if (Outd_var_S(ii,set).eq.'ME') pnme=ii
        if (Outd_var_S(ii,set).eq.'MX') pnmx=ii
        nbit(ii)=Outd_nbit(ii,set)
        filt(ii)=Outd_filtpass(ii,set)
        coef(ii)=Outd_filtcoef(ii,set)
      enddo

      do ii=1,Outd_var_max(set)
         if (Outd_var_S(ii,set).eq.'GZ') pngz=ii
         if (Outd_var_S(ii,set).eq.'VT') pnvt=ii
         if (Outd_var_S(ii,set).eq.'TT') pntt=ii
         if (Outd_var_S(ii,set).eq.'ES') pnes=ii
         if (Outd_var_S(ii,set).eq.'TD') pntd=ii
         if (Outd_var_S(ii,set).eq.'HR') pnhr=ii
         if (Outd_var_S(ii,set).eq.'PX') pnpx=ii
         if (Outd_var_S(ii,set).eq.'HU') pnhu=ii
         if (Outd_var_S(ii,set).eq.'TW') pntw=ii
         if (Outd_var_S(ii,set).eq.'QC') pnqc=ii
         if (Outd_var_S(ii,set).eq.'WW') pnww=ii
         if (Outd_var_S(ii,set).eq.'ZZ') pnzz=ii
         if (Outd_var_S(ii,set).eq.'TH') pnth=ii
        nbit(ii)=Outd_nbit(ii,set)
        filt(ii)=Outd_filtpass(ii,set)
        coef(ii)=Outd_filtcoef(ii,set)
      enddo

      if (pnpt.ne.0.and.Grd_rcoef(2).ne.1.0) pnpt=0

      psum=pnpn+pnp0+pnpt+pnla+pnlo+pnme+pnmx

      psum=psum +  &
           pngz+pnvt+pntt+pnes+pntd+pnhr+pnpx+pnhu+ &
           pntw+pnqc+pnww+pnzz+pnth

      if (psum.eq.0)return

!_______________________________________________________________________

!     Obtain humidity HUT1 and other GMM variables
      nullify(hut1)
      gmmstat = gmm_get('TR/'//'HU'//':P',hut1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'out_thm ERROR at gmm_get(hut1)'
      if (pnqc.ne.0) then
          nullify(qct1)
          gmmstat = gmm_get('TR/'//'QC'//':P',qct1,meta3d)
!     if QC is not available, forget it
          if (GMM_IS_ERROR(gmmstat)) pnqc=0
      endif 
      gmmstat = gmm_get(gmmk_fiptx_s,fiptx,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'out_dyn ERROR at gmm_get(fiptx)'
      gmmstat = gmm_get(gmmk_tt1_s,tt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'out_dyn ERROR at gmm_get(tt1)'
      gmmstat = gmm_get(gmmk_wt1_s,wt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'out_dyn ERROR at gmm_get(wt1)'
      gmmstat = gmm_get(gmmk_fis0_s,fis0,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'out_dyn ERROR at gmm_get(fis0)'
!_______________________________________________________________________
!
!     Compute Virtual temperature
!     Always With water loading
         qh =0.
         do n=1,7
            nullify (tr1)
            gmmstat = gmm_get('TR/'//h2o_liste_S(n)//':P',tr1,meta3d)
            if (.not.GMM_IS_ERROR(gmmstat)) then
                do k=1,l_nk+2
                do j=1,l_nj
                do i=1,l_ni
                   qh (i,j,k) = qh (i,j,k) + max(0.0,tr1(i,j,k))
                enddo
                enddo
                enddo
            endif
         enddo
         call mfottvh2 (tt1,w3,hut1,qh,l_minx,l_maxx, &
                        l_miny,l_maxy,l_nk+2,1,l_ni,1,l_nj,.true.)
         do k=1,l_nk+2
            do j=1,l_nj
            do i=1,l_ni
               vt (i,j,k) = tt1(i,j,k) + w3(i,j,k) * qh(i,j,k)
            enddo
            enddo
         enddo
!
!     Compute or store Geopotential Height (GZ)

      do k=1,l_nk
         do j=1,l_nj
         do i=1,l_ni
            gz (i,j,k) = fiptx(i,j,k)+Ver_fistr_8%m(k)
         enddo
         enddo
      enddo

!     Store PTOP (PT)
      ptop (:,:) = Cstv_ptop_8
      l_ninj=(l_maxx-l_minx+1)*(l_maxy-l_miny+1)
!     Compute and store P0
      w1(:,:)=F_st1(:,:)
      call vsexp (w2,w1,l_ninj)
!
      do j=l_miny,l_maxy
      do i=l_minx,l_maxx
         p0   (i,j) = w2(i,j)*Cstv_pref_8
      end do
      end do
!
!_________________________________________________________________
!
!     2.0    Output 2D variables 
!_________________________________________________________________
!     output 2D fields on 0mb (pressure)
      kind=2
!
      if (pnme.ne.0)then
            call ecris_fst2(fis0,l_minx,l_maxx,l_miny,l_maxy,0.0, &
              'ME  ',prmult_pnme,0.0,kind,1,1, 1, nbit(pnme) )
         endif
      if (pnmx.ne.0)then
            call ecris_fst2(fis0,l_minx,l_maxx,l_miny,l_maxy,0.0, &
              'MX  ',1.0,0.0,kind,1,1, 1, nbit(pnmx) )
         endif
      if (pnpt.ne.0) &
          call ecris_fst2(ptop,l_minx,l_maxx,l_miny,l_maxy,0.0, &
              'PT  ',.01,0.0,kind,1, 1, 1, nbit(pnpt) )
      if (pnla.ne.0) &
          call ecris_fst2(Geomn_latrx,1,l_ni,1,l_nj,0.0, &
              'LA  ',1.0,0.0,kind,1, 1, 1, nbit(pnla) )
      if (pnlo.ne.0) &
          call ecris_fst2(Geomn_lonrx,1,l_ni,1,l_nj,0.0, &
              'LO  ',1.0,0.0,kind,1, 1, 1, nbit(pnlo) )

!_______________________________________________________________________
!
!     3.0    Precomputations for output over pressure levels or PN or 
!            GZ on thermo levels
!
!        The underground extrapolation can use precalculated
!        temperatures over fictitious underground geopotential levels.
!        The number of fictitious levels is "Out3_nundr".
!        The levels in meters are stored in "Out3_zund(Out3_nundr)".
!        Both "Out3_nundr" and "Out3_zund" are user's given 
!        parameters.
!_______________________________________________________________________
!

      If (lastdt .eq. -1) then
          allocate ( ttx(LDIST_SHAPE,Out3_nundr),htx(LDIST_SHAPE,Out3_nundr), &
                     gz_ta(LDIST_SHAPE,nk+2), gz_m_plus(LDIST_SHAPE,0:nk+1), &
                     wlao(LDIST_SHAPE))
!         Store WLAO (latitude in rad)
          deg2rad    = acos( -1.0)/180.
          do j=1,l_nj
          do i=1,l_ni
             wlao (i,j) = Geomn_latrx(i,j) * deg2rad
          end do
          end do
      endif

!     Compute GZ on thermo levels in gz_ta
      if ( lastdt .ne. Lctl_step ) then
         do k=1,l_nk
            do j= 1, l_nj
            do i= 1, l_ni
               gz_m_plus(i,j,k)=gz(i,j,k)
            enddo
            enddo
         enddo
         gz_m_plus(:,:,1:l_nk)= gz(:,:,:) 
         gz_m_plus(:,:,0)=fiptx(:,:,0)+Ver_fistr_8%m(0)
         gz_m_plus(:,:,l_nk+1)=fis0(:,:)
         call out_padbuf(gz_m_plus,l_minx,l_maxx,l_miny,l_maxy,G_nk+2)
         gz_ta(:,:,l_nk+2)=gz_m_plus(:,:,l_nk+1)
!     Precomputations for interpolation from momentum to thermo levels.
         v_interp='CUBIC_UQAM'
         call posiz3 (posit,huv,wlnph_m,wlnph_ta,ktop,kbot,l_ninj,G_nk+1,G_nk+2)
         call vertint3(gz_ta,gz_m_plus,posit,huv,l_ninj,G_nk+1,G_nk+2)
      endif
      if ( Out3_nundr.gt.0 .and. lastdt .ne. Lctl_step ) then
         
       do 200 kl=1,Out3_nundr

         do 160 j=1,l_nj
         do 150 i=1,l_ni

!        Store fictitious height level in htx

         htx(i,j,kl) = Out3_zund(kl) * Dcst_grav_8

!        Determine if fictitious level is above or below ground

         w1(i,j) = fis0(i,j) - htx(i,j,kl)

         if ( w1(i,j) .gt. 0 ) then

!           fictitious level is under ground:
!           temperature is obtained by linear EXTrapolation
!           identify under ground grid point
! 
            if ( abs( wlao(i,j)*180./Dcst_pi_8 ) .ge. 49. ) then

                w1(i,j) = vt(i,j,G_nk+2) +       .0005 * w1(i,j)
            else
                w1(i,j) = vt(i,j,G_nk+2) + Dcst_stlo_8 * w1(i,j)
            endif

            w2(i,j) = 1.0

        else

!           fictitious level is above ground:
!           temperature is obtained by linear INTerpolation
!           identify above ground grid point

            do k=l_nk+1,1,-1
               w1(i,j) = gz_ta (i,j,k) - htx(i,j,kl)
               if ( w1(i,j) .gt. 0. ) goto 10
            enddo
 10         continue
            
            w2(i,j)= - (   vt(i,j,k) -    vt(i,j,k+1) ) / &
                     (gz_ta(i,j,k) - gz_ta(i,j,k+1) )
            
            w1(i,j) = vt (i,j,k) + w2(i,j) * w1(i,j)

            w2(i,j) = 0.0

         endif

 150     continue
 160     continue

         call glbcolc (wk1,G_ni,G_nj,w1,l_minx,l_maxx,l_miny,l_maxy,1)
         call glbcolc (wk2,G_ni,G_nj,w2,l_minx,l_maxx,l_miny,l_maxy,1)

!        For all under ground grid points at level htx(i,j,kl)
!        recompute temperature by HORIZONTAL interpolation
!
         if (Ptopo_myproc.eq.0)  &
              call liebman_2 (wk1,wk2,wk3,wk4,0.1,G_ni,G_nj)

         call glbdist (wk1,G_ni,G_nj,w1,l_minx,l_maxx,l_miny,l_maxy, &
                               1,G_halox,G_haloy)

         do j=1,l_nj
         do i=1,l_ni
            ttx(i,j,kl) = w1(i,j)
         enddo
         enddo

 200   continue

!        At this point:
!        temperature field is stored in ttx for future use
!        fictitious levels  are stored in htx for future use

      endif
      lastdt = Lctl_step

      l_ninj=(l_maxx-l_minx+1)*(l_maxy-l_miny+1)

!     Calculate PN
      if (pnpn.ne.0) then
          call vslog(w2,p0,l_ninj)
          call pnm2(w1,tt1(l_minx,l_miny,nk+2),fis0,w2,wlao, &
               ttx,htx,Out3_nundr,l_minx,l_maxx,l_miny,l_maxy,1)
          if (filt(pnpn).gt.0) &
            call filter(w1,filt(pnpn),coef(pnpn),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, 1)
          call ecris_fst2(w1,l_minx,l_maxx,l_miny,l_maxy,0.0, &
              'PN  ',.01,0.0,kind,1, 1, 1, nbit(pnpn) )
      endif
      
!     Calculate P0      
      if (pnp0.ne.0) then
         do j=l_miny,l_maxy
         do i=l_minx,l_maxx
            w1(i,j) = p0(i,j)
         enddo
         enddo
         if (filt(pnp0).gt.0)&
         call filter(w1,filt(pnp0),coef(pnp0),'G', .false.,&
              l_minx,l_maxx,l_miny,l_maxy, 1)
         call ecris_fst2(w1,l_minx,l_maxx,l_miny,l_maxy,0.0,&
              'P0  ',.01,0.0,kind,1, 1, 1, nbit(pnp0) ) 
      endif

      if (pnww.ne.0) then
!ccparallel
            call calomeg_w (omega,F_st1,wt1,tt1,LDIST_DIM,nk)            
!vl      calomeg  gives values to nk+1 ! 
!ccend parallel
         do j= 1, l_nj
         do i= 1, l_ni
            omega(i,j,nk+2)=omega(i,j,nk+1)
         enddo         
         enddo         
      endif

      if (pnth.ne.0) then
         do k= 1,nk+1
            do j= 1,l_nj
            do i= 1,l_ni
               th(i,j,k)= tt1(i,j,k)*(theta_p0/exp(wlnph_ta(i,j,k)))**Dcst_cappa_8
            enddo
            enddo
         enddo
         do j= 1,l_nj
         do i= 1,l_ni
            th(i,j,nk+2)= tt1(i,j,nk+2)*(theta_p0/exp(wlnph_ta(i,j,nk+2)))**Dcst_cappa_8
         enddo
         enddo
      endif

      if (Level_typ_S(levset) .eq. 'M') then
!_______________________________________________________________________
!
!     4.0   Output 3-D Derived Variables on ETA levels (momentum/thermo)
!_______________________________________________________________________
!
!       Setup the indexing for output 
          kind=Level_kind_ip1
          allocate (indo( min(Level_max(levset),Level_momentum) ))
          allocate (indo_t( min(Level_max(levset),Level_thermo) ))
          call out_slev(Level(1,levset), Level_max(levset), &
                        Level_momentum,indo,nko)
          call out_slev(Level(1,levset), Level_max(levset), &
                        Level_thermo,indo_t,nko_t)

         if (pngz.ne.0)then
             nko_m=nko
             if (indo(nko).eq.G_nk+1 .and. indo_t(nko_t).eq.G_nk+2) then
                 nko_m= nko-1
             endif
             call ecris_fst2(gz_m_plus(l_minx,l_miny,1), &
              l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
              'GZ  ',prmult_pngz,0.0,kind,nk+1, indo, nko_m, nbit(pngz) )
             call ecris_fst2(gz_ta, &
              l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
              'GZ  ',prmult_pngz,0.0,kind,nk+2,indo_t,nko_t,nbit(pngz))
         endif
         if (pnvt.ne.0)then
            call ecris_fst2(vt,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                 'VT  ',1.0,pradd_pnvt,kind,nk+2,indo_t,nko_t, nbit(pnvt) )
         endif
         if (pnth.ne.0) then
               call ecris_fst2(th,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                    'TH  ',1.0,0.0,kind,nk+2,indo_t,nko_t,nbit(pnvt) )               
         endif
         if (pnhu.ne.0) then

            if (Out3_cliph_L) then
                do k= 1,nk+2
                   do j= 1, l_nj
                   do i= 1, l_ni
                      t8(i,j,k) = amax1( hut1(i,j,k), 0. )
                   enddo
                   enddo
                enddo
                call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
              'HU  ',1.0,     0.0,  kind,nk+2, indo_t, nko_t,nbit(pnhu) )
            else
                call ecris_fst2(hut1,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
              'HU  ',1.0,     0.0,  kind,nk+2, indo_t, nko_t,nbit(pnhu) )
            endif
         endif

         if ( .not.(Lctl_step .eq. 0) .and. Schm_phyms_L &
                       .and.  pnqc.ne.0 ) then
!            QC output for timestep 0 is done after physics have executed
             if (Out3_cliph_L) then
                do k= 1,nk+2
                 do j= 1,l_nj
                 do i= 1,l_ni
                    t8(i,j,k) = amax1( qct1(i,j,k), 0. )
                 enddo
                 enddo
                enddo
                call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
             'QC  ',1.0,      0.0,  kind,nk+2, indo_t, nko_t, nbit(pnqc) )
             else
                call ecris_fst2(qct1,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
             'QC  ',1.0,      0.0,  kind,nk+2, indo_t, nko_t, nbit(pnqc) )
             endif
         endif

         if ( pntt.ne.0 .or. pntd.ne.0 .or. pnhr.ne.0 ) then

!        Calculate TT (in tt)

            call mfottv2(tt,vt,hut1, l_minx, l_maxx,l_miny,l_maxy, &
                            l_nk+2,1,l_ni,1,l_nj,.false.)
            call out_padbuf(tt,l_minx,l_maxx,l_miny,l_maxy,G_nk+2)

         endif

         if (pntt.ne.0)then            
            call ecris_fst2(tt,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                 'TT ' ,1.0,pradd_pntt, kind,nk+2,indo_t,nko_t, nbit(pntt) )
         endif
         if (pnes.ne.0.or.pnpx.ne.0.or.pntw.ne.0.or.pntd.ne.0.or.pnhr.ne.0)then

!            Calculate PX (in px), thermo levels.
!            And output all the levels!
             call vsexp(px_ta,wlnph_ta,l_ninj*(nk+2))
             px_ta(:,:,nk+2) = p0(:,:)

!            Calculate PX (in px), momentum levels.
             call vsexp(px_m,wlnph_m(l_minx,l_miny,1),l_ninj*(nk+1))
             px_m(:,:,nk+1) = p0(:,:)

!            Prepare VT,HU for physics functions
             do k= 1,nk+2
             do j= 1,l_nj
             do i= 1,l_ni
                hu(i,j,k) = hut1(i,j,k)
             enddo
             enddo
             enddo
             call out_padbuf(hu,l_minx,l_maxx,l_miny,l_maxy,G_nk+2)
             call out_padbuf(vt,l_minx,l_maxx,l_miny,l_maxy,G_nk+2)
         endif
                     
         if (pnpx.ne.0)then
             nko_m=nko
             if (indo(nko).eq.G_nk+1 .and. indo_t(nko_t).eq.G_nk+2) then
                 nko_m= nko-1
             endif
             call ecris_fst2(px_m,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
              'PX  ',prmult_pnpx,0.0,kind,nk+1,indo,nko_m,nbit(pnpx) )
             call ecris_fst2(px_ta,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
              'PX  ',prmult_pnpx,0.0,kind,nk+2,indo_t,nko_t,nbit(pnpx) )
         endif

         if (pntw.ne.0) then
!        Calculate THETAW TW (t8=TW) (px=PX)
             call mthtaw2 (t8,hu,vt, px_ta,px_ta,3, .false.,Out3_satues_L, &
                           .true.,Dcst_trpl_8,l_ninj,nk+2,l_ninj)
             call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
              'TW  ',1.0,0.0, kind,nk+2, indo_t, nko_t, nbit(pntw) )
         endif

         if (pnes.ne.0 .or. pntd.ne.0) then
!        Calculate ES (t8=ES) (px=PX)
             call mhuaes(t8,hu,vt,px_ta,px_ta,3, .false., Out3_satues_L, &
                            l_ninj,nk+2,l_ninj)

             if (Out3_cliph_L) then
                do k= 1,nk+2
                 do j= 1,l_nj
                 do i= 1,l_ni
                    t8(i,j,k) = amin1( t8(i,j,k), 30.)
                    t8(i,j,k) = amax1( t8(i,j,k), 0. )
                 enddo
                 enddo
                enddo
             endif

             if (pnes.ne.0) &
             call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
              'ES  ',1.0,0.0, kind,nk+2, indo_t, nko_t, nbit(pnes) )

             if (pntd.ne.0) then
!            Calculate TD (tt=TT,t8=old ES, t8=TD=TT-ES)
                 do k= 1,nk+2
                    do j= 1,l_nj
                    do i= 1,l_ni
                       t8(i,j,k) = tt(i,j,k) - t8(i,j,k)
                    enddo
                    enddo
                 enddo
                 call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                 'TD  ',1.0,pradd_pntd,kind,nk+2,indo_t,nko_t,nbit(pntd) )
             endif
         endif

         if (pnhr.ne.0) then
!            Calculate HR (t8=HR,tt=TT,px=PX)
             if (Out3_satues_L) then
                 call mfohr(t8,hu,tt, &
                         px_ta,px_ta,3,l_ninj,G_nk+2,l_ninj)
             else
                 call mfohra(t8,hu,tt, &
                         px_ta,px_ta,3,l_ninj,G_nk+2,l_ninj)
             endif
             if ( Out3_cliph_L ) then
                do k= 1,nk+2
                  do j= 1,l_nj
                  do i= 1,l_ni
                     t8(i,j,k)=amin1( t8(i,j,k), 1.0 )
                     t8(i,j,k)=amax1( t8(i,j,k), 0.  )
                  enddo
                  enddo
                enddo
             endif
             call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                 'HR  ',1.0,0.0, kind,nk+2, indo_t, nko_t, nbit(pnhr) )
         endif

         if (pnww.ne.0) then
             call ecris_fst2(omega,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                 'WW  ',1.0,0.0, kind,nk+2, indo_t, nko_t, nbit(pnww) )
         endif

         if (pnzz.ne.0) then
            do k= 1,nk+1
               do j= 1,l_nj
               do i= 1,l_ni
                  t8(i,j,k)=wt1(i,j,k)
               enddo
               enddo
            enddo
!           Put a copy of value at NK+1 into diagnostic level for output
            do j= 1, l_nj
            do i= 1, l_ni
               t8(i,j,nk+2) = t8(i,j,nk+1)
            enddo            
            enddo            
            call ecris_fst2(t8,l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                    'ZZ  ',1.0,0.0, kind,nk+2, indo_t, nko_t, nbit(pnzz) )
         endif
         deallocate(indo,indo_t)
      else
!_______________________________________________________________________
!
!     5.0    Output 3-D Derived Variables on PRESSURE levels
!_______________________________________________________________________
!
!       Set kind to 2 for pressure output
        kind=2
!       Setup the indexing for output 
        nko=Level_max(levset)
        allocate ( indo(nko), rf(nko) , prprlvl(nko) )
        do i = 1, nko
           indo(i)=i
           rf(i)= Level(i,levset)
           prprlvl(i) = rf(i) * 100.0
        enddo

        allocate(hu_pres(LDIST_SHAPE,nko))
        allocate(vt_pres(LDIST_SHAPE,nko))
        allocate(tt_pres(LDIST_SHAPE,nko))
        allocate(td_pres(LDIST_SHAPE,nko))
        allocate(px_pres(LDIST_SHAPE,nko)) 
        allocate(w5(LDIST_SHAPE,nko))


!       Calculate vertical derivative of HUT1 with respect to wlnph_ta

        call verder(px_ta,hut1,wlnph_ta,2.0,2.0,l_minx,l_maxx,l_miny,l_maxy, &
                                             nk+2, 1,l_ni,1,l_nj)

!       Calculate HU (hu_pres=HU,px_ta=vert.der)
        call prgen(hu_pres,hut1,px_ta,wlnph_ta,prprlvl,nko,  &
                   Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy,nk+2,&
                   1,l_ni,1,l_nj)
        if ( Out3_cliph_L ) then
           do k= 1, nko
              do j= 1,l_nj
              do i= 1,l_ni
                 hu_pres(i,j,k) = amax1( hu_pres(i,j,k), 0. )
              enddo
              enddo
           enddo
        endif

!       Calculate GZ,VT (w5=GZ_pres, vt_pres=VT_pres)

        call prgzvta( w5, vt_pres, prprlvl, nko, &
                      gz_ta, vt, wlnph_ta, wlao, &
                      ttx, htx, Out3_nundr,Out3_cubzt_L,  &
                      Out3_linbot, l_minx,l_maxx,l_miny,l_maxy,nk+2)

        if (pngz.ne.0) then
            if (filt(pngz).gt.0)then
               call filter(w5,filt(pngz),coef(pngz),'G', .false., &
                    l_minx,l_maxx,l_miny,l_maxy, nko)
            endif
            call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'GZ  ',prmult_pngz,0.0, kind,nko,indo,nko,nbit(pngz) )
        endif

        if (pntt.ne.0.or.pntd.ne.0.or.pnhr.ne.0) then

!           Calculate TT (tt_pres=TT,vt_pres=VT,hu_pres=HU)
            call mfottv2(tt_pres,vt_pres,hu_pres, l_minx, l_maxx,l_miny,l_maxy, &
                            nko,1,l_ni,1,l_nj,.false.)
        endif

        if ( pnes.ne.0.or.pntw.ne.0.or.pntd.ne.0.or.pnhr.ne.0) then
!           Calculate PX for ES,TD,HR
            do k=1,nko
               do j= 1, l_nj
               do i= 1, l_ni
                  px_pres(i,j,k) = prprlvl(k)
               enddo
               enddo
            enddo
            call out_padbuf(px_pres,l_minx,l_maxx,l_miny,l_maxy,nko)
            call out_padbuf(tt_pres,l_minx,l_maxx,l_miny,l_maxy,nko)
            call out_padbuf(hu_pres,l_minx,l_maxx,l_miny,l_maxy,nko)
        endif

        if (pntw.ne.0) then
!           Calculate THETAW TW (w5=TW_pres) (px_pres=PX)
            call mthtaw2 (w5,hu_pres,vt_pres, &
                           px_pres,px_pres,3,.false.,Out3_satues_L, &
                           .true.,Dcst_trpl_8,l_ninj,nko,l_ninj)
            if (filt(pntw).gt.0) &
                call filter(w5,filt(pntw),coef(pntw),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
            call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,rf, &
                'TW  ',1.0,0.0, kind,nko, indo, nko, nbit(pntw) )
        endif
!
        if (pnes.ne.0.or.pntd.ne.0) then
!           Calculate ES (w5=ES_pres,hu_pres=HU,w2=VT,px_pres=PX)
            call mhuaes (w5, hu_pres, vt_pres, &
                          px_pres,px_pres,3,.false.,Out3_satues_L, &
                          l_ninj, nko, l_ninj)
            if ( Out3_cliph_L ) then
               do k=1,nko
                 do j= 1, l_nj
                 do i= 1, l_ni
                    w5(i,j,k) = amin1( w5(i,j,k), 30.)
                    w5(i,j,k) = amax1( w5(i,j,k), 0. )
                 enddo
                 enddo
               enddo
            endif

            if (pntd.ne.0) then
!           Calculate TD (tt_pres=TT,w5=ES, TD=TT-ES)
              do k=1,nko
                 do j= 1, l_nj
                 do i= 1, l_ni
                    td_pres(i,j,k) = tt_pres(i,j,k) - w5(i,j,k)
                 enddo
                 enddo
              enddo
              call filter(td_pres,filt(pntd),coef(pntd),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
              call ecris_fst2(td_pres,l_minx,l_maxx,l_miny,l_maxy,rf, &
                'TD  ',1.0,pradd_pntd, kind,nko,indo,nko,nbit(pntd) )
            endif

            if (pnes.ne.0) then
                if (filt(pnes).gt.0) &
                    call filter(w5,filt(pnes),coef(pnes),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
                call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,rf, &
                   'ES  ',1.0,0.0, kind,nko, indo, nko, nbit(pnes) )
            endif
        endif

        if (pnhr.ne.0) then
!           Calculate HR (w5=HR_pres:hu_pres=HU,tt_pres=TT,px_pres=PX)
            if (Out3_satues_L) then
                call mfohr (w5,hu_pres,tt_pres,px_pres, &
                          px_pres,3,l_ninj,nko,l_ninj)
            else
                call mfohra (w5,hu_pres,tt_pres,px_pres, &
                         px_pres,3,l_ninj,nko,l_ninj)
            endif
            if ( Out3_cliph_L ) then
               do k=1,nko
                  do j= 1, l_nj
                  do i= 1, l_ni
                     w5(i,j,k) = amin1( w5(i,j,k), 1.0 )
                     w5(i,j,k) = amax1( w5(i,j,k), 0.  )
                  enddo
                  enddo
               enddo
            endif
            if (filt(pnhr).gt.0) &
                call filter(w5,filt(pnhr),coef(pnhr),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
            call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,rf, &
                'HR  ',1.0,0.0, kind,nko, indo, nko, nbit(pnhr) )
        endif

        if (pnvt.ne.0) then
            if (filt(pnvt).gt.0) &
                call filter(vt_pres,filt(pnvt),coef(pnvt),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
            call ecris_fst2(vt_pres,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'VT  ',1.0,pradd_pnvt, kind,nko,indo, nko, nbit(pnvt) )
        endif

         if (pnth.ne.0) then
          call verder(px_ta,th,wlnph_ta,2.0,2.0,l_minx,l_maxx,l_miny,l_maxy, &
                                             nk+2, 1,l_ni,1,l_nj)
          call prgen( w5, th, px_ta, wlnph_ta, prprlvl,nko, &
                      Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy,nk+2,&
                      1,l_ni,1,l_nj)
            call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'TH  ',1.0,      0.0,  kind,nko, indo, nko, nbit(pnth) )
         endif

        if (pnhu.ne.0) then
            if (filt(pnhu).gt.0) &
                call filter(hu_pres,filt(pnhu),coef(pnhu),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
            call ecris_fst2(hu_pres,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'HU  ',1.0,       0.0, kind,nko, indo, nko, nbit(pnhu) )
        endif

        if (pntt.ne.0) then
            if (filt(pntt).gt.0) &
                call filter(tt_pres,filt(pntt),coef(pntt),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
            call ecris_fst2(tt_pres,l_minx,l_maxx,l_miny,l_maxy,rf,  &
              'TT  ',1.0,pradd_pntt, kind,nko, indo, nko, nbit(pntt) )
        endif

        if ( .not.(Lctl_step .eq. 0) .and. Schm_phyms_L &
                       .and.  pnqc.ne.0  ) then
!         QC output for timestep 0 is done after physics have executed
          call verder(px_ta,qct1,wlnph_ta,2.0,2.0,l_minx,l_maxx,l_miny,l_maxy, &
                                              nk+2,1,l_ni,1,l_nj)
!         Calculate QC (qc_pres=w5,px=vert.der)
          call prgen( w5, qct1, px_ta, wlnph_ta, prprlvl,nko,  &
                      Out3_cubzt_L,l_minx,l_maxx,l_miny,l_maxy, nk+2,&
                      1,l_ni,1,l_nj)
          if ( Out3_cliph_L ) then
               do k= 1, nko
                  do j= 1, l_nj
                  do i= 1, l_ni
                     w5(i,j,k) = amax1( w5(i,j,k), 0. )
                  enddo
                  enddo
               enddo
          endif
          if (filt(pnqc).gt.0) &
            call filter(w5,filt(pnqc),coef(pnqc),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
             call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,rf, &
              'QC  ',1.0,       0.0, kind,nko, indo, nko, nbit(pnqc) )
        endif

        if (pnww.ne.0) then
           call verder (px_ta,omega,wlnph_ta,2.0,2.0, &
                        l_minx,l_maxx,l_miny,l_maxy, nk+2, 1,l_ni,1,l_nj)
            call prgen( w5,omega, px_ta, wlnph_ta, prprlvl,nko,  &
                        Out3_cubww_L,l_minx,l_maxx,l_miny,l_maxy, nk+2,&
                        1,l_ni,1,l_nj)
            if (filt(pnww).gt.0) &
                call filter(w5,filt(pnww),coef(pnww),'G', .false., &
                        l_minx,l_maxx,l_miny,l_maxy, nko)
             call ecris_fst2(w5,l_minx,l_maxx,l_miny,l_maxy,rf, &
                 'WW  ',1.0,0.0, kind,nko, indo, nko, nbit(pnww) )
        endif


      deallocate(indo,rf,prprlvl)
      deallocate(w5,px_pres,hu_pres,td_pres,tt_pres,vt_pres)
      endif

      return
      end
