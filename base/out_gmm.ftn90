!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r out_gmm - output GMM fields
!
#include "model_macros_f.h"
!
      subroutine out_gmm2 (levset,set)
      use out_vref_mod, only: out_vref
      implicit none
#include <arch_specific.hf>
!
      integer levset,set
!
!author
!     Lee V.                    - rpn July 2009 (from output VMM)
!
!revision
! v3_20 - Lee V.            - initial MPI version
! v3_30 - McTaggart-Cowan R.- allow for user-defined domain tag extensions
! v3_31 - Lee V.            - kind is set to 2 (press) for 2D fields, not -1
! v4_03 - Lee V.            - modification of Out_etik_S in out_sgrid only
! v4_05 - Lee V.            - adaptation to GMM
! v4_13 - Lee V.            - ptrs to GMM variables must have the right shape
! v4_40 - Lee V.            - change in argument call for this routine
!                             in order to select the "bot" levels
! v4_40 - Lee V.            - bug correction for when number of pressure levels
!                             is greater than number of model levels
!
!object
!     output all the GMM fields
!	
!
! Index vectors for level indentifications
! ----------------------------------------
! 
! There is one vector for the momentum level : Ver_hyb%m.
!
! There are 1 vector for the thermo levels :
!    Ver_hyb%t : Thermo levels without special levels but top and surface.
!
!                Ver_hyb%m(1:G_nk)                 Ver_hyb%t(1:G_nk+1)
! model top
! ===========1        -                              X
! o o o o o o2        -                              -
! - - - - - -3        X                              -
!
! ===========4        -                              X
!  
!    ...             ...                            ...
!
!
! ===========2*k      -                              X
!
! - - - - - -2*k+1    X                              -
!
!    ...             ...                            ...
!
! - - - - - -2*G_nk+1 X                              -
! o o o o o o2*G_nk+2 -                              -
! ===========2*G_nk+3 -                              X
! model surface
!
!----------------------------------------------------------------------
#include "gmm.hf"
#include "glb_ld.cdk"
#include "lun.cdk"
#include "out3.cdk"
#include "out.cdk"
#include "grid.cdk"
#include "outd.cdk"
#include "geomn.cdk"
#include "rhsc.cdk"
#include "init.cdk"
#include "rstr.cdk"
#include "vt0.cdk"
#include "vth.cdk"
#include "vt1.cdk"
#include "vta.cdk"
#include "vtx.cdk"
#include "orh.cdk"
#include "p_geof.cdk"
#include "lctl.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
#include "level.cdk"
!
      type(gmm_metadata) :: tmp_meta
      character(len=GMM_MAXNAMELENGTH), dimension(256) :: keylist
      integer i,j,k, ii, pnerr,nkeys,gridset,ig2,istat
      integer i0,in,j0,jn,kn
      integer, dimension(:), allocatable::indo,indo_t,indo_s,indo_s1
      integer ierr,nko,nko_t,nko_s,nko_s1
      logical next_L,periodx_L,uvgrid_L
!
      real, pointer, dimension(:,:,:) :: tr3
      real, pointer, dimension(:,:  ) :: tr2
      real, pointer, dimension(:    ) :: tr1
!_______________________________________________________________________
!
      if ( Level_typ_S(levset).eq.'P') return

      nkeys     = gmm_keys(keylist)
      periodx_L = .false.
      uvgrid_L  = .false.

      if (.not.G_lam .and. (Grid_x1(Outd_grid(set))- &
            Grid_x0(Outd_grid(set))+1).eq. G_ni ) periodx_L=.true.
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj

!     Setup the indexing for output
      allocate (indo   ( min(Level_max(levset),Level_momentum) ))
      allocate (indo_t ( min(Level_max(levset),Level_thermo)   ))
      allocate (indo_s ( min(Level_max(levset),G_nk)           ))
      allocate (indo_s1( min(Level_max(levset),G_nk+1)         ))
      call out_slev(Level(1,levset), Level_max(levset), &
                    Level_momentum,indo,nko)
      call out_slev(Level(1,levset), Level_max(levset), &
                    Level_thermo,indo_t,nko_t)
      call out_slev(Level(1,levset), Level_max(levset), &
                    G_nk,indo_s,nko_s) ! G_nk levels
      call out_slev(Level(1,levset), Level_max(levset), &
                    G_nk+1,indo_s1,nko_s1) ! G_nk +1 levels

!     Exceptions are: U, V, on MOM
!     Exceptions are: ZD,W on THERMO

      do 100 ii=1,Outd_var_max(set)
      do 50   i=1,nkeys

         gridset = Outd_grid(set)
         levset  = Outd_lev (set)

         if (uvgrid_L) then
             uvgrid_L=.false.
             call out_sgrid2( Grid_x0 (gridset),Grid_x1 (gridset), &
                              Grid_y0 (gridset),Grid_y1 (gridset), &
                              Grid_ig1(gridset),Grid_ig2(gridset), &
                              periodx_L, Grid_stride(gridset)    , &
                              Grid_etikext_s(gridset) )
         endif

         if (Outd_var_S(ii,set).eq.keylist(i)(1:4)) then
             istat = gmm_getmeta(keylist(i),tmp_meta)
             if (GMM_IS_ERROR(istat))  &
                 print *,'out_gmm ERROR at gmm_getmeta on',keylist(i)
             nullify(tr1, tr2, tr3)

             if (keylist(i)(1:2).eq.'ZD'.or.keylist(i)(1:2).eq.'WT') then
! ZD,WT are on thermo levels but has no surface
                istat = gmm_get(keylist(i),tr3,tmp_meta)
                call ecris_fst2(tr3, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                   keylist(i),1.0,0.0,Level_kind_ip1,G_nk+1,indo_s1,nko_s1, &
                   Outd_nbit(ii,set) )
             elseif (keylist(i)(1:4).eq.'MCSP') then
! MCSP is on thermo levels but has no surface
                write(*,*)'MCSP',tmp_meta
                istat = gmm_get(keylist(i),tr3,tmp_meta)
                call ecris_fst2(tr3, 1,l_ni,1,l_nj,Ver_hyb%t               , &
                    keylist(i),1.0,0.0,Level_kind_ip1,G_nk+2,indo_s1,nko_s1, &
                    Outd_nbit(ii,set) )
             elseif (keylist(i)(1:3).eq.'UT1'.or.keylist(i)(1:3).eq.'UT0') then
! UT1,UT0 are on momentum levels
                istat = gmm_get(keylist(i),tr3,tmp_meta)
                uvgrid_L = .true.
                ig2 = Grid_ig2(gridset)+1
                if (Out3_uendode_L) ig2 = Grid_ig2(gridset)
                call out_sgrid2( Grid_x0 (gridset),min(Grid_x1(gridset),G_niu), &
                                 Grid_y0 (gridset),Grid_y1(gridset)           , &
                                 Grid_ig1(gridset),ig2                        , &
                                 periodx_L, Grid_stride(gridset)              , &
                                 Grid_etikext_s(gridset) )
                call out_href2 ( 'U_point' )

                call ecris_fst2(tr3, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                      keylist(i),1.0,0.0,Level_kind_ip1,G_nk+1, indo, nko , &
                      Outd_nbit(ii,set) )
             elseif (keylist(i)(1:3).eq.'VT1'.or.keylist(i)(1:3).eq.'VT0') then
! VT1,VT0 are on momentum levels
                istat = gmm_get(keylist(i),tr3,tmp_meta)
                uvgrid_L = .true.
                ig2 = Grid_ig2(gridset)+2
                if (Out3_uendode_L) ig2 = Grid_ig2(gridset)
                call out_sgrid2 ( Grid_x0(gridset),Grid_x1(gridset)           , &
                                  Grid_y0(gridset),min(Grid_y1(gridset),G_njv), &
                                  Grid_ig1(gridset),ig2                       , &
                                  periodx_L, Grid_stride(gridset)             , &
                                  Grid_etikext_s(gridset) )
                 call out_href2 ( 'V_point' )

                 call ecris_fst2(tr3, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                      keylist(i),1.0,0.0,Level_kind_ip1,G_nk+1, indo, nko  , &
                      Outd_nbit(ii,set) )
              elseif (keylist(i)(1:4)=='UTND'.or.keylist(i)(1:4)=='VTND') then
! UTND,VTND are on momentum levels
                 istat = gmm_get(keylist(i),tr3,tmp_meta)
                 call ecris_fst2(tr3(l_minx,l_miny,2), l_minx,l_maxx,l_miny,l_maxy, &
                                 Ver_hyb%m, keylist(i),1.0,0.0,Level_kind_ip1     , &
                                 tmp_meta%l(3)%high, indo,nko,Outd_nbit(ii,set) )
! tmp_meta%l(1) is on X
! tmp_meta%l(2) is on Y
! tmp_meta%l(3) is on Z
             elseif (tmp_meta%l(1)%low .eq. 1) then !3d no halo
                kn=(tmp_meta%l(1)%high)/(l_ni*l_nj) !
                istat = gmm_get(keylist(i),tr1,tmp_meta)
                if (kn .eq. G_nk) then !on momentum,no surface
                   call ecris_fst2(tr1,1,l_ni,1,l_nj,Ver_hyb%m, &
                        keylist(i),1.0,0.0,Level_kind_ip1,G_nk, &
                        indo_s,nko_s, Outd_nbit(ii,set))
                elseif (kn .eq. G_nk+1) then !on thermo, no surface
                   call ecris_fst2(tr1,1,l_ni,1,l_nj,Ver_hyb%t  , &
                        keylist(i),1.0,0.0,Level_kind_ip1,G_nk+1, &
                        indo_s1,nko_s1, Outd_nbit(ii,set))
                endif
             elseif (tmp_meta%l(3)%high .eq.0) then !2d halo field
                istat = gmm_get(keylist(i),tr2,tmp_meta)
                call ecris_fst2(tr2,l_minx,l_maxx,l_miny,l_maxy,0.0, &
                      keylist(i),1.0,0.0,  2, 1, 1, 1, Outd_nbit(ii,set) )
             elseif (tmp_meta%l(3)%low .eq.0) then !3d halo with a level 0
                istat = gmm_get(keylist(i),tr3,tmp_meta)
                call ecris_fst2(tr3(l_minx,l_miny,1)          , &
                      l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m   , &
                      keylist(i),1.0,0.0,Level_kind_ip1,G_nk+1, &
                      indo_s1,nko_s1, Outd_nbit(ii,set) )
             elseif (tmp_meta%l(3)%high .eq.G_nk) then 
                !3d halo on momentum, no surface
                istat = gmm_get(keylist(i),tr3,tmp_meta)
                call ecris_fst2(tr3, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                     keylist(i),1.0,0.0,Level_kind_ip1,tmp_meta%l(3)%high , &
                     indo_s,nko_s,Outd_nbit(ii,set) )
             elseif (tmp_meta%l(3)%high .eq.G_nk+1) then 
                !3d halo on momentum+surface
                istat = gmm_get(keylist(i),tr3,tmp_meta)
                call ecris_fst2(tr3, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%m, &
                     keylist(i),1.0,0.0,Level_kind_ip1,tmp_meta%l(3)%high , &
                     indo,nko,Outd_nbit(ii,set) )
             elseif (tmp_meta%l(3)%high .eq.G_nk+2) then 
                !3d halo on thermo+surface
                istat = gmm_get(keylist(i),tr3,tmp_meta)
                call ecris_fst2(tr3, l_minx,l_maxx,l_miny,l_maxy,Ver_hyb%t, &
                      keylist(i),1.0,0.0,Level_kind_ip1,tmp_meta%l(3)%high, &
                      indo_t,nko_t,Outd_nbit(ii,set) )
             endif
             cycle

         endif

  50  continue
 100  continue

      deallocate(indo,indo_t,indo_s,indo_s1)

! ___________________________________________________________________
      return
      end
