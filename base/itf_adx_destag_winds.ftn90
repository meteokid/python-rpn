!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#include "model_macros_f.h"

   subroutine itf_adx_destag_winds (F_u, F_v, F_uth, F_vth)
      implicit none
#include <arch_specific.hf>
      !@objective unstagger wind components (Interpolate to geopotential grid)
      !@arguments
      real, dimension(:,:,:), pointer :: F_uth,F_vth !I, staggered winds
      real, dimension(:,:,:), pointer :: F_u,F_v     !O, destaggered winds
      !@revisions
      ! v4_40 - Qaddouri/Lee      - Yin-Yang, to exchange unstaggered winds
      !**/

#include "glb_ld.cdk"
#include "grd.cdk"
#include "inuvl.cdk"

Interface
Subroutine itf_adx_yywinds (F_u,F_v,i0u,j0u,inu,jnu,i0v,j0v,inv,jnv)
      integer :: i0u,j0u,inu,jnu,i0v,j0v,inv,jnv
      real, dimension(:,:,:), pointer :: F_u, F_v
End Subroutine itf_adx_yywinds
End Interface

      !- CUBIC LAGRANGE INTERPOLATION COEFFICIENTS from AND to U and V grids
      !      real*8 inuvl_wxux3_8(l_minx:l_maxx,4) ! coef for U to PHI-grid
      !      real*8 inuvl_wyvy3_8(l_miny:l_maxy,4) ! coef for V to PHI-grid

#define UNSTAG_X(f,i,j,k,a) (a(i,1)*f(i-2,j,k) + a(i,2)*f(i-1,j,k) + a(i,3)*f(i,j,k) + a(i,4)*f(i+1,j,k))
#define UNSTAG_Y(f,i,j,k,a) (a(j,1)*f(i,j-2,k) + a(j,2)*f(i,j-1,k) + a(j,3)*f(i,j,k) + a(j,4)*f(i,j+1,k))

      integer :: i0u,j0u,inu,jnu,i0v,j0v,inv,jnv
      integer :: i,j,k, nrow=0

      !---------------------------------------------------------------------

      call rpn_comm_xch_halo(F_uth,l_minx,l_maxx,l_miny,l_maxy,&
           l_niu,l_nj,l_nk,G_halox,G_haloy,G_periodx,G_periody,G_niu,nrow)
      call rpn_comm_xch_halo(F_vth,l_minx,l_maxx,l_miny,l_maxy,&
           l_ni,l_njv,l_nk,G_halox,G_haloy,G_periodx,G_periody,G_ni,nrow)

      i0u = 1
      inu = l_niu
      j0u = 1
      jnu = l_nj
      if (G_lam) then
         if (l_west) i0u = 3
         if (l_east) inu = l_niu - 1
      endif
      i0v = 1
      inv = l_ni
      j0v = 0
      jnv = l_njv
      if (l_south) j0v = 3
      if (l_north) jnv = l_njv - 1

       !- Interpolate advection winds to geopotential grid
!$omp parallel private(i,j,k)
!$omp do
      DO_K: do k=1,l_nk

         do j = j0u, jnu
            do i = i0u, inu
               F_u(i,j,k) = UNSTAG_X(F_uth,i,j,k,inuvl_wxux3_8)
            enddo
            do i = 1,i0u-1
               F_u(i,j,k) = F_uth(i,j,k)
            enddo
            do i = inu+1,l_niu
               F_u(i,j,k) = F_uth(i,j,k)
            enddo
         enddo

         do j = j0v, jnv
            do i = i0v, inv
               F_v(i,j,k) = UNSTAG_Y(F_vth,i,j,k,inuvl_wyvy3_8)
            enddo
         enddo

         if (.not.G_lam) then

            if (l_south) then
               do i = i0v, inv
                  F_v(i,j0v-2,k) = &
                       inuvl_wyvy3_8(j0v-2,3) * F_vth(i,j0v-2,k) + &
                       inuvl_wyvy3_8(j0v-2,4) * F_vth(i,j0v-1,k)
                  F_v(i,j0v-1,k) = &
                       inuvl_wyvy3_8(j0v-1,2) * F_vth(i,j0v-2,k) + &
                       inuvl_wyvy3_8(j0v-1,3) * F_vth(i,j0v-1,k) + &
                       inuvl_wyvy3_8(j0v-1,4) * F_vth(i,j0v,k  )
               enddo
            endif
            if (l_north) then
               do i = i0v, inv
                  F_v(i,jnv+2,k) = &
                       inuvl_wyvy3_8(jnv+2,1) * F_vth(i,jnv  ,k) + &
                       inuvl_wyvy3_8(jnv+2,2) * F_vth(i,jnv+1,k)
                  F_v(i,jnv+1,k) = &
                       inuvl_wyvy3_8(jnv+1,1) * F_vth(i,jnv-1,k) + &
                       inuvl_wyvy3_8(jnv+1,2) * F_vth(i,jnv  ,k) + &
                       inuvl_wyvy3_8(jnv+1,3) * F_vth(i,jnv+1,k)
               enddo
            endif

         else

            do i = i0v, inv
               do j = 1, j0v-1
                  F_v(i,j,k) = F_vth(i,j,k)
               enddo
               do j = jnv+1, l_njv
                  F_v(i,j,k) = F_vth(i,j,k)
               enddo
            enddo

         endif

      enddo DO_K
!$omp enddo
!$omp end parallel

      if (Grd_yinyang_L)  &
          call itf_adx_yywinds (F_u,F_v,i0u,j0u,inu,jnu,i0v,j0v,inv,jnv)

      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_destag_winds
