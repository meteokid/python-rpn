!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r pw_update - Update physical quantities
!
#include "model_macros_f.h"
!
      subroutine pw_update_GPW
      implicit none
#include <arch_specific.hf>
!
!author
!     Michel Desgagne - May 2010
!
!revision
! v4_14 - Desgagne, M.     - Initial revision
!
#include "gmm.hf"
#include "glb_ld.cdk"
#include "cstv.cdk"
#include "lun.cdk"
#include "schm.cdk"
#include "vt1.cdk"
#include "p_geof.cdk"
#include "ver.cdk"
#include "pw.cdk"
#include "dcst.cdk"
!
      integer i, j, k, istat
      real*8 idt
      real wk1(l_ni,l_nj,2),wk2(l_ni,l_nj,2),wprev(l_ni,l_nj,l_nk)
      real fip(l_minx:l_maxx,l_miny:l_maxy,G_nk+1)
      logical, save :: initialized=.false.
!     ________________________________________________________________
!

      istat = gmm_get(gmmk_pw_ww_plus_s , pw_ww_plus )
      istat = gmm_get(gmmk_pw_gz_plus_s , pw_gz_plus )
      istat = gmm_get(gmmk_pw_pm_plus_s , pw_pm_plus )
      istat = gmm_get(gmmk_pw_pt_plus_s , pw_pt_plus )
      istat = gmm_get(gmmk_pw_ww_dyn_s  , pw_ww_dyn  )

      istat = gmm_get(gmmk_tt1_s  ,   tt1)
      istat = gmm_get(gmmk_wt1_s  ,   wt1)
      istat = gmm_get(gmmk_st1_s  ,   st1)
      istat = gmm_get(gmmk_fis0_s ,  fis0)
      istat = gmm_get(gmmk_qt1_s  ,   qt1)

      call diag_fi (fip, st1, tt1, qt1, fis0, &
                    l_minx,l_maxx,l_miny,l_maxy,G_nk, 1, l_ni, 1, l_nj)

!$omp parallel private(wk1,wk2,i,j)

!$omp do
      do k=1,l_nk
         wprev (1:l_ni,1:l_nj,k) = pw_ww_plus (1:l_ni,1:l_nj,k)
      end do
!$omp enddo

!$omp do
      do k=1,l_nk+1
         if (k.eq.1)then
            pw_pm_plus(:,:,0) = Cstv_ptop_8
            ! This is not used it think
            do j=1,l_nj
            do i=1,l_ni
               pw_pt_plus(i,j,0) = 0.5d0*(Cstv_ptop_8+Ver_a_8%m(1)+Ver_b_8%m(1)*st1(i,j))
            enddo
            enddo
         endif
         do j=1,l_nj
         do i=1,l_ni
            wk1(i,j,1) = Ver_a_8%m(k) + Ver_b_8%m(k) * st1(i,j)
            wk1(i,j,2) = Ver_a_8%t(k) + Ver_b_8%t(k) * st1(i,j)
         enddo
         enddo
         call vsexp(wk2(1,1,1), wk1(1,1,1), 2*l_ni*l_nj)
         pw_pm_plus(1:l_ni,1:l_nj,k) = wk2(1:l_ni,1:l_nj,1)
         pw_pt_plus(1:l_ni,1:l_nj,k) = wk2(1:l_ni,1:l_nj,2)
      end do
!$omp enddo

!$omp do
      do k=1,l_nk
         pw_ww_plus(:,:,k) = wt1(:,:,k)
         pw_gz_plus(1:l_ni,1:l_nj,k)= fip(1:l_ni,1:l_nj,k) + &
                        Ver_fistr_8%m(k)-fis0(1:l_ni,1:l_nj)
      end do
!$omp enddo
      

!$omp do
      do j= 1, l_nj
      do i= 1, l_ni
         pw_pt_plus(i,j,l_nk+1) = pw_pm_plus(i,j,l_nk+1)
      end do
      end do
!$omp enddo

      if (initialized) then
         idt = 1d0/Cstv_dt_8
!$omp do  
         do k= 1, l_nk
            pw_ww_dyn (1:l_ni,1:l_nj,k) = pw_ww_dyn (1:l_ni,1:l_nj,k) + &
            idt * ( pw_ww_plus (1:l_ni,1:l_nj,k) - wprev (1:l_ni,1:l_nj,k) )
         end do
!$omp enddo
      endif

!$omp end parallel

!     Initial update has been completed
      initialized = .true.
!     ________________________________________________________________
!
      return
      end
