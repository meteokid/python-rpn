!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
!*s/r sol_hcr - iterative solution of horizontal Helmholtz problem
!               cgrid model with rotated poles
!
#include "model_macros_f.h"
!
      subroutine sol_hcr (F_sol_8,F_rhs_8,F_w1_8,F_w2_8,F_dg1_8,F_dg2_8, &
                          F_dwfft_8,iln,Minx,Maxx,Miny,Maxy,Ni,Nj,Nk)
      implicit none
#include <arch_specific.hf>
!
      integer iln,Minx,Maxx,Miny,Maxy,Ni,Nj,Nk
      real*8 F_sol_8 (Minx:Maxx,Miny:Maxy,Nk), &
             F_rhs_8 (Minx:Maxx,Miny:Maxy,Nk), &
              F_w1_8 (Minx:Maxx,Miny:Maxy,Nk), &
              F_w2_8 (Minx:Maxx,Miny:Maxy,Nk), &
             F_dg1_8(*),F_dg2_8(*),F_dwfft_8(*)
!
!author
!     Desgagne/Lee ( after version v1_03 of solhcr8 )
!
!revision
! v2_00 - Desgagne/Lee       - initial MPI version
! v3_00 - Desgagne & Lee     - Lam configuration
! v3_01 - Qaddouri A.        - add call sol_parite_2
! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
! v3_21 - Desgagne M.        - Optimization
! v3_30 - Qaddouri A.        - add Call to iterative solver 
! v4_40 - Qaddouri A.        - Add Schwarz iterative solution for YinYang
!object
!
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! F_sol_8
!----------------------------------------------------------------
!
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "grd.cdk"
#include "ldnh.cdk"
#include "sol.cdk"
#include "opr.cdk"
#include "eigv.cdk"
#include "ptopo.cdk"
#include "fft.cdk"
#include "cstv.cdk"
#include "schm.cdk"
#include "trp.cdk"
#include "lctl.cdk"
#include "orh.cdk"
#include "lun.cdk"
!
      integer i, j, k, k0, offi, offj, Gni, Gnj, NSTOR, nev, &
              Niter, iter, its, err
      logical print_conv
      real*8 work_8 (Minx:Maxx,Miny:Maxy,Nk)
      real*8 abpt((maxy-miny+1)*(trp_12smax-trp_12smin+1)*G_ni),conv
      real*8, dimension(:),allocatable :: wk_evec_8
      real linfini
!
!     ---------------------------------------------------------------
      print_conv = (iln.eq.Schm_itnlh   ) .and. &
                   (Orh_icn.eq.Schm_itcn) .and. &
                   (Ptopo_couleur.eq.0  ) .and. &
                   (Lun_out.gt.0)
!
! Compute length of working vector without pilot region
!
      Gni=G_ni-Lam_pil_w-Lam_pil_e
      Gnj=G_nj-Lam_pil_s-Lam_pil_n

      if (.not.Fft_fast_L) then
          allocate ( wk_evec_8(Gni*Gni) )
          do j=1,Gni
          do i=1,Gni
            wk_evec_8((j-1)*Gni+i)= &
                    Opr_xevec_8((j+Lam_pil_w-1)*G_ni+i+Lam_pil_w)
          enddo
          enddo
      endif

      offi = Ptopo_gindx(1,Ptopo_myproc+1)-1
      offj = Ptopo_gindx(3,Ptopo_myproc+1)-1

!$omp parallel private (i,j,k) shared (offi,offj)
!$omp do
      do j=1+pil_s,Nj-pil_n
         call dgemm ('N','N', (ni-pil_w-pil_e), G_nk, G_nk, 1.0D0,      &
                     F_rhs_8(1+pil_w,j,1), (Maxy-Miny+1)*(Maxx-Minx+1), &
                     Opr_lzevec_8,g_nk,0.0d0,                           &
                     F_w1_8 (1+pil_w,j,1), (Maxy-Miny+1)*(Maxx-Minx+1))

         do k=1,Schm_nith
            do i = 1+pil_w, Ni-pil_e
               F_w1_8(i,j,k)= Opr_opsxp0_8(G_ni+offi+i) * &
                              Opr_opsyp0_8(G_nj+offj+j) * F_w1_8(i,j,k) 
            enddo
         end do
      end do
!$omp enddo
!$omp do
      do k=1,Nk
         work_8(:,:,k) = F_w1_8(:,:,k)
      end do
!$omp enddo
!$omp end parallel 
     
      Niter=1
      if (Grd_yinyang_L) then
         Niter=Sol_yyg_maxits  ! Niter > 1 only with Grd_yinyang_L
         F_w2_8 = 0.0D0
      endif

!Iterate for solution more than once if necessary


      do 100 iter=1,Niter

         if ( sol_type_S.eq.'ITERATIVE' ) then

            call  sol_fgmres2( F_w2_8, work_8, iln, l_ni, l_nj, &
                                    Minx, Maxx, Miny, Maxy, Nk, &
                                          print_conv, conv, its )
         else

            if (Fft_fast_L) then

                  call sol_fft8_3 ( &
                     F_w2_8, work_8, Minx, Maxx, Miny, Maxy, ldnh_nj   , &
                     trp_12smin, trp_12smax, Schm_nith, trp_12sn       , &
                     G_ni, G_nj, trp_22min , trp_22max, trp_22n        , &
                     trp_12smin, trp_12smax, trp_22min, trp_22max,G_nj , &
                     Ptopo_npex, Ptopo_npey, Sol_ai_8,Sol_bi_8,Sol_ci_8, &
                     F_dg2_8,F_dwfft_8,G_lam)

            else

               if (.not. Eigv_parity_L) then
                  call sol_mxma8_2 ( F_w2_8, work_8, wk_evec_8,  &
                            Minx, Maxx, Miny, Maxy,ldnh_nj, &
                  trp_12smin, trp_12smax, Schm_nith, trp_12sn ,  &
                  G_ni, G_nj, trp_22min , trp_22max, trp_22n  , &
                  trp_12smin, trp_12smax, trp_22min, trp_22max,G_nj, &
                  Ptopo_npex, Ptopo_npey, Sol_ai_8,Sol_bi_8,Sol_ci_8, &
                  F_dg1_8,F_dg2_8,F_dwfft_8)
               else
                  nev= (G_ni+2)/2
                  NSTOR = nev + ( 1 - mod(nev,2) )
                  call sol_parite_2( F_w2_8, F_w1_8, Opr_evvec_8, Opr_odvec_8, &
                             Minx, Maxx, Miny, Maxy, l_nj, &
                  trp_12smin, trp_12smax, Schm_nith, trp_12sn , &
                  G_ni, G_nj, trp_22min , trp_22max, trp_22n  , &
                  trp_12smin, trp_12smax, trp_22min, trp_22max,G_nj, &
                  Ptopo_npex, Ptopo_npey, Sol_ai_8,Sol_bi_8,Sol_ci_8, &
                  F_dg1_8,F_dg2_8,F_dwfft_8,Abpt,NSTOR,nev)
               endif
            endif

         endif

         if (Grd_yinyang_L) then
            work_8(:,:,:) = F_w1_8(:,:,:)
            call yyg_rhs_scalbc(work_8,F_w2_8,minx,maxx,miny,maxy,NK,iter,linfini)
            if (Lun_debug_L.and.print_conv) write(Lun_out,1001) linfini,iter
            if ((iter.gt.1).and.(linfini.lt.Sol_yyg_eps))  goto 999
         endif

  100 continue

 999  if ( sol_type_S.eq.'ITERATIVE' .and. print_conv ) write(Lun_out,1003) conv, its

      if (Grd_yinyang_L) then
         if (print_conv) then
            write(Lun_out,1002) linfini,iter
            if (linfini.gt.Sol_yyg_eps) write(Lun_out,9001) Sol_yyg_eps
         endif
      endif

!     inverse projection 

!$omp parallel shared ( g_nk )
!$omp do
      do j=1+pil_s,Nj-pil_n
         call dgemm ('N','T', (ni-pil_w-pil_e), G_nk, G_nk, 1.0D0,      &
                     F_w2_8 (1+pil_w,j,1), (Maxy-Miny+1)*(Maxx-Minx+1), &
                     Opr_zevec_8,g_nk,0.0d0,                            &
                     F_sol_8(1+pil_w,j,1), (Maxy-Miny+1)*(Maxx-Minx+1))
      enddo
!$omp enddo
!$omp end parallel

      if (.not. Fft_fast_L) deallocate (wk_evec_8)

 1001 format (3x,'Iterative YYG    solver convergence criteria: ',1pe14.7,' at iteration', i3)
 1002 format (3x,'Final YYG    solver convergence criteria: ',1pe14.7,' at iteration', i3)
 1003 format (3x,'Final FGMRES solver convergence criteria: ',1pe14.7,' at iteration', i3)
 9001 format (3x,'WARNING: iterative YYG solver DID NOT converge to requested criteria:: ',1pe14.7)
!
!     ---------------------------------------------------------------
! 
      return
      end
