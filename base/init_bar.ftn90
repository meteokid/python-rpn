!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r init_bar - prepare data for autobarotropic runs (Williamson cases)
!
      subroutine init_bar ( F_u, F_v, F_w, F_t, F_zd, F_s, F_q, F_topo, &
                            pref_tr, suff_tr, Mminx,Mmaxx,Mminy,Mmaxy , &
                            Nk, F_datev)
      implicit none
#include <arch_specific.hf>

      character* (*) pref_tr,suff_tr,F_datev
      integer Mminx,Mmaxx,Mminy,Mmaxy,Nk
      real F_u (Mminx:Mmaxx,Mminy:Mmaxy,  Nk), F_v(Mminx:Mmaxx,Mminy:Mmaxy,Nk), &
           F_w (Mminx:Mmaxx,Mminy:Mmaxy,  Nk), F_t(Mminx:Mmaxx,Mminy:Mmaxy,Nk), &
           F_zd(Mminx:Mmaxx,Mminy:Mmaxy,  Nk), F_s(Mminx:Mmaxx,Mminy:Mmaxy   ), &
           F_q (Mminx:Mmaxx,Mminy:Mmaxy,2:Nk+1), F_topo (Mminx:Mmaxx,Mminy:Mmaxy)
!
!author
!     claude girard    february 2014

#include "gmm.hf"
#include "glb_ld.cdk"
#include "lun.cdk"
#include "bmf.cdk"
#include "ptopo.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "lam.cdk"
#include "geomg.cdk"
#include "grd.cdk"
#include "lctl.cdk"
#include "schm.cdk"
#include "out3.cdk"
#include "acq.cdk"
#include "vtopo.cdk"
#include "anal.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "tr3d.cdk"
#include "vt1.cdk"
#include "pw.cdk"
#include "step.cdk"
#include "bcsgrds.cdk"
#include "wil_williamson.cdk"

      integer,external :: bmf_get,get_px,newdate,samevert

      type(gmm_metadata) :: mymeta
      character(len=GMM_MAXNAMELENGTH) :: tr_name
      logical initial_data
      integer nvar,i,j,k,kk,err,nbpts,nka_m,nka_t,nkmax,&
              err_pwuu,err_pwvv,err_pwtt,prdfsum,istat,dat,&
              mustvinterp
      integer G_nkt, G_nkm,i0,in,j0,jn
      real, allocatable, dimension(:    ) :: rna
      real, allocatable, dimension(:,:  ) :: pres,psu_temp,psv_temp,apsu_temp,apsv_temp
      real, allocatable, dimension(:,:,:) :: u_temp,v_temp, hu_temp, tt_temp, &
                                               gz_temp,zd_temp,w_temp,q_temp
      real, allocatable, dimension(:,:,:) :: srclev_m,dstlev_m,srclev_t,dstlev_t
      real, pointer    , dimension(:,:,:) :: tr,hu
      real*8,allocatable,dimension(:    ) :: za_8,zb_8,zat_8,zbt_8
      real, dimension(l_ni,l_nj) :: pps, ps , topo_temp, topo_abdes
      real*8 lnpref_8,fistr_top_8,diffd
      real step_current
!
!     ---------------------------------------------------------------
!
      call datp2f   ( dat, F_datev )
      err = newdate ( dat, bmf_time1, bmf_time2, -3 )

      if (Ptopo_myproc.eq.0) write(lun_out,9000) bmf_time1, bmf_time2
!
! Lecture des donnees
!
      call get_bmfvar ( Acqi_niu, Acqi_nju, Acqi_niv, Acqi_njv, nka_m, nka_t )

      nbpts = l_ni*l_nj
      nkmax = max ( nka_m, nka_t, G_nk+1 )

      allocate ( za_8 (nka_m), zb_8 (nka_m), zat_8(nka_t), zbt_8(nka_t),           &
                 u_temp(Acqi_niu,Acqi_nju,nkmax), v_temp(Acqi_niv,Acqi_njv,nkmax), &
                 hu_temp(l_ni,l_nj,nkmax), tt_temp(l_ni,l_nj,nkmax),               &
                 gz_temp(l_ni,l_nj,nkmax), zd_temp(l_ni,l_nj,nkmax),               &
                  w_temp(l_ni,l_nj,nkmax),  q_temp(l_ni,l_nj,nkmax)                )

      call read_bmf ( za_8, zb_8, nka_m, zat_8, zbt_8, nka_t            , &
                      u_temp,Acqi_niu,Acqi_nju, v_temp,Acqi_niv,Acqi_njv, &
                      hu_temp,tt_temp,gz_temp,ps,topo_temp              , &
                      zd_temp,w_temp,q_temp, l_ni, l_nj, nkmax)

      Acql_vertint = .false.
      Ana_zd_L=.true.
      Ana_w_L=.true.
      Ana_q_L = .true.
      if (Williamson_case.eq.1) then
          call wil_case1(gz_temp,l_ni,l_nj,nkmax)
          call wil_uvcase1(u_temp,Acqi_niu,Acqi_nju, &
                        v_temp,Acqi_niv,Acqi_njv,nkmax)
      endif
      if (Williamson_case.eq.2) then
          call wil_case2(gz_temp,l_ni,l_nj,nkmax)
          call wil_uvcase2(u_temp,Acqi_niu,Acqi_nju, &
                        v_temp,Acqi_niv,Acqi_njv,nkmax)
      endif
      if (Williamson_case.eq.5) then
          call wil_case5(gz_temp,topo_abdes,l_ni,l_nj,nkmax)
          call wil_uvcase5(u_temp,Acqi_niu,Acqi_nju, &
                        v_temp,Acqi_niv,Acqi_njv,nkmax)
      endif
      if (Williamson_case.eq.6) then
          call wil_case6(gz_temp,l_ni,l_nj,nkmax)
          call wil_uvcase6(u_temp,Acqi_niu,Acqi_nju, &
                        v_temp,Acqi_niv,Acqi_njv,nkmax)
      endif
      if (Williamson_case.eq.8) then
          call wil_case8(gz_temp,l_ni,l_nj,nkmax)
          call wil_uvcase8(u_temp,Acqi_niu,Acqi_nju, &
                        v_temp,Acqi_niv,Acqi_njv,nkmax)
      endif

      initial_data = trim(F_datev).eq.trim(Step_runstrt_S)
      if ( initial_data .and. (Step_kount.eq.0) ) &
         call adjust_topo2( F_topo, topo_temp, gz_temp(1,1,nka_t)   , &
                           ( .not.Acql_prsanl .and. Lam_blendoro_L ), &
                           l_minx,l_maxx,l_miny,l_maxy,l_ni,l_nj )

      if (Vtopo_L) then
         call difdatsd (diffd,Step_runstrt_S,F_datev)
         step_current = diffd*86400.d0/dble(step_dt)
         call var_topo2 (topo_temp, step_current, 1,l_ni,1,l_nj)
      else
         topo_temp(1:l_ni,1:l_nj) = F_topo(1:l_ni,1:l_nj)
      endif

      lnpref_8 = log(Cstv_pref_8)
      fistr_top_8=-Cstv_RTstr_8*(Ver_z_8%m(1)-Cstv_Zsrf_8)
      do j=1,l_nj
      do i=1,l_ni
         pps(i,j)=lnpref_8

!        Reduce size of mountains
!        ------------------------
         if (Williamson_case.eq.5) then
             F_topo(i,j)=topo_abdes(i,j)*Dcst_grav_8
         else
             F_topo(i,j)=F_topo(i,j)/10.
         endif

!        Define log(surface pressure)
         F_s(i,j)=(Dcst_grav_8*gz_temp(i,j,1)-fistr_top_8-F_topo(i,j)) &
                    /Cstv_rtstr_8
      enddo
      enddo

      do k=1,g_nk
      do j=1,l_nj
      do i=1,l_ni
         F_t(i,j,k)  = Cstv_tstr_8
         F_zd (i,j,k) = 0.0
         F_w (i,j,k) = 0.0
      end do
      end do
      end do

      do k=1,G_nk
         F_u(1:Acqi_niu,1:Acqi_nju,k) = u_temp(1:Acqi_niu,1:Acqi_nju,1)
         F_v(1:Acqi_niv,1:Acqi_njv,k) = v_temp(1:Acqi_niv,1:Acqi_njv,1)
      end do

!     Insert the value of gz_temp into the HU tracer for WIll case 1
!     --------------------------------------------------------------
      if (Williamson_case.eq.1) then
         do k=1,Tr3d_ntr
            err= bmf_get (Tr3d_name_S(k),bmf_time1,bmf_time2,-1,hu_temp, &
                                        -1.,1,l_ni,1,l_nj,1,nkmax)
            nullify(tr)
            tr_name = trim(pref_tr)//trim(Tr3d_name_S(k))//trim(suff_tr)
               istat = gmm_get(tr_name,tr,mymeta)
            if (GMM_IS_ERROR(istat)) print *,'readdyn ERROR at gmm_get',tr_name
            if ( err.eq.0 ) then
                 tr (1:l_ni,1:l_nj,1:g_nk) = max(gz_temp(1:l_ni,1:l_nj,1:g_nk), 0.)
            endif
         enddo
      endif

      Acql_pwuv= .false. ;  Acql_pwtt= .false.

      deallocate (u_temp,v_temp,gz_temp,tt_temp,hu_temp,zd_temp,w_temp, &
                                     q_temp,za_8,zb_8,zat_8,zbt_8)
      call bmf_clear

 9000 format(/,' TREATING INPUT DATA VALID AT: ',i8.6,'.',i8.8, &
             /,' ===============================================')
!
!     ---------------------------------------------------------------
!
      return
      end
