!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!**s/r  pressure_sponge -  Performs vertical blending
!
#include "model_macros_f.h"
!
      subroutine height_sponge ()
      implicit none
!author 
!     Plante A.           - May 2004 
!
!revision
! v4_05 - Lepine M.         - VMM replacement with GMM
!
!object
!
!arguments
!       none
!
!implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "vt1.cdk"
#include "schm.cdk"
#include "lun.cdk"
#include "zblen.cdk"
#include "dcst.cdk"
#include "mtn.cdk"
#include "p_geof.cdk"
#include "geomg.cdk"
#include "theo.cdk"
!
!
      integer err,i,j,k, longueur
      integer n

      real betav_m(LDIST_SHAPE,l_nk),betav_t(LDIST_SHAPE,l_nk+1),ubar
      real fi_t(LDIST_SHAPE,l_nk+1)

!----------------------------------------------------------------------
 
      gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'height_sponge ERROR at gmm_get(ut1)'
      gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'height_sponge ERROR at gmm_get(vt1)'
      gmmstat = gmm_get(gmmk_wt1_s,wt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'height_sponge ERROR at gmm_get(wt1)'
      gmmstat = gmm_get(gmmk_tt1_s,tt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'height_sponge ERROR at gmm_get(tt1)'
      gmmstat = gmm_get(gmmk_st1_s,st1,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'height_sponge ERROR at gmm_get(st1)'
      if (.not.Schm_hydro_L) then
         gmmstat = gmm_get(gmmk_qt1_s,qt1,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'height_sponge ERROR at gmm_get(qt1)'
      else
         nullify(qt1)
      endif
 
      call set_betav(betav_m,betav_t,st1,LDIST_DIM,l_nk)

      ubar=mtn_flo/Dcst_rayt_8

      if(Theo_case_S .ne. 'MTN_SCHAR' ) then
         call apply(ut1  ,ubar,betav_m,LDIST_DIM, l_nk)
         call apply(vt1  ,0.  ,betav_m,LDIST_DIM, l_nk)
         if(.not.Schm_hydro_L) then
            call apply(qt1(l_minx,l_miny,1),0.,betav_m,LDIST_DIM, l_nk)
         endif
         if(Zblen_spngtt_L)then
            call apply_tt(tt1,betav_t,st1,LDIST_DIM, l_nk)
         endif
      endif
      call apply(wt1  ,0.  ,betav_t,LDIST_DIM, l_nk+1)
 
!----------------------------------------------------------------------
      return
      end

!=======================================================================
#include "model_macros_f.h"

      subroutine apply(ff,value,betav, DIST_DIM, Nk)

      implicit none

      integer  DIST_DIM, Nk 

#include "glb_pil.cdk"
#include "glb_ld.cdk"

      real ff(DIST_SHAPE,Nk),value,betav(DIST_SHAPE,Nk)

      integer i,j,k,i0,in,j0,jn 

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj     
      if (l_west ) i0 = 1+pil_w
      if (l_east ) in = l_ni-pil_e
      if (l_south) j0 = 1+pil_s
      if (l_north) jn = l_nj-pil_n

      do k=1,Nk
         do j=j0,jn
            do i=i0,in
               ff(i,j,k)=(1.-betav(i,j,k))*ff(i,j,k)+betav(i,j,k)*value
            enddo
         enddo
      enddo
      
      return

      end
!=======================================================================
#include "model_macros_f.h"

      subroutine apply_tt(tt,betav_t, F_s,DIST_DIM, Nk)

      implicit none

      integer  DIST_DIM, Nk 

#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "mtn.cdk"
#include "cstv.cdk"
#include "type.cdk"
#include "ver.cdk"

      real tt(DIST_SHAPE,Nk+1),F_s(DIST_SHAPE)
      real betav_t(DIST_SHAPE,Nk+1)

      real capc1,my_tt,a00,a02,tempo,hauteur

      integer i,j,k,i0,in,j0,jn 

      a00 = mtn_nstar * mtn_nstar/Dcst_grav_8
      capc1 = Dcst_grav_8*Dcst_grav_8/(mtn_nstar*mtn_nstar*Dcst_cpd_8*mtn_tzero)

      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj     
      if (l_west ) i0 = 1+pil_w
      if (l_east ) in = l_ni-pil_e
      if (l_south) j0 = 1+pil_s
      if (l_north) jn = l_nj-pil_n

      do k=1,Nk
         do j=j0,jn
            do i=i0,in
               tempo = exp(Ver_z_8%t(k)+Ver_b_8%t(k)*F_s(i,j))
               a02 = (tempo/Cstv_pref_8)**Dcst_cappa_8
               hauteur=-log((capc1-1.+a02)/capc1)/a00
               my_tt=mtn_tzero*((1.-capc1)*exp(a00*hauteur)+capc1)
               tt(i,j,k)=(1.-betav_t(i,j,k))*tt(i,j,k)+ &
                    betav_t(i,j,k)*my_tt
            enddo
         enddo
      enddo
      
      return

      end
!=======================================================================
