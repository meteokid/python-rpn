!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r itf_phy_geti
!
#include "model_macros_f.h"
Integer Function itf_phy_geti (vd, opt) 

     Use phy_input_types
     Use phy_input_iface, Only : phy_simple_transforms,phy_cor_twater,phy_global_fields
     Use itf_phy_iface  , Only : itf_phy_gdef,itf_phy_fold_sfc,itf_phy_unfold_sfc
     Implicit None

     Type(variable), Pointer      :: vd
     Type(input_options)          :: opt
!
!Author
!     Lubos Spacek - October 2009
!
!Revision
! v4_10 - Spacek, L.     - First revision
! v4_1x - Dugas, B.      - Remove explicit physics dependencies
! v4_40 - Lee, V.        - Add Yin-Yang interpolation for geophysical fields
!
!Object
!     This function provides I/O and horizontal interpolation
!     fonctionality for surface fields required by the physics.
!     The treatment is done by Ptopo_myproc=1 and then
!     distributed to other PEs.
!
!Arguments
!          - Output -
! vd       Structure containing desired descriptors
!
!          - Input -
! opt      allowed options: global_fields_L
!
!Implicits
#include "gmm.hf"

#include "hgc.cdk"
#include "modconst.cdk"
#include "geomn.cdk"
#include "geomg.cdk"
#include "itf_phy_buses.cdk"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "path.cdk"
#include "ptopo.cdk"
#include "lun.cdk"
#include "lctl.cdk"
#include "p_geof.cdk"
#include "lam.cdk"
#include "grd.cdk"

      Integer, External :: fnom, fstouv, fstinf, fstprm, fstfrm, fclos, fstopc
      Integer, External :: fstluk, fstinl, wkoffit, ezgdef_fmem, ezdefset
      Integer, External :: ezsetopt, ip1_all, ezsint, newdate
      Logical, External :: samegrid

      Type(variable), Pointer                  :: temp
      Type(input_dimensions), Dimension(nip1)  :: idim

      Integer :: i,j,k,ii,ij,ik,nf, nft, nr, iun, iok, ier,jer, rx,gmmstat
      Integer :: target_file, tip, global_ni, goff, ifold
      Integer :: dte, det, ipas, p1, p2, p3, g1, g2, g3, g4, bit
      Integer :: dty, swa, lng, dlf, ubc, ex1, ex2, ex3
      Integer :: dum0,dum1,dum2,dum3,dum4,month,day,moa,jj
      Integer :: ni,nj,nk,nijk,sgid,lgid,kind,key,indx,indi,indj,offi,offj
      Integer, Parameter :: nmax=100, fmax=50, lenmax=150
      Integer, Dimension(nip1,4) :: keys,istat
      Logical :: found_L=.False.,NoInterp_L, flag, ier_L
      Character(LEN=1), Dimension(nip1)      :: grd,grref
      Character(LEN=1) :: typ
      Character(LEN=4) :: var
      Character(LEN=12):: lab,cdum
      Character(LEN=lenmax), Dimension(fmax) :: file_found
      Character(LEN=lenmax+15):: command
      Real, Allocatable, Dimension(:,:) :: field,field2,global
      Real, Allocatable, Dimension(:)   :: ax,ay
      Real(kind=8)  :: xx_8(G_ni,G_nj),yy_8(G_ni,G_nj)
!
      real localf(l_ni,l_nj), xfi(G_ni+1), yfi(G_nj)
      real yinyangf(G_ni,G_nj)
!
      Real :: zp1,poa,poam,sum,sumt
      Real(kind=8)  :: rad2deg_8
!
      type(gmm_metadata) :: mymeta
      real, pointer, dimension (:,:) :: BUSENT_3d
!
!     ---------------------------------------------------------------
temp=>vd
!
ier = fstopc('MSGLVL','SYSTEM',0)
ier = fstopc('TOLRNC','SYSTEM',0)
If(Lun_debug_L)ier = fstopc('MSGLVL','INFORM',0)
If(Lun_debug_L)ier = fstopc('TOLRNC','INFORM',0)
goff=0 ; If(G_lam) goff=2

call prsdate (dum0,month,day,dum1,dum2,dum3,dum4,Mod_runstrt_S)

if (Grd_yinyang_L) then
!   Prepare for YY_scal interp
          do j=1,G_nj
          do i=1,G_ni
             xx_8(i,j)=G_xg_8(i)
          enddo
          enddo
          do j=1,G_nj
          do i=1,G_ni
             yy_8(i,j)=G_yg_8(j)
          enddo
          enddo
endif

call itf_phy_gdef (lgid, dstf_gid, xfi, yfi)

read (Lctl_rxstat_S(5:),*) rx

flag=.True. ; itf_phy_geti=-1 ; iun=0

If(Ptopo_myproc==0)&
  Write(Lun_out,"(/,'PHYSICS: acquiring data (S/R ITF_PHY_GETI)',/,46('='))")
If(Lun_debug_L) call Print_stack()
!
Main1 : Do
! Initialization
   nft=Count_files()
!
   If(vd%glbfld_L) allocate( vd%globalf(G_ni,G_nj,vd%p_nu) )
!
   If (nft/=0) Then
      istat=0
      Do target_file=1,nft
         idim=input_dimensions(-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1)
!
         if ((target_file.gt.1).and.(Lun_out.gt.0)) write (Lun_out,1001) trim(vd%nomvar), &
                Trim(vd%file(target_file-1)(index(vd%file(target_file-1),'RUNMOD'):))
!
         if (Lun_out.gt.0) write (Lun_out,1000) trim(vd%nomvar), &
                Trim(vd%file(target_file)(index(vd%file(target_file),'RUNMOD'):)),vd%interp
!
         If (Ptopo_myproc==0) Then
            ier = fnom   (iun,Trim(vd%file(target_file)),'RND+OLD+R/O',0)
            ier = fstouv (iun,'RND')
         endif
!
         Do tip=1,vd%p_nu

            If ( Locate_key (keys(tip,1),keys(tip,2),keys(tip,3),keys(tip,4)) <0 ) Cycle

            Call RPN_COMM_bcast (idim(tip),11,"MPI_INTEGER"  ,0,"grid",ier)
            Call RPN_COMM_bcastc(grd(tip), 1 ,"MPI_CHARACTER",0,"grid",ier)

            nijk=idim(tip)%ni*idim(tip)%nj*idim(tip)%nk
            Allocate (field(idim(tip)%ni,idim(tip)%nj))
            Allocate (ax(idim(tip)%ni),ay(idim(tip)%nj))
!
            If (grd(tip)=='Z')Then
               If(Ptopo_myproc==0)Then
                  global_ni = G_ni+1
                  If(G_lam) global_ni = G_ni
                  NoInterp_L = samegrid( iun,global_ni,G_nj, &
                         idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,&
                         Hgc_ig1ro,Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro,xfi,yfi)
               Endif
               Call RPN_COMM_bcast (NoInterp_L,1,"MPI_LOGICAL"  ,0,"grid",ier)
               If(.Not.NoInterp_L)Then
                  ier=Read_Axes()
                  Call RPN_COMM_bcastc(grref(tip), 1,"MPI_CHARACTER" ,0,"grid",ier)
                  Call RPN_COMM_bcast (ax   ,idim(tip)%ni,"MPI_REAL" ,0,"grid",ier)
                  Call RPN_COMM_bcast (ay   ,idim(tip)%nj,"MPI_REAL" ,0,"grid",ier)
                  sgid = ezgdef_fmem(idim(tip)%ni,idim(tip)%nj,grd(tip),grref(tip),&
                         idim(tip)%rig1,idim(tip)%rig2,idim(tip)%rig3,idim(tip)%rig4, ax, ay)
               Endif
            Else
               NoInterp_L = .False.
               sgid = ezgdef_fmem(idim(tip)%ni,idim(tip)%nj, grd(tip),grref(tip),&
                      idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,idim(tip)%ig4, ax, ay)
            Endif
!
            If(.Not.NoInterp_L)Then
               If(Lam_acidtest_L)then
                  ier = ezsetopt ('INTERP_DEGREE', 'VOISIN')
               Else
                  ier = ezsetopt ('INTERP_DEGREE', vd%interp)
!!$                  print *,'(itf_phy_geti) interp_degree=',trim(vd%interp) ; call flush(6)
               Endif
            Endif
!
            istat(tip,target_file) = Read_field()
            If(vd%glbfld_L) Then
!
               If(Ptopo_myproc==0)Then
!
                  If (NoInterp_L) Then
                     vd%globalf(1:G_ni,1:G_nj,tip)=field(1:G_ni,1:G_nj)
                  Else 
                     ier = ezdefset ( dstf_gid, sgid )
                     ier = ezsint (vd%globalf(1,1,tip), field)
                  Endif
                  If (Grd_yinyang_L) then
                      yinyangf(1:G_ni,1:G_nj)=vd%globalf(1:G_ni,1:G_nj,tip)
                      Call yyg_scalgeo(yinyangf,xx_8,yy_8, &
                        G_Xg_8(1),G_Yg_8(1),G_ni,G_nj,1,vd%interp,vd%nomvar)
                      vd%globalf(1:G_ni,1:G_nj,tip)=yinyangf(1:G_ni,1:G_nj)
                  endif
!
!!$                  print *,'(itf_phy_geti) G:',tip,trim(vd%nomvar),vd%findx,minval(vd%globalf(1:G_ni,1:G_nj,tip)),maxval(vd%globalf(1:G_ni,1:G_nj,tip));call flush(6)
                  ier = Phy_simple_transforms( vd%phyvar,vd%globalf(1:G_ni,1:G_nj,tip),vd%glbfld_L )
!
               Endif
!
            Else
               If(NoInterp_L) Then
                  If(G_lam) Then
                     Call glbdist( field,G_ni,G_nj, localf,1,l_ni,1,l_nj,1,0,0)
                  Else
                     If(Ptopo_myproc==0)Then
                        allocate( global(G_ni,G_nj) )
                        global=field(1:G_ni,1:G_nj)
                     Endif
                     Call glbdist( global,G_ni,G_nj, localf,1,l_ni,1,l_nj,1,0,0)
                     If(Ptopo_myproc==0) deallocate( global )
                  Endif
               Else
!!$                  print *,'(geti) ezsint',lgid, sgid
                  ier = ezdefset ( lgid, sgid )
                  ier = ezsint ( localf, field )
               Endif
               If(Grd_yinyang_L) then
                  call glbcolc( yinyangf,G_ni,G_nj, localf,1,l_ni,1,l_nj,1 )
                  If(Ptopo_myproc==0) then
                     Call yyg_scalgeo(yinyangf,xx_8,yy_8, &
                           G_Xg_8(1),G_Yg_8(1),G_ni,G_nj,1,vd%interp,vd%nomvar)
                  Endif
                  Call glbdist( yinyangf,G_ni,G_nj, localf,1,l_ni,1,l_nj,1,0,0)
               Endif
               If(Lun_debug_L) call glbstat2 (localf,vd%nomvar,"scalge",1,l_ni,1,l_nj,1,1,1,G_ni,1,G_nj,1,1)
!
!!$               print *,'(itf_phy_geti) L:',tip,trim(vd%nomvar),vd%findx,minval(localf),maxval(localf);call flush(6)
               ier = Phy_simple_transforms( vd%phyvar, localf, vd%glbfld_L )
!!$               call statfld3(localf,vd%nomvar,tip,'geti', &
!!$                    1,size(localf,1),1,size(localf,2),1,1, &
!!$                    1,1,1,size(localf,1),size(localf,2),1,8)

               Call itf_phy_fold_sfc( vd%values(1:p_ni,1:p_nj,tip), localf, l_ni, l_nj )
!
            Endif
!
            Deallocate(field,ax,ay,Stat=ier); Call handle_error(ier,'phy_acquire_data','1')
!
         Enddo !tip
!
         If (Ptopo_myproc==0) then
            ier= fstfrm(iun) ; ier= fclos(iun) ; iun= 0
         endif
         If (Sum(istat(:,target_file))==vd%p_nu) Exit
      Enddo
!
      flag = flag.and.Final_check(.true.)
!
   Elseif (NFT==0) Then
!
      If (vd%phyvar=='DLAT') localf=Geomn_latrx
      If (vd%phyvar=='DLON') localf=Geomn_lonrx
      If (vd%phyvar=='MF') Then
         gmmstat = gmm_get(gmmk_fis0_s,fis0,mymeta)
         if (GMM_IS_ERROR(gmmstat)) then
            write(*,*)'itf_phy_geti: ERROR at gmm_get(fis0)'
            ier = -1
         endif
         Call handle_error_l(ier==0,'itf_phy_geti','put_info 1')
         localf(1:l_ni,1:l_nj)=fis0(1:l_ni,1:l_nj)/Dcst_grav_8
      Endif
      If (vd%phyvar=='DXDY') Then
         Do j=1,l_nj
         Do i=1,l_ni
            localf(i,j)= geomg_hxu_8(i-1)*geomg_hyv_8(j-1)*     &
                         Dcst_rayt_8*Dcst_rayt_8*geomg_cy_8(j)
         Enddo
         Enddo
      Endif
      If(vd%phyvar=='EPONMOD')Then
          localf=1.0
          If(.not.G_lam) Call itf_phy_vlsp( localf, l_ni, l_nj )
      Endif
!
      If(vd%glbfld_L) Then
         call glbcolc( vd%globalf(1,1,1),G_ni,G_nj, localf,1,l_ni,1,l_nj,1 )
         If(Ptopo_myproc==0) &
         ier = Phy_simple_transforms( vd%phyvar,vd%globalf(1:G_ni,1:G_nj,1),vd%glbfld_L )
!!$         If(Ptopo_myproc==0) &
!!$              print *,'(itf_phy_geti) G:',trim(vd%nomvar),vd%findx,minval(vd%globalf(1:G_ni,1:G_nj,1)),maxval(vd%globalf(1:G_ni,1:G_nj,1));call flush(6)
      Else
!!$         print *,'(itf_phy_geti) L:',trim(vd%phyvar),vd%findx,minval(localf),maxval(localf);call flush(6)
         ier = Phy_simple_transforms( vd%phyvar,localf,vd%glbfld_L )
         call itf_phy_fold_sfc (vd%values(1:p_ni,1:p_nj,1), localf, l_ni, l_nj)
      Endif
!
   Endif
!
   If(Lun_debug_L) print *,'ITF_PHY_GETI in MAIN1 on ',trim( vd%phyvar )
!
   If ( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
!
End Do Main1
!
If(opt%global_fields_L) then
!
   if (Ptopo_myproc==0)Then
      vd=>temp ; Call Phy_global_fields( vd )
   Endif
!
   vd=>temp ; Main2 : do
      If(vd%glbfld_L) Then
!
         Do tip=1,vd%p_nu
            If (Grd_yinyang_L .and. Ptopo_myproc==0) then
               yinyangf(1:G_ni,1:G_nj)= vd%globalf(1:G_ni,1:G_nj,tip)
               Call yyg_scalgeo(yinyangf,xx_8,yy_8, &
                   G_Xg_8(1),G_Yg_8(1),G_ni,G_nj,1,vd%interp,vd%nomvar)
               vd%globalf(1:G_ni,1:G_nj,tip)=yinyangf(1:G_ni,1:G_nj)
            endif
            Call glbdist( vd%globalf(1:G_ni,1:G_nj,tip),G_ni,G_nj, localf,1,l_ni,1,l_nj,1,0,0)
            call itf_phy_fold_sfc( vd%values(1:p_ni,1:p_nj,tip), localf, l_ni, l_nj )
         Enddo
         deallocate( vd%globalf,Stat=ier ); Call handle_error(ier,'itf_phy_geti','2')
!
      Endif
      If( .Not. Associated(vd%next_value)) Exit
      vd => vd%next_value
   End Do Main2
!
Endif
!
Call handle_error_l (ier==0,'itf_phy_geti','put_info 2')
If (flag.And.Ptopo_myproc==0) Write(*,*)'All variables found!'
Call handle_error_l(flag,'itf_phy_geti','Missing variables, see the listing')

vd=>temp
Call Phy_cor_twater( vd, p_ni,p_nj )

If (Ptopo_myproc==0) Write(*,"(/a/72('='))")'PROCESSING ANCIENT GEOBUS'

vd=>temp
Stats : Do
   Do tip=1,vd%p_nu
      call itf_phy_unfold_sfc( vd%values(1:p_ni,1:p_nj,tip), localf, l_ni,l_nj )
      If(Lun_debug_L) &
      call statf_dm3( localf,vd%phyvar,tip,'PUTI',1,l_ni, &
           1,l_nj,1,1,1+goff,1+goff,1,G_ni-goff,G_nj-goff,1,rx)
   Enddo
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
Enddo Stats

gmmstat = gmm_get ('BUSPER_3d',BUSPER_3d,mymeta)
gmmstat = gmm_get ('BUSENT_3d',BUSENT_3d,mymeta)

vd=>temp
main3 : Do
!
   If (vd%inbus_L) Then     ! Do we put the variable in a bus?
      If (vd%bper_L) Then    ! Put into busper
         Do j=1,p_nj
!!$            ij=vd%findx+(j-1)*p_bper_siz
            Do k=1,vd%p_nu
               ik=vd%findx+(k-1)*p_ni
! When completed, next line becomes useless and all of itf_phy_geti
               BUSPER_3d (ik:ik+p_ni-1,j) = vd%values(1:p_ni,j,k)
            Enddo
         Enddo
      Else                ! Put into geofld
         Do j=1,p_nj
!!$            ij=vd%findx+(j-1)*p_bent_siz
            Do k=1,vd%p_nu
!!$               ik=ij+(k-1)*p_ni
!!$               geofld(ik:ik+p_ni-1) = vd%values(1:p_ni,j,k)
               ik=vd%findx+(k-1)*p_ni
               BUSENT_3d(ik:ik+p_ni-1,j) = vd%values(1:p_ni,j,k)
            Enddo
         Enddo
      Endif
   Endif            ! If not, next variable is treated
!
   If( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
!
End Do main3
!
vd=>temp
!
itf_phy_geti = 0
!
 1000 format (' TREATING: ',a,' FROM FILE: ',a,' WITH ',a)
 1001 format (' ===> WARNING: VARIABLE ',a,' NOT FOUND IN FILE: ',a)
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Contains
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
Integer Function Locate_key (key1,key2,key3,key4)
Implicit None
Integer key1,key2,key3,key4
!
!     ---------------------------------------------------------------
!
Locate_key=-1 ; key1=-1;key2=-1;key3=-1;key4=-1
!
If (Ptopo_myproc==0) Then

   If(vd%search(target_file)/='V')Then
      key1      = Locate_ip1()
      Locate_key= Sign(1,key1)
   Else
      If ( day .Gt. 15 ) Then
         jj = 32 - day
         If ( jj .Gt. 15 ) jj = 15
         moa = month + 1
         If ( month .Eq. 12 ) moa = 1
      Else
         jj  = day
         moa = month - 1
         If ( month .Eq. 1 ) moa = 12
      Endif
      poa = ( jj + 13 ) / 28.
      poam = 1. - poa

      vd%datev=-1
      Write(*,'(a,2i3,a,f)')'    Interpolate '//vd%nomvar//' between months',moa,month,' w=',poa

      vd%ip2=moa
      key2 = Locate_ip1()
      If (key2<=0) Write(*,6000,advance='no')Trim(vd%nomvar),vd%ip2
      vd%ip2=month
      key1 = Locate_ip1()
      If (key1<=0) Write(*,6000,advance='no')Trim(vd%nomvar),vd%ip2
      Locate_key = min(Sign(1,key1),Sign(1,key2))
   Endif
!
   If (Locate_key>=0) Then
      ier = fstprm (key1,dte,det,ipas,&
                    idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,bit,dty, &
                    p1,p2, p3, typ, var, lab, grd(tip),&
                    idim(tip)%ig1, idim(tip)%ig2, idim(tip)%ig3, idim(tip)%ig4,&
                    swa, lng, dlf, ubc, ex1, ex2, ex3)
      If (grd(tip)=='Z') Then
         key3 = fstinf (iun, ni,nj,nk,-1,' ',&
                        idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,' ','>>')
         key4 = fstinf (iun, ni,nj,nk,-1,'',&
                        idim(tip)%ig1,idim(tip)%ig2,idim(tip)%ig3,'','^^')
         ier = fstprm (key3,dte,det,ipas,ni,nj,nk,bit,dty,&
                       p1, p2, p3, typ, var, lab, grref(tip),&
                       idim(tip)%rig1, idim(tip)%rig2,&
                       idim(tip)%rig3, idim(tip)%rig4, swa,&
                       lng, dlf, ubc, ex1, ex2, ex3)
      Endif
   Endif
!
Endif
Call RPN_COMM_bcast (Locate_key,1,"MPI_INTEGER"  ,0,"grid",ier)
!
6000 Format(/,'!!! Error', 75('*'),/,'     Variable ',a,&
            ' not available at IP2: ',i5,/,'!!! Error',75('*'),/)
!
!     ---------------------------------------------------------------
!
End Function Locate_key
!
!
Integer Function Locate_ip1()
!
!     ---------------------------------------------------------------
!
If (vd%ip1(tip) .Eq. -1 .Or. vd%ip1(tip) .Eq. 0 ) Then
   Locate_ip1 = fstinf (iun, idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,vd%datev,vd%etk,&
                        vd%ip1(tip),vd%ip2,vd%ip3,vd%typvar,vd%nomvar )
Else
   Call convip ( vd%ip1(tip), zp1, kind, -1, cdum, .False. )
   Locate_ip1 = fstinf (iun, idim(tip)%ni,idim(tip)%nj,idim(tip)%nk,vd%datev,vd%etk,&
                        ip1_all(zp1,kind),vd%ip2,vd%ip3,vd%typvar,vd%nomvar )
Endif
if (Locate_ip1.lt.0) write (6,1001) vd%nomvar,vd%datev,vd%ip1(tip),vd%ip2,vd%ip3,iun
 1001 format (' WARNING: in Locate_ip1:',/,' ====> CANNOT LOCATE ',a,i11,3i10,' in UNIT: ',i5)
!
!     ---------------------------------------------------------------
!
End Function Locate_ip1
!
!
Integer Function Read_axes()
Read_axes=-1
!
!     ---------------------------------------------------------------
!
If (Ptopo_myproc==0) Then
   If ( keys(tip,3)>0) Then
      ier = fstluk( ax, keys(tip,3), idim(tip)%ni,1,      1)
      jer = fstluk( ay, keys(tip,4), 1,      idim(tip)%nj,1)
      Read_axes = ier*jer
   Endif
Endif
!
Call RPN_COMM_bcast (Read_axes,1,"MPI_INTEGER"  ,0,"grid",ier)
!
!     ---------------------------------------------------------------
!
End Function Read_axes
!
!
Integer Function Read_field()
!
!     ---------------------------------------------------------------
!
If (Ptopo_myproc==0) Then
   Read_field=-1
   ier = fstopc('MSGLVL','INFORM',0)
   ier = fstopc('TOLRNC','INFORM',0)
   ier = fstluk( field, keys(tip,1), idim(tip)%ni,idim(tip)%nj,idim(tip)%nk)
!!$   call statfld3(field,vd%nomvar,0,'geti', &
!!$        1,size(field,1),1,size(field,2),1,1, &
!!$        1,1,1,size(field,1),size(field,2),1,8)

   If ( keys(tip,2)>0) Then
      Allocate(field2(idim(tip)%ni,idim(tip)%nj))
      ier = fstluk( field2, keys(tip,2), idim(tip)%ni,idim(tip)%nj,idim(tip)%nk)
!!$      call statfld3(field2,trim(vd%nomvar)//'2',0,'geti', &
!!$           1,size(field2,1),1,size(field2,2),1,1, &
!!$           1,1,1,size(field2,1),size(field2,2),1,8)
      field = poa*field + poam*field2
!!$      call statfld3(field,trim(vd%nomvar)//'3',0,'geti', &
!!$           1,size(field,1),1,size(field,2),1,1, &
!!$           1,1,1,size(field,1),size(field,2),1,8)
      Deallocate(field2,Stat=ier)
   Endif
   If(.Not.Lun_debug_L)ier = fstopc('MSGLVL','SYSTEM',0)
   If(.Not.Lun_debug_L)ier = fstopc('TOLRNC','SYSTEM',0)
   Read_field=1
Endif
!
If(.Not.(vd%glbfld_L .Or. NoInterp_L ))&
Call RPN_COMM_bcast (field,idim(tip)%ni*idim(tip)%nj,"MPI_REAL" ,0,"grid",ier)
Call RPN_COMM_bcast (Read_field,1,"MPI_INTEGER"  ,0,"grid",ier)
!
!     ---------------------------------------------------------------
!
End Function Read_field
!
!
Integer Function Count_files()
!
!     ---------------------------------------------------------------
!
logical flaggeophy
Count_files=0
nf=0;nft=1;nr=0;
If (Ptopo_myproc==0) Then
   file_found=''
! File names
   Do i=1,nfiles
      If (Len_trim(vd%file(i))/=0) Then
         nf=nf+1
         flaggeophy = trim(vd%file(i))=='GEOPHY'
         vd%file(nf)= trim(Path_phy_S)//trim(vd%file(i))
         if (flaggeophy) then
            if (Grd_yinyang_L) then
               vd%file(nf)=trim(vd%file(nf))//'/Gem_geophy_'//trim(Grd_yinyang_S)//'.fst'
            else
               vd%file(nf)=trim(vd%file(nf))//'/Gem_geophy.fst'
            endif
         endif
      Endif
   Enddo
   Do i=1,nreps
      If(Len_trim(vd%rep(i))/=0)nr=nr+1
   Enddo
   Do i = 1,nf
      Inquire (FILE=Trim(vd%file(i)),EXIST=found_L)
      If (.Not.found_L) then
         write (Lun_out,"(/' FILE: ',a,' NOT AVAILABLE')") Trim(vd%file(i))
         Cycle
      endif
      ier = wkoffit(Trim(vd%file(i)))
      If ((ier/=1).And.(ier/=2).And.(ier/=33).And.(ier/=34)) Then
         Write (Lun_out,"(/'Format unknown file: ',a/)") Trim(vd%file(i))
         Cycle
      Endif
      file_found(nft)=vd%file(i)
      nft=nft+1
   Enddo
   Count_files=nft-1
Endif
Call handle_error_l((Count_files.eq.nf),'itf_phy_geti','INPUT FILES')

Call RPN_COMM_bcast (Count_files,1,"MPI_INTEGER"  ,0,"grid",ier)
!
!     ---------------------------------------------------------------
!
End Function Count_files
!
!
Logical Function Final_check (action)
Logical :: action

Logical           :: flag
Integer           :: i,j,k,ier,dtpr,tmpr
!
!     ---------------------------------------------------------------
!
If(Ptopo_myproc==0)Then
 flag=.true.
 ier = newdate(vd%datev,dtpr,tmpr,-3)
 Do j=1,vd%p_nu
    If(Sum(istat(j,:))==0)Then
       If(action)Write(*,6000)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j),dtpr,tmpr
       flag=.False..and.flag
    Else
       flag=.True..and.flag
       If(action)Then
          If(NoInterp_L)Then
             Write(*,6010)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j),dtpr,tmpr
          Else
             Write(*,6020)Trim(vd%nomvar),Trim(vd%phyvar),vd%ip1(j),dtpr,tmpr
           Endif
       Endif
    Endif
 Enddo
Final_check=flag
Endif
!
Call RPN_COMM_bcast (Final_check,1,"MPI_LOGICAL"  ,0,"grid",ier)
!
 6000 Format(/,'!!! Error', 75('*'),/,'     Variable ',a,' alias ',a,&
             ' not available at LEVEL: ',i5,' DATEV: ',i8.8,1x,i8.8/,&
               '!!! Error',75('*'),/)
 6010 Format('     Variable ',a,' alias ',a,&
             '  distributed at LEVEL ',i5,' DATEV: ',i8.8,1x,i8.8)
 6020 Format('     Variable ',a,' alias ',a,&
             ' interpolated at LEVEL ',i5,' DATEV: ',i8.8,1x,i8.8)
!
!     ---------------------------------------------------------------
!
End Function Final_check
!
!
Subroutine Print_stack
!
!     ---------------------------------------------------------------
!  
Do
   Write(Lun_out,6000)
   Write(Lun_out,6010)vd%nomvar,vd%phyvar,vd%interp,vd%search,vd%etk,&
                      vd%typvar,vd%findx
   Write(Lun_out,"('IP1',2(15i5,/,3x))")vd%ip1(1:vd%p_nu)
   Write(Lun_out,"('FILE ',2(a,/,5x))")(Trim(vd%file(i)),i=1,nfiles)
   Write(Lun_out,"('REPS ',2(a,/,5x))")(Trim(vd%rep(i)),i=1,nfiles)
   Write(Lun_out,"(72('='))")
   If ( .Not. Associated(vd%next_value)) Exit
   vd => vd%next_value
End Do
!
vd=>temp
!
6000 Format('ENTRY NAME ','PHY NAME ',9x,'INTERP ',10x,'SEARCH ', &
            'LABEL',3x,'TYPE',1x,'POSITION')
6010 Format(a4,7x,a16,2x,a16,2x,3a,3x,a8,2x,a2,i8)
!
!     ---------------------------------------------------------------
! 
End Subroutine Print_stack
!
!
End Function itf_phy_geti


