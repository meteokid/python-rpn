!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r tracers - Initializes list of tracers
!
#include "model_macros_f.h"
!
      subroutine tracers ()
      use phy_itf, only: PHY_MAXNAMELENGTH,phymeta,phy_getmeta
      implicit none
#include <arch_specific.hf>
!
!author
!     Michel Desgagne  -  Sept 2001
!
!revision
! v2_31 - Desgagne M.       - initial version
! v3_21 - Lee V.            - remove Tr2d
! v3_30 - Desgagne M.       - memory calculation for tracers
!
!object
!
!arguments
!        Tr3d_name_S acquires the list of tracers from itf_phy_inikey
!        In this subroutine, it will acquire what is introduced from
!        Tr3d_username_S (constructed from the entry routine)
!        ie: QC can be filled with either QC or QCT1 or QCT0 from the
!            given analysis (accessed by E_tr3dname_S of gement nml)
!            but this is converted via BMF/BCS/3DF as QC
!        Tracers requested under auto cascade requires only the first
!        2 letters
!
!implicits
#include <clib_interface.cdk>
#include "lun.cdk"
#include "hzd.cdk"
#include "tr3d.cdk"
      logical hu_L,flag
      integer i,j,k,indx1,needinit,istat,nmeta
      character(len=PHY_MAXNAMELENGTH) :: varname_S,prefix_S,basename_S,time_S,ext_S
      type(phymeta), dimension(:), pointer :: pmeta
!*
!     __________________________________________________________________
!
      nmeta = phy_getmeta(pmeta,' ',F_npath='V',F_bpath='D',F_quiet=.true.)

      do i=1,nmeta
         varname_S = pmeta(i)%vname
         istat = clib_toupper(varname_S)
         if (varname_S(1:3) /= 'TR/') cycle
         call gmmx_name_parts(varname_S,prefix_S,basename_S,time_S,ext_S)
         if (any(Tr3d_name_S(1:tr3d_ntr) == basename_S)) cycle
         tr3d_ntr = tr3d_ntr + 1
         Tr3d_name_S(tr3d_ntr) = basename_S
         Tr3d_wload(tr3d_ntr)  = pmeta(i)%wload
      enddo

      hu_L   = .false.
      do k=1,tr3d_ntr
         if (Tr3d_name_S(k)(1:2).eq.'HU') then
            hu_L  = .true.
            indx1 = k
         endif
      end do

      if (.not.hu_L) then
         tr3d_ntr = tr3d_ntr + 1
         Tr3d_name_S(tr3d_ntr)(1:4) = 'HU  '
         indx1 = tr3d_ntr
      endif
      Tr3d_wload (indx1) = .false.

      do 10 i=1,Tr3d_userntr
!
! Is user tracers already in Tr3d stack?
         do k=1,tr3d_ntr
            if (trim(Tr3d_name_S(k)).eq.trim(Tr3d_username_S(i))) then
               Tr3d_sval(k) = Tr3d_usersval(i)
               goto 10
            endif
         end do
!
! Otherwise add user tracer to Tr3d stack
         tr3d_ntr = tr3d_ntr + 1
         Tr3d_name_S(tr3d_ntr) = Tr3d_username_S(i)
 10   continue
!
      if (Lun_out.gt.0) then
         write (Lun_out,'(/a)') 'TRACERS (3D storage):'
         do i=1,tr3d_ntr
            write (Lun_out,1002) trim(Tr3d_name_S(i)),i
         end do
      endif
!
! Trim user list of tracers to horizontally diffuse (Hzd_tr3d_name_S)
! to fit the current list of tracers of this run
!
      Hzd_tr3d_ntr = 0
      do i=1, HZD_MAXTR
         call low2up (Hzd_tr3d_name_S(i),varname_S)
         flag=.false.
         do k=1,tr3d_ntr
            if (trim(varname_S).eq.trim(Tr3d_name_S(k))) then
               do j=1,Hzd_tr3d_ntr
                  if (trim(varname_S).eq.trim(Hzd_tr3d_name_S(j)))flag=.true.
               end do
               if (.not.flag) then
                  Hzd_tr3d_ntr = Hzd_tr3d_ntr + 1
                  flag=.true.
                  cycle
               else
                  flag=.false.
               endif
            endif
         end do
         if (flag) Hzd_tr3d_name_S(Hzd_tr3d_ntr) = varname_S
      end do
!
 1002 format (2x,a16,2x,i4)
!
!     __________________________________________________________________
!
      return
      end
