!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

#include "model_macros_f.h"
!**s/r statf_dm3 - calcule la moyenne, la variance, le minimum et 
!                 le maximum d un champs et imprime le resultat SANS GLBCOLC
!                 Le calcule peut changer dependement le topologie
!
      subroutine statf_dm3( F_field, F_nv_S, F_no, F_from_S, &
                              Minx,Maxx,Miny,Maxy,Mink,Maxk, &
                              F_i0,F_j0,F_k0,F_in,F_jn,F_kn,F_rx)
      implicit none
#include <arch_specific.hf>
! 
      character*(*) F_nv_S , F_from_S
      integer Minx,Maxx,Miny,Maxy,Mink,Maxk, &
              F_i0,F_j0,F_k0,F_in,F_jn,F_kn,F_no,F_rx
      real F_field (Minx:Maxx,Miny:Maxy,Mink:Maxk)
!
!author
!     M. Desgagne
!
!revision
! v2_00 - Desgagne M.       - initial MPI version (from MC2)
! v3_20 - Desgagne & Lee    - to statfld on each tile, then MPI reduce
! v3_20                       to obtain global stats
! v3_30 - Tanguay M.        - Add if(Lun_out.gt.0)
! v4.30 - Dugas B.          - Calls statf_dm16 under AIX when Lctl_debug_L is true
!
!object
!
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! F_field       I         Field to be operated on
! F_nv_S        I         User provided string to define F_field
! F_no          I         Usually the timestep #
! F_from_S      I         Usually the name of the calling subroutine
! F_i0,F_j0     I         Global lower-left indexes of the sub-domain
!                            on which to perform statistics
! F_in,F_jn     I         Global upper-right indexes of the sub-domain
!                            on which to perform statistics
! F_k0,F_kn     I         Range of levels on which to perform statistics
!----------------------------------------------------------------
!
!implicits
#include "glb_ld.cdk"
#include "lun.cdk"
#include "ptopo.cdk"
!
      integer i,j,k,imin,jmin,kmin,imax,jmax,kmax,err,no, &
              nijk(8,Ptopo_numproc),tnijk(8,Ptopo_numproc),nw,i0,in,j0,jn
      real*8 sum,sumd2,moy,var,mind,maxd,fijk,npt_8, &
             minmax(3,max(2,Ptopo_numproc)),tminmax(3,max(2,Ptopo_numproc))
!
!--------------------------------------------------------------------
!
#if defined (AIX)
      if (F_rx.gt.8) then
         call statf_dm16( F_field, F_nv_S, F_no, F_from_S, &
                          Minx,Maxx,Miny,Maxy,Mink,Maxk,   &
                          F_i0,F_j0,F_k0,F_in,F_jn,F_kn )
         return
      endif
#endif
!
      nijk  (:,:) = 0
      minmax(:,:) = 0.0d0
!
      i0 = max(F_i0 - Ptopo_gindx(1,Ptopo_myproc+1) + 1, 1)
      in = min(F_in - Ptopo_gindx(1,Ptopo_myproc+1) + 1, l_ni)
      j0 = max(F_j0 - Ptopo_gindx(3,Ptopo_myproc+1) + 1, 1)
      jn = min(F_jn - Ptopo_gindx(3,Ptopo_myproc+1) + 1, l_nj)
      nijk(8,Ptopo_myproc+1) = 0
      if ((i0.le.l_ni).and.(in.ge.1).and. &
          (j0.le.l_nj).and.(jn.ge.1) ) nijk(8,Ptopo_myproc+1) = 1
!
      if (nijk(8,Ptopo_myproc+1).gt.0) then
         sum   = 0.0
         sumd2 = 0.0
         imin  = i0
         jmin  = j0
         kmin  = F_k0
         imax  = i0
         jmax  = j0
         kmax  = F_k0
         maxd  = F_field(i0,j0,F_k0)
         mind  = F_field(i0,j0,F_k0)
!
         do k=F_k0,F_kn
         do j=j0,jn
         do i=i0,in
            fijk = F_field(i,j,k)
            sum = sum + fijk
            sumd2 = sumd2 + fijk*fijk
            if (fijk .gt. maxd) then
               maxd = fijk
               imax = i
               jmax = j
               kmax = k
            endif
            if (fijk .lt. mind) then
               mind = fijk
               imin = i
               jmin = j
               kmin = k
            endif
         end do
         end do
         end do
!
         minmax(1,Ptopo_myproc+1) = maxd
         minmax(2,Ptopo_myproc+1) = mind
         minmax(3,1) = sum
         minmax(3,2) = sumd2
!
         nijk  (1,Ptopo_myproc+1) = imax + Ptopo_gindx(1,Ptopo_myproc+1) - 1
         nijk  (2,Ptopo_myproc+1) = jmax + Ptopo_gindx(3,Ptopo_myproc+1) - 1
         nijk  (3,Ptopo_myproc+1) = kmax
         nijk  (4,Ptopo_myproc+1) = imin + Ptopo_gindx(1,Ptopo_myproc+1) - 1
         nijk  (5,Ptopo_myproc+1) = jmin + Ptopo_gindx(3,Ptopo_myproc+1) - 1
         nijk  (6,Ptopo_myproc+1) = kmin
         nijk  (7,1) = (in-i0+1)*(jn-j0+1)*(F_kn-F_k0+1)
!
      endif
!
      nw = 3*max(2,Ptopo_numproc)
      call rpn_comm_REDUCE ( nijk, tnijk, 8*Ptopo_numproc, &
                       "MPI_INTEGER","MPI_SUM",0,"grid",err )
      call rpn_comm_REDUCE ( minmax, tminmax, nw, &
                       "MPI_DOUBLE_PRECISION","MPI_SUM",0,"grid",err )
!       
      if (Ptopo_myproc.eq.0) then
!
         imax  = tnijk (1,1)
         jmax  = tnijk (2,1)
         kmax  = tnijk (3,1)
         imin  = tnijk (4,1)
         jmin  = tnijk (5,1)
         kmin  = tnijk (6,1)
         maxd  = tminmax(1,1)
         mind  = tminmax(2,1)
!
         do i=1,Ptopo_numproc
            if ( tnijk (8,i) .gt. 0 ) then
               fijk = tminmax(1,i)
               if (fijk .gt. maxd) then
                  maxd = fijk
                  imax = tnijk (1,i)
                  jmax = tnijk (2,i)
                  kmax = tnijk (3,i)
               else if (fijk .eq. maxd) then
                  if (kmax.gt.tnijk(3,i)) then
                      imax = tnijk (1,i)
                      jmax = tnijk (2,i)
                      kmax = tnijk (3,i)
                  else if (kmax.eq.tnijk(3,i).and.jmax.gt.tnijk(2,i)) then
                      imax = tnijk (1,i)
                      jmax = tnijk (2,i)
                      kmax = tnijk (3,i)
                  endif
               endif
               fijk = tminmax(2,i)
               if (fijk .lt. mind) then
                  mind = fijk
                  imin = tnijk (4,i)
                  jmin = tnijk (5,i)
                  kmin = tnijk (6,i)
               else if (fijk .eq. mind) then
                  if (kmin.gt.tnijk(6,i)) then
                      imin = tnijk (4,i)
                      jmin = tnijk (5,i)
                      kmin = tnijk (6,i)
                  else if (kmin.eq.tnijk(6,i).and.jmin.gt.tnijk(5,i)) then
                      imin = tnijk (4,i)
                      jmin = tnijk (5,i)
                      kmin = tnijk (6,i)
                  endif
               endif
            endif
         end do
!
         npt_8 = dble(tnijk(7,1))
         sum   = tminmax(3,1)
         sumd2 = tminmax(3,2)
         moy   = sum / npt_8 
         var   = max(0.d0,(sumd2 + moy*moy*npt_8 - 2*moy*sum) / npt_8)
         var   = sqrt(var)
!
         no=F_no
         if (F_rx.lt.8) then
         write(Lun_out,98) no,F_nv_S,moy,var,imin,jmin,kmin,mind, &
                        imax,jmax,kmax,maxd,F_from_S
         else
         write(Lun_out,99) no,F_nv_S,moy,var,imin,jmin,kmin,mind, &
                        imax,jmax,kmax,maxd,F_from_S
         endif
!
      endif
!
 98   format (i4,a4,' Mean:',1pe14.6,' Var:',1pe14.6, &
              ' Min:[(',i4,',',i4,',',i3,')', &
              1pe14.6,']',' Max:[(',i4,',',i4,',',i3,')', &
              1pe14.6,']',a6)
 99   format (i4,a4,' Mean:',1pe22.12,' Var:',1pe22.12,/ &
              ' Min:[(',i4,',',i4,',',i3,')', &
              1pe22.12,']',' Max:[(',i4,',',i4,',',i3,')', &
              1pe22.12,']',a6)
!
!----------------------------------------------------------------
!
      return
      end 
#if defined (AIX)
!**s/r statf_dm16 - Comme pour statf_dm3 mais les calculs sont effectues en real(16)
!
      subroutine statf_dm16( F_field, F_nv_S, F_no, F_from_S, &
                               Minx,Maxx,Miny,Maxy,Mink,Maxk, &
                               F_i0,F_j0,F_k0,F_in,F_jn,F_kn)
      implicit none
#include <arch_specific.hf>
! 
      character*(*) F_nv_S , F_from_S
      integer Minx,Maxx,Miny,Maxy,Mink,Maxk, &
              F_i0,F_j0,F_k0,F_in,F_jn,F_kn,F_no
      real F_field (Minx:Maxx,Miny:Maxy,Mink:Maxk)
!
!author
!     B Dugas
!
!revision
! v4_30 - Dugas B.          - initial version (based on statf_dm3)
!
!object
!
!arguments
!  Name        I/O                 Description
!----------------------------------------------------------------
! F_field       I         Field to be operated on
! F_nv_S        I         User provided string to define F_field
! F_no          I         Usually the timestep #
! F_from_S      I         Usually the name of the calling subroutine
! F_i0,F_j0     I         Global lower-left indexes of the sub-domain
!                            on which to perform statistics
! F_in,F_jn     I         Global upper-right indexes of the sub-domain
!                            on which to perform statistics
! F_k0,F_kn     I         Range of levels on which to perform statistics
!----------------------------------------------------------------
!
!implicits
#include "glb_ld.cdk"
#include "lun.cdk"
#include "ptopo.cdk"
#include "acid.cdk"
!
      integer i,j,k,imin,jmin,kmin,imax,jmax,kmax,err,no, &
              nijk(8,Ptopo_numproc),tnijk(8,Ptopo_numproc),nw,i0,in,j0,jn
      real(16) sumd1,sumd2,moy,var,mind,maxd,fijk,npt_8, &
             minmax(4),tminmax(4,max(2,Ptopo_numproc)),zero
!
!--------------------------------------------------------------------
!
      nijk  (:,:) = 0
      minmax(:) = 0.0
      zero = 0.0
!
      i0 = max(F_i0 - Ptopo_gindx(1,Ptopo_myproc+1) + 1, 1)
      in = min(F_in - Ptopo_gindx(1,Ptopo_myproc+1) + 1, l_ni)
      j0 = max(F_j0 - Ptopo_gindx(3,Ptopo_myproc+1) + 1, 1)
      jn = min(F_jn - Ptopo_gindx(3,Ptopo_myproc+1) + 1, l_nj)
      nijk(8,Ptopo_myproc+1) = 0
      if ((i0.le.l_ni).and.(in.ge.1).and. &
          (j0.le.l_nj).and.(jn.ge.1) ) nijk(8,Ptopo_myproc+1) = 1
!
      if (nijk(8,Ptopo_myproc+1).gt.0) then
         sumd1 = 0.0
         sumd2 = 0.0
         imin  = i0
         jmin  = j0
         kmin  = F_k0
         imax  = i0
         jmax  = j0
         kmax  = F_k0
         maxd  = F_field(i0,j0,F_k0)
         mind  = F_field(i0,j0,F_k0)
!
         do k=F_k0,F_kn
         do j=j0,jn
         do i=i0,in
            fijk = F_field(i,j,k)
            sumd1 = sumd1 + fijk
            sumd2 = sumd2 + fijk*fijk
            if (fijk .gt. maxd) then
               maxd = fijk
               imax = i
               jmax = j
               kmax = k
            endif
            if (fijk .lt. mind) then
               mind = fijk
               imin = i
               jmin = j
               kmin = k
            endif
         end do
         end do
         end do
!
         minmax(1) = maxd
         minmax(2) = mind
         minmax(3) = sumd1
         minmax(4) = sumd2
!
         nijk  (1,Ptopo_myproc+1) = imax + Ptopo_gindx(1,Ptopo_myproc+1) - 1
         nijk  (2,Ptopo_myproc+1) = jmax + Ptopo_gindx(3,Ptopo_myproc+1) - 1
         nijk  (3,Ptopo_myproc+1) = kmax
         nijk  (4,Ptopo_myproc+1) = imin + Ptopo_gindx(1,Ptopo_myproc+1) - 1
         nijk  (5,Ptopo_myproc+1) = jmin + Ptopo_gindx(3,Ptopo_myproc+1) - 1
         nijk  (6,Ptopo_myproc+1) = kmin
         nijk  (7,1) = (in-i0+1)*(jn-j0+1)*(F_kn-F_k0+1)
!
      endif
!
      nw = 4
      call rpn_comm_REDUCE ( nijk, tnijk, 8*Ptopo_numproc, &
                       "MPI_INTEGER","MPI_SUM",0,"grid",err )
      call RPN_COMM_gather( &
     +       minmax, 4*nw, 'MPI_INTEGER', &
     +      tminmax, 4*nw, 'MPI_INTEGER', 0,'GRID',err )
!       
      if (Ptopo_myproc.eq.0) then
!
         imax  = tnijk (1,1)
         jmax  = tnijk (2,1)
         kmax  = tnijk (3,1)
         imin  = tnijk (4,1)
         jmin  = tnijk (5,1)
         kmin  = tnijk (6,1)
         maxd  = tminmax(1,1)
         mind  = tminmax(2,1)
!
         do i=1,Ptopo_numproc
            if ( tnijk (8,i) .gt. 0 ) then
               fijk = tminmax(1,i)
               if (fijk .gt. maxd) then
                  maxd = fijk
                  imax = tnijk (1,i)
                  jmax = tnijk (2,i)
                  kmax = tnijk (3,i)
               else if (fijk .eq. maxd) then
                  if (kmax.gt.tnijk(3,i)) then
                      imax = tnijk (1,i)
                      jmax = tnijk (2,i)
                      kmax = tnijk (3,i)
                  else if (kmax.eq.tnijk(3,i).and.jmax.gt.tnijk(2,i)) then
                      imax = tnijk (1,i)
                      jmax = tnijk (2,i)
                      kmax = tnijk (3,i)
                  endif
               endif
               fijk = tminmax(2,i)
               if (fijk .lt. mind) then
                  mind = fijk
                  imin = tnijk (4,i)
                  jmin = tnijk (5,i)
                  kmin = tnijk (6,i)
               else if (fijk .eq. mind) then
                  if (kmin.gt.tnijk(6,i)) then
                      imin = tnijk (4,i)
                      jmin = tnijk (5,i)
                      kmin = tnijk (6,i)
                  else if (kmin.eq.tnijk(6,i).and.jmin.gt.tnijk(5,i)) then
                      imin = tnijk (4,i)
                      jmin = tnijk (5,i)
                      kmin = tnijk (6,i)
                  endif
               endif
            endif
         end do
!
         npt_8 = dble(tnijk(7,1))
         sumd1 = sum( tminmax(3,1:Ptopo_numproc) )
         sumd2 = sum( tminmax(4,1:Ptopo_numproc) )
         moy   = sumd1 / npt_8 
         var   = max(zero,(sumd2 + moy*moy*npt_8 - 2*moy*sumd1) / npt_8)
         var   = sqrt(var)
!
         no=F_no
         write(Lun_out,98) no,F_nv_S,moy,var,imin,jmin,kmin,mind, &
                        imax,jmax,kmax,maxd,F_from_S
!
      endif
!
 98   format (i4,a4,' Mean:',1pe14.7,' Var:',1pe23.16, &
              ' Min:[(',i4,',',i4,',',i3,')', &
              1pe14.7,']',' Max:[(',i4,',',i4,',',i3,')', &
              1pe14.7,']',a6)
!
!----------------------------------------------------------------
!
      return
      end 
#endif
