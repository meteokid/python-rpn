!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r readdyn - read the dynamics fields from entrance programs
!
#include "model_macros_f.h"
!
      subroutine readdyn3 (F_u, F_v, F_w, F_t, F_zd, F_s, F_q, F_topo, &
                           pref_tr, suff_tr, Mminx,Mmaxx,Mminy,Mmaxy,F_datev)
      implicit none
#include <arch_specific.hf>
!
      character* (*) pref_tr,suff_tr,F_datev
      integer Mminx,Mmaxx,Mminy,Mmaxy
      real F_u (Mminx:Mmaxx,Mminy:Mmaxy,*), F_v(Mminx:Mmaxx,Mminy:Mmaxy,*), &
           F_w (Mminx:Mmaxx,Mminy:Mmaxy,*), F_t(Mminx:Mmaxx,Mminy:Mmaxy,*), &
           F_zd(Mminx:Mmaxx,Mminy:Mmaxy,*), F_s(Mminx:Mmaxx,Mminy:Mmaxy  ), &
           F_q (Mminx:Mmaxx,Mminy:Mmaxy,0:*), F_topo (Mminx:Mmaxx,Mminy:Mmaxy)
!
!author 
!     Michel Roch - rpn - jan 1994
!
!revision
! v2_00 - Desgagne M.      - initial MPI version (from readdyn v1_03)
! V2_20 - Desgagne M.      - longitudes, latitudes and topography now
! v2_20                      read from gem_osdyn
! v2_21 - Desgagne M.      - new calling sequence to glbdist and
! v2_21                      rpn_comm stooge for MPI
! v2_21 - Lee V.           - modifications for LAM version
! v2_30 - Corbeil L.       - Added BMF stuff instead of rdfld, added 
! v2_30                      vertical interpolation
! v2_31 - Edouard/Lee      - proper treatment of hybrid coordinate 
! v2_31 - Desgagne         - clean up and introduce tracers
! v2_31 - Lee V.           - enable case for no interpolation
! v2_32 - Lee V.           - hybrid coordinate derives from "HY" record
! v2_32                    - if same grid and levels but the topography is
! v2_32                      different, vertical interpolation will be done
! v2_32                    - input winds are always UU,VV
! v3_00 - Lee V.           - re-arranged sequence to match new LAM entry
! v3_01 - Corbeil L.       - introduce interface acqui
! v3_10 - Lee V.           - added deallocate topu_temp,topv_temp,gzu_temp...
! v3_11 - Gravel S.        - provide for variable topography
! v3_11 - Lee V.           - correct vertical interp on tracers from pres anal
! v3_12 - Winger K.        - convert TD to HU with pressure level analysis
! v3_20 - Pellerin P.      - to run in off-line mode
! v3_20 - Gravel S.        - allow for initialization with ECMWF analyses
! v3_21 - Dugas B.         - replace TD by ES in pressure mode
! v3_30 - McTaggart-Cowan R. - update implementation of variable orography
! v4_00 - Plante & Girard  - Log-hydro-pressure coord on Charney-Phillips grid
! v4_03 - Lee V.           - Adapt to using new pressure functions
! v4_04 - Plante A.        - Remove offline mode
! v4_04 - Tanguay M.       - modif when autobar on IBM 
! v4_05 - Plante A.        - Add reads and interpolation for w, zd, q
! v4_40 - Lee V.           - Add setup for Yin-yang barotropic (Williamson)
!
!object
!	
!arguments
!	none
!
!implicits
#include "gmm.hf"
#include "glb_ld.cdk"
#include "lun.cdk"
#include "bmf.cdk"
#include "ptopo.cdk"
#include "cstv.cdk" 
#include "dcst.cdk" 
#include "lam.cdk"
#include "geomg.cdk"
#include "grd.cdk"
#include "lctl.cdk"
#include "schm.cdk"
#include "out3.cdk"
#include "acq.cdk"
#include "vtopo.cdk"
#include "anal.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "tr3d.cdk"
#include "vt1.cdk"
#include "pw.cdk"
#include "step.cdk"
#include "bcsgrds.cdk"
#include "wil_williamson.cdk"
!
!modules
      integer,external :: bmf_get,get_px,newdate,samevert
!
      type(gmm_metadata) :: mymeta
      character(len=GMM_MAXNAMELENGTH) :: tr_name
      logical initial_data
      integer nvar,i,j,k,kk,err,nbpts,nka_m,nka_t,nkmax,&
              err_pwuu,err_pwvv,err_pwtt,prdfsum,istat,dat,&
              mustvinterp
      integer G_nkt, G_nkm,i0,in,j0,jn
      real, allocatable, dimension(:    ) :: rna
      real, allocatable, dimension(:,:  ) :: pres,psu_temp,psv_temp,apsu_temp,apsv_temp
      real, allocatable, dimension(:,:,:) :: u_temp,v_temp, hu_temp, tt_temp, &
                                             gz_temp,zd_temp,w_temp,q_temp,   &
                                             u_temp2,v_temp2, vt_temp,        &
                                             work,srclev,dstlev
      real, pointer    , dimension(:,:,:) :: tr,hu
      real*8,allocatable,dimension(:    ) :: za_8,zb_8,zat_8,zbt_8
      real, dimension(l_ni,l_nj) :: pps, ps , topo_temp, topo_abdes
      real qh(LDIST_SHAPE,G_nk+2),tt(LDIST_SHAPE,G_nk+2)
      real*8 lnpref_8,fistr_top_8,diffd
      real step_current
!
!     Acqi_datasp(2) 
!            0 => p =    A                         (B=0),  prs-anal
!            1 => p =    A+B*   ps       , F_p0=ps (A=0),  sig-anal
!            2 => p =    A+B*   ps       , F_p0=ps      ,  etasef-anal
!            3 => p =    A+B*   ps       , F_p0=ps      ,  eta-anal
!            4 => p =    A+B*   ps       , F_p0=ps      ,  hyb-anal
!            5 => p =    A+B*   ps       , F_p0=ps      ,  ecm-anal
!            6 => p =exp(A+B*ln(ps/pref)), F_p0=ps      ,  stg-anal

!*
!     ---------------------------------------------------------------
!
      lnpref_8 = log(Cstv_pref_8)
!
      call datp2f   ( dat, F_datev )
      err = newdate ( dat, bmf_time1, bmf_time2, -3 )

      if (Ptopo_myproc.eq.0) write(lun_out,9000) bmf_time1, bmf_time2
!
! Lecture des donnees
!
      call get_bmfvar ( Acqi_niu, Acqi_nju, Acqi_niv, Acqi_njv, nka_m, nka_t )

      nbpts = l_ni*l_nj
      G_nkt = G_nk+2
      G_nkm = G_nk+1
      if (.not. Schm_phyms_L) then
         G_nkt = G_nk+1
         G_nkm = G_nk
      endif

      nkmax = max ( nka_m, nka_t, G_nk+2 )

      allocate ( za_8 (nka_m), zb_8 (nka_m), zat_8(nka_t), zbt_8(nka_t),           &
                 u_temp(Acqi_niu,Acqi_nju,nkmax), v_temp(Acqi_niv,Acqi_njv,nkmax), &
                 hu_temp(l_ni,l_nj,nkmax), tt_temp(l_ni,l_nj,nkmax),               &
                 gz_temp(l_ni,l_nj,nkmax), zd_temp(l_ni,l_nj,nkmax),               &
                  w_temp(l_ni,l_nj,nkmax),  q_temp(l_ni,l_nj,nkmax)                )

      call read_bmf ( za_8,zb_8,nka_m, zat_8,zbt_8,nka_t, &
                      u_temp,Acqi_niu,Acqi_nju, v_temp,Acqi_niv,Acqi_njv, &
                      hu_temp,tt_temp,gz_temp,ps,topo_temp, &
                      zd_temp,w_temp,q_temp, l_ni, l_nj, nkmax)

      Acql_vertint = .true.
      if(Acqi_datasp(1)==11)then
         Acql_vertint = .false.
         i0=1;in=l_ni;j0=1;jn=l_nj
         if (Grd_yinyang_L) then
             i0=1+pil_w
             in=l_ni-pil_e
             j0=1+pil_s
             jn=l_nj-pil_n
         endif
         mustvinterp = samevert(za_8,zb_8,nka_m,zat_8,zbt_8,nka_t,&
                         gz_temp(1,1,nka_t),topo_temp,l_ni,l_nj,i0,in,j0,jn)
         if (mustvinterp .gt. 0) Acql_vertint = .true.
      endif

      if ( Schm_autobar_L ) then
           Acql_vertint = .false.
           Ana_zd_L=.true.
           Ana_w_L=.true.
           Ana_q_L = .true.
           if (Williamson_case.eq.1) then
               call wil_case1(gz_temp,l_ni,l_nj,nkmax)
               call wil_uvcase1(u_temp,Acqi_niu,Acqi_nju, &
                             v_temp,Acqi_niv,Acqi_njv,nkmax)
           endif
           if (Williamson_case.eq.2) then
               call wil_case2(gz_temp,l_ni,l_nj,nkmax)
               call wil_uvcase2(u_temp,Acqi_niu,Acqi_nju, &
                             v_temp,Acqi_niv,Acqi_njv,nkmax)
           endif
           if (Williamson_case.eq.5) then
               call wil_case5(gz_temp,topo_abdes,l_ni,l_nj,nkmax)
               call wil_uvcase5(u_temp,Acqi_niu,Acqi_nju, &
                             v_temp,Acqi_niv,Acqi_njv,nkmax)
           endif
           if (Williamson_case.eq.6) then
               call wil_case6(gz_temp,l_ni,l_nj,nkmax)
               call wil_uvcase6(u_temp,Acqi_niu,Acqi_nju, &
                             v_temp,Acqi_niv,Acqi_njv,nkmax)
           endif
           if (Williamson_case.eq.8) then
               call wil_case8(gz_temp,l_ni,l_nj,nkmax)
               call wil_uvcase8(u_temp,Acqi_niu,Acqi_nju, &
                             v_temp,Acqi_niv,Acqi_njv,nkmax)
           endif
      endif
!
      initial_data = trim(F_datev).eq.trim(Step_runstrt_S)
      if ( initial_data .and. (Step_kount.eq.0) ) &
         call adjust_topo2( F_topo, topo_temp, gz_temp(1,1,nka_t)   , &
                           ( .not.Acql_prsanl .and. Lam_blendoro_L ), &
                           l_minx,l_maxx,l_miny,l_maxy,l_ni,l_nj )

      if (Vtopo_L) then
         call difdatsd (diffd,Step_runstrt_S,F_datev)
         step_current = diffd*86400.d0/dble(step_dt)
         call var_topo2 (topo_temp, step_current, 1,l_ni,1,l_nj)
      else
         topo_temp(1:l_ni,1:l_nj) = F_topo(1:l_ni,1:l_nj)
      endif

      if (Ptopo_myproc.eq.0) then
         write(lun_out,*) &
            ' Acql_etaanl=',Acql_etaanl,' Vtopo_L=',Vtopo_L
         write(lun_out,*) &
            ' Acql_siganl =',Acql_siganl ,' Acql_hybanl =',Acql_hybanl, &
            ' Acql_prsanl=',Acql_prsanl
         write(lun_out,*) &
            ' Acql_staganl =',Acql_staganl,' Acql_vertint =',Acql_vertint
      endif
!
      allocate(work(l_ni,l_nj,max(nkmax,G_nk+2)))
!
!---------------------------------------------------------------------
!     OBTAIN PS,PPS
!     NOTE: Acqi_vertlv, nka_m, nka_t 
!     includes the diag/surface level at hyb=1.0, for vert. interp 
!--------------------------------------------------------------------
      if(Schm_autobar_L) then
!
!         REQUESTED:otherwise IBM has problem with undefined PPS
!         ------------------------------------------------------
          do j=1,l_nj
          do i=1,l_ni
             pps(i,j)=lnpref_8
          enddo
          enddo
!
          fistr_top_8=-Cstv_RTstr_8*(Cstv_Ztop_8-Cstv_Zsrf_8)
          do j=1,l_nj
          do i=1,l_ni
!            Reduce size of the mountains when Shallow water
!            -----------------------------------------------
!            if (Williamson_case.eq.5.and.Grd_yinyang_L) then
             if (Williamson_case.eq.5) then
                 F_topo(i,j)=topo_abdes(i,j)*Dcst_grav_8
             else
                 F_topo(i,j)=F_topo(i,j)/10.
             endif
             F_s(i,j)=(Dcst_grav_8*gz_temp(i,j,1)-fistr_top_8-F_topo(i,j)) &
                        /Cstv_rtstr_8
          enddo
          enddo
         do k=1,G_nkt
         do j=1,l_nj
         do i=1,l_ni
            F_t(i,j,k)  = Cstv_tstr_8
         end do
         end do
         end do
!        Insert the value of gz_temp into the HU tracer for WIll case 1
!        --------------------------------------------------------------
         do  102 k=1,Tr3d_ntr
            err= bmf_get (Tr3d_name_S(k),bmf_time1,bmf_time2,-1,hu_temp, &
                                        -1.,1,l_ni,1,l_nj,1,nkmax)
            nullify(tr)
            tr_name = trim(pref_tr)//trim(Tr3d_name_S(k))//trim(suff_tr)
      	    istat = gmm_get(tr_name,tr,mymeta)
            if (GMM_IS_ERROR(istat)) print *,'readdyn ERROR at gmm_get',tr_name
            if ( err.eq.0 ) then
                 tr (1:l_ni,1:l_nj,1:G_nk+2) = max(gz_temp(1:l_ni,1:l_nj,1:G_nk+2), 0.)
            endif
 102     continue
      else

         if (Acql_prsanl) then
!         ANALYSIS IS ON PRESSURE COORDINATES
!         Compute pressure on model surface PPS
!
             allocate(rna(nka_m))
             do i=1,nka_m
                rna(i)=za_8(i)
             enddo
             call gz2p0(pps,gz_temp,topo_temp,rna,nbpts,nka_m)
             deallocate (rna)
!
             do j=1,l_nj
             do i=1,l_ni
                F_s (i,j) =pps(i,j)-lnpref_8
                pps(i,j) = F_s (i,j)
             enddo
             enddo
         else if (Acql_vertint) then
!         ANALYSIS IS ON ETA/SIG/HYB/ECMWF COORDINATES
!         Compute pressure on model surface PPS
!
          allocate(pres(nbpts,nka_t))
          allocate(vt_temp(l_ni,l_nj,nkmax))
            err = get_px(pres,ps,nbpts,zat_8,zbt_8,nka_t,Acqi_datasp(2),.false.)
            call handle_error(err,'readdyn','readdyn:get_px')
            if (ana_vt_l) then
               vt_temp(:,:,:) = tt_temp(:,:,:)
            else
               do k=1,nka_t
                  call mfotvt (vt_temp(1,1,k),tt_temp(1,1,k),hu_temp(1,1,k), &
                               nbpts,1,nbpts)
               enddo
            endif
            call adj_ss2topo(pps, topo_temp,pres,gz_temp(1,1,nka_t), &
                             vt_temp,nbpts,nka_t)
          deallocate(vt_temp)
!           ps is p0 for non stag
             do j=1,l_nj
             do i=1,l_ni
                F_s(i,j)=log(pps(i,j))-lnpref_8
                pps(i,j)= F_s(i,j)
             enddo
             enddo
          deallocate(pres)
         else
!NO INTERPOLATION REQUIRED
             do j=1,l_nj
             do i=1,l_ni
                pps   (i,j) =  ps(i,j)
                F_s(i,j) = pps(i,j)
             end do
             end do
         endif
!---------------------------------------------------------------------
!     SETUP THE vertical interpolation column for SRC and DST
!---------------------------------------------------------------------
         if (Acql_vertint) then
            allocate (srclev(l_ni,l_nj,nka_t), &
                      dstlev(l_ni,l_nj,G_nk+2) )
            err = get_px(srclev,ps,l_ni*l_nj,zat_8,zbt_8,nka_t,Acqi_datasp(2),.true.)
            call handle_error(err,'readdyn','readdyn:get_px')
            err = get_px(dstlev,pps,l_ni*l_nj,Ver_a_8%t,Ver_b_8%t,G_nk+2,Ver_code,.true.)
            call handle_error(err,'readdyn','readdyn:get_px')
         endif

!
!---------------------------------------------------------------------
!     TRACERS, HU, thermo levels + diag, mass grid
!---------------------------------------------------------------------
!
         do  100 k=1,Tr3d_ntr
            err= bmf_get (Tr3d_name_S(k),bmf_time1,bmf_time2,-1,hu_temp, &
                                        -1.,1,l_ni,1,l_nj,1,nkmax)
            nullify(tr)
            tr_name = trim(pref_tr)//trim(Tr3d_name_S(k))//trim(suff_tr)
      	    istat = gmm_get(tr_name,tr,mymeta)
            if (GMM_IS_ERROR(istat)) print *,'readdyn ERROR at gmm_get',tr_name
            if ( err.eq.0 ) then
               if (Acql_vertint) then
                  call vte_intvertx3(work,hu_temp,srclev,dstlev,nbpts, &
                                             nka_t,G_nkt,'HU','cubic')
                  if (Schm_bitpattern_L) then 
                     tr (1:l_ni,1:l_nj,1:G_nkt) = work   (1:l_ni,1:l_nj,1:G_nkt)
                  else
                     tr (1:l_ni,1:l_nj,1:G_nkt) = max(work   (1:l_ni,1:l_nj,1:G_nkt), 0.)
                  endif
               else
                  if (Schm_bitpattern_L) then 
                     tr (1:l_ni,1:l_nj,1:G_nkt) = hu_temp(1:l_ni,1:l_nj,1:G_nkt)
                  else
                     tr (1:l_ni,1:l_nj,1:G_nkt) = max(hu_temp(1:l_ni,1:l_nj,1:G_nkt), 0.)
                  endif
               endif 
            else
               tr (1:l_ni,1:l_nj,1:G_nkt) = Tr3d_sval(k)
            endif
 100     continue

!        TEMPERATURE TT1
         if (Acql_vertint) then
             call vte_intvertx3(work,tt_temp,srclev,dstlev,nbpts, &
                                nka_t,G_nkt,'VT','cubic')
         else
             work(:,:,:)=tt_temp(:,:,:)
         endif
!        print *,'readdyn:ana_vt_l is true'
         if (ana_vt_l) then
             do k=1,G_nkt
             do j=1,l_nj
             do i=1,l_ni
                F_t (i,j,k) = work(i,j,k)
             end do
             end do
             end do
         else
             do k=1,G_nkt
             do j=1,l_nj
             do i=1,l_ni
                tt (i,j,k) = work(i,j,k)
             end do
             end do
             end do
             nullify(hu)
             istat = gmm_get('TR/'//'HU'//trim(suff_tr),hu,mymeta)
             if (GMM_IS_ERROR(istat)) print *,'readdyn ERROR at gmm_get','TR/'//'HU'//trim(suff_tr)
             call sumhydro(qh,l_minx,l_maxx,l_miny,l_maxy,G_nkt,'P')
             call mfottvh2(tt,F_t,hu,qh,l_minx,l_maxx,l_miny,l_maxy, G_nkt, &
                           1,l_ni,1,l_nj,.true.)
         endif
!
!---------------------------------------------------------------------

      endif !END of NOT AUTOBAR

      F_zd(:,:,1:G_nkm)=0. ; F_w(:,:,1:G_nkm)=0.

      if (Acql_vertint) then
         call vte_intvertx3(work,zd_temp,srclev,dstlev,nbpts, &
                            nka_t,G_nkm,'ZD','cubic')
         F_zd(:,:,1) = 0. ; F_zd(:,:,g_nk+1) = 0.

         do k=2,G_nkm
            F_zd(1:l_ni,1:l_nj,k) = work(1:l_ni,1:l_nj,k)
         end do
      else
         do k=2,G_nkm
            F_zd(1:l_ni,1:l_nj,k) = zd_temp(1:l_ni,1:l_nj,k)
         end do
      endif
      
      if (Acql_vertint) then
         call vte_intvertx3(work,w_temp,srclev,dstlev,nbpts, &
                            nka_t,G_nkm,'WT','cubic')
         do k=1,G_nkm
            F_w(1:l_ni,1:l_nj,k) = work(1:l_ni,1:l_nj,k)
         end do
      else
         do k=1,G_nkm
            F_w(1:l_ni,1:l_nj,k) = w_temp(1:l_ni,1:l_nj,k)
         end do
      endif
      if (Schm_autobar_L) F_w(:,:,1:G_nkm)= 0.

      if(.not.Schm_hydro_L)then
         if (Acql_vertint) then
            deallocate(srclev,dstlev)
            allocate ( srclev(l_ni,l_nj,nka_m   ), &
                       dstlev(l_ni,l_nj,G_nk+1) )
            err = get_px(srclev,ps,l_ni*l_nj,za_8,zb_8,nka_m,Acqi_datasp(2),.true.)
            call handle_error(err,'readdyn','readdyn:get_px')
            err = get_px(dstlev,pps,l_ni*l_nj,Ver_a_8%m,Ver_b_8%m,G_nk+1,Ver_code,.true.)
            call handle_error(err,'readdyn','readdyn:get_px')                  
            call vte_intvertx3(work,q_temp,srclev,dstlev,nbpts, &
                               nka_m,G_nkm,'QT','cubic')        
!
            do k=1,g_nkm
               F_q(:,:,k) = work(:,:,k)
            end do
         else
            do k=2,G_nkm
               F_q(:,:,k) = q_temp(:,:,k)
            end do
         endif
         F_q(:,:,0) = 0.
      endif
!---------------------------------------------------------------------
!     OBTAIN WINDS, momentum levels + diag, on u/v grids
!---------------------------------------------------------------------

      if (Acql_vertint) then
        deallocate(srclev,dstlev)
        allocate  ( psu_temp(Acqi_niu,Acqi_nju), &
                   apsu_temp(Acqi_niu,Acqi_nju), &
                    psv_temp(Acqi_niv,Acqi_njv), &
                   apsv_temp(Acqi_niv,Acqi_njv) )
        allocate ( u_temp2(Acqi_niu,Acqi_nju,nkmax), &
                   v_temp2(Acqi_niv,Acqi_njv,nkmax) )
!
!       Get pressure on the U,V analysis grid 
        call adj_ss2uv(ps,l_ni,l_nj,apsu_temp,Acqi_niu,Acqi_nju, &
                       apsv_temp,Acqi_niv,Acqi_njv,Acqi_datasp(2))
!
!       Get pressure on the U,V destination model grid
        call adj_ss2uv(pps,l_ni,l_nj,psu_temp,Acqi_niu,Acqi_nju, &
                       psv_temp,Acqi_niv,Acqi_njv,Ver_code)
!
        allocate ( srclev (Acqi_niu,Acqi_nju,nka_m), &
                   dstlev (Acqi_niu,Acqi_nju,G_nk+1) )

        err = get_px(srclev,apsu_temp,Acqi_niu*Acqi_nju,za_8,zb_8,nka_m,Acqi_datasp(2),.true.)
        call handle_error(err,'readdyn','readdyn:get_px')
        err = get_px(dstlev,psu_temp,Acqi_niu*Acqi_nju,Ver_a_8%m,Ver_b_8%m,G_nk+1,Ver_code,.true.)
        call handle_error(err,'readdyn','readdyn:get_px')
        call vte_intvertx3(u_temp2,u_temp,srclev,dstlev,Acqi_niu*Acqi_nju, &
                           nka_m,G_nkm,'UU','cubic')
        deallocate (srclev,dstlev)
!
        allocate ( srclev (Acqi_niv,Acqi_njv,nka_m), &
                   dstlev (Acqi_niv,Acqi_njv,G_nk+1) )
        err = get_px(srclev,apsv_temp,Acqi_niv*Acqi_njv,za_8,zb_8,nka_m,Acqi_datasp(2),.true.)
        call handle_error(err,'readdyn','readdyn:get_px')
        err = get_px(dstlev,psv_temp,Acqi_niv*Acqi_njv,Ver_a_8%m,Ver_b_8%m,G_nk+1,Ver_code,.true.)
        call handle_error(err,'readdyn','readdyn:get_px')
        call vte_intvertx3(v_temp2,v_temp,srclev,dstlev,Acqi_niv*Acqi_njv, &
                           nka_m,G_nkm,'VV','cubic')
        do k=1,g_nkm
           u_temp(1:Acqi_niu,1:Acqi_nju,k) = u_temp2(1:Acqi_niu,1:Acqi_nju,k)
           v_temp(1:Acqi_niv,1:Acqi_njv,k) = v_temp2(1:Acqi_niv,1:Acqi_njv,k)
        enddo
        deallocate (srclev,dstlev)
        deallocate ( apsu_temp,apsv_temp,psu_temp,psv_temp,u_temp2,v_temp2)
      endif

      if(Acqi_datasp(1)/=11) call vte_uv2img (u_temp, v_temp, Acqi_niu, Acqi_nju, &
                             Acqi_niv, Acqi_njv, g_nkm, geomg_y_8(1), geomg_yv_8(1))

      do k=1,g_nkm
         F_u(1:Acqi_niu,1:Acqi_nju,k) = u_temp(1:Acqi_niu,1:Acqi_nju,k)
         F_v(1:Acqi_niu,1:Acqi_nju,k) = v_temp(1:Acqi_niu,1:Acqi_nju,k)
      end do

      Acql_pwuv= .false. ;  Acql_pwtt= .false.

      if (Schm_phyms_L) then

         err_pwuu = bmf_get ('PWUU',bmf_time1,bmf_time2,-1,hu_temp,-1, &
                                               1,l_ni,1, l_nj,1,nkmax)
         err_pwvv = bmf_get ('PWVV',bmf_time1,bmf_time2,-1,tt_temp,-1, &
                                               1,l_ni,1, l_nj,1,nkmax)

         if ((err_pwuu.eq.0).and.(err_pwvv.eq.0)) then
            err = gmm_get (gmmk_pw_uu_plus_s, pw_uu_plus, mymeta)
            err = gmm_get (gmmk_pw_vv_plus_s, pw_vv_plus, mymeta)
            do k=1,g_nkm
               pw_uu_plus(1:l_ni,1:l_nj,k+1) = hu_temp(1:l_ni,1:l_nj,k)
               pw_vv_plus(1:l_ni,1:l_nj,k+1) = tt_temp(1:l_ni,1:l_nj,k)
            end do
            pw_uu_plus(:,:,1) = 0.
            pw_vv_plus(:,:,1) = 0.
            Acql_pwuv= .true.
         endif
         
         err_pwtt = bmf_get ('PWTT',bmf_time1,bmf_time2,-1,hu_temp,-1, &
                                               1,l_ni,1, l_nj,1,nkmax)
         if (err_pwtt.eq.0) then
            err = gmm_get (gmmk_pw_tt_plus_s, pw_tt_plus, mymeta)
            do k=1,g_nkm
               pw_tt_plus(1:l_ni,1:l_nj,k+1) = hu_temp(1:l_ni,1:l_nj,k)
            end do
            pw_tt_plus(:,:,1) = 0.
            Acql_pwtt= .true.
         endif

      endif
      
      deallocate (u_temp,v_temp,gz_temp,tt_temp,hu_temp,zd_temp,w_temp, &
                                     q_temp,work,za_8,zb_8,zat_8,zbt_8)
      call bmf_clear

 9000 format(/,' TREATING INPUT DATA VALID AT: ',i8.6,'.',i8.8, &
             /,' ===============================================')
!
!     ---------------------------------------------------------------
!
      return
      end
