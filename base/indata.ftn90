!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r indata - Read and process the input data at 
!               beginning of integration
!
#include "model_macros_f.h"
!
      subroutine indata
!
      implicit none
#include <arch_specific.hf>
!
!author 
!     Michel Roch - rpn - apr 1994
!
!revision
! v2_00 - Desgagne M.       - initial MPI version (from indata v1_03)
! v2_10 - Tanguay M.        - introduce partition of preprocessing when 4D-Var 
! v2_20 - Pellerin P.       - read geophysical fields depending on schemes
! v2_20 - Lee V.            - eliminated p_slicgeo, output of geophysical fields
! v2_20 -                     will be from the entry or permanent physics bus
! v2_30 - Desgagne M.       - entry vertical interpolator in gemdm
! v2_31 - Tanguay M.        - adapt for vertical hybrid coordinate 
! v3_02 - Buehner M.        - leave winds as images for 4dvar or SV jobs
! v3_03 - Tanguay M.        - Adjoint Lam configuration 
! v3_11 - Gravel S.         - Adapt for theoretical cases and varying topo
! v3_11 - Tanguay M.        - Abort when V4dg_conf.ne.0 and Vtopo_L  
! v3_30 - Desgagne M.       - re-organize code to eliminate v4d controls
! v3_30 - Lee V.            - new LAM I/O interface
! v4_00 - Plante & Girard   - Log-hydro-pressure coord on Charney-Phillips grid
! v4_03 - Tanguay M.        - Williamson's cases
! v4_03 - Lee/Desgagne - ISST
! v4_06 - Lepine M.         - VMM replacement with GMM
! v4_06 - Lee V.            - predat is called after readdyn, casc_3df_dynp
! v4_10 - Tanguay M.        - VMM replacement with GMM for (TL/AD)
! v4_12 - Tanguay M.        - Adapt to revised predat
! v4_13 - Spacek L.         - Delete call to readgeo, add Path_phy_S
! v4_13 - Tanguay M.        - Adjustments GEM413 .not. Schm_hydro_L
! v4_21 - Plante A.         - Call predat4     
!
!object
!	
!arguments
!	none
!
!implicits
#include "gmm.hf"
#include "acid.cdk"
#include "lam.cdk"
#include "grd.cdk"
#include "schm.cdk"
#include "glb_ld.cdk"
#include "bmf.cdk"
#include "p_geof.cdk"
#include "vt1.cdk"
#include "vtx.cdk"
#include "vtopo.cdk"
#include "lun.cdk"
#include "step.cdk"
#include "wil_williamson.cdk"
#include "path.cdk"
!
      logical  v4d_indata2,v4d_predat
      integer  nav_3df,newdate
      external nav_3df,newdate,v4d_indata2,v4d_predat
!
      type(gmm_metadata) :: mymeta
      character*256 fn
      integer err,unf,errop,dat,k,skipcode,istat
!
!     ---------------------------------------------------------------
!
      if (Lun_out.gt.0) write (Lun_out,1000)
!
      call v4d_indata1 (Vtopo_L)
!
      istat = gmm_get(gmmk_ut1_s,ut1,mymeta)
      if (GMM_IS_ERROR(istat)) print *,'indata ERROR at gmm_get(ut1)'
      istat = gmm_get(gmmk_vt1_s,vt1,mymeta)
      if (GMM_IS_ERROR(istat)) print *,'indata ERROR at gmm_get(vt1)'
      istat = gmm_get(gmmk_wt1_s,wt1,mymeta)
      if (GMM_IS_ERROR(istat)) print *,'indata ERROR at gmm_get(wt1)'
      istat = gmm_get(gmmk_tt1_s,tt1,mymeta)
      if (GMM_IS_ERROR(istat)) print *,'indata ERROR at gmm_get(tt1)'
      istat = gmm_get(gmmk_zdt1_s,zdt1,mymeta)
      if (GMM_IS_ERROR(istat)) print *,'indata ERROR at gmm_get(zdt1)'
      istat = gmm_get(gmmk_st1_s,st1,mymeta)
      if (GMM_IS_ERROR(istat)) print *,'indata ERROR at gmm_get(st1)'
      istat = gmm_get(gmmk_fiptx_s,fiptx,mymeta)
      if (GMM_IS_ERROR(istat)) print *,'indata ERROR at gmm_get(fiptx)'
      istat = gmm_get(gmmk_fis0_s,fis0,mymeta)
      if (GMM_IS_ERROR(istat)) print *,'indata ERROR at gmm_get(fis0)'
!
      if (.not. Schm_hydro_L) then
         istat = gmm_get(gmmk_qt1_s,qt1,mymeta)
         if (GMM_IS_ERROR(istat)) print *,'indata ERROR at gmm_get(qt1)'
      else
         nullify (qt1)
      endif
      if ( Vtopo_L) then
         istat = gmm_get(gmmk_dfis_s,dfis,mymeta)
         if (GMM_IS_ERROR(istat)) print *,'var_topo ERROR at gmm_get(dfis)'
      else
         nullify (dfis)
      endif
!
      if ( v4d_indata2 (ut1,vt1,tt1,zdt1,st1,fis0,fiptx,wt1,qt1, &
                           l_minx,l_maxx,l_miny,l_maxy) ) goto 9999
!
      if (Grd_yinyang_L) then         
         Path_ind_S=trim(Path_input_S)//'/MODEL_INPUT/'//trim(Grd_yinyang_S)
      else
         Path_ind_S=trim(Path_input_S)//'/MODEL_INPUT'
      endif
      Path_phy_S=trim(Path_input_S)//'/'
!
      errop = -1
      if (G_lam) then
         unf = 76
         fn  = trim(Path_ind_S)//'/3df_filemap.txt'
         open (unf,file=fn,access='SEQUENTIAL',status='OLD', &
                              iostat=errop,form='FORMATTED')
      endif
!
      if ( errop.eq.0 ) then
         err = nav_3df  (unf,1.2,1.0d0)
         call handle_error(err,'nav_3df','')
         if (Acid_test_L.and..not.Acid_pilot_L) then
            call acid_3df_dynp (G_ni,G_nj,unf)
         else
            call casc_3df_dynp2 (ut1,vt1,wt1,tt1,zdt1,st1,qt1,fis0,dfis, &
                 l_minx,l_maxx,l_miny,l_maxy,G_ni,G_nj,unf,Step_runstrt_S)
         endif
      else
         call datp2f   ( dat, Step_runstrt_S )
         err = newdate ( dat, bmf_time1, bmf_time2, -3 )
!
         if ( Schm_theoc_L ) then
            call theo_3D (ut1,vt1,wt1,tt1,zdt1,st1,fis0, &
                          qt1,dfis, 'TR/',':P') ! canonical cases - generate initial data
         else
            call readdyn2 (ut1,vt1,wt1,tt1,zdt1,st1,fiptx,fis0, &
                           qt1,dfis, 'TR/',':P', &
                           l_minx,l_maxx,l_miny,l_maxy)
         endif	  
      endif
!
      call v4d_indata3 (ut1,vt1,l_minx,l_maxx,l_miny,l_maxy) 
!
      call set_dync ()
!
      if (Schm_autobar_L.and.Williamson_case.ne.0)  &
                             call wil_prepare_case 
!
      if (.not. v4d_predat ( ut1, vt1, tt1, zdt1, st1, fis0, fiptx, wt1, qt1, &
                                       l_minx,l_maxx,l_miny,l_maxy) )  &
           call    predat4 ( ut1, vt1, tt1, zdt1, wt1, st1, qt1, fis0, fiptx,    &
                                       l_minx,l_maxx,l_miny,l_maxy)
!
      call glbstat2(fis0,'ME',"indata",l_minx,l_maxx,l_miny,l_maxy,1,1, 1,G_ni,1,G_nj,1,1)
!
 9999 if (G_lam) then
         call nest_init ()
      else
         call glhalo_init()
      endif
!
!     ---------------------------------------------------------------
!
 1000 format(/,'TREATING INITIAL CONDITIONS  (S/R INDATA)',/,41('='))
 1002 format(/,' FILE ',A,'_gfilemap.txt IS NOT AVAILABLE --CONTINUE--',/,/)
!
      return
      end
