!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r yyg_yangrid
!
      integer function yyg_yangrid ()
      implicit none
!
!author
!     V. Lee/A. Qaddouri - April 2011
!
!revision
! v4_40 - Qaddouri/Lee      - To obtain Yang grid
!
!object
!  To return the rotation for the Yang grid using the rotation from Yin
!
#include "grd.cdk"
#include "lun.cdk"
!
      real   xlat1,xlon1,xlat2,xlon2
      real*8 a_8,b_8,c_8,d_8,xyz1_8(3),xyz2_8(3)
      real*8 rot_8(3,3),invrot_8(3,3),xyz3_8(3),xyz4_8(3)
      real*8 yyrot_8(3,3),mrot_8(3,3),m1rot_8(3,3)
      integer i,j
!
!-------------------------------------------------------------------
!
      yyg_yangrid = -1

!First check the Yin grid rotation is ok
      if (Grd_xlat1.lt.0.0 .and. Grd_xlat2.lt. 0.0 .and. &
                                 Grd_xlon2.gt.Grd_xlon1) then
          print *,'ERROR: Grd_xlat1,Grdxlat2 < 0.0 and Grd_xlon2 > Grd_xlon1'
          if (Lun_out.gt.0) then
             write(Lun_out,1001)  Grd_xlat1,Grd_xlon1,Grd_xlat2,Grd_xlon2
             write(Lun_out,8000)
          endif
          return
      else if (Grd_xlat1.ge.0.0 .and. Grd_xlat2.ge.0.0 .and. &
                                 Grd_xlon1.gt.Grd_xlon2) then
          print *,'ERROR: Grd_xlat1,Grd_xlat2 >= 0.0 and Grd_xlon1 > Grd_xlon2'
          if (Lun_out.gt.0) then
             write(Lun_out,1001)  Grd_xlat1,Grd_xlon1,Grd_xlat2,Grd_xlon2
             write(Lun_out,8000)
          endif
          return
      endif
!
!Then get the rotation for the Yin grid
      call llacar ( xyz1_8, Grd_xlon1, Grd_xlat1, 1, 1 )
      call llacar ( xyz2_8, Grd_xlon2, Grd_xlat2, 1, 1 )
      a_8 = (xyz1_8(1)*xyz2_8(1)) + (xyz1_8(2)*xyz2_8(2))  &
                                  + (xyz1_8(3)*xyz2_8(3))
      b_8 = sqrt (((xyz1_8(2)*xyz2_8(3)) - (xyz2_8(2)*xyz1_8(3)))**2 &
               +  ((xyz2_8(1)*xyz1_8(3)) - (xyz1_8(1)*xyz2_8(3)))**2  &
               +  ((xyz1_8(1)*xyz2_8(2)) - (xyz2_8(1)*xyz1_8(2)))**2)
      c_8 = sqrt ( xyz1_8(1)**2 + xyz1_8(2)**2 + xyz1_8(3)**2 )
      d_8 = sqrt ( ( ( (a_8*xyz1_8(1)) - xyz2_8(1) ) / b_8 )**2 + &
                   ( ( (a_8*xyz1_8(2)) - xyz2_8(2) ) / b_8 )**2 + &
                   ( ( (a_8*xyz1_8(3)) - xyz2_8(3) ) / b_8 )**2  )
      rot_8(1,1)=  -xyz1_8(1)/c_8
      rot_8(1,2)=  -xyz1_8(2)/c_8
      rot_8(1,3)=  -xyz1_8(3)/c_8
      rot_8(2,1)=  ( ((a_8*xyz1_8(1)) - xyz2_8(1)) / b_8)/d_8
      rot_8(2,2)=  ( ((a_8*xyz1_8(2)) - xyz2_8(2)) / b_8)/d_8
      rot_8(2,3)=  ( ((a_8*xyz1_8(3)) - xyz2_8(3)) / b_8)/d_8
      rot_8(3,1)=   &
                 ( (xyz1_8(2)*xyz2_8(3)) - (xyz2_8(2)*xyz1_8(3)))/b_8
      rot_8(3,2)=   &
                 ( (xyz2_8(1)*xyz1_8(3)) - (xyz1_8(1)*xyz2_8(3)))/b_8
      rot_8(3,3)=   &
                 ( (xyz1_8(1)*xyz2_8(2)) - (xyz2_8(1)*xyz1_8(2)))/b_8

!Get transpose of rotation
      do i=1,3
      do j=1,3
         invrot_8(i,j)=rot_8(j,i)
      enddo
      enddo

!Find the centre of Yang grid through Yin by setting
      xlon1 = 0.0
      xlat1 = 0.0
!And set the rotation for Yang grid with respect to Yin
      xlon2 = 0.0
      xlat2 = 90.0

!Obtain the cartesian coordinates
      call llacar ( xyz1_8, xlon1, xlat1, 1, 1 )
      call llacar ( xyz2_8, xlon2, xlat2, 1, 1 )
      call mxma8(invrot_8,1,3,xyz1_8,1,3,xyz3_8,1,3,3,3,1)
      call mxma8(invrot_8,1,3,xyz2_8,1,3,xyz4_8,1,3,3,3,1)

!Obtain the real geographic coordinates
      call cartall(xlon1,xlat1, xyz3_8,1)
      call cartall(xlon2,xlat2, xyz4_8,1)
      if (xlon1.ge.360.) xlon1=xlon1-360.0
      if (xlon2.ge.360.) xlon2=xlon2-360.0
!
      if (trim(Grd_yinyang_S) .eq. 'YAN') then
         Grd_xlat1=xlat1
         Grd_xlon1=xlon1
         Grd_xlat2=xlat2
         Grd_xlon2=xlon2
      endif
!
      yyg_yangrid = 1
!
 1001 format(/,' WRONG YIN GRID CONFIGURATION --- ABORT ---'/, &
               ' Grd_xlat1,Grd_xlon1,Grd_xlat2,Grd_xlon2:'/4f10.3/)
 8000 format (/,'========= ERROR IN S/R yyg_yangrid ============='/)
!
!-------------------------------------------------------------------
!
      return
      end
