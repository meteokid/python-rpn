!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#include "model_macros_f.h"

!/**
subroutine itf_adx_get_winds2 ( F_ud, F_vd, F_wd, F_ua, F_va, F_wa, F_wat, &	
                                F_minx,F_maxx,F_miny,F_maxy,F_nk         , &
                                F_lni,F_lnj,F_nk_winds )
   implicit none
#include <arch_specific.hf>
   !@objective process winds in preparation for advection
   !@arguments

   integer :: F_minx,F_maxx,F_miny,F_maxy,F_nk,F_lni,F_lnj,F_nk_winds
   real, dimension(F_minx:F_maxx,F_miny:F_maxy,F_nk_winds) :: &
                  F_ud, F_vd, F_wd    !O, model de-stag winds
   real, dimension(F_lni,F_lnj,F_nk) :: F_ua,F_va,F_wa,F_wat

   !@author alain patoine
   !@revisions
   ! v2_31 - Desgagne M.       - removed stkmemw
   ! v3_00 - Desgagne & Lee    - Lam configuration
   ! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
   ! v3_21 - Desgagne M.       - Revision OpenMP
   ! v4_   - Gravel S.         - Staggered version
   ! v4_10 - Plante A.         - Add interpolation of wind on their non-native
   ! Jan 2010, S. Chamberland: split out of adw and into smaller/logical units
   ! v4_40 - Qaddouri/Lee - Yin-Yang, to exchange de-stag winds,use global range
   !@description
   !  
!**/

#include "glb_ld.cdk"
#include "gmm.hf"
#include "vth.cdk"
#include "vt0.cdk"
#include "vt1.cdk"
#include "schm.cdk"

   integer :: istat,i,j,k,k2
   real, dimension(:,:,:), pointer :: um,ut,uh,vm,vt,vh,wm,wh

Interface
Subroutine itf_adx_destag_winds (F_u,F_v,F_uth,F_vth)
      real, dimension(:,:,:), pointer :: F_uth,F_vth !I, staggered winds
      real, dimension(:,:,:), pointer :: F_u,F_v     !O, destaggered winds
End Subroutine itf_adx_destag_winds 
subroutine itf_adx_img2real_winds(F_ur,F_vr,F_ui,F_vi)
      real, dimension(:,:,:), pointer :: F_ui,F_vi !I=image winds
      real, dimension(:,:,:), pointer :: F_ur,F_vr !O=real winds
End Subroutine itf_adx_img2real_winds
subroutine itf_adx_interp_thermo2mom(F_fld_m,F_fld_t)
      real, dimension(:,:,:), pointer :: F_fld_t !intent(in)
      real, dimension(:,:,:), pointer :: F_fld_m !intent(out)
End Subroutine itf_adx_interp_thermo2mom
subroutine itf_adx_interp_mom2thermo(F_fld_t,F_fld_m)
      real, dimension(:,:,:), pointer :: F_fld_m !intent(in)
      real, dimension(:,:,:), pointer :: F_fld_t !intent(out)
End Subroutine itf_adx_interp_mom2thermo
End Interface

   !---------------------------------------------------------------------

   istat = GMM_OK
   istat = min(gmm_get(gmmk_ut0_s ,  ut0),istat)
   istat = min(gmm_get(gmmk_vt0_s ,  vt0),istat)
   istat = min(gmm_get(gmmk_zdt0_s, zdt0),istat)
   istat = min(gmm_get(gmmk_ut1_s ,  ut1),istat)
   istat = min(gmm_get(gmmk_vt1_s ,  vt1),istat)
   istat = min(gmm_get(gmmk_zdt1_s, zdt1),istat)

   allocate ( um(l_minx:l_maxx,l_miny:l_maxy,l_nk  ), &
              ut(l_minx:l_maxx,l_miny:l_maxy,l_nk+1), &
              uh(l_minx:l_maxx,l_miny:l_maxy,l_nk  ), &
              vm(l_minx:l_maxx,l_miny:l_maxy,l_nk  ), &
              vt(l_minx:l_maxx,l_miny:l_maxy,l_nk+1), &
              vh(l_minx:l_maxx,l_miny:l_maxy,l_nk  ), &
              wm(l_minx:l_maxx,l_miny:l_maxy,l_nk  ), &
              wh(l_minx:l_maxx,l_miny:l_maxy,0:l_nk) )

   if(Schm_trapeze_L) then
      call itf_adx_destag_winds  (um,vm,ut0,vt0)
      call itf_adx_img2real_winds(um,vm,um ,vm )
      call itf_adx_interp_thermo2mom(wm,zdt0)
      F_ua =  um(1:l_ni,1:l_nj,1:l_nk)
      F_va =  vm(1:l_ni,1:l_nj,1:l_nk)
      F_wa =  wm(1:l_ni,1:l_nj,1:l_nk)
      F_wat=zdt0(1:l_ni,1:l_nj,1:l_nk)
      uh (1:l_niu,1:l_nj ,1:l_nk)= ut1 (1:l_niu,1:l_nj ,1:l_nk)
      vh (1:l_ni ,1:l_njv,1:l_nk)= vt1 (1:l_ni ,1:l_njv,1:l_nk)
      wh (1:l_ni ,1:l_nj ,1:l_nk)= zdt1(1:l_ni ,1:l_nj ,1:l_nk)
   else
      uh (1:l_niu,1:l_nj ,1:l_nk  )= .5*( ut1(1:l_niu,1:l_nj ,1:l_nk)+ ut0(1:l_niu,1:l_nj ,1:l_nk))
      vh (1:l_ni ,1:l_njv,1:l_nk  )= .5*( vt1(1:l_ni ,1:l_njv,1:l_nk)+ vt0(1:l_ni ,1:l_njv,1:l_nk))
      wh (1:l_ni ,1:l_nj ,1:l_nk  )= .5*(zdt1(1:l_ni ,1:l_nj ,1:l_nk)+zdt0(1:l_ni ,1:l_nj ,1:l_nk))
   endif

   wh(1:l_ni ,1:l_nj ,0)=0.0

   call itf_adx_destag_winds  (um,vm,uh,vh)
   call itf_adx_img2real_winds(uh,vh,um,vm)

   if(Schm_superwinds_L)then

      call itf_adx_interp_mom2thermo(ut,uh)
      call itf_adx_interp_mom2thermo(vt,vh)
      call itf_adx_interp_thermo2mom(wm,wh)

      k2= 0
      do k = 1, F_nk_winds, 2
         k2 = k2+1
         do j = l_miny, l_maxy
         do i = l_minx, l_maxx 
            F_ud(i,j,k) =   ut(i,j,k2)
            F_vd(i,j,k) =   vt(i,j,k2)
            F_wd(i,j,k) =   wh(i,j,k2-1)
         enddo
         enddo
      enddo
      k2= 0
      do k = 2, F_nk_winds, 2
         k2 = k2+1
         do j = l_miny, l_maxy
         do i = l_minx, l_maxx 
            F_ud(i,j,k) = uh(i,j,k2)
            F_vd(i,j,k) = vh(i,j,k2)
            F_wd(i,j,k) = wm(i,j,k2)
         enddo
         enddo
      enddo

   else

      call itf_adx_interp_thermo2mom (wm,zdth)
      F_ud=uh; F_vd=vh; F_wd=wm

   endif

   deallocate(um,ut,uh,vm,vt,vh,wm,wh)

   !---------------------------------------------------------------------
   return

end subroutine itf_adx_get_winds2




