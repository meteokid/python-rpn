!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#include "model_macros_f.h"
#include "msg.h"
#include "stop_mpi.h"

subroutine itf_adx_get_winds()
   implicit none
#include <arch_specific.hf>
   !---------------------------------------------------------------------
   call stop_mpi(STOP_ERROR,'itf_adx_get_winds','called a stub')
   !---------------------------------------------------------------------
   return
end subroutine itf_adx_get_winds

!/**
subroutine itf_adx_get_winds2(F_su,F_sv,F_sw,F_minx,F_maxx,F_miny,F_maxy,F_nk)
   implicit none
#include <arch_specific.hf>
   !@objective process winds in preparation for advection
   !@arguments
   integer :: F_minx,F_maxx,F_miny,F_maxy,F_nk
   real,dimension(F_minx:F_maxx,F_miny:F_maxy,F_nk) :: &
        F_su,F_sv,F_sw !O, model de-stag winds on m-t levels super set
   !@author alain patoine
   !@revisions
   ! v2_31 - Desgagne M.       - removed stkmemw
   ! v3_00 - Desgagne & Lee    - Lam configuration
   ! v3_10 - Corbeil & Desgagne & Lee - AIXport+Opti+OpenMP
   ! v3_21 - Desgagne M.       - Revision OpenMP
   ! v4_   - Gravel S.         - Staggered version
   ! v4_10 - Plante A.         - Add interpolation of wind on their non-native
   ! Jan 2010, S. Chamberland: split out of adw and into smaller/logical units
   ! v4_40 - Qaddouri/Lee - Yin-Yang, to exchange de-stag winds,use global range
   !@description
   !  
!**/
#include "glb_ld.cdk"
#include "gmm.hf"
#include "vth.cdk"
   !      real, pointer, dimension (:,:,:) :: uth,vth,zdth
   !      character(len=8) :: gmmk_uth_s, gmmk_vth_s, gmmk_zdth_s
!!$#include "acid.cdk"
   !      logical acid_test_l
   type(gmm_metadata) :: dummy_gmm_meta
   integer :: istat
   real, dimension(:,:,:), pointer :: um,vm,wm,ut,vt

Interface
Subroutine itf_adx_destag_winds (F_u,F_v,F_uth,F_vth)
      real, dimension(:,:,:), pointer :: F_uth,F_vth !I, staggered winds
      real, dimension(:,:,:), pointer :: F_u,F_v     !O, destaggered winds
End Subroutine itf_adx_destag_winds 
subroutine itf_adx_img2real_winds(F_ur,F_vr,F_ui,F_vi)
      real, dimension(:,:,:), pointer :: F_ui,F_vi !I=image winds
      real, dimension(:,:,:), pointer :: F_ur,F_vr !O=real winds
End Subroutine itf_adx_img2real_winds
subroutine itf_adx_interp_thermo2mom(F_fld_m,F_fld_t)
      real, dimension(:,:,:), pointer :: F_fld_t !intent(in)
      real, dimension(:,:,:), pointer :: F_fld_m !intent(out)
End Subroutine itf_adx_interp_thermo2mom
subroutine itf_adx_interp_mom2thermo(F_fld_t,F_fld_m)
      real, dimension(:,:,:), pointer :: F_fld_m !intent(in)
      real, dimension(:,:,:), pointer :: F_fld_t !intent(out)
End Subroutine itf_adx_interp_mom2thermo
subroutine itf_adx_combine_levels(F_su,F_um,F_ut,F_nk)
      integer :: F_nk
      real,dimension(:,:,:) :: &
           F_su !O - combined field on both level types
      real,dimension(:,:,:),pointer :: &
           F_um, & !I - field on momentum levels
           F_ut    !I - field on thermo levels
End Subroutine itf_adx_combine_levels
End Interface

   !---------------------------------------------------------------------
   call msg(MSG_DEBUG,'itf_adx_get_winds')

   istat = GMM_OK
   istat = min(gmm_get(gmmk_uth_s,uth,dummy_gmm_meta),istat)
   istat = min(gmm_get(gmmk_vth_s,vth,dummy_gmm_meta),istat)
   istat = min(gmm_get(gmmk_zdth_s,zdth,dummy_gmm_meta),istat)
   call handle_error(istat,'adx_main_1_wnd','Problem in gmm_get')

   allocate( &
        ut(l_minx:l_maxx,l_miny:l_maxy,l_nk+1), &
        vt(l_minx:l_maxx,l_miny:l_maxy,l_nk+1), &
        wm(l_minx:l_maxx,l_miny:l_maxy,l_nk), &
        stat=istat)
   call handle_error_l(istat==0,'itf_adx_get_winds','Problem allocating mem')

   um => ut
   vm => vt
   call itf_adx_destag_winds(um,vm,uth,vth)
   call itf_adx_img2real_winds(uth,vth,um,vm)
   nullify(um,vm)

   call itf_adx_interp_mom2thermo(ut,uth)
   call itf_adx_interp_mom2thermo(vt,vth)
   call itf_adx_interp_thermo2mom(wm,zdth)

   call itf_adx_combine_levels(F_su,uth,ut,F_nk)
   call itf_adx_combine_levels(F_sv,vth,vt,F_nk)
   call itf_adx_combine_levels(F_sw,wm,zdth,F_nk)

   deallocate(ut,vt,wm)

   call msg(MSG_DEBUG,'itf_adx_get_winds [end]')
   !---------------------------------------------------------------------
   return

end subroutine itf_adx_get_winds2

   subroutine itf_adx_combine_levels(F_su,F_um,F_ut,F_nk)
      implicit none
#include <arch_specific.hf>
#include "glb_ld.cdk"
      !@objective Combine momentum and themro level into super vector
      !@arguments
      integer :: F_nk
      real,dimension(l_minx:l_maxx,l_miny:l_maxy,F_nk) :: &
           F_su !O - combined field on both level types
      real,dimension(:,:,:),pointer :: &
           F_um, & !I - field on momentum levels
           F_ut    !I - field on thermo levels
      !@author Andre Plante
      !@description
      !     Index k  in loops below is used to address super levels
      !     Index k2 in loops below is use to address thermo/momentum leves
      !
      !     Example of index for l_nk=3
      !
      !     -----------------------------
      !     | Super | Thermo | momentum |
      !     |---------------------------|
      !     |   1   |    1   |          |
      !     |---------------------------|
      !     |   2   |        |    1     |
      !     |---------------------------|
      !     |   3   |    2   |          |
      !     |---------------------------|
      !     |   4   |        |    2     |
      !     |---------------------------|
      !     |   5   |    3   |          |
      !     |---------------------------|
      !     |   6   |        |    3     |
      !     |---------------------------|
      !     |   7   |    4   |          |
      !     |---------------------------|
      !
      !     Note : no OPENMP uptimization done, since one thread probably occupy 
      !            the band width.
      !**/
      integer i,j,k,k2
      !---------------------------------------------------------------------
      k2 = 0
      do k = 1, F_nk, 2
         k2 = k2+1
         do j = l_miny, l_maxy
            do i = l_minx,l_maxx 
               F_su(i,j,k) = F_ut(i,j,k2)
            enddo
         enddo
      enddo
      k2=0
      do k = 2, F_nk, 2
         k2 = k2 + 1
         do j = l_miny, l_maxy
            do i = l_minx,l_maxx 
               F_su(i,j,k) = F_um(i,j,k2)
            enddo
         enddo
      enddo
      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_combine_levels
   subroutine itf_adx_destag_winds(F_u,F_v,F_uth,F_vth)
      implicit none
#include <arch_specific.hf>
      !@objective unstagger wind components (Interpolate to geopotential grid)
      !@arguments
      real, dimension(:,:,:), pointer :: F_uth,F_vth !I, staggered winds
      real, dimension(:,:,:), pointer :: F_u,F_v     !O, destaggered winds
      !@revisions
      ! v4_40 - Qaddouri/Lee      - Yin-Yang, to exchange unstaggered winds
      !**/
#include "glb_ld.cdk"
#include "grd.cdk"
#include "inuvl.cdk"
Interface
Subroutine itf_adx_yywinds (F_u,F_v,i0u,j0u,inu,jnu,i0v,j0v,inv,jnv)
      integer :: i0u,j0u,inu,jnu,i0v,j0v,inv,jnv
      real, dimension(:,:,:), pointer :: F_u, F_v
End Subroutine itf_adx_yywinds
End Interface
      !- CUBIC LAGRANGE INTERPOLATION COEFFICIENTS from AND to U and V grids
      !      real*8 inuvl_wxux3_8(l_minx:l_maxx,4) ! coef for U to PHI-grid
      !      real*8 inuvl_wyvy3_8(l_miny:l_maxy,4) ! coef for V to PHI-grid

#define UNSTAG_X(f,i,j,k,a) (a(i,1)*f(i-2,j,k) + a(i,2)*f(i-1,j,k) + a(i,3)*f(i,j,k) + a(i,4)*f(i+1,j,k))
#define UNSTAG_Y(f,i,j,k,a) (a(j,1)*f(i,j-2,k) + a(j,2)*f(i,j-1,k) + a(j,3)*f(i,j,k) + a(j,4)*f(i,j+1,k))

      integer :: i0u,j0u,inu,jnu,i0v,j0v,inv,jnv
      integer :: i,j,k, nrow=0
      !---------------------------------------------------------------------

      call rpn_comm_xch_halo(F_uth,l_minx,l_maxx,l_miny,l_maxy,&
           l_niu,l_nj,l_nk,G_halox,G_haloy,G_periodx,G_periody,G_niu,nrow)
      call rpn_comm_xch_halo(F_vth,l_minx,l_maxx,l_miny,l_maxy,&
           l_ni,l_njv,l_nk,G_halox,G_haloy,G_periodx,G_periody,G_ni,nrow)

      i0u = 1
      inu = l_niu
      j0u = 1
      jnu = l_nj
      if (G_lam) then
         if (l_west) i0u = 3
         if (l_east) inu = l_niu - 1
      endif
      i0v = 1
      inv = l_ni
      j0v = 0
      jnv = l_njv
      if (l_south) j0v = 3
      if (l_north) jnv = l_njv - 1

       !- Interpolate advection winds to geopotential grid
!$omp parallel
!$omp do
      DO_K: do k=1,l_nk

         do j = j0u, jnu
            do i = i0u, inu
               F_u(i,j,k) = UNSTAG_X(F_uth,i,j,k,inuvl_wxux3_8)
            enddo
            do i = 1,i0u-1
               F_u(i,j,k) = F_uth(i,j,k)
            enddo
            do i = inu+1,l_niu
               F_u(i,j,k) = F_uth(i,j,k)
            enddo
         enddo

         do j = j0v, jnv
            do i = i0v, inv
               F_v(i,j,k) = UNSTAG_Y(F_vth,i,j,k,inuvl_wyvy3_8)
            enddo
         enddo

         if (.not.G_lam) then

            if (l_south) then
               do i = i0v, inv
                  F_v(i,j0v-2,k) = &
                       inuvl_wyvy3_8(j0v-2,3) * F_vth(i,j0v-2,k) + &
                       inuvl_wyvy3_8(j0v-2,4) * F_vth(i,j0v-1,k)
                  F_v(i,j0v-1,k) = &
                       inuvl_wyvy3_8(j0v-1,2) * F_vth(i,j0v-2,k) + &
                       inuvl_wyvy3_8(j0v-1,3) * F_vth(i,j0v-1,k) + &
                       inuvl_wyvy3_8(j0v-1,4) * F_vth(i,j0v,k  )
               enddo
            endif
            if (l_north) then
               do i = i0v, inv
                  F_v(i,jnv+2,k) = &
                       inuvl_wyvy3_8(jnv+2,1) * F_vth(i,jnv  ,k) + &
                       inuvl_wyvy3_8(jnv+2,2) * F_vth(i,jnv+1,k)
                  F_v(i,jnv+1,k) = &
                       inuvl_wyvy3_8(jnv+1,1) * F_vth(i,jnv-1,k) + &
                       inuvl_wyvy3_8(jnv+1,2) * F_vth(i,jnv  ,k) + &
                       inuvl_wyvy3_8(jnv+1,3) * F_vth(i,jnv+1,k)
               enddo
            endif

         else

            do i = i0v, inv
               do j = 1, j0v-1
                  F_v(i,j,k) = F_vth(i,j,k)
               enddo
               do j = jnv+1, l_njv
                  F_v(i,j,k) = F_vth(i,j,k)
               enddo
            enddo

         endif

      enddo DO_K
!$omp enddo
!$omp end parallel

      if (Grd_yinyang_L)  &
          call itf_adx_yywinds (F_u,F_v,i0u,j0u,inu,jnu,i0v,j0v,inv,jnv)

      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_destag_winds

   subroutine itf_adx_yywinds (F_u,F_v,i0u,j0u,inu,jnu,i0v,j0v,inv,jnv)
      implicit none
#include <arch_specific.hf>
      !@objective convert wind from image to real values
      !@arguments
      integer :: i0u,j0u,inu,jnu,i0v,j0v,inv,jnv
      real, dimension(:,:,:), pointer :: F_u, F_v
      !@revisions
      ! v4_40 - Qaddouri/Lee      - Yin-Yang uses global range
     !**/
#include "glb_ld.cdk"
#include "geomg.cdk"
      integer :: i,j,k
      real*8 sc_8(l_nj)
      real temp_um (l_minx:l_maxx,l_miny:l_maxy,l_nk)
      real temp1_um(l_minx:l_maxx,l_miny:l_maxy,l_nk)
      real temp_vm (l_minx:l_maxx,l_miny:l_maxy,l_nk)
      real temp1_vm(l_minx:l_maxx,l_miny:l_maxy,l_nk)
      !---------------------------------------------------------------------     
       ! lazy code ===> should be fixed
          temp_um (:,:,:)=0.0
          temp_vm (:,:,:)=0.0
          temp1_um(:,:,:)=0.0
          temp1_vm(:,:,:)=0.0
          do j = 1,l_nj
             sc_8(j) = 1.D0/Geomg_cy_8(j)
          enddo
          do k=1,l_nk
             do j= j0u, jnu
             do i= i0u, inu
                temp_um (i,j,k)= F_u(i,j,k)*sc_8(j)
                temp1_um(i,j,k)= temp_um (i,j,k)
             enddo
             enddo
             do j= j0v, jnv
             do i= i0v, inv
                temp_vm (i,j,k)= F_v(i,j,k)*sc_8(j)
                temp1_vm(i,j,k)= temp_vm (i,j,k)
             enddo
             enddo
          end do
          !Exchange U and V between Yin and Yang
          call rpn_comm_xch_halo(temp_um,l_minx,l_maxx,l_miny,l_maxy,&
               l_ni,l_nj,G_nk, G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
          call rpn_comm_xch_halo(temp_vm,l_minx,l_maxx,l_miny,l_maxy,&
               l_ni,l_nj,G_nk, G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
          call rpn_comm_xch_halo(temp1_um,l_minx,l_maxx,l_miny,l_maxy,&
               l_ni,l_nj,G_nk, G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
          call rpn_comm_xch_halo(temp1_vm,l_minx,l_maxx,l_miny,l_maxy,&
               l_ni,l_nj,G_nk, G_halox,G_haloy,G_periodx,G_periody,l_ni,0)

          call  yyg_scaluv ( temp1_um,temp_um,temp1_vm,temp_vm,&
                              l_minx,l_maxx,l_miny,l_maxy,G_nk )

          if (l_west) then
              do k= 1, G_nk
              do j= 1,l_nj
              do i= 1, 2
                 F_u(i,j,k)= temp1_um (i,j,k)*Geomg_cy_8(j)
              enddo
              enddo
              enddo
          endif
          if (l_east) then
              do k= 1, G_nk
              do j= 1,l_nj
                 F_u(l_niu,j,k)= temp1_um (l_niu,j,k)*Geomg_cy_8(j)
                 F_u(l_ni ,j,k)= temp1_um (l_ni ,j,k)*Geomg_cy_8(j)
              enddo
              enddo
          endif
          if (l_south) then
              do k= 1, G_nk
              do i= 1, l_ni
              do j= 1, 2
                 F_v(i,j,k)=temp1_vm (i,j,k)*Geomg_cy_8(j)
              enddo
              enddo
              enddo
          endif
          if (l_north) then
              do k= 1, G_nk
              do i= 1, l_ni
                 F_v(i,l_njv,k)= temp1_vm(i,l_njv,k)*Geomg_cy_8(l_njv)
                 F_v(i,l_nj ,k)= temp1_vm(i,l_nj ,k)*Geomg_cy_8(l_nj )
              enddo
              enddo
          endif
      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_yywinds

   subroutine itf_adx_img2real_winds(F_ur,F_vr,F_ui,F_vi)
      implicit none
#include <arch_specific.hf>
      !@objective convert wind from image to real values
      !@arguments
      real, dimension(:,:,:), pointer :: F_ui,F_vi !I=image winds
      real, dimension(:,:,:), pointer :: F_ur,F_vr !O=real winds
      !@revisions
      ! v4_40 - Qaddouri/Lee      - Yin-Yang uses global range
     !**/
#include "glb_ld.cdk"
#include "geomg.cdk"
#include "grd.cdk"
      !      real*8 Geomg_cy_8(l_miny:l_maxy) !cosine of latitude
      integer :: i,j,k, i0,j0,in,jn
      real*8  :: sc_8
      !---------------------------------------------------------------------
!$omp parallel private(i0,in,j0,jn,sc_8)
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam.and..not.Grd_yinyang_L) then
         if (l_south) j0 = 3
         if (l_north) jn = l_njv - 1
      endif

!$omp do
      do k = 1,l_nk
         do j = j0,jn
            sc_8 = 1.D0 / geomg_cy_8(j)
            do i = i0,in
               F_vr(i,j,k) = sc_8 * F_vi(i,j,k)
            enddo
         enddo
      enddo
!$omp enddo

      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam.and..not.Grd_yinyang_L) then
         if (l_west) i0 = 3
         if (l_east) in = l_niu - 1
      endif

!$omp do 
      do k = 1,l_nk
         do j = j0,jn
            sc_8 = 1.D0 / geomg_cy_8(j)
            do i = i0,in
               F_ur(i,j,k) = sc_8 * F_ui(i,j,k)
            enddo
         enddo
      enddo
!$omp enddo
!$omp end parallel
      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_img2real_winds

   subroutine itf_adx_interp_thermo2mom(F_fld_m,F_fld_t)
      implicit none
#include <arch_specific.hf>
      !@objective interpolate from thermodynamic to momentum levels
      !@arguments
      real, dimension(:,:,:), pointer :: F_fld_t !intent(in)
      real, dimension(:,:,:), pointer :: F_fld_m !intent(out)
      !**/
#include "glb_ld.cdk"
#include "grd.cdk"
#undef TYPE_CDK
#include "ver.cdk"
#include "schm.cdk"
      integer :: i,j,k, i0,j0,in,jn
      real*8  :: xx, x1, x2, x3, x4, w1, w2, w3, w4,den
      real*8, dimension(:), pointer :: zd_z_8
#define lag3(xx, x1, x2, x3, x4)  (((xx - x2) * (xx - x3) * (xx - x4))/( (x1 - x2) * (x1 - x3) * (x1 - x4)))
      !---------------------------------------------------------------------
      allocate(zd_z_8(l_nk+1))
      zd_z_8(1:l_nk+1)=Ver_z_8%t(1:l_nk+1)
      ! Last zdot level is at surface not at Ver_z_8%t(l_nk+1)
      !  This is true for all config, however we just adjust it for Schm_tlift.eq.1
      !  to validate with previous version if Adx_tlift.eq.0 and Schm_thermopos_L=.true.
      if(Schm_Tlift.eq.1)zd_z_8(l_nk+1)=Ver_z_8%m(l_nk+1)

!$omp parallel private(i0,in,j0,jn,xx,x1,x2,x3,x4,w1,w2,w3,w4,den)
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
      if (G_lam.and..not.Grd_yinyang_L) then
         if (l_west)  i0 = 3
         if (l_east)  in = l_ni - 1
         if (l_south) j0 = 3
         if (l_north) jn = l_nj - 1
      endif

!$omp do
      do k=2,l_nk-1
         xx = Ver_z_8%m(k)
         x1 = zd_z_8(k-1)
         x2 = zd_z_8(k)
         x3 = zd_z_8(k+1)
         x4 = zd_z_8(k+2)
         w1 = lag3(xx, x1, x2, x3, x4)
         w2 = lag3(xx, x2, x1, x3, x4)
         w3 = lag3(xx, x3, x1, x2, x4)
         w4 = lag3(xx, x4, x1, x2, x3)
         do j = j0, jn
            do i = i0, in
               F_fld_m(i,j,k)= &
                    w1*F_fld_t(i,j,k-1) + w2*F_fld_t(i,j,k)  + &
                    w3*F_fld_t(i,j,k+1) + w4*F_fld_t(i,j,k+2)
            enddo
         enddo
      enddo
!$omp enddo

      !- Note  F_fld_t(i,j,1) = 0     
      k = 1
      w2 = (zd_z_8(k)-Ver_z_8%m(k)) / (zd_z_8(k)-zd_z_8(k+1))

!$omp do     
      do j = j0, jn
         do i = i0, in
            F_fld_m(i,j,k) = w2*F_fld_t(i,j,k+1)
         enddo
      enddo
!$omp enddo

      !- Note  F_fld_t(i,j,l_nk+1) = 0  
      k = l_nk
      w1 = (Ver_z_8%m(k)-zd_z_8(k+1)) / (zd_z_8(k)-zd_z_8(k+1))

!$omp do     
      do j = j0, jn
         do i = i0, in
            F_fld_m(i,j,k) = w1*F_fld_t(i,j,k)
         enddo
      enddo
!$omp enddo
!$omp end parallel
      deallocate(zd_z_8)
      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_interp_thermo2mom

   subroutine itf_adx_interp_mom2thermo(F_fld_t,F_fld_m)
      implicit none
#include <arch_specific.hf>
      !@objective interpolate from momentum to thermodynamic levels
      !@arguments
      real, dimension(:,:,:), pointer :: F_fld_m !intent(in)
      real, dimension(:,:,:), pointer :: F_fld_t !intent(out)
      !@revisions
      ! v4_40 - Qaddouri/Lee      - Yin-Yang, to use global range
      !**/
#include "glb_ld.cdk"
#include "grd.cdk"
#undef TYPE_CDK
#include "ver.cdk"
#include "schm.cdk"
      integer :: i,j,k, i0,j0,in,jn
      real*8  :: xx, x1, x2, x3, x4, w1, w2, w3, w4,den
      real*8, dimension(:), pointer :: zd_z_8
#define lag3(xx, x1, x2, x3, x4)  (((xx - x2) * (xx - x3) * (xx - x4))/( (x1 - x2) * (x1 - x3) * (x1 - x4)))
      !---------------------------------------------------------------------
      allocate(zd_z_8(l_nk+1))
      zd_z_8(1:l_nk+1)=Ver_z_8%t(1:l_nk+1)
      ! Last zdot level is at surface not at Ver_z_8%t(l_nk+1)
      !  This is true for all config, however we just adjust it for Schm_tlift.eq.1
      !  to validate with previous version if Adx_tlift.eq.0 and Schm_thermopos_L=.true.
      if(Schm_Tlift.eq.1)zd_z_8(l_nk+1)=Ver_z_8%m(l_nk+1)

!$omp parallel private(i0,in,j0,jn,xx,x1,x2,x3,x4,w1,w2,w3,w4,den)
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
      if (G_lam.and..not.Grd_yinyang_L) then
         if (l_west)  i0 = 3
         if (l_east)  in = l_ni - 1
         if (l_south) j0 = 3
         if (l_north) jn = l_nj - 1
      endif

!$omp do
      do k = 3, l_nk-1
         xx = zd_z_8(k)
         x1 = Ver_z_8%m(k-2)
         x2 = Ver_z_8%m(k-1)
         x3 = Ver_z_8%m(k  )
         x4 = Ver_z_8%m(k+1)
         w1 = lag3(xx, x1, x2, x3, x4)
         w2 = lag3(xx, x2, x1, x3, x4)
         w3 = lag3(xx, x3, x1, x2, x4)
         w4 = lag3(xx, x4, x1, x2, x3)
         do j = j0, jn
            do i = i0, in
               F_fld_t(i,j,k) = &
                    w1*F_fld_m(i,j,k-2) + w2*F_fld_m(i,j,k-1) + &
                    w3*F_fld_m(i,j,k  ) + w4*F_fld_m(i,j,k+1)
            enddo
         enddo
      enddo
!$omp enddo

      den = 1.d0/(Ver_z_8%m(1)-Ver_z_8%m(2))
      k = 2      
      w1 = (zd_z_8(k)   -Ver_z_8%m(2)) * den
      w2 = (Ver_z_8%m(1)-zd_z_8(k)   ) * den

!$omp do     
      do j = j0, jn
         do i = i0, in
            F_fld_t(i,j,k) = w1*F_fld_m(i,j,1) + w2*F_fld_m(i,j,2)
         enddo
      enddo
!$omp enddo

      !- Updward Extrapolation
      k = 1      
      w1 = (zd_z_8(k)   -Ver_z_8%m(2)) * den
      w2 = (Ver_z_8%m(1)-zd_z_8(k)   ) * den

!$omp do     
      do j = j0, jn
         do i = i0, in
            F_fld_t(i,j,k) = w1*F_fld_m(i,j,1) + w2*F_fld_m(i,j,2)
         enddo
      enddo
!$omp enddo

      den = 1.d0/(Ver_z_8%m(l_nk-1)-Ver_z_8%m(l_nk))
      k = l_nk
      w1 = (zd_z_8(k)        -Ver_z_8%m(l_nk)) * den
      w2 = (Ver_z_8%m(l_nk-1)-zd_z_8(k)      ) * den

!$omp do     
      do j = j0, jn
         do i = i0, in
            F_fld_t(i,j,k) = w1*F_fld_m(i,j,l_nk-1) + w2*F_fld_m(i,j,l_nk)
         enddo
      enddo
!$omp enddo

      !- Downdward Extrapolation
      k = l_nk+1
      w1 = (zd_z_8(k)        -Ver_z_8%m(l_nk)) * den
      w2 = (Ver_z_8%m(l_nk-1)-zd_z_8(k)      ) * den

!$omp do     
      do j = j0, jn
         do i = i0, in
            F_fld_t(i,j,k) = w1*F_fld_m(i,j,l_nk-1) + w2*F_fld_m(i,j,l_nk)
         enddo
      enddo
!$omp enddo
!$omp end parallel
      deallocate(zd_z_8)
      !---------------------------------------------------------------------
      return
   end subroutine itf_adx_interp_mom2thermo
