!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
!**s/r getijlalo -
!
      subroutine getijlalo (F_ig,F_jg,F_lat,F_lon,F_il,F_jl, &
                                         F_MISSING,F_offset)
      implicit none
#include <arch_specific.hf>
!
      integer F_ig,F_jg,F_il,F_jl,F_MISSING,F_offset
      real F_lat,F_lon

#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "ptopo.cdk"
#include "dcst.cdk"
#include "hgc.cdk"

      integer, external :: ezgdef_fmem,gdll
      integer numi,numj,i,j,k,dgid,err
      real lat,lon,difmin,c
      real xfi(G_ni),yfi(G_nj),latg(G_ni,G_nj),long(G_ni,G_nj)
      real*8 xyz1(3),xyz2(3),rad2deg_8
!
!     ---------------------------------------------------------------
!
      rad2deg_8  = 180.d0/Dcst_pi_8
      xfi(1:G_ni)= G_xg_8(1:G_ni)*rad2deg_8
      yfi(1:G_nj)= G_yg_8(1:G_nj)*rad2deg_8
      dgid = ezgdef_fmem (G_ni , G_nj , 'Z', 'E', Hgc_ig1ro, &
                Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro, xfi, yfi )
      err = gdll (dgid,latg,long)

      if ((F_ig.eq.F_MISSING).or.(F_jg.eq.F_MISSING)) then

         lat = F_lat
         lon = amod(F_lon+360.0,360.0)
         call llacar (xyz1,lon,lat,1,1)
         difmin= 9999999.
         numi= 1
         numj= 1

         do j= 1, G_nj
         do i= 1, G_ni
            call llacar (xyz2,long(i,j),latg(i,j),1,1)
            xyz2(1) = xyz1(1)-xyz2(1)
            xyz2(2) = xyz1(2)-xyz2(2)
            xyz2(3) = xyz1(3)-xyz2(3)
            c = sqrt( xyz2(1)**2 + xyz2(2)**2 + xyz2(3)**2 ) 
            if ( c .lt. difmin ) then
               difmin= c
               numi  = i
               numj  = j
            endif
         enddo
         enddo
         
      else

         numi= F_ig + Glb_pil_w
         numj= F_jg + Glb_pil_s
         numi= min(G_ni-Glb_pil_e,max(1+Glb_pil_w,numi))
         numj= min(G_nj-Glb_pil_n,max(1+Glb_pil_s,numj))

      endif

      F_ig = numi - F_offset
      F_jg = numj - F_offset
      F_il = numi - Ptopo_gindx(1,Ptopo_myproc+1) + 1
      F_jl = numj - Ptopo_gindx(3,Ptopo_myproc+1) + 1
      F_lat= latg(numi,numj)
      F_lon= long(numi,numj)
      
      if ( (F_il.lt.1).or.(F_il.gt.l_ni) .or. &
           (F_jl.lt.1).or.(F_jl.gt.l_nj) ) then
         F_il= F_MISSING
         F_jl= F_MISSING
      else
         F_il= F_il - F_offset*west
         F_jl= F_jl - F_offset*south
      endif
!
!     ---------------------------------------------------------------
!
      return
      end
      
