!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r e_ac_posi -  find the positional points to extract cascade
!                   grid given the analyse files
#include "model_macros_f.h"
!     
      integer function e_ac_posi (xpx,ypx,dimgx,dimgy,F_width)
      implicit none
#include <arch_specific.hf>
!     
      integer dimgx,dimgy,F_width
      real xpx(dimgx), ypx(dimgy)
!
!author
!        Vivian Lee      - 2006 (from MC2 ac_posi)
!revision
! v3_30 - Lee V.       - initial version for GEMDM
! v4_03 - Lee/Desgagne - ISST
! v4_30 - Tanguay M.   - Allow same grid in analysis and in model (BCS mode)
! v4_30 - Tanguay M.   - Add epsilon_8
!*
#include "e_grids.cdk"
#include "e_grdc.cdk"
#include "path.cdk"
#include <clib_interface.cdk>
!
      integer  stretch_axis2
      external stretch_axis2
      character* 512 filen
      integer i,j,k,cnt,err,dum1,dum2,gidi,gifi,gjfi
      integer is,nis,js,njs,jn,iw,niw,ie,jw,njw
      integer idg,jdg
      real x0, xl, y0, yl, dum, n1, n2, b1, b2
      real*8 ONE_8, CLXXX_8
      real*8 orr, deg2rad_8
      parameter( ONE_8   = 1.0 )
      parameter( CLXXX_8 = 180.0 )
!
      real*8, parameter :: EPSILON_8 = 1.0e-5
!
!---------------------------------------------------------------------
!
      e_ac_posi = -1
      deg2rad_8 = acos( -ONE_8 )/CLXXX_8
!
      idg=1
      jdg=1
      e_grdc_gid = 0
      e_grdc_gjd = 0
      e_grdc_gif = 0
      e_grdc_gjf = 0
      e_grdc_gjdi = 0
      gidi=0
      gifi=0
      gjfi=0
!
!     *** Positional parameters for f and q points
!
      do i=1,dimgx
         if (xpx(i).le.xfi(1)) e_grdc_gid=i
         if (xpx(i).le.xfi(F_width+1)) gidi=i
         if (xpx(i).le.xfi(nifi)) e_grdc_gif=i
         if (xpx(i).le.xfi(nifi-F_width)) gifi=i
      enddo
      if (e_grdc_gid.ge.e_grdc_gif) e_grdc_gid = 0
!
      do i=1,dimgy
         if (ypx(i)-EPSILON_8.le.yfi(1)) e_grdc_gjd=i
         if (ypx(i).le.yfi(F_width+1)) e_grdc_gjdi=i
         if (ypx(i).le.yfi(njfi)) e_grdc_gjf=i
         if (ypx(i).le.yfi(njfi-F_width)) gjfi=i
      enddo
      if (e_grdc_gjd.ge.e_grdc_gjf) e_grdc_gjd = 0
!
      if ((e_grdc_gid.gt.0).and.(e_grdc_gjd.gt.0)) then
         if ( (e_grdc_gid-2.gt.0) .and. (e_grdc_gif+3.lt.dimgx) .and. &
              (e_grdc_gjd-2.gt.0) .and. (e_grdc_gjf+3.lt.dimgy) ) then
            e_grdc_gid = e_grdc_gid - 2
            e_grdc_gjd = e_grdc_gjd - 2
            e_grdc_gif = e_grdc_gif + 3
            e_grdc_gjf = e_grdc_gjf + 3
         else
            if ( (e_grdc_gid.eq.1) .and. (e_grdc_gif.eq.dimgx) .and. &
                 (e_grdc_gjd.eq.1) .and. (e_grdc_gjf.eq.dimgy) ) then
!
               print *,'*************************************'
               print *,'E_AC_POSI: same_size grid as analysis'
               print *,'*************************************'
!
            else
!
               print *,'e_ac_posi: '
               print *,'trop serre, il faut que'
               print *,'e_grdc_gid=',e_grdc_gid,'-2.gt.0'
               print *,'e_grdc_gjd=',e_grdc_gjd,'-2.gt.0'
               print *,'e_grdc_gif=',e_grdc_gif,'+3.lt.',dimgx
               print *,'e_grdc_gjf=',e_grdc_gjf,'+3.lt.',dimgy
               e_grdc_gid = 0
               e_grdc_gjd = 0
            endif
!
         endif
!
      else
         e_grdc_gid = 0
         e_grdc_gjd = 0
      endif
      if ((e_grdc_gid.eq.0).or.(e_grdc_gjd.eq.0)) return
!
 999  continue
      e_grdc_hbwe = -1
      e_grdc_hbsn = -1
      e_grdc_hbwe = max (gidi-e_grdc_gid+1,e_grdc_gif-gifi+1)
      e_grdc_hbsn = max (e_grdc_gjdi-e_grdc_gjd+1,e_grdc_gjf-gjfi+1)
      n1 = e_grdc_gif-e_grdc_gid+1
      n2 = e_grdc_gjf-e_grdc_gjd+1
      b1 = e_grdc_hbwe + 1
      b2 = e_grdc_hbsn + 1
      if (4.*b1*(n1-b1)/n1/n1.gt.0.95) e_grdc_hbwe = -1
      if (4.*b2*(n2-b2)/n2/n2.gt.0.95) e_grdc_hbsn = -1
      write (6,1003) e_grdc_gid,e_grdc_gif,e_grdc_gjd,e_grdc_gjf

      e_grdc_ni = e_grdc_gif-e_grdc_gid+1
      e_grdc_nj = e_grdc_gjf-e_grdc_gjd+1

      e_ac_posi = 0
!
 1003 format (' Cascade grid:gid,gif,gjd,gjf ',4i6)
!--------------------------------------------------------------------
      return
      end

