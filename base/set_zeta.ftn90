!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!  s/r set_zeta    - Generates A and B of the hybrid coordinate
!                    Also sets Z and other related vertical parameters.
!
#include "model_macros_f.h"
!
      subroutine set_zeta2( F_hybuser, Nk )
      use vGrid_Descriptors, only: vgrid_descriptor,vgd_new,vgd_get,vgd_levels,VGD_OK
      use vgrid_wb, only: vgrid_wb_put
   !     
      implicit none
#include <arch_specific.hf>
!
      integer Nk
      real, dimension(Nk) :: F_hybuser        !user-specified hybrid coordinate values
!
! authors
!      A. Plante & C. Girard - CMC - janvier 2008
!
! revision
!
! v4_00 - Plante & Girard   - Log-hydro-pressure coord on Charney-Phillips grid
! v4_4  - Plante - add standard pressure profils for physics.
!
! object
!    To return A, B parameters for momentum and thermodynamic levels
!    These levels are used for DYNAMICAL CALCULATIONS in the models
!    Some are VIRTUAL levels
!
!    Also to return other parameters related to the vertical discretization
!
!         Z, dZ, 1/dZ, dBdZ, etc
!
! Virtual level vvvvvvvvvvvvvvvvv Ver_z_8%m(0)
!
!         Ztop  ================= Ver_z_8%t(1)
!
!               - - - - - - - - - Ver_z_8%m(1)
!
!               ================= Ver_z_8%t(2) = ( Ver_z_8%m(2) + Ver_z_8%m(1) ) / 2
!
!               - - - - - - - - - Ver_z_8%m(2)
!
!                      ...
!
!               - - - - - - - - - Ver_z_8%m(G_nk-1)
!
!               ================= Ver_z_8%t(G_nk) = ( Ver_z_8%m(nk) + Ver_z_8%m(nk-1) ) / 2
!
!               - - - - - - - - - Ver_z_8%m(G_nk)
!
!         Zsrf  ================= Ver_z_8%t(G_nk+1)
!
! Virtual level vvvvvvvvvvvvvvvvv Ver_z_8%m(G_nk+1)
!
! arguments
! none
!
#include "glb_ld.cdk"
#include "lun.cdk"
#include "dcst.cdk"
#include "cstv.cdk"
#include "grd.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
#include "dimout.cdk"
#include "level.cdk"
#include "that.cdk"
!
      type(vgrid_descriptor) :: vcoord
      integer k,istat,err,glb_err
      integer, dimension(:), pointer :: ip1m,ip1t
      real, dimension(:), pointer :: hybm_free,hybt_free,std_p_prof
      real :: hybm(0:G_nk+1),hybt(0:G_nk+2)
      real*8 zero, half, one, two
      parameter(zero=0.d0,half=0.5d0,one=1.d0,two=2.d0)
      character*8 dumc
!     __________________________________________________________________
!
      allocate(   Ver_hyb%m  (G_nk+1),     Ver_hyb%t(G_nk+2), &
           Ver_std_p_prof%m(  G_nk+1),Ver_std_p_prof%t(G_nk+2), &  
                  Ver_ip1%m(  G_nk+1),     Ver_ip1%t(G_nk+2), &
                  Ver_a_8%m(  G_nk+1),     Ver_a_8%t(G_nk+2), &
                  Ver_b_8%m(  G_nk+1),     Ver_b_8%t(G_nk+2), &
                  Ver_z_8%m(0:G_nk+1),     Ver_z_8%t(G_nk+1), &
                 Ver_dz_8%m(  G_nk  ),    Ver_dz_8%t(G_nk+1), &
                Ver_idz_8%m(  G_nk  ),   Ver_idz_8%t(G_nk+1), &
               Ver_dbdz_8%m(  G_nk  ),  Ver_dbdz_8%t(G_nk+1), &
              Ver_fistr_8%m(0:G_nk  ), Ver_fistr_8%t(G_nk+1), &
                 Ver_wp_8%m ( G_nk  ),    Ver_wm_8%m(G_nk  ), &
                 Ver_wp_8%t ( G_nk+1),    Ver_wm_8%t(G_nk+1), &
                    ln_that%t(G_nk+1),    dln_that%t(G_nk+1), &
                                                  stat=istat)
      call check_alloc(istat,'set_zeta',1)
!
      Cstv_RTstr_8= Dcst_rgasd_8*Cstv_Tstr_8
      Cstv_pref_8 = 100000.d0
!
      Ver_code = 6
      glb_err  = 0
!
      istat = 0
      if (Cstv_pref_8.ne.100000.d0) istat = -1
      call handle_error(istat, 'set_zeta','Cstv_pref_8 must equal 100000.d0')
!
      Cstv_Zsrf_8 = log(Cstv_pref_8)
      Cstv_Ztop_8 = log(Cstv_ptop_8)
!
      ! Construct vertical coordinate
      err = vgd_new (vcoord, kind=5, version=Level_version, hyb=F_hybuser, &
                     rcoef1=Grd_rcoef(1),rcoef2=Grd_rcoef(2) , &
                     ptop_8=Cstv_ptop_8, pref_8=Cstv_pref_8,stdout_unit=Lun_out)
      if (err /= VGD_OK) glb_err = -1
      call handle_error (glb_err,'set_zeta','coordinate construction failed')

      ! Retrieve information required to fill model arrays

      if (vgd_get(vcoord,'CA_M - vertical A coefficient (m)',Ver_a_8%m) /= VGD_OK) glb_err = -1
      if (vgd_get(vcoord,'CB_M - vertical B coefficient (m)',Ver_b_8%m) /= VGD_OK) glb_err = -1
      if (vgd_get(vcoord,'CA_T - vertical A coefficient (t)',Ver_a_8%t) /= VGD_OK) glb_err = -1
      if (vgd_get(vcoord,'CB_T - vertical B coefficient (t)',Ver_b_8%t) /= VGD_OK) glb_err = -1
      if (vgd_get(vcoord,'VCDM - vertical coordinate (m)'   ,hybm_free) /= VGD_OK) glb_err = -1
      if (vgd_get(vcoord,'VCDT - vertical coordinate (t)'   ,hybt_free) /= VGD_OK) glb_err = -1
      if (vgd_get(vcoord,'VIPM - level ip1 list (m)'        ,ip1m     ) /= VGD_OK) glb_err = -1
      if (vgd_get(vcoord,'VIPT - level ip1 list (t)'        ,ip1t     ) /= VGD_OK) glb_err = -1

      call handle_error (glb_err,'set_zeta','retrieving coordinate info')

      err = vgd_levels(vcoord,ip1m,std_p_prof,100000.,in_log=.false.) 
      if (err /= VGD_OK) glb_err = -1
      call handle_error (glb_err,'set_zeta','problem getting standard pressure profile for m levels')
      Ver_std_p_prof%m=std_p_prof

      deallocate(std_p_prof)
      err = vgd_levels(vcoord,ip1t,std_p_prof,100000.,in_log=.false.)                                                                     
      if (err /= VGD_OK) glb_err = -1                                                                                                  
      call handle_error (glb_err,'set_zeta','problem getting standard pressure profile for t levels')
      Ver_std_p_prof%t=std_p_prof

      ! Add outside level at top boundary and fill hybrid coordinate values
      hybm(1:size(hybm_free)) = hybm_free
      hybt(1:size(hybt_free)) = hybt_free
      hybm(0) = real(Cstv_ptop_8/Cstv_pref_8)
      hybt(0) = hybm(0)
      Ver_hyb%m(1:G_nk+1) = hybm(1:G_nk+1)
      Ver_hyb%t(1:G_nk+2) = hybt(1:G_nk+2)
      Ver_hyb_top = hybm(0)
      if (Schm_autobar_L) Ver_hyb%t(1) = hybt(0)
!
!     -------------
!     Now define Z:
!     -------------
!
      Ver_z_8%m(0) = Cstv_Ztop_8
      do k = 1, G_nk+1
         Ver_z_8%m(k) = Ver_a_8%m(k)
      enddo
!
      do k = 1, G_nk+1
         Ver_z_8%t(k) = Ver_a_8%t(k)
      enddo
!
!     --------------
!     Compute fistar
!     --------------
!     
      do k = 1, G_nk+1
         Ver_fistr_8%m(k-1)=-Cstv_RTstr_8*(Ver_z_8%m(k-1)-Cstv_Zsrf_8)
         Ver_fistr_8%t(k  )=-Cstv_RTstr_8*(Ver_z_8%t(k  )-Cstv_Zsrf_8)
      enddo
!
!     ----------------------
!     Compute dZ, 1/dZ, dBdZ
!     ----------------------
!
      Ver_dz_8%m(1)      = Ver_z_8%t(2)     - Ver_z_8%m(0)
      do k=2,G_nk-1
         Ver_dz_8%m(k)   = Ver_z_8%t(k+1)   - Ver_z_8%t(k)
      enddo      
      Ver_dz_8%m(G_nk)   = Ver_z_8%m(G_nk+1)- Ver_z_8%t(G_nk)
!
      do k=1,G_nk
         Ver_idz_8%m(k)  =  one/Ver_dz_8%m(k)
      enddo      
!     
      do k=1,G_nk+1
           Ver_dz_8%t(k) = Ver_z_8%m(k) - Ver_z_8%m(k-1)
          Ver_idz_8%t(k) = one/Ver_dz_8%t(k)
      enddo
!

         Ver_dbdz_8%t(1) = (Ver_b_8%m(1)-0.d0)*Ver_idz_8%t(1)
      do k=2,G_nk+1
         Ver_dbdz_8%t(k) = (Ver_b_8%m(k)-Ver_b_8%m(k-1))*Ver_idz_8%t(k)
      enddo
!
!     -------------------------------------------------------
!     Compute AVERGING WEIGHTS FROM THERMO TO MOMENTUM LEVELS 
!     -------------------------------------------------------
!
      do k=1,G_nk
         if(k.eq.G_nk) then
            Ver_wp_8%m(k) = Ver_dz_8%t(k+1)*Ver_idz_8%m(k)
         else
            Ver_wp_8%m(k) = Ver_dz_8%t(k+1)*half*Ver_idz_8%m(k)
         endif

            Ver_wm_8%m(k) = one-Ver_wp_8%m(k)
!
          Ver_dbdz_8%m(k) = Ver_wp_8%m(k) * Ver_dbdz_8%t(k+1)  &
                          + Ver_wm_8%m(k) * Ver_dbdz_8%t(k)
      enddo
!
!     -------------------------------------------------------
!     Compute AVERGING WEIGHTS FROM MOMENTUM TO THERMO LEVELS 
!     -------------------------------------------------------
!
      Ver_wp_8%t(1) = 0.d0
      Ver_wm_8%t(1) = 1.d0
      if(Schm_NoTopThL_L)Ver_wm_8%t(1) = 0.d0
      do k=2,G_nk
         Ver_wp_8%t(k) = half
         Ver_wm_8%t(k) = half
      enddo
      Ver_wp_8%t(G_nk+1) = 1.d0
      Ver_wm_8%t(G_nk+1) = 0.d0
!
!     ----------------------------------------------------------
!     Initialize to ZERO the log of That/Tstr and its derivative
!     ----------------------------------------------------------
!
      do k=1,G_nk+1
          ln_that%t(k) = 0.0
         dln_that%t(k) = 0.0
      enddo
!
!     Encode Ver_ip1 for OUTPUT
!
      Ver_ip1%m(1:G_nk+1) = ip1m(1:G_nk+1)
      Ver_ip1%t(1:G_nk+1) = ip1t(1:G_nk+1)
      Ver_ip1%t(G_nk+2)   = Ver_ip1%m(G_nk+1)
!
!     ----------------------------------------------------------
!     Save vcoord and ip1m/t for output
!     ----------------------------------------------------------
      err = vgrid_wb_put('ref-m',vcoord,ip1m)
      err = vgrid_wb_put('ref-t',vcoord,ip1t)
!     __________________________________________________________________
!
      return
      end
