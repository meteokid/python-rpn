!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r itf_phy_apply - apply tendencies to dynamical variables
!
#include "model_macros_f.h"
!
      subroutine itf_phy_apply ( F_apply_L )
      implicit none
#include <arch_specific.hf>
!
      logical,intent(IN) :: F_apply_L
!
!author
!     Michel Roch - rpn - april 1994
!
!revision
! v2_00 - Desgagne M.       - initial MPI version
! v2_30 - Edouard S.        - change call to uv2tdzd
! v2_31 - Desgagne M.       - clean up and introduce h2o tracers
! v3_00 - Laroche S.        - adaptation to include simplified physics
! v3_02 - Plante A.         - water loading
! v3_03 - Desgagne M.       - new switches for secondary tendencies
! v3_12 - Dugas B.          - no longer zero out tendencies in the LAM
!                             blending area, following Lam_0ptend_L
! v3_20 - Laroche S.        - slight modification to rpn_comm_xch_halo call
! v3_21 - Tanguay M.        - Zero wk5 for hatoprg
! v3_21 - Desgagne M.       - Revision OpenMP
! v3_30 - Spacek L.         - Eliminate filter for condensation tendencies
!                             and arguments F_tcond,F_qdifv
! v4_03 - Spacek L.         - Staggered version
! v4_04 - Spacek L.         - correction pnt_trp(1) to pnt_trp(HUCOND)!
! v4_05 - Lee V.            - remove OMP on Schm_wload, correction on h2o loop
! v4_06 - Lepine M.         - VMM replacement with GMM
!
#include "gmm.hf"
#include "glb_ld.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "geomg.cdk"
#include "vt1.cdk"
#include "vtx.cdk"
#include "p_geof.cdk"
#include "pw.cdk"

      logical,save :: init_L = .false.
      integer,save :: UU_indx=0, VV_indx=0, TT_indx=0

      type(gmm_metadata) :: mymeta
      integer i, j, k, km1,istat,lght, soit
      real con(YDIST_SHAPE), tdu(LDIST_SHAPE,p_nk),tdv(LDIST_SHAPE,p_nk)
      character(len=3) :: bus_S
!     __________________________________________________________________
!
! In LAM config: physics tendencies are valid on the global scope 
! (3,G_ni-2) (3,G_nj-2). Because of horizontal staggering of tendencies
! of the wind components we lose additional points. Physics tendencies
! on U are therefore valid with the scope (4,G_ni-4) (3,G_nj-2) and 
! physics tendencies on V  with the scope (3,G_ni-2) (4,G_nj-4).
!
      if (.not. F_apply_L) return

      if (.not.init_L) then
         bus_S = 'VOL'
         call getindx2 ('PHYTD_UU', bus_S, UU_indx, lght, soit)
         call getindx2 ('PHYTD_VV', bus_S, VV_indx, lght, soit)
         call getindx2 ('PHYTD_TT', bus_S, TT_indx, lght, soit)
         init_L = .true.
      endif

      con(1:l_nj)= cos(geomg_y_8(1:l_nj)) / Dcst_rayt_8

      if (TT_indx.gt.0) then
         istat = gmm_get(gmmk_tt1_s, tt1, mymeta)
         call tt2virt (tt1, .true., 'P')
         if (Schm_pheat_L) then
            istat = gmm_get(gmmk_tt1_s  ,tt1  ,mymeta)
            istat = gmm_get(gmmk_st1_s  ,st1  ,mymeta)
            istat = gmm_get(gmmk_fiptx_s,fiptx,mymeta)
            istat = gmm_get(gmmk_fis0_s ,fis0 ,mymeta)
            if(.not.Schm_hydro_L) istat = gmm_get(gmmk_qt1_s,qt1,mymeta)
            call diag_fip (fiptx(l_minx,l_miny,1),st1,tt1(l_minx,l_miny,2),qt1(l_minx,l_miny,1),fis0,LDIST_DIM,l_nk)
         endif
      endif

      if ((UU_indx.gt.0) .and. (VV_indx.gt.0)) then
         istat = gmm_get(gmmk_ut1_s,ut1,mymeta)
         istat = gmm_get(gmmk_vt1_s,vt1,mymeta)
         istat = gmm_get('PW_UU:P'   ,pw_uu_plus,mymeta)
         istat = gmm_get('PW_VV:P'   ,pw_vv_plus,mymeta)
         istat = gmm_get('PW_UU_COPY',pw_uu_copy,mymeta)
         istat = gmm_get('PW_VV_COPY',pw_vv_copy,mymeta)

!$omp parallel private(j)
!$omp do
         do k= 1, p_nk
            tdu(l_minx:l_maxx,l_miny:0,k) = 0. ; tdu(l_minx:l_maxx,l_nj+1:l_maxy,k) = 0.
            tdv(l_minx:l_maxx,l_miny:0,k) = 0. ; tdv(l_minx:l_maxx,l_nj+1:l_maxy,k) = 0.
            tdu(l_minx:0,l_miny:l_maxy,k) = 0. ; tdu(l_ni+1:l_maxx,l_miny:l_maxy,k) = 0.
            tdv(l_minx:0,l_miny:l_maxy,k) = 0. ; tdv(l_ni+1:l_maxx,l_miny:l_maxy,k) = 0.
            do j= 1, l_nj
               tdu(1:l_ni,j,k) = (pw_uu_plus(1:l_ni,j,k+1)- &
                                  pw_uu_copy(1:l_ni,j,k+1)) *con(j)
               tdv(1:l_ni,j,k) = (pw_VV_plus(1:l_ni,j,k+1)- &
                                  pw_VV_copy(1:l_ni,j,k+1)) *con(j)
            end do
         end do
!$omp enddo
!$omp end parallel

         call itf_phy_uvgridscal (tdu, tdv, LDIST_DIM, p_nk, .false. )

!$omp parallel do
         do k=1,l_nk+1
            ut1(1:l_niu,:,k) = ut1(1:l_niu,:,k) + tdu(1:l_niu,:,k+1-1)
            vt1(:,1:l_njv,k) = vt1(:,1:l_njv,k) + tdv(:,1:l_njv,k+1-1)
         end do
!$omp end parallel do

      endif
!     __________________________________________________________________
!
      return
      end
