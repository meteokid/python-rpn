!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r itf_phy_apply - apply tendencies to dynamical variables
!
#include "model_macros_f.h"
!
      subroutine itf_phy_apply ( F_apply_L )
      use nest_blending, only: nest_blend
      implicit none
!
      logical,intent(IN) :: F_apply_L
!
!author
!     Michel Roch - rpn - april 1994
!
!revision
! v2_00 - Desgagne M.       - initial MPI version
! v2_30 - Edouard S.        - change call to uv2tdzd
! v2_31 - Desgagne M.       - clean up and introduce h2o tracers
! v3_00 - Laroche S.        - adaptation to include simplified physics
! v3_02 - Plante A.         - water loading
! v3_03 - Desgagne M.       - new switches for secondary tendencies
! v3_12 - Dugas B.          - no longer zero out tendencies in the LAM
!                             blending area, following Lam_0ptend_L
! v3_20 - Laroche S.        - slight modification to rpn_comm_xch_halo call
! v3_21 - Tanguay M.        - Zero wk5 for hatoprg
! v3_21 - Desgagne M.       - Revision OpenMP
! v3_30 - Spacek L.         - Eliminate filter for condensation tendencies
!                             and arguments F_tcond,F_qdifv
! v4_03 - Spacek L.         - Staggered version
! v4_04 - Spacek L.         - correction pnt_trp(1) to pnt_trp(HUCOND)!
! v4_05 - Lee V.            - remove OMP on Schm_wload, correction on h2o loop
! v4_06 - Lepine M.         - VMM replacement with GMM
!
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "cstv.cdk"
#include "nest.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "geomg.cdk"
#include "lam.cdk"
#include "vt1.cdk"
#include "vtx.cdk"
#include "p_geof.cdk"
#include "pw.cdk"
#include "itf_phy_buses.cdk"
#include "lctl.cdk"
#include "out3.cdk"

      logical nest_it, flag_u, flag_v
      integer i, j, k, n, err, cnt, UU_indx, VV_indx, km1
      real wk2(LDIST_SHAPE,p_nk),con(YDIST_SHAPE), &
           tdu(LDIST_SHAPE,p_nk),tdv(LDIST_SHAPE,p_nk)
      real, pointer, dimension(:,:,:) :: tr,trm
!     __________________________________________________________________
!
! In LAM config: physics tendencies are valid on the global scope 
! (3,G_ni-2) (3,G_nj-2). Because of horizontal staggering of tendencies
! of the wind components we lose additional points. Physics tendencies
! on U are therefore valid with the scope (4,G_ni-4) (3,G_nj-2) and 
! physics tendencies on V  with the scope (3,G_ni-2) (4,G_nj-4).
!
      flag_u  = .False. ; flag_v = .false.
      wk2     = 0.
!
      nest_it = ( Lam_0ptend_L .and. G_lam .and. &
                ((Lam_blend_Hx.gt.0).or.(Lam_blend_Hy.gt.0)) )
!
      con(:)  = cos(geomg_y_8(:)) / Dcst_rayt_8
!
      if (.not. F_apply_L) then
      
         cnt = 0
         do n=1,p_bvol_top

         if (volnm(n)(1:5) .eq. 'PHYTD') then
            cnt = cnt + 1
            nullify(tr,trm)
            gmmstat = gmm_get('TR/'//trim(volnm(n)(7:))//':P',tr,meta3d)
	    if (gmmstat.eq.0) then
               if (trim(volnm(n)(7:)).ne.'HU') then
                  gmmstat = gmm_get('TR/'//trim(volnm(n)(7:))//':M',trm,meta3d)
!$omp parallel do
                  do k=1,p_nk-1
                     tr (:,:,k) = tr(:,:,k) + Cstv_dt_8*phy_tend(:,:,k,cnt)
                     trm(:,:,k) = tr(:,:,k)
                  end do
!$omp end parallel do
               endif
            endif
         endif

         end do

         return

      endif

      cnt     = 0
      UU_indx = 0
      VV_indx = 0

      do n = 1, p_bvol_top

         if (volnm(n)(1:5) .eq. 'PHYTD') then
            cnt = cnt + 1
            if  (volnm(n)(7:)  .eq. 'UU') UU_indx=cnt
            if  (volnm(n)(7:)  .eq. 'VV') VV_indx=cnt
            if ((volnm(n)(7:)  .eq. 'UU') .or. (volnm(n)(7:)  .eq. 'VV') ) cycle

            if ( nest_it ) call nest_blend (phy_tend(:,:,:,cnt),wk2,LDIST_DIM,1,p_nk,'M')

            nullify(tr)
            gmmstat = gmm_get('TR/'//trim(volnm(n)(7:))//':P',tr,meta3d)
	    if (gmmstat.eq.0) then
!$omp parallel do
               do k=1,p_nk
                  tr (:,:,k) = tr(:,:,k) + Cstv_dt_8*phy_tend(:,:,k,cnt)
               end do
!$omp end parallel do
            endif

            if (volnm(n)(7:)  .eq. 'TT'   ) then
               gmmstat = gmm_get('PW_TT:P',pw_tplus,meta3d)
!$omp parallel do
               do k= 1, p_nk
                  pw_tplus (:,:,k) = pw_tplus(:,:,k) + Cstv_dt_8*phy_tend(:,:,k,cnt)
               end do
!$omp end parallel do
               if (Schm_pheat_L) then
                  gmmstat = gmm_get(gmmk_tt1_s  ,tt1  ,meta3d)
                  gmmstat = gmm_get(gmmk_st1_s  ,st1  ,meta2d)
                  gmmstat = gmm_get(gmmk_fiptx_s,fiptx,meta3d)
                  gmmstat = gmm_get(gmmk_fis0_s ,fis0 ,meta2d)
                  if(.not.Schm_hydro_L)&
                       gmmstat = gmm_get(gmmk_qt1_s,qt1,meta3d)
                  call diag_fip (fiptx,st1,tt1,qt1,fis0,LDIST_DIM,l_nk)
               endif
            endif

         endif

      end do

      gmmstat = gmm_get(gmmk_tt1_s, tt1, meta3d)
      call tt2virt (tt1, .true., 'P')

      if ((UU_indx.gt.0) .and. (VV_indx.gt.0)) then
         gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
         gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
         gmmstat = gmm_get('PW_UU:P',pw_uplus,meta3d)
         gmmstat = gmm_get('PW_VV:P',pw_vplus,meta3d)

!	 tdu = 0. ; tdv = 0.
!$omp parallel do
         do k= 1, p_nk
            tdu(l_minx:l_maxx,l_miny:0,k) = 0. ; tdu(l_minx:l_maxx,l_nj+1:l_maxy,k) = 0.
            tdv(l_minx:l_maxx,l_miny:0,k) = 0. ; tdv(l_minx:l_maxx,l_nj+1:l_maxy,k) = 0.
            tdu(l_minx:0,l_miny:l_maxy,k) = 0. ; tdu(l_ni+1:l_maxx,l_miny:l_maxy,k) = 0.
            tdv(l_minx:0,l_miny:l_maxy,k) = 0. ; tdv(l_ni+1:l_maxx,l_miny:l_maxy,k) = 0.
            do j= 1, l_nj
               tdu(1:l_ni,j,k) = phy_tend(1:l_ni,j,k,UU_indx)*con(j)
               tdv(1:l_ni,j,k) = phy_tend(1:l_ni,j,k,VV_indx)*con(j)
            end do
         end do
!$omp end parallel do

         if ( nest_it ) then
            call blend_pntr (phy_tend(l_minx,l_miny,1,UU_indx),wk2,LDIST_DIM,1,p_nk,'M')
            call blend_pntr (phy_tend(l_minx,l_miny,1,VV_indx),wk2,LDIST_DIM,1,p_nk,'M')
         endif

!$omp parallel do
         do k= 1, p_nk
         do j= 1, l_nj
         do i= 1, l_ni
            pw_uplus(i,j,k) = pw_uplus(i,j,k) + Cstv_dt_8*phy_tend(i,j,k,UU_indx)
            pw_vplus(i,j,k) = pw_vplus(i,j,k) + Cstv_dt_8*phy_tend(i,j,k,VV_indx)
         end do
         end do
         end do
!$omp end parallel do

         call itf_phy_uvgridscal (tdu, tdv, LDIST_DIM, p_nk, .false. )

         if ( nest_it ) then
            call nest_blend (tdu,wk2,LDIST_DIM,1,p_nk,'U')
            call nest_blend (tdv,wk2,LDIST_DIM,1,p_nk,'V')
         endif

!$omp parallel do
         do k=1,l_nk+1
            ut1 (1:l_niu,:,k) =  ut1(1:l_niu,:,k) + Cstv_dt_8*tdu(1:l_niu,:,k+1)
            vt1 (:,1:l_njv,k) =  vt1(:,1:l_njv,k) + Cstv_dt_8*tdv(:,1:l_njv,k+1)
         end do
!$omp end parallel do

      endif
!     __________________________________________________________________
!
      return
      end
