!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r gemdm_config - Establish final model configuration
!
#include <model_macros_f.h>
#include <msg.h>
!
      integer function gemdm_config ( )
      implicit none

!author
!     M. Desgagne    - Summer 2006
!
!revision
! v3_30 - Desgagne M.       - initial version
! v4_00 - Plante & Girard   - Log-hydro-pressure coord on Charney-Phillips grid
! v4_03 - Lee/Desgagne      - ISST, add Grdc_maxcfl, Step_maxcfl, elim Grdc_pil
! v4_04 - Plante A.         - Remove offline mode
! v4_05 - Desgagne M.       - Throw warning and return for digital filter in LAM
! v4_05 - McTaggart-Cowan R.- Set Lun_sortie_s and Schm_opentop_L
! v4_10 - Tanguay M.        - Adjust digital filter when LAM

#include <arch_specific.hf>
#include <rmnlib_basics.hf>
#include <gmm.hf>
#include <WhiteBoard.hf>
#include "dcst.cdk"
#include "nml.cdk"
#include "step.cdk"
#include "ver.cdk"
#include "out.cdk"
#include "modconst.cdk"

      integer, external :: bin2com,time2sec

      character*16  dumc_S, datev
      character*256 fln_S
      logical wronghyb
      integer i, k, nrec, ipcode, ipkind, istat
      real    pcode,deg_2_rad,sec
      real*8  diffd, dayfrac, sec_in_day
      parameter (sec_in_day=86400.0d0)
!
!-------------------------------------------------------------------
!
      gemdm_config = -1

      if (.not.Step_leapyears_L) then
         call Ignore_LeapYear ()
         if (Lun_out.gt.0) write(Lun_out,6010)
      endif

      Lun_debug_L = (Lctl_debug_L.and.Ptopo_myproc.eq.0)
     
!     Use newcode style:
      call convip ( ipcode, pcode, ipkind, 0, ' ', .false. )

      Level_mode_ip1 = 1
      Level_kind_ip1 = 5
      Level_version  = 4
      if(Schm_Tlift.eq.1)then
         call handle_error(-1,'gemdm_config','review for toplev removed and Tlift')
         Level_version  = 3
      endif

      if (G_lam) then
         Glb_pil_n = Grd_extension
         Glb_pil_s=Glb_pil_n ; Glb_pil_w=Glb_pil_n ; Glb_pil_e=Glb_pil_n
         if (Grd_yinyang_L) then
            Lam_blend_H  = 0
            Lam_ctebcs_L = .true.
            Lam_blendoro_L = .false.
         else
            Lam_blend_H = max(0,Lam_blend_H)
         endif
         Lam_blend_Hx = Lam_blend_H ; Lam_blend_Hy = Lam_blend_H
         if (Schm_theoc_L) Lam_blend_Hy = 0
         Lam_tdeb = 999999.0
      endif
      if ((G_lam).and.(.not.Grd_yinyang_L)) then
         Lam_gbpil_T = max(0,Lam_gbpil_T)
         Lam_blend_T = max(0,Lam_blend_T)
      else
         Lam_gbpil_T = 0
         Lam_blend_T = 0
      endif

      deg_2_rad = Dcst_pi_8/180.

      P_lmvd_high_lat = min(90.,abs(P_lmvd_high_lat))
      P_lmvd_low_lat  = min(P_lmvd_high_lat,abs(P_lmvd_low_lat))
      P_lmvd_weigh_low_lat  = max(0.,min(1.,P_lmvd_weigh_low_lat ))
      P_lmvd_weigh_high_lat = max(0.,min(1.,P_lmvd_weigh_high_lat))

      call low2up  (Out3_unit_S,dumc_S)
      Out3_unit_S=dumc_S

      Out_rewrit_L   = .false.
      if (Clim_climat_L) Out_rewrit_L=.true.

      if (.not.Grd_yinyang_L) Out3_uencode_L  = .false.
      if (Out3_uencode_L)     Out3_fullplane_L= .true.
      if(Out3_nbitg .lt. 0) then
         if (lun_out.gt.0) write (Lun_out, 9154)
         Out3_nbitg=16
      endif
      Out3_nundr = 0
      do i = 1, MAXELEM
         if(Out3_zund(i) .eq. 0 ) goto 80
         Out3_nundr = Out3_nundr + 1
      enddo
 80   continue
      Out3_lieb_nk = 0
      do i = 1, MAXELEM
         if(Out3_lieb_levels(i) .le. 0. ) goto 81
         Out3_lieb_nk = Out3_lieb_nk + 1
      enddo
 81   continue
      if ((Out3_nundr.gt.0).and.(Out3_lieb_nk.gt.0)) Out3_lieb_nk=0

      if ( Schm_modcn .eq. 0 ) Schm_modcn = Step_total

      if (Step_runstrt_S == 'NIL') then
         Step_runstrt_S = Mod_runstrt_S
      else
         Mod_runstrt_S = Step_runstrt_S
      endif

      Cstv_dt_8     = dble(Step_dt)

!     Counting # of vertical levels specified by user
      G_nk = 0
      do k = 1, maxhlev
         if (hyb(k) .lt. 0.) exit
         G_nk = k
      enddo
      if (lun_out.gt.0) &
      write(lun_out,'(2x,"hyb="/5(f12.9,","))') hyb(1:g_nk)

      call set_zeta2( hyb, G_nk )

      if (Step_runstrt_S.eq."NIL") then
         if (lun_out.gt.0) then
            write (Lun_out, 6005)
            write (Lun_out, 8000)
         endif
         return
      endif
      
      dayfrac= - (Lctl_step * Step_dt / sec_in_day)
      call incdatsd (datev, Step_runstrt_S, dayfrac)
      call datp2f ( Out3_date, datev )

      if (lun_out.gt.0) write (Lun_out,6007) Step_runstrt_S, datev

      Grdc_ndt = -1
      if (time2sec(Grdc_nfe,sec)==RMN_OK) Grdc_ndt = sec/real(Cstv_dt_8)
      if (Grdc_ndt.gt.-1) Grdc_ndt = max( 1, Grdc_ndt)

      Grdc_start= Lctl_step
      if (Grdc_start_S /= '') then
         if (time2sec(Grdc_start_S,sec)==RMN_OK) Grdc_start= sec / real(Step_dt)
      endif

      Grdc_end= Step_total
      if (Grdc_end_S /= '') then
         if (time2sec(Grdc_end_S,sec)==RMN_OK) Grdc_end= sec / real(Step_dt)
      endif

      Grdc_maxcfl = max(1,Grdc_maxcfl)
      Grdc_pil    = Grdc_maxcfl + Grd_bsc_base + Grd_bsc_ext1
      Grdc_ni     = Grdc_ni   + 2*Grdc_pil
      Grdc_nj     = Grdc_nj   + 2*Grdc_pil
      Grdc_iref   = Grdc_iref +   Grdc_pil
      Grdc_jref   = Grdc_jref +   Grdc_pil     

      call low2up  (Lam_hint_S ,dumc_S)
      Lam_hint_S= dumc_S

      call low2up  (sol_type_S ,dumc_S)
      sol_type_S= dumc_S
      call low2up  (sol_precond_S ,dumc_S)
      sol_precond_S= dumc_S

      if ( (Sol_type_S.ne.'ITERATIVE_2D') .and. &
           (Sol_type_S.ne.'ITERATIVE_3D') .and. &
           (Sol_type_S.ne.'DIRECT'   ) ) then
         if (lun_out.gt.0) write (Lun_out, 9200) Sol_type_S
         return
      endif

      if (Sol_type_S(1:9).eq.'ITERATIVE') then
         if (Sol_precond_S .ne.'JACOBI') then
            if (lun_out.gt.0) write (Lun_out, 9201) Sol_precond_S
            return
         endif
      endif

      G_ni  = Grd_ni
      G_nj  = Grd_nj

      G_niu = G_ni
      G_njv = G_nj - 1
      if (G_lam) then
         G_niu = G_ni - 1
         if (Eigv_parity_L) then
            Eigv_parity_L = .false.
            if (lun_out.gt.0) write (Lun_out, 7005)
         endif
         if (Schm_psadj_L.and..not.Grd_yinyang_L) then
            if (lun_out.gt.0) then
               write (Lun_out, 7020)
               write (Lun_out, 8000)
            endif
            return
         endif
      endif

!     Check for open top (piloting and blending)
      Schm_opentop_L  = .false.
      if (Lam_gbpil_T > 0) then
         Schm_opentop_L = .true.
         if(lun_out.gt.0.and.Vspng_nk.ne.0)write (Lun_out, 9570)
         Vspng_nk       = 0
      endif
      if (Lam_gbpil_T <= 0 .and. Lam_blend_T > 0) then
         if (lun_out.gt.0)write (Lun_out, 9580)
         return
      endif

!     Check for incompatible use of IAU and DF
      if (Iau_period > 0. .and. Init_balgm_L) then
         if (Lun_out.gt.0) then
            write (Lun_out, 7040)
            write (Lun_out, 8000)
         endif
         return
      endif

!     Some common setups for AUTOBAROTROPIC runs
      if (Schm_autobar_L) then
          if (lun_out.gt.0) write (Lun_out, 6100)
          Schm_topo_L=.false.
          Out3_nundr = 0
      endif
      if (Williamson_case.gt.0) then
          if (Williamson_case.eq.3.or.Williamson_case.eq.4) then
             if (lun_out.gt.0) write (Lun_out, 6300)
             return
          endif
          if (Williamson_case.gt.2.and.Williamson_alpha.ne.0.) then
             if (lun_out.gt.0) write (Lun_out, 6400)
             return
          endif
          if (Williamson_case.eq.2.and. Grd_yinyang_L .and. &
              Williamson_alpha.ne.0.0 .and. Williamson_alpha.ne.90.0 ) then
             if (lun_out.gt.0) write (Lun_out, 6500)
             return
          endif

          Williamson_alpha=Williamson_alpha*(Dcst_pi_8/180.0)
      endif

      if (Init_dfnp <= 0) then
         if (Init_balgm_L .and. Lun_out > 0) write(Lun_out,6602) 
         Init_balgm_L = .false.
      endif
      Init_dfnp = max(0,Init_dfnp)
      if (Init_balgm_L) then
         if ( mod(Init_dfnp,2) .ne. 1 ) then
            if (Lun_out.gt.0) write(Lun_out,6600) Init_dfnp
            return
         endif
         if ( Init_dfnp .eq. 1 ) then
            if (Lun_out.gt.0) write(Lun_out,6601)
            return
         endif
      endif

      if (Lctl_debug_L) then
         istat = gmm_verbosity(GMM_MSG_DEBUG)
         istat = wb_verbosity(WB_MSG_DEBUG)
         call msg_set_minMessageLevel(MSG_DEBUG)
         call handle_error_setdebug(Lctl_debug_L)
      endif

      gemdm_config = 1

 6005 format (/' Starting time Step_runstrt_S not specified'/)
 6007 format (/X,48('#'),/,2X,'STARTING DATE OF THIS RUN IS : ',a16,/ &
                           2X,'00H FORECAST WILL BE VALID AT: ',a16,/ &
              X,48('#')/)
 6010 format (//'  =============================='/&
                '  = Leap Years will be ignored ='/&
                '  =============================='//)
 6100 format (//'  =============================='/&
               '  AUTO-BAROTROPIC RUN:          '/&
                '  Schm_topo_L set to .false.,Out3_nundr=0 '/&
                '  =============================='//)
 6300 format (/' Williamson case 3 and 4 are not available'/)
 6400 format (/' Williamson Alpha(in deg) must be 0.0 for cases greater than 2 '/)
 6500 format (/' Williamson case 2: Alpha(in deg) must be 0.0 or 90.0 for Grd_yinyang '/)
 6600 format (/' PROBLEM: THE VARIABLE Init_dfnp = ',i4,'  IS EVEN'/)
 6601 format (/' PROBLEM: THE VARIABLE Init_dfnp cannot be equal to 1'/)
 6602 format (/' WARNING: Init_dfnp is <= 0; Settings Init_balgm_L=.F.'/)
 7005 format (/' EIGENMODES with definite PARITY NOT AVAILABLE IF LAM'/)
 7020 format (/' OPTION Schm_psadj_L=.true. NOT AVAILABLE IF LAM'/)
 7040 format (/' OPTION Init_balgm_L=.true. NOT AVAILABLE if applying IAU (Iau_period>0)'/)
 8000 format (/,'========= ABORT IN S/R GEMDM_CONFIG ============='/)
 9154 format (/,' Out3_nbitg IS NEGATIVE, VALUE will be set to 16'/)
 9200 format (/'ABORT: WRONG CHOICE OF SOLVER for Helmholtz problem: Sol_type_S =',a/)
 9201 format (/'ABORT: WRONG CHOICE OF PRE-CONDITIONNER FOR ITERATIVE SOLVER: Sol_precond_S =',a/)
 9570 format (/,'WARNING: Vspng_nk set to zero since top piloting is used'/)
 9580 format (/,'ABORT: Non zero Lam_blend_T cannot be used without top piloting'/)
!
!-------------------------------------------------------------------
!
      return
      end

