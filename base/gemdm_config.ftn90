!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!**s/r gemdm_config - Establish final model configuration
!
#include "model_macros_f.h"
#include "msg.h"
!
      integer function gemdm_config ( )
      implicit none
#include <arch_specific.hf>
!
!author
!     M. Desgagne    - Summer 2006
!
!revision
! v3_30 - Desgagne M.       - initial version
! v4_00 - Plante & Girard   - Log-hydro-pressure coord on Charney-Phillips grid
! v4_03 - Lee/Desgagne      - ISST, add Grdc_maxcfl, Step_maxcfl, elim Grdc_pil
! v4_04 - Plante A.         - Remove offline mode
! v4_05 - Desgagne M.       - Throw warning and return for digital filter in LAM
! v4_05 - McTaggart-Cowan R.- Set Lun_sortie_s and Schm_opentop_L
! v4_10 - Tanguay M.        - Adjust digital filter when LAM
! 
!
!object
!
#include "dcst.cdk"
#include "nml.cdk"
#include "step.cdk"
#include "ver.cdk"
#include "out.cdk"
#include "modconst.cdk"
       include "v4dg.inc"
!
      integer  bin2com,newdate,parse_grdc
      external bin2com,newdate,parse_grdc
!
      integer   time1, time2, istat
!
      character*16 dumc_S
      character*256 fln_S
      logical wronghyb
      integer i, k, nrec, err, ipcode, ipkind
      real pcode,deg_2_rad
!
!-------------------------------------------------------------------
!
      gemdm_config = -1
!
      if (.not.Step_leapyears_L) then
         call Ignore_LeapYear ()
         if (Lun_out.gt.0) write(Lun_out,6010)
      endif
!
      Lun_debug_L = (Lctl_debug_L.and.Ptopo_myproc.eq.0)
!        
!     Use newcode style:
      call convip ( ipcode, pcode, ipkind, 0, ' ', .false. )
!
      Level_mode_ip1 = 1
      Level_kind_ip1 = 5
      Level_version  = 2
!
      call low2up  (Hzd_type_S,dumc_S)
      Hzd_type_S = dumc_S
      Hzd_lnr    = min(max(0.,Hzd_lnr   ),0.9999999)
      Hzd_pwr    = Hzd_pwr    / 2
      Hzd_pwr    = min(max(2,Hzd_pwr   *2),8)
      if (Hzd_lnr_tr.lt.0.) Hzd_lnr_tr = Hzd_lnr
      if (Hzd_pwr_tr.lt.0 ) Hzd_pwr_tr = Hzd_pwr
      Hzd_lnr_tr = min(max(0.,Hzd_lnr_tr),0.9999999)
      Hzd_pwr_tr = Hzd_pwr_tr / 2
      Hzd_pwr_tr = min(max(2,Hzd_pwr_tr*2),8)
!
      if (G_lam) then
         Glb_pil_n = Grd_extension
         Glb_pil_s=Glb_pil_n ; Glb_pil_w=Glb_pil_n ; Glb_pil_e=Glb_pil_n
         if (Grd_yinyang_L) then
            Lam_blend_H  = 0
            Lam_ctebcs_L = .true.
            Lam_blendoro_L = .false.
         else
            Lam_blend_H = max(0,Lam_blend_H)
         endif
         Lam_blend_Hx = Lam_blend_H ; Lam_blend_Hy = Lam_blend_H
         if (Schm_theoc_L) Lam_blend_Hy = 0
        Lam_tdeb = 999999.0
      endif
      Lam_gbpil_T = max(0,Lam_gbpil_T)
      Lam_blend_T = max(0,Lam_blend_T)
!
      deg_2_rad = Dcst_pi_8/180.
!
      P_lmvd_high_lat = min(90.,abs(P_lmvd_high_lat))
      P_lmvd_low_lat  = min(P_lmvd_high_lat,abs(P_lmvd_low_lat))
      P_lmvd_weigh_low_lat  = max(0.,min(1.,P_lmvd_weigh_low_lat ))
      P_lmvd_weigh_high_lat = max(0.,min(1.,P_lmvd_weigh_high_lat))
!
      call low2up  (Out3_unit_S,dumc_S)
      Out3_unit_S=dumc_S
!
      Out_datyp      = 134
      Out_rewrit_L   = .false.
      if (Clim_climat_L) Out_rewrit_L=.true.
!
      if(Out3_nbitg .lt. 0) then
         if (lun_out.gt.0) write (Lun_out, 9154)
         Out3_nbitg=16
      endif
      Out3_nundr = 0
      do i = 1, MAXELEM
         if(Out3_zund(i) .eq. 0 ) goto 80
         Out3_nundr = Out3_nundr + 1
      enddo
 80   continue
!
      if ( Schm_modcn .eq. 0 ) Schm_modcn = Step_total
!
      if (Step_runstrt_S == 'NIL') then
         Step_runstrt_S = Mod_runstrt_S
      else
         Mod_runstrt_S = Step_runstrt_S
      endif
!
      Cstv_dt_8     = dble(Step_dt)
!
!     Counting # of vertical levels specified by user
      G_nk = 0
      do k = 1, maxhlev
         if (hyb(k) .lt. 0.) exit
         G_nk = k
      enddo
!
      call set_zeta ( hyb )
!
      if (V4dg_conf.ne.0.and.Sol_type_S.eq.'ITERATIF') then
          if (Lun_out.gt.0)  write (Lun_out, 9300) 
          return
      endif
!
      if (Step_runstrt_S.eq."NIL") then
         if (lun_out.gt.0) then
            write (Lun_out, 6005)
            write (Lun_out, 8000)
         endif
         return
      endif
!
      if (Vtopo_start .ge. 0) then
         if (lun_out.gt.0) then
            write (Lun_out, 6200)
            write (Lun_out, 8000)
         endif
         return
      endif
!
      call datp2f ( Out3_date, Step_runstrt_S )
      err = newdate ( Out3_date, time1, time2, -3 )
      if (lun_out.gt.0) write (Lun_out,6007) Step_runstrt_S,time1,time2
!
      Grdc_ndt   = parse_grdc (Grdc_nfe    , nint(Cstv_dt_8))
      Grdc_start = parse_grdc (Grdc_start_S, nint(Cstv_dt_8))
      Grdc_end   = parse_grdc (Grdc_end_S  , nint(Cstv_dt_8))
      if (Grdc_ndt.gt.-1) Grdc_ndt = max( 1, Grdc_ndt)
      Grdc_start = max(0,Grdc_start)
      if (Grdc_end.lt. 0) Grdc_end = Step_total
      Grdc_maxcfl = max(1,Grdc_maxcfl)
      Grdc_pil    = Grdc_maxcfl + Grd_bsc_base + Grd_bsc_ext1
      Grdc_ni     = Grdc_ni   + 2*Grdc_pil
      Grdc_nj     = Grdc_nj   + 2*Grdc_pil
      Grdc_iref   = Grdc_iref +   Grdc_pil
      Grdc_jref   = Grdc_jref +   Grdc_pil     

      Acid_npas=0
!
      call low2up  (Lam_hint_S ,dumc_S)
      Lam_hint_S= dumc_S
      call low2up  (sol_type_S ,dumc_S)
      sol_type_S= dumc_S
      call low2up  (sol_precond_S ,dumc_S)
      sol_precond_S= dumc_S
!
      G_ni  = Grd_ni
      G_nj  = Grd_nj
!
      G_niu = G_ni
      G_njv = G_nj - 1
      if (G_lam) then
         G_niu = G_ni - 1
         if (Eigv_parity_L) then
            Eigv_parity_L = .false.
            if (lun_out.gt.0) write (Lun_out, 7005)
         endif
         if (Schm_psadj_L) then
            if (lun_out.gt.0) then
               write (Lun_out, 7020)
               write (Lun_out, 8000)
            endif
            return
         endif
      endif

!     Check for open top (piloting or blending)
      Schm_opentop_L  = .false.
      if (Lam_blend_T > 0 .or. Lam_gbpil_T > 0) then
         Schm_opentop_L = .true.
         Vspng_nk       = 0
      endif
!
      if (Lctl_debug_L) call msg_set_minMessageLevel(MSG_DEBUG)

      gemdm_config = 1
!
 6005 format (/' Starting time Step_runstrt_S not specified'/)
 6007 format (/X,63('#'),/,2X,'STARTING DATE for RUN is: ',a16,'= ', &
              i8.8,'.',i8.8,/X,63('#')/)
 6010 format (//'  =============================='/&
                '  = Leap Years will be ignored ='/&
                '  =============================='//)
 6200 format (/' VARIABLE TOPOGRAPHY NOT AVAILABLE IN THIS VERSION'/)
 7005 format (/' EIGENMODES with definite PARITY NOT AVAILABLE IF LAM'/)
 7020 format (/' OPTION Schm_psadj_L=.true. NOT AVAILABLE IF LAM'/)
 8000 format (/,'========= ABORT IN S/R GEMDM_CONFIG ============='/)
 9100 format (/'ABORT: you must supply levels in namelist variable hyb'/)
 9154 format (/,' Out3_nbitg IS NEGATIVE, VALUE will be set to 16'/)
 9250 format (/' ===> WRONG SPECIFICATION OF HYB VERTICAL LEVELS:'/ &
               '      LEVELS MUST BE MONOTONICALLY INCREASING'/ &
               '      FROM HYB(1) ---- ABORT ----'// &
               '      Current choice:')
 9300 format (/,'ABORT: ADJOINT not done for Sol_type_S = ITERATIF',/)
 9400 format (/,'ABORT: Cstv_ptop_8 must be > 0',/)
 9550 format (/,'ABORT: hyb must be < 1.0 and > ',es10.4,/)
 9560 format (/,'ABORT: Top piloting must have topology 2x* or *x2'/)

!
!-------------------------------------------------------------------
!
      return
      end
!
      integer function parse_grdc (F_string_s,F_timestep)
      implicit none
#include <arch_specific.hf>
      character*(*) F_string_s
      integer F_timestep

      character*1 nfe
      integer len, nfe_nsec

      parse_grdc = -1
      len = len_trim( F_string_s )
      if (len.gt.0) then
         call low2up (F_string_s(len:len),nfe)
         nfe_nsec = 3600
         if (nfe.eq.'D') nfe_nsec = 86400
         if (nfe.eq.'M') nfe_nsec = 60
         if (nfe.eq.'S') nfe_nsec = 1
         if ((nfe.eq.'D').or.(nfe.eq.'H').or. &
             (nfe.eq.'M').or.(nfe.eq.'S')) len= len-1
         read ( F_string_s(1:len), * ) parse_grdc
         parse_grdc = parse_grdc * nfe_nsec / F_timestep
      endif
      return
      end
