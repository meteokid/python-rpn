!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!** s/r e_rdhint3 read and perform horizontal interpolation
!
#include "model_macros_f.h"
!
      integer function e_rdhint3 (   &
                  f, dgid, ni, nj, nomvar_S, ip1, ip2, ip3, etik_S, &
                  typvar_S, anyip_L, fhint_L, interp_S, un1, stdo )
!
      implicit none
#include <arch_specific.hf>
!
      character* (*) nomvar_S,interp_S,etik_S,typvar_S
      logical anyip_L,fhint_L
      integer dgid, ni, nj, ip1, ip2, ip3, un1, stdo
      real  f(*)
!
!author
!     Michel Desgagne - January 2001
!
!revision
! v2_21 - Desgagne M.       - initial version
! v3_00 - Lee V.            - must interpolate if not fhint_L
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_01 - Lee V.            - new ip1 encoding (kind=5 -- unnormalized)
! v3_02 - Dugas B.          - convip for topography
! v3_30 - McTaggart & Lee   - grid check, adjusted for LAM
!
!implicites
#include "e_grids.cdk"
#include "e_cdate.cdk"
#include "hgc.cdk"
#include "e_anal.cdk"
#include "grd.cdk"
#include "glb_ld.cdk"
#include "glb_pil.cdk"
!
! NOTES: will return e_rdhint3= -1 if nomvar_S is not found or if
!                                 a problem occurs
!                    e_rdhint3=  0 if nomvar_S is found with specified 
!                                 ip123 and no horizontal interpolation 
!                                 is required
!                    e_rdhint3=  1 if nomvar_S is found and horizontal 
!                                 interpolation is performed
!                    e_rdhint3=  2 if nomvar_S is found with no specific 
!                                 ip123 and no horizontal interpolation 
!                                 is required
!*                  
      integer,external :: fstinf,fstprm,fstluk,ezqkdef,ezdefset,ezsetopt,ezsint
      integer,external :: ezgetopt,ezsetival,ezgetival,ip1_all,samesubgrid
      logical,external :: samegrid

      character*1  grd
      character*2  typ
      character*4  var
      character*12  lab,cdum
      character*32  interp2_S
      real    zp1
      logical tr_ip_L,must_interpo_L
      integer dte, det, ipas, p1, p2, p3, g1, g2, g3, g4, bit, &
              dty, swa, lng, dlf, ubc, ex1, ex2, ex3
      integer i,key,nisrc,njsrc,nksrc,err,src_gid,iunit,kind,ni1,nj1,subid,nicore,njcore
      real xlon,ylat,conv_ip1
      pointer (paxlon, xlon(*)), (paylat, ylat(*))
      real,   dimension(:), allocatable  :: w1
!
!--------------------------------------------------------------------
!
      e_rdhint3 = -1      
      if (ip1 .eq. -1 .or. ip1 .eq. 0 ) then
        key = fstinf (un1,nisrc,njsrc,nksrc,datev,etik_S,ip1,ip2,ip3,typvar_S, &
                                                             nomvar_S)
      else
        call convip ( ip1, zp1, kind, -1, cdum, .false. )
        write(6,*)'e_rdhint3: ip1,zp1,kind= ',ip1,zp1,kind
        key = fstinf (un1,nisrc,njsrc,nksrc,datev,etik_S,ip1_all(zp1,kind),ip2 &
           ,ip3,typvar_S,nomvar_S)
      endif

      tr_ip_L = key.ge.0
!
      if ( (.not.tr_ip_L) .and. (anyip_L) ) then
         call e_rdhint_out2(stdo, "Warning field not found: ",nomvar_S,ip1,ip2,ip3,' ')
         write(stdo,*) "Will try to locate it with with no specific ip123"
         key = fstinf (un1,nisrc,njsrc,nksrc,datev,etik_S,-1,-1,-1,typvar_S, &
                                                             nomvar_S)
      endif
      if (key .lt. 0) then
         call e_rdhint_out2(stdo, "Missing field: ",nomvar_S,ip1,ip2,ip3,' ')
         return
      endif
!
      allocate (w1(nisrc*njsrc*nksrc))
      err = fstluk( w1, key, nisrc,njsrc,nksrc)
      err = fstprm (key, DTE, DET, IPAS, nisrc, njsrc, nksrc, BIT, DTY, P1, &
                    P2, P3, TYP, VAR, LAB, GRD, G1, G2, G3, G4, SWA,  &
                    LNG, DLF, UBC, EX1, EX2, EX3)
!
      if ( grd .ne. 'A' .and. grd .ne. 'B' .and. grd .ne. 'E' .and. &
           grd .ne. 'G' .and. grd .ne. 'L' .and. grd .ne. 'N' .and. &
           grd .ne. 'S' .and. grd .ne. 'Y' .and. grd .ne. 'Z' .and. &
           grd .ne. 'U' ) then
           call e_rdhint_out2(stdo, "UNKNOWN grid for field: ",nomvar_S,ip1,p2,ip3,' ')
           goto 999
       endif
      if (.not.LAM) then
        if ( grd .ne. 'A' .and. grd .ne. 'B' .and. grd .ne. 'L' .and. &
             grd .ne. 'G' .and. grd .ne. 'Z' .and. grd .ne. 'U') then
           call e_rdhint_out2(stdo, "WRONG grid for field: ",nomvar_S,ip1,p2,ip3,' ')
           goto 999
        endif
      endif
!
      subid=-1
      must_interpo_L = .false.
      interp2_S = interp_S
      iunit = 0
      if (grd.eq.'Z' .or. grd.eq.'U') iunit=un1
      ni1 = nisrc ; nj1 = njsrc
      if (any(grd ==(/'u','U'/))) then
          ni1 = -1 ; nj1 = -1
      endif
      src_gid = ezqkdef (ni1, nj1, GRD, g1, g2, g3, g4, iunit)
      if ((fhint_L).or.(grd.ne.'Z' .and. grd.ne.'U')) then
         must_interpo_L = .true.
      else
          if (grd.eq.'Z') then
             if (dgid.eq.dstf_gid) then
                paxlon = loc(xfi(1))
                paylat = loc(yfi(1))
             else if (dgid.eq.dstu_gid) then
                paxlon = loc(xu(1))
                paylat = loc(yfi(1))
             else
                paxlon = loc(xfi(1))
                paylat = loc(yv(1))
             endif
             if ((nisrc.ne.ni).or.(njsrc.ne.nj)) then
                must_interpo_L = .true.
             else
                must_interpo_L =  &
                     .not. samegrid (un1, nisrc,njsrc, g1,g2,g3, Hgc_ig1ro, &
                     Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro,xlon, ylat)
             endif
          endif

          if (grd.eq.'U') then
             !multiple grids - limit the check to the core grid points
             if (dgid.eq.dstf_gid) then
                paxlon = loc(xfi(1))
                paylat = loc(yfi(1))
             else if (dgid.eq.dstu_gid) then
                paxlon = loc(xu(1))
                paylat = loc(yfi(1))
             else
                paxlon = loc(xfi(1))
                paylat = loc(yv(1))
             endif
             must_interpo_L = .true.
!Each entry (Yin or Yang) program has only one processor treating the model grid
             nicore = G_ni-Glb_pil_w-Glb_pil_e ; njcore = G_nj-Glb_pil_s-Glb_pil_n
             if (nisrc >= nicore .and. njsrc/2 >= njcore) then
                subid = samesubgrid(src_gid,nicore,njcore,Hgc_ig1ro,Hgc_ig2ro, &
                     Hgc_ig3ro,Hgc_ig4ro,xlon(1+Glb_pil_w),ylat(1+Glb_pil_s))
                if (subid >= 0) then
                   print *,'U grid contains sub grid match to ',nisrc,'>=',nicore,';',njsrc/2,'>=',njcore,';',subid
                endif
             endif
             if (subid >= 0) then
                 interp2_S = 'NEAREST'
                 err = ezsetopt ('USE_1SUBGRID', 'YES')
                 err = ezsetival('SUBGRIDID', subid)
             endif
          endif
      endif

      if ( must_interpo_L ) then
         call e_rdhint_out2(stdo, "Horizontal interpolation: ",nomvar_S,ip1,p2,ip3,interp2_S)
         err = ezdefset ( dgid, src_gid )
         err = ezsetopt ('INTERP_DEGREE', interp2_S)
         err = ezsint(f, w1)
         e_rdhint3 = 1
         !# WILL NOT reset to default because in GEMNTR, we need this onegrid for e_intwind... winds being staggered they can never be interpoled with nearest/onegrid... reset needed
         if (subid >= 0) err = ezsetopt('USE_1SUBGRID','NO')
      else
!  ONLY possible to copy if analysis is on a Z grid
         e_rdhint3 = 0
         call e_rdhint_out2(stdo, "NO horizontal interpolation on ",nomvar_S,ip1,p2,ip3,' ')
!
         do i=1,ni*nj
            f(i) = w1(i)
         enddo
!
      endif
!
      do i=1,ni*nj
         if ( abs( f(i) ) .lt. 1.0E-30 ) f(i) = 0.
      end do
!
 999  deallocate(w1)
!
!
!---------------------------------------------------------------------
!
      return
      end
      subroutine e_rdhint_out2(stdo,string_S,nomvar_S,ip1,ip2,ip3,msg_S)
      implicit none
#include <arch_specific.hf>
      character* (*) nomvar_S,string_S,msg_S
      character*12 dumc_S
      character*256 pformat_S
      integer  ip1, ip2, ip3, kind,stdo
      real     conv_ip1
      integer  longueur
      external longueur

      if (ip1.eq.-1) then
          pformat_S = "(/,'(S/R e_rdhint3) "//string_S(1:longueur(string_S))// &
                  "',A4,' for ip123=',3i5,x,a)"
          write(stdo,fmt=pformat_S) nomvar_S,ip1,ip2,ip3,trim(msg_S)
      else
          call convip ( ip1 , conv_ip1, kind, -1, dumc_S, .false. )
          pformat_S = "(/,'(S/R e_rdhint3) "//string_S(1:longueur(string_S))// &
                  "',A4,' for ip123=',F12.5,2i5,x,a)"
          write(stdo,fmt=pformat_S) nomvar_S,conv_ip1,ip2,ip3,trim(msg_S)
      endif

      return
      end

