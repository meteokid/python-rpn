!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/r prep_2_tl - TLM of prep_2 
*
#include "model_macros_f.h"
*
      subroutine prep_2_tl ( F_ru,  F_rv,  F_ruw1,F_ruw2,F_rvw1,F_rvw2,
     $                       F_xct1,F_yct1,F_zct1,F_fis, F_rc,  F_rt,
     $                       F_rw,  F_rf,  F_oru, F_orv, F_rb,  F_nest_t,
*
     $                       F_ru_m,  F_rv_m,  F_ruw1_m,F_ruw2_m,F_rvw1_m,F_rvw2_m,
     $                       F_xct1_m,F_yct1_m,F_zct1_m,         F_rc_m,  F_rt_m,
     $                       F_rw_m,  F_rf_m,  F_oru_m, F_orv_m, F_rb_m , F_nest_t_m,
*
     $                       DIST_DIM, ni, nj, Nk )
*
      implicit none
*
      integer DIST_DIM, ni, nj, Nk
      real F_ru    (DIST_SHAPE,Nk)  ,F_rv    (DIST_SHAPE,Nk)  ,
     $     F_ruw1  (DIST_SHAPE,Nk)  ,F_ruw2  (DIST_SHAPE,Nk)  ,
     $     F_rvw1  (DIST_SHAPE,Nk)  ,F_rvw2  (DIST_SHAPE,Nk)  ,
     $     F_xct1  (ni,nj,Nk)       ,F_yct1  (ni,nj,Nk)       ,
     $     F_zct1  (ni,nj,Nk)       ,F_fis   (DIST_SHAPE)     ,
     $     F_rc    (DIST_SHAPE,Nk)  ,F_rt    (DIST_SHAPE,Nk+1),
     $     F_rw    (DIST_SHAPE,Nk+1),F_rf    (DIST_SHAPE,Nk+1),
     $     F_oru   (DIST_SHAPE,Nk)  ,F_orv   (DIST_SHAPE,Nk)  ,
     $     F_rb    (DIST_SHAPE)     ,F_nest_t(DIST_SHAPE,*)
*
      real F_ru_m   (DIST_SHAPE,Nk)  ,F_rv_m   (DIST_SHAPE,Nk)  ,
     $     F_ruw1_m (DIST_SHAPE,Nk)  ,F_ruw2_m (DIST_SHAPE,Nk)  ,
     $     F_rvw1_m (DIST_SHAPE,Nk)  ,F_rvw2_m (DIST_SHAPE,Nk)  ,
     $     F_xct1_m (ni,nj,Nk)       ,F_yct1_m (ni,nj,Nk)       ,
     $     F_zct1_m (ni,nj,Nk)       ,
     $     F_rc_m   (DIST_SHAPE,Nk)  ,F_rt_m    (DIST_SHAPE,Nk+1),
     $     F_rw_m   (DIST_SHAPE,Nk+1),F_rf_m    (DIST_SHAPE,Nk+1),
     $     F_oru_m  (DIST_SHAPE,Nk)  ,F_orv_m   (DIST_SHAPE,Nk)  ,
     $     F_rb_m   (DIST_SHAPE)     ,F_nest_t_m(DIST_SHAPE,*)
*
*author
*     M.Tanguay
*
*revision
* v2_10 - Tanguay M.        - initial MPI version
* v2_31 - Tanguay M.        - adapt ADJ for new advection code and LAM version 
* v3_00 - Tanguay M.        - adapt to restructured prep_2 
* v3_03 - Tanguay M.        - Adjoint Lam and NoHyd configuration 
* v3_11 - Tanguay M.        - AIXport+Opti+OpenMP for TLM-ADJ
* v3_30 - Tanguay M.        - Use invhsyv 
* v4_04 - Tanguay M.        - Staggered version TL/AD 
* v4_12 - Tanguay M.        - OPENMP TL/AD
* v4_12 - Tanguay M.        - TL/AD Open top
*
*object
*     see id section
*
*arguments
*     see appropriate comdeck documentation
*
*implicits
#include "glb_ld.cdk"
#include "lun.cdk"
#include "lam.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "grd.cdk"
#include "geomg.cdk"
#include "offc.cdk"
#include "schm.cdk"
#include "intuv.cdk"
#include "inuvl.cdk"
#include "type.cdk"
#include "adw.cdk"
#include "cori.cdk"
#include "ver.cdk"
#include "ptopo.cdk"
*
      integer i, j, k, i0, j0, k0, in, jn, i00, inn, j00, jnn
      real*8  x_8, y_8, z_8, cx_8, cy_8, cz_8, rx_8, ry_8, rz_8
      real*8  bbb_8, mumu_8, tot_8
      real*8  a1_8, a2_8, a3_8, a4_8, b1_8, b2_8, b4_8, b5_8,xxx_8, yyy_8, zzz_8
      real    rdiv(DIST_SHAPE), Ttop(DIST_SHAPE), w_rt
*
      real    rdiv_m(DIST_SHAPE), Ttop_m(DIST_SHAPE), w_rt_m
*
      real*8  ZERO_8, ONE_8, TWO_8, FOUR_8, QUARTER_8 
      parameter( ZERO_8=0.0, ONE_8=1.0, TWO_8=2.0, FOUR_8=4.0, 
     $           QUARTER_8=.25 )
*
      real*8 cx_m_8, cy_m_8, cz_m_8, rx_m_8, ry_m_8, rz_m_8, mumu_m_8
*
      if (Schm_opentop_L) call handle_error(-1,'prep_2_tl','Schm_opentop_L not done')
*
******************************************************************
* Metric corrections to the RHS of horizontal momentum equations *
******************************************************************
      tot_8 = - FOUR_8*Dcst_omega_8/Cstv_dt_8
*
*     Coriolis term is zero for theoretical cases
*
      if( Schm_theoc_L ) tot_8 = ZERO_8 
*
      bbb_8 = ( ONE_8 - Offc_b0_8 ) / Offc_b0_8
*
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
      k0 = 1+Lam_gbpil_T
      if (G_lam) then
         if (l_west)  i0= pil_w
         if (l_east)  in= l_niu - pil_e + 2
         if (l_south) j0= pil_s
         if (l_north) jn= l_njv - pil_n + 2
      endif
*
!$omp parallel private(x_8,y_8,z_8,rz_8,ry_8,rx_8,cx_8,cy_8,cz_8,
!$omp&                 mumu_8,rdiv,xxx_8,yyy_8,zzz_8,
!$omp&                 rz_m_8,ry_m_8,rx_m_8,
!$omp&                 cx_m_8,cy_m_8,cz_m_8,
!$omp&                 mumu_m_8,rdiv_m)
!$omp do
      do 100 k= k0, l_nk
      do 100 j= j0, jn
      do 100 i= i0, in
*
*     Compute components of r(t0) and put in x, y, z
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         y_8 = adw_cy_8(j)
         if (G_lam) then
         x_8 = adw_cx_8(i) * y_8
         y_8 = adw_sx_8(i) * y_8
         else
         x_8 = adw_cx_8(l_i0 - 1 + i) * y_8
         y_8 = adw_sx_8(l_i0 - 1 + i) * y_8
         endif
         z_8 = adw_sy_8(j)
*
*     Compute (Rx, Ry, Rz) = (rx, ry, rz)
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*
*        TRAJECTORY
*        ----------
         mumu_m_8 =    ( ONE_8 + F_zct1_m(i,j,k) )*( ONE_8 - F_zct1_m(i,j,k) )
*
*        TLM 
*        ---
         mumu_8  =    (         F_zct1  (i,j,k) )*( ONE_8 - F_zct1_m(i,j,k) )
     %             +  ( ONE_8 + F_zct1_m(i,j,k) )*(       - F_zct1  (i,j,k) )
*
*        TRAJECTORY and TLM 
*        ------------------
         if (mumu_m_8 .GT. ZERO_8) then
         mumu_8   = - ( ONE_8 / mumu_m_8**2) * mumu_8
         mumu_m_8 =     ONE_8 / mumu_m_8
         endif
*
*        TRAJECTORY
*        ----------
         rz_m_8 = F_rvw2_m(i,j,k)
         ry_m_8 =  mumu_m_8 * (F_xct1_m(i,j,k)*F_ruw2_m(i,j,k)-
     $                         F_yct1_m(i,j,k)*F_zct1_m(i,j,k)*rz_m_8)
         rx_m_8 = -mumu_m_8 * (F_yct1_m(i,j,k)*F_ruw2_m(i,j,k)+
     $                         F_xct1_m(i,j,k)*F_zct1_m(i,j,k)*rz_m_8)
*
*        TLM 
*        ---
         rz_8 = F_rvw2(i,j,k)
         ry_8 =  
     %          mumu_m_8* ( 
     %                    F_xct1_m(i,j,k)*F_ruw2  (i,j,k)
     %                  + F_xct1  (i,j,k)*F_ruw2_m(i,j,k)
*
     %                  - F_yct1_m(i,j,k)*F_zct1_m(i,j,k)*rz_8
     %                  - F_yct1_m(i,j,k)*F_zct1  (i,j,k)*rz_m_8
     %                  - F_yct1  (i,j,k)*F_zct1_m(i,j,k)*rz_m_8)
     %        + mumu_8 * ( 
     %                    F_xct1_m(i,j,k)*F_ruw2_m(i,j,k)
*
     %                  - F_yct1_m(i,j,k)*F_zct1_m(i,j,k)*rz_m_8)

         rx_8 = 
     %        - mumu_m_8* ( 
     %                    F_yct1_m(i,j,k)*F_ruw2  (i,j,k)
     %                  + F_yct1  (i,j,k)*F_ruw2_m(i,j,k)
*
     %                  + F_xct1_m(i,j,k)*F_zct1_m(i,j,k)*rz_8
     %                  + F_xct1_m(i,j,k)*F_zct1  (i,j,k)*rz_m_8
     %                  + F_xct1  (i,j,k)*F_zct1_m(i,j,k)*rz_m_8)
     %        - mumu_8 * (
     %                    F_yct1_m(i,j,k)*F_ruw2_m(i,j,k)
*
     %                  + F_xct1_m(i,j,k)*F_zct1_m(i,j,k)*rz_m_8)
*
*     Compute components of (r - r~) and put in cx, cy, cz
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*
*        TRAJECTORY
*        ----------
         cx_m_8 = x_8 - F_xct1_m(i,j,k)
         cy_m_8 = y_8 - F_yct1_m(i,j,k)
         cz_m_8 = z_8 - F_zct1_m(i,j,k)
*
*        TLM
*        ---
         cx_8 = - F_xct1(i,j,k)
         cy_8 = - F_yct1(i,j,k)
         cz_8 = - F_zct1(i,j,k)

*     Find components of Coriolis vector  2 * omg/tau * [k' ^ (r - r~)]
*     where geographic unit north vector  k' = r_13 I + r_23 J + r_33 K
*     Then substract them from (rx, ry, rz)
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         if (.not.Cori_cornl_L) then
*
*        TRAJECTORY
*        ----------
         rx_m_8 = rx_m_8 + ( Grd_rot_8(2,3)*cz_m_8 - Grd_rot_8(3,3)*cy_m_8 )*tot_8
         ry_m_8 = ry_m_8 + ( Grd_rot_8(3,3)*cx_m_8 - Grd_rot_8(1,3)*cz_m_8 )*tot_8
         rz_m_8 = rz_m_8 + ( Grd_rot_8(1,3)*cy_m_8 - Grd_rot_8(2,3)*cx_m_8 )*tot_8
*
*        TLM
*        ---
         rx_8 = rx_8 + ( Grd_rot_8(2,3)*cz_8 - Grd_rot_8(3,3)*cy_8 )*tot_8
         ry_8 = ry_8 + ( Grd_rot_8(3,3)*cx_8 - Grd_rot_8(1,3)*cz_8 )*tot_8
         rz_8 = rz_8 + ( Grd_rot_8(1,3)*cy_8 - Grd_rot_8(2,3)*cx_8 )*tot_8
*
         endif
*
*     Compute components of c and put in cx, cy, cz 
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*        TRAJECTORY
*        ----------
         cx_m_8 = x_8 + bbb_8*F_xct1_m(i,j,k)
         cy_m_8 = y_8 + bbb_8*F_yct1_m(i,j,k)
         cz_m_8 = z_8 + bbb_8*F_zct1_m(i,j,k)
*
*        TLM
*        ---
         cx_8 = bbb_8*F_xct1(i,j,k)
         cy_8 = bbb_8*F_yct1(i,j,k)
         cz_8 = bbb_8*F_zct1(i,j,k)
*
*     Compute mu and modify (Rx,Ry,Rz)
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*        TRAJECTORY
*        ----------
         mumu_m_8 = - ( x_8*rx_m_8 + y_8*ry_m_8 + z_8*rz_m_8 )
     %               /( x_8*cx_m_8 + y_8*cy_m_8 + z_8*cz_m_8 )
         rx_m_8 = rx_m_8 + mumu_m_8*cx_m_8
         ry_m_8 = ry_m_8 + mumu_m_8*cy_m_8
         rz_m_8 = rz_m_8 + mumu_m_8*cz_m_8
*
*        TLM 
*        ---
         mumu_8 = 
     %          -   ( x_8*rx_8   + y_8*ry_8   + z_8*rz_8  )
     %             /( x_8*cx_m_8 + y_8*cy_m_8 + z_8*cz_m_8)
     %          + ( ( x_8*rx_m_8 + y_8*ry_m_8 + z_8*rz_m_8)
     %             *( x_8*cx_8   + y_8*cy_8   + z_8*cz_8  ) )
     %             /( x_8*cx_m_8 + y_8*cy_m_8 + z_8*cz_m_8)**2
         rx_8 = rx_8 + mumu_m_8*cx_8 + mumu_8*cx_m_8
         ry_8 = ry_8 + mumu_m_8*cy_8 + mumu_8*cy_m_8
         rz_8 = rz_8 + mumu_m_8*cz_8 + mumu_8*cz_m_8
*
*     Compute advective contributions on G-grid 
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*        TRAJECTORY
*        ----------
         F_ruw2_m(i,j,k) = x_8*ry_m_8 - y_8*rx_m_8 - F_ruw1_m(i,j,k)
         F_rvw2_m(i,j,k) = rz_m_8 - F_rvw1_m(i,j,k)
*
*        TLM 
*        ---
         F_ruw2(i,j,k) = x_8*ry_8 - y_8*rx_8 - F_ruw1(i,j,k)
         F_rvw2(i,j,k) = rz_8 - F_rvw1(i,j,k)
         
100   continue 
!$omp enddo

**********************************************************
* Final form of the RHS of horizontal momentum equations *
**********************************************************
*
!$omp single
*     TRAJECTORY
*     ----------
      call rpn_comm_xch_halo( F_fis , LDIST_DIM, l_ni,l_nj,  1 ,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo( F_ruw2_m,LDIST_DIM, l_ni,l_nj,G_nk,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo( F_rvw2_m,LDIST_DIM, l_ni, l_nj,G_nk,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
*
*     TLM
*     ---
      call rpn_comm_xch_halo( F_ruw2, LDIST_DIM, l_ni,l_nj,G_nk,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo( F_rvw2, LDIST_DIM, l_ni, l_nj,G_nk,
     $              G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
*
*     CONSTANT
*     --------
      i0 = 1
      in = l_niu
      j0 = 1+pil_s
      jn = l_nj-pil_n
      if (G_lam) then
         if (l_west)  i0=1+pil_w
         if (l_east)  in=l_niu-pil_e
      endif
      j00 = 1
      jnn = l_njv
      i00 = 1+pil_w
      inn = l_ni-pil_e
      if (G_lam) then
         if (l_south) j00 = 1+pil_s
         if (l_north) jnn = l_njv-pil_n
      else
         if (l_south) j00 = 2
         if (l_north) jnn = l_njv-1
      endif
!$omp end single
*
!$omp do
      do k=k0,l_nk
*
*     Add advective contributions to Ru & Rv
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         do j= j0, jn
         do i= i0, in
*
*           TRAJECTORY
*           ----------
            F_ru_m(i,j,k) =  F_oru_m(i,j,k) + 
     $                   inuvl_wxxu3_8(i,1)*F_ruw2_m(i-1,j,k)
     $                 + inuvl_wxxu3_8(i,2)*F_ruw2_m(i  ,j,k)
     $                 + inuvl_wxxu3_8(i,3)*F_ruw2_m(i+1,j,k)
     $                 + inuvl_wxxu3_8(i,4)*F_ruw2_m(i+2,j,k)
*
*           TLM 
*           ---
            F_ru(i,j,k) =  F_oru(i,j,k) + 
     $                   inuvl_wxxu3_8(i,1)*F_ruw2(i-1,j,k)
     $                 + inuvl_wxxu3_8(i,2)*F_ruw2(i  ,j,k)
     $                 + inuvl_wxxu3_8(i,3)*F_ruw2(i+1,j,k)
     $                 + inuvl_wxxu3_8(i,4)*F_ruw2(i+2,j,k)
         end do
         end do
*
         do j= j00, jnn
         do i= i00, inn
*
*           TRAJECTORY
*           ----------
            F_rv_m(i,j,k) =  F_orv_m(i,j,k) +
     $                   inuvl_wyyv3_8(j,1)*F_rvw2_m(i,j-1,k)
     $                 + inuvl_wyyv3_8(j,2)*F_rvw2_m(i,j  ,k)
     $                 + inuvl_wyyv3_8(j,3)*F_rvw2_m(i,j+1,k)
     $                 + inuvl_wyyv3_8(j,4)*F_rvw2_m(i,j+2,k)
*
*           TLM 
*           ---
            F_rv(i,j,k) =  F_orv(i,j,k) +
     $                   inuvl_wyyv3_8(j,1)*F_rvw2(i,j-1,k)
     $                 + inuvl_wyyv3_8(j,2)*F_rvw2(i,j  ,k)
     $                 + inuvl_wyyv3_8(j,3)*F_rvw2(i,j+1,k)
     $                 + inuvl_wyyv3_8(j,4)*F_rvw2(i,j+2,k)
         end do
         end do
         if (.not.G_lam) then
            if (l_south) then
            do i = 1, l_ni
*           TRAJECTORY
*           ----------
            F_rv_m(i,1,k) = F_orv_m(i,1,k) + 
     $                  inuvl_wyyv3_8(1,2)*F_rvw2_m(i,1,k)
     $                + inuvl_wyyv3_8(1,3)*F_rvw2_m(i,2,k)
     $                + inuvl_wyyv3_8(1,4)*F_rvw2_m(i,3,k)
*
*           TLM 
*           ---
            F_rv(i,1,k) = F_orv(i,1,k)  +
     $                  inuvl_wyyv3_8(1,2)*F_rvw2(i,1,k)
     $                + inuvl_wyyv3_8(1,3)*F_rvw2(i,2,k)
     $                + inuvl_wyyv3_8(1,4)*F_rvw2(i,3,k)
            end do
            endif
            if (l_north) then
            do i = 1, l_ni
*           TRAJECTORY
*           ----------
            F_rv_m(i,l_njv,k) = F_orv_m(i,l_njv,k) + 
     $                      inuvl_wyyv3_8(l_njv,1)*F_rvw2_m(i,l_njv-1,k)
     $                    + inuvl_wyyv3_8(l_njv,2)*F_rvw2_m(i,l_njv  ,k)
     $                    + inuvl_wyyv3_8(l_njv,3)*F_rvw2_m(i,l_njv+1,k)
*
*           TLM 
*           ---
            F_rv(i,l_njv,k) = F_orv(i,l_njv,k) +
     $                      inuvl_wyyv3_8(l_njv,1)*F_rvw2(i,l_njv-1,k)
     $                    + inuvl_wyyv3_8(l_njv,2)*F_rvw2(i,l_njv  ,k)
     $                    + inuvl_wyyv3_8(l_njv,3)*F_rvw2(i,l_njv+1,k)
            end do
            endif
         endif

      end do
!$omp enddo
*
*******************************************
* N.B. OPENTOP BOUNDARY CONDITION:        *
* Top temperature is externally specified *
*******************************************
*
      if (Schm_opentop_L) then
         do j= 1+pil_s, l_nj-pil_n
         do i= 1+pil_w, l_ni-pil_e
*
*           TRAJECTORY
*           ---------- 
            F_rb_m(i,j) = F_rt_m(i,j,k0)
            Ttop_m(i,j) = F_nest_t_m(i,j,k0)
*
*           TLM
*           --- 
            F_rb(i,j) = F_rt(i,j,k0)
            Ttop(i,j) = F_nest_t(i,j,k0)
*
         end do
         end do
      else
         do j= 1+pil_s, l_nj-pil_n
         do i= 1+pil_w, l_ni-pil_e
*
*           TRAJECTORY
*           ---------- 
            F_rb_m(i,j) = 0.0
            Ttop_m(i,j) = 0.0
*
*           TLM
*           ---
            F_rb(i,j) = 0.0
            Ttop(i,j) = 0.0
*
         end do
         end do
      endif
*
**************************************
* Combination of governing equations * 
**************************************
!$omp single
*
      a1_8 = Dcst_cappa_8 / Cstv_RTstr_8
      a2_8 = Ver_epsilon_8 / Cstv_RTstr_8
      a3_8 = ONE_8 / ( Cstv_tau_8*Cstv_tauT_8 * Cstv_RTstr_8 )
                         a4_8 = 0.d0
      if(Schm_autobar_L) a4_8 = a3_8/(Cstv_Zsrf_8-Cstv_Ztop_8)
*
      b1_8 = ONE_8 / ( Dcst_grav_8 * Cstv_tauT_8 )
      b2_8 = Ver_gamma_8 / ( Dcst_cappa_8 * Cstv_tau_8 )
      b4_8 = ONE_8 / ( Dcst_cappa_8 * Cstv_tau_8 )
      b5_8 = ONE_8 / ( Dcst_cappa_8 * Cstv_tau_8*Cstv_tauT_8*Cstv_Tstr_8 )
*
*     TRAJECTORY
*     ----------
      call rpn_comm_xch_halo( F_ru_m,LDIST_DIM,l_niu,l_nj,G_nk,
     $             G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
      call rpn_comm_xch_halo( F_rv_m,LDIST_DIM,l_ni,l_njv,G_nk,
     $             G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
*
*     TLM
*     ---
      call rpn_comm_xch_halo( F_ru, LDIST_DIM,l_niu,l_nj,G_nk,
     $             G_halox,G_haloy,G_periodx,G_periody,l_ni,0 ) 
      call rpn_comm_xch_halo( F_rv, LDIST_DIM,l_ni,l_njv,G_nk,
     $             G_halox,G_haloy,G_periodx,G_periody,l_ni,0 )
!$omp end single
*
!$omp do
      do k=k0,l_nk
*
         if(.not.Schm_hydro_L) then
*           Combining continuity & w equations
*           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_ni-pil_e
*
*              TRAJECTORY
*              ----------
               F_rc_m(i,j,k) = F_rc_m(i,j,k) - b1_8 *
     $                          ( Ver_wp_8%m(k) * F_rw_m(i,j,k+1)
     $                          + Ver_wm_8%m(k) * F_rw_m(i,j,k  ) )
*
*              TLM
*              ---
               F_rc(i,j,k) = F_rc(i,j,k) - b1_8 *
     $                          ( Ver_wp_8%m(k) * F_rw(i,j,k+1)
     $                          + Ver_wm_8%m(k) * F_rw(i,j,k  ) )
*
            end do
            end do
         endif
*
*        Computing the divergence of the RHS of momentum equations
*        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         if (G_lam) then
             do j= 1+pil_s, l_nj-pil_n
             do i= 1+pil_w, l_ni-pil_e
*
*               TRAJECTORY
*               ----------
                rdiv_m(i,j) = ( F_ru_m(i,j,k) - F_ru_m(i-1,j,k) )
     $                        / ( Geomg_cy2_8(j)*Geomg_hxu_8(i-1) )
     $                    + ( F_rv_m(i,j,k) - F_rv_m(i,j-1,k) )
     $                        * Geomg_invhsyv_8(j-1)
*
*               TLM 
*               ---
                rdiv(i,j) = ( F_ru(i,j,k) - F_ru(i-1,j,k) )
     $                        / ( Geomg_cy2_8(j)*Geomg_hxu_8(i-1) )
     $                    + ( F_rv(i,j,k) - F_rv(i,j-1,k) )
     $                        * Geomg_invhsyv_8(j-1)
*
             end do
             end do
         else
*
*            TRAJECTORY
*            ----------
             call caldiv_2 ( rdiv_m(minx,miny), F_ru_m(minx,miny,k),
     $                                          F_rv_m(minx,miny,k), LDIST_DIM, 1)
*            TLM 
*            ---
             call caldiv_2 ( rdiv(minx,miny), F_ru(minx,miny,k),
     $                                        F_rv(minx,miny,k), LDIST_DIM, 1)
*
         endif
*
*        Combining divergence & continuity equations : Rc'
*        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         do j= 1+pil_s, l_nj-pil_n
         do i= 1+pil_w, l_ni-pil_e
*
*           TRAJECTORY
*           ----------
            F_rc_m(i,j,k) = rdiv_m(i,j) - F_rc_m(i,j,k) / Cstv_tau_8
*
*           TLM 
*           ---
            F_rc(i,j,k) = rdiv(i,j) - F_rc(i,j,k) / Cstv_tau_8
*
         end do
         end do
*
      end do
!$omp enddo
*
!$omp do
      do k=k0,l_nk+1
*
*        Computing Rt" & Rf"
*        ~~~~~~~~~~~~~~~~~~~
*
         if (.not. Schm_hydro_L) then
*           Combining Rt and Rw
*           ~~~~~~~~~~~~~~~~~~~
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_ni-pil_e
*
*              TRAJECTORY
*              ---------- 
               F_rt_m(i,j,k) = F_rt_m(i,j,k) + b1_8 * F_rw_m(i,j,k)
*
*              TLM
*              --- 
               F_rt(i,j,k) = F_rt(i,j,k) + b1_8 * F_rw(i,j,k)
*
            end do
            end do
         endif
*
         do j= 1+pil_s, l_nj-pil_n
         do i= 1+pil_w, l_ni-pil_e
*
*           TRAJECTORY and TLM
*           ------------------ 
*
            w_rt        = F_rt  (i,j,k)
            w_rt_m      = F_rt_m(i,j,k)
*
*           Computing Rt"
*           ~~~~~~~~~~~~~
            F_rt  (i,j,k) = b2_8 * ( w_rt   + a2_8 * F_rf  (i,j,k) )
            F_rt_m(i,j,k) = b2_8 * ( w_rt_m + a2_8 * F_rf_m(i,j,k) )
*
*           Computing Rf"
*           ~~~~~~~~~~~~~
            F_rf  (i,j,k) = b2_8 * ( w_rt   - a1_8 * F_rf  (i,j,k) )
            F_rf_m(i,j,k) = b2_8 * ( w_rt_m - a1_8 * F_rf_m(i,j,k) )
*
         end do
         end do
*
      enddo
!$omp enddo
*
*************************************************************
* The linear contributions to the RHS of Helmholtz equation *
*************************************************************
*
*     Finish computations of RP(Rc"), combining Rc', Rt", Rf"
*     and applying boundary conditions
*
!$omp do
      do k=k0,l_nk
         xxx_8=ONE_8 + Ver_dz_8%m(k) * Ver_wp_8%m(k)
         yyy_8=ONE_8 - Ver_dz_8%m(k) * Ver_wm_8%m(k)
         do j= 1+pil_s, l_nj-pil_n
         do i= 1+pil_w, l_ni-pil_e
*
*           TRAJECTORY
*           ----------
            F_rc_m(i,j,k) = Ver_dz_8%m(k) * ( F_rc_m(i,j,k) - a4_8 * F_fis(i,j) )
     $                      - xxx_8 * F_rt_m(i,j,k+1) + yyy_8 * F_rt_m(i,j,k)
*
*           TLM 
*           ---
            F_rc(i,j,k) = Ver_dz_8%m(k) * ( F_rc(i,j,k) )
     $                    - xxx_8 * F_rt(i,j,k+1) + yyy_8 * F_rt(i,j,k)
*
         end do
         end do
         if (.not. Schm_hydro_L) then
            zzz_8=Ver_dz_8%m(k) * Ver_epsilon_8
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_ni-pil_e
*
*              TRAJECTORY
*              ----------
               F_rc_m(i,j,k) = F_rc_m(i,j,k) - zzz_8 *
     $                          ( Ver_wp_8%m(k) * F_rf_m(i,j,k+1)
     $                          + Ver_wm_8%m(k) * F_rf_m(i,j,k  ) )
*
*              TLM 
*              ---
               F_rc(i,j,k) = F_rc(i,j,k) - zzz_8 *
     $                          ( Ver_wp_8%m(k) * F_rf(i,j,k+1)
     $                          + Ver_wm_8%m(k) * F_rf(i,j,k  ) )
*
            end do
            end do
         endif
      end do
!$omp enddo
*
*     Applying boundary conditions.
*
!$omp do
      do j= 1+pil_s, l_nj-pil_n
      do i= 1+pil_w, l_ni-pil_e
*
*        TRAJECTORY
*        ----------
         F_rb_m(i,j)        = F_rt_m(i,j,k0)-b4_8*F_rb_m(i,j)+ b5_8*Ttop_m(i,j)
         F_rc_m(i,j,k0)     = F_rc_m(i,j,k0) - Ver_cstp_8 * F_rb_m(i,j)
         F_rt_m(i,j,l_nk+1) = F_rt_m(i,j,l_nk+1) - a3_8 * F_fis(i,j)
         F_rc_m(i,j,l_nk)   = F_rc_m(i,j,l_nk) + Ver_cssp_8 * F_rt_m(i,j,l_nk+1)
*
*        TLM 
*        ---
         F_rb(i,j)        = F_rt(i,j,k0)-b4_8*F_rb(i,j)+ b5_8*Ttop(i,j)
         F_rc(i,j,k0)     = F_rc(i,j,k0) - Ver_cstp_8 * F_rb(i,j)
         F_rt(i,j,l_nk+1) = F_rt(i,j,l_nk+1) 
         F_rc(i,j,l_nk)   = F_rc(i,j,l_nk) + Ver_cssp_8 * F_rt(i,j,l_nk+1)
*
      end do
      end do
!$omp enddo
*
!$omp end parallel
*
*     __________________________________________________________________
*
      return
      end
