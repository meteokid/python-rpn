!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------

subroutine adx_trilin2_tl()
   call stop_mpi(STOP_ERROR,'adx_trilin2_tl','called a stub')
   return
end subroutine adx_trilin2_tl

!/**
subroutine adx_trilin3_tl(F_out   , F_in    , &
                          F_capx  , F_capy  , F_capz  , & 
                          F_out_m , F_in_m  , F_dt    , F_n_m, &
                          F_capx_m, F_capy_m, F_capz_m, i0,in,j0,jn, &
                          F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,F_nk, F_nk_super)

   !@objective TLM of adx_trilin3 
   implicit none
   !@arguments
   integer :: F_nk, F_nk_super  !I, number of vertical levels
   integer :: F_aminx, F_amaxx, F_aminy, F_amaxy !I, input field array bounds
   integer :: F_ni, F_nj        !I, dims of output field
   integer :: i0, in, j0, jn    !I, scope ofthe operator
   real,dimension(F_ni,F_nj,F_nk) :: &
        F_capx  , F_capy  , F_capz  , &  !I, precomputed displacements along x,y,z
        F_capx_m, F_capy_m, F_capz_m     !I, precomputed displacements along x,y,z TRAJ
   integer,dimension(F_ni,F_nj,F_nk) :: &
        F_n_m                   !I, pos in the 3D volume of interpolation boxes TRAJ
   real    :: F_dt              !I, multiplicative constant (1. or timestep)
   real,dimension(F_aminx:F_amaxx,F_aminy:F_amaxy,F_nk_super)::&
        F_in , &                !I, field to interpolate
        F_in_m                  !I, field to interpolate TRAJ
   real,dimension(F_ni,F_nj,F_nk) :: &
        F_out, &                !O, F_dt * result of interpolation
        F_out_m                 !O, F_dt * result of interpolation TRAJ
   !@author monique tanguay
   !@revisions
   ! v4_XX - Tanguay M.        - Adjustments GEM413
!**/
#include "adx_dims.cdk"
   integer :: i, j, k, nit, njt, i2,j2,k2,ij2
   real*8  :: capx_8,capy_8,capz_8,capx_m_8,capy_m_8,capz_m_8, &
              prf1_8,prf2_8,prf3_8,prf4_8,prf1_m_8,prf2_m_8,prf3_m_8,prf4_m_8, &
              prf1_y_8,prf2_y_8,prf1_y_m_8,prf2_y_m_8

#define INT_LIN_I48(F3D4,AA8,II,JJ,KK) ((1.D0-AA8)*dble(F3D4(II,JJ,KK)) + AA8*dble(F3D4(II+1,JJ,KK)))
#define INT_LIN_I48_tl(F3D4,AA8,F3D4_M,AA8_M,II,JJ,KK) ( (1.D0-AA8_M)*dble(F3D4(II,JJ,KK))+AA8_M*dble(F3D4(II+1,JJ,KK))+(-AA8)*dble(F3D4_M(II,JJ,KK))+AA8*dble(F3D4_M(II+1,JJ,KK)) )
#define INT_LIN_IJ48(F3D4,AX8,AY8,II,JJ,KK) ((1.D0-AY8)*INT_LIN_I48(F3D4,AX8,II,JJ,KK) + AY8*INT_LIN_I48(F3D4,AX8,II,JJ+1,KK))
#define INT_LIN_IJ48_tl(F3D4,AX8,AY8,F3D4_M,AX8_M,AY8_M,II,JJ,KK) ( (1.D0-AY8_M)*INT_LIN_I48_tl(F3D4,AX8,F3D4_M,AX8_M,II,JJ,KK)+AY8_M*INT_LIN_I48_tl(F3D4,AX8,F3D4_M,AX8_M,II,JJ+1,KK)+(-AY8)*INT_LIN_I48(F3D4_M,AX8_M,II,JJ,KK)+AY8*INT_LIN_I48(F3D4_M,AX8_M,II,JJ+1,KK) )
#define INT_LIN_IJK48(F3D4,AX8,AY8,AZ8,II,JJ,KK) ((1.D0-AZ8)*INT_LIN_IJ48(F3D4,AX8,AY8,II,JJ,KK) + AZ8*INT_LIN_IJ48(F3D4,AX8,AY8,II,JJ,KK+1))
#define INT_LIN_IJK48_tl(F3D4,AX8,AY8,AZ8,F3D4_M,AX8_M,AY8_M,AZ8_M,II,JJ,KK) ( (1.D0-AZ8_M)*INT_LIN_IJ48_tl(F3D4,AX8,AY8,F3D4_M,AX8_M,AY8_M,II,JJ,KK)+AZ8_M*INT_LIN_IJ48_tl(F3D4,AX8,AY8,F3D4_M,AX8_M,AY8_M,II,JJ,KK+1)+(-AZ8)*INT_LIN_IJ48(F3D4_M,AX8_M,AY8_M,II,JJ,KK)+AZ8*INT_LIN_IJ48(F3D4_M,AX8_M,AY8_M,II,JJ,KK+1)  )
   !---------------------------------------------------------------------
   nit = adx_lmaxx - adx_lminx + 1
   njt = adx_lmaxy - adx_lminy + 1

   do k=1,F_nk
      do j=j0,jn
         do i=i0,in

            !TRAJECTORY
            !----------
            k2  = 1 + F_n_m(i,j,k)/(nit*njt)
            ij2 = F_n_m(i,j,k) - (k2-1)*nit*njt

            !- lmin shift needed since indexes are computed with array starting at 1
            j2  = 1   + ij2/nit
            i2  = ij2 - (j2-1)*nit + (adx_lminx-1)
            j2  = j2 + (adx_lminy-1)

            !- ---------------
            !- x interpolation 
            !- ---------------
            capx_m_8 = dble(F_capx_m(i,j,k)) 
            capx_8   = dble(F_capx  (i,j,k)) 
  
            prf1_m_8 = (1.0 - capx_m_8) * dble(F_in_m(i2,j2  ,k2  )) + capx_m_8 * dble(F_in_m(i2+1,j2  ,k2  ))
            prf1_8   = (1.0 - capx_m_8) * dble(F_in  (i2,j2  ,k2  )) + capx_m_8 * dble(F_in  (i2+1,j2  ,k2  )) + & 
                       (    - capx_8  ) * dble(F_in_m(i2,j2  ,k2  )) + capx_8   * dble(F_in_m(i2+1,j2  ,k2  ))  
 
            prf2_m_8 = (1.0 - capx_m_8) * dble(F_in_m(i2,j2+1,k2  )) + capx_m_8 * dble(F_in_m(i2+1,j2+1,k2  ))
            prf2_8   = (1.0 - capx_m_8) * dble(F_in  (i2,j2+1,k2  )) + capx_m_8 * dble(F_in  (i2+1,j2+1,k2  )) + & 
                       (    - capx_8  ) * dble(F_in_m(i2,j2+1,k2  )) + capx_8   * dble(F_in_m(i2+1,j2+1,k2  ))  

            prf3_m_8 = (1.0 - capx_m_8) * dble(F_in_m(i2,j2  ,k2+1)) + capx_m_8 * dble(F_in_m(i2+1,j2  ,k2+1))
            prf3_8   = (1.0 - capx_m_8) * dble(F_in  (i2,j2  ,k2+1)) + capx_m_8 * dble(F_in  (i2+1,j2  ,k2+1)) + &
                       (    - capx_8  ) * dble(F_in_m(i2,j2  ,k2+1)) + capx_8   * dble(F_in_m(i2+1,j2  ,k2+1))
   
            prf4_m_8 = (1.0 - capx_m_8) * dble(F_in_m(i2,j2+1,k2+1)) + capx_m_8 * dble(F_in_m(i2+1,j2+1,k2+1))
            prf4_8   = (1.0 - capx_m_8) * dble(F_in  (i2,j2+1,k2+1)) + capx_m_8 * dble(F_in  (i2+1,j2+1,k2+1)) + &
                       (    - capx_8  ) * dble(F_in_m(i2,j2+1,k2+1)) + capx_8   * dble(F_in_m(i2+1,j2+1,k2+1))
  
            !- y interpolation 
            !- ---------------
            capy_m_8 = dble(F_capy_m(i,j,k)) 
            capy_8   = dble(F_capy  (i,j,k)) 
 
            prf1_y_m_8 = (1.0 - capy_m_8) * prf1_m_8 + capy_m_8 * prf2_m_8
            prf1_y_8   = (1.0 - capy_m_8) * prf1_8   + capy_m_8 * prf2_8   + &
                         (    - capy_8  ) * prf1_m_8 + capy_8   * prf2_m_8
  
            prf2_y_m_8 = (1.0 - capy_m_8) * prf3_m_8 + capy_m_8 * prf4_m_8
            prf2_y_8   = (1.0 - capy_m_8) * prf3_8   + capy_m_8 * prf4_8   + &
                         (    - capy_8  ) * prf3_m_8 + capy_8   * prf4_m_8
  
            !- z interpolation 
            !- ---------------
            capz_m_8 = dble(F_capz_m(i,j,k)) 
            capz_8   = dble(F_capz  (i,j,k)) 
  
            F_out_m(i,j,k) = ( (1.0 - capz_m_8) * prf1_y_m_8 + capz_m_8  * prf2_y_m_8 ) * F_dt
            F_out  (i,j,k) = ( (1.0 - capz_m_8) * prf1_y_8   + capz_m_8  * prf2_y_8   + & 
                               (    - capz_8  ) * prf1_y_m_8 + capz_8    * prf2_y_m_8 ) * F_dt
         enddo
      enddo
   enddo
   !---------------------------------------------------------------------
   return
end subroutine adx_trilin3_tl
