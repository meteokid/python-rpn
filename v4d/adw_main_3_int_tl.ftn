! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r adw_main_3_int_tl - TLM of adw_main_3_int when Adw_lag3d_L=.TRUE. 
*
#include "model_macros_f.h"
*
      subroutine adw_main_3_int_tl ( F_u, F_v, F_w, F_u_m, F_v_m, F_w_m )
*
      implicit none
      real F_u  (*),F_v  (*),F_w  (*)
      real F_u_m(*),F_v_m(*),F_w_m(*)
*
*author
*     monique tanguay
*
*revision
* v2_31 - Tanguay M.        - initial MPI version
* v3_00 - Tanguay M.        - adapt to restructured adw_main 
* v3_02 - Tanguay M.        - restore tracers monotone if V4dg_conf.ne.0
* v3_03 - Tanguay M.        - Adjoint NoHyd configuration 
* v3_11 - Tanguay M.        - introduce key Adw_mono_L
* v3_20 - Tanguay M.        - Lagrange 3D
* v3_21 - Tanguay M.        - Call adw_main_3_intlag_tl based on Adw_lag3d_L
* v3_30 - Tanguay M.        - correct calculation for LAM when Glb_pil gt 7 
* v4_04 - Tanguay M.        - Staggered version TL/AD 
* v4_10 - Tanguay M.        - VMM replacement with GMM for (TL/AD)
*
*language
*     fortran 77
*
*object
*     see id section
*
*     CAUTION: WUP-ZZ1-ZDUP not done
*
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
*        |                                                       |     |
*        |                                                       |     |
* F_u,F_v| 3 components of upstream positions at t1 at input     |  iw |
* F_w    | used as work field afterward                          |     |
*________|_______________________________________________________|_____|
*
*implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "ptopo.cdk"
#include "geomg.cdk"
#include "orh.cdk"
#include "lctl.cdk"
#include "step.cdk"
#include "lun.cdk"
#include "schm.cdk"
#include "offc.cdk"
#include "cstv.cdk"
#include "rhsc.cdk"
#include "v4dg.cdk"
#include "type.cdk"
#include "adw.cdk"
#include "tr3d.cdk"
#include "vt1.cdk"
#include "vt0.cdk"
#include "ver.cdk"
#include "orh_m.cdk"
#include "rhsc_m.cdk"
#include "adw_m.cdk"
#include "vt1_m.cdk"
#include "vt0_m.cdk"
*
************************************************************************
      integer i0,in,j0,jn,err
*
      integer n, nij, nijkt, nijkm, nijkad, cnt, unf
      integer i,j,k
*
      integer DIST_DIM
*
      real*8 aaa_8
*
      real, allocatable, dimension(:) :: pos_x, pos_y, pos_z
      real, allocatable, dimension(:) :: pos_x_m, pos_y_m, pos_z_m
      real, pointer    , dimension(:,:,:) :: tr0,tr1,tr0_m,tr1_m
*
      real work(LDIST_SHAPE,l_nk+1)
*
************************************************************************
*
      if (Schm_zdotMid_L) call gem_stop('adw_main_3_intlag_TL : Schm_zdotMid_L not DONE',-1)
      if (Schm_zdotlag_L) call gem_stop('adw_main_3_intlag_TL : Schm_zdotlag_L not DONE',-1)
*
      if (Lun_debug_L) write (Lun_out,1000)
*
      nij    = l_ni   *l_nj
      nijkt  = l_ni   *l_nj   *(l_nk+1)
      nijkm  = l_ni   *l_nj   * l_nk
      nijkad = Adw_nit*Adw_njt*(l_nk+1)
      call hpalloc(Adw_capx1_   ,nijkt,      err,1)
      call hpalloc(Adw_capy1_   ,nijkt,      err,1)
      call hpalloc(Adw_capz1_   ,nijkt,      err,1)
      call hpalloc(Adw_n1_      ,nijkt,      err,1)
      call hpalloc(Adw_xdd1_    ,nijkt,      err,1)
      call hpalloc(Adw_xgg1_    ,nijkt,      err,1)
      call hpalloc(Adw_ydd1_    ,nijkt,      err,1)
      call hpalloc(Adw_ygg1_    ,nijkt,      err,1)
      call hpalloc(Adw_cz1_     ,nijkt,      err,1)
      call hpalloc(Adw_c1_      ,nijkt,      err,1)
      call hpalloc(Adw_wrkb_    ,nijkt,      err,1)
      call hpalloc(Adw_wrkc_    ,nijkt,      err,1)
*
      allocate ( pos_x(nijkad) )
      allocate ( pos_y(nijkad) )
      allocate ( pos_z(nijkad) )
*
*     TRAJECTORY
*     ----------
      call hpalloc(Adw_capx1_m_ ,nijkt,      err,1)
      call hpalloc(Adw_capy1_m_ ,nijkt,      err,1)
      call hpalloc(Adw_capz1_m_ ,nijkt,      err,1)
      call hpalloc(Adw_n1_m_    ,nijkt,      err,1)
      call hpalloc(Adw_xdd1_m_  ,nijkt,      err,1)
      call hpalloc(Adw_xgg1_m_  ,nijkt,      err,1)
      call hpalloc(Adw_ydd1_m_  ,nijkt,      err,1)
      call hpalloc(Adw_ygg1_m_  ,nijkt,      err,1)
      call hpalloc(Adw_cz1_m_   ,nijkt,      err,1)
      call hpalloc(Adw_c1_m_    ,nijkt,      err,1)
      call hpalloc(Adw_wrkb_m_  ,nijkt,      err,1)
      call hpalloc(Adw_wrkc_m_  ,nijkt,      err,1)
*
      allocate ( pos_x_m(nijkad) )
      allocate ( pos_y_m(nijkad) )
      allocate ( pos_z_m(nijkad) )
*
      pos_x_m = 0.
      pos_y_m = 0.
      pos_z_m = 0.
*
************************************************************************
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west)  i0=pil_w
          if (l_east)  in=l_niu - pil_e + 2
          if (l_south) j0=pil_s
          if (l_north) jn=l_njv - pil_n + 2
      endif
*
***********************************************************************
* Prepare for advection on momentum levels
***********************************************************************
!
C!$omp parallel do private(n)
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
*        TRAJECTORY
*        ----------
         pos_x_m(n) =  F_u_m(n)
         pos_y_m(n) =  F_v_m(n)
         pos_z_m(n) =  F_w_m(n)
*
*        TLM
*        ---
         pos_x(n) =  F_u(n)
         pos_y(n) =  F_v(n)
         pos_z(n) =  F_w(n)
*
      enddo
      enddo
      enddo
C!$omp end parallel do
*
      if (G_lam) 
     %    call adw_cliptraj_tl (pos_x, pos_y, pos_x_m, pos_y_m, i0, in, j0, jn, l_nk, 'INT_MT_TL') 
*
***********************************************************************
* Perform interpolation on momentum levels
***********************************************************************
      gmmstat = gmm_get(gmmk_ruw1_s,ruw1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(ruw1)'
      gmmstat = gmm_get(gmmk_rvw1_s,rvw1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rvw1)'
      gmmstat = gmm_get(gmmk_ruw2_s,ruw2,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(ruw2)'
      gmmstat = gmm_get(gmmk_rvw2_s,rvw2,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rvw2)'
      gmmstat = gmm_get(gmmk_rhsc_s,rhsc,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rhsc)'
      gmmstat = gmm_get(gmmk_orhsc_s,orhsc,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(orhsc)'
*
*     TRAJECTORY
*     ----------
      gmmstat = gmm_get(gmmk_ruw1_m_s,ruw1_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(ruw1_m)'
      gmmstat = gmm_get(gmmk_rvw1_m_s,rvw1_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rvw1_m)'
      gmmstat = gmm_get(gmmk_ruw2_m_s,ruw2_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(ruw2_m)'
      gmmstat = gmm_get(gmmk_rvw2_m_s,rvw2_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rvw2_m)'
      gmmstat = gmm_get(gmmk_rhsc_m_s,rhsc_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rhsc_m)'
      gmmstat = gmm_get(gmmk_orhsc_m_s,orhsc_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(orhsc_m)'
*
*     ----------------------------
*     Keep positions in CAP fields
*     ----------------------------
C!$omp parallel private(n)
*
C!$omp do 
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
*        TRAJECTORY
*        ----------
         Adw_capx1_m(n) = pos_x_m(n)
         Adw_capy1_m(n) = pos_y_m(n)
         Adw_capz1_m(n) = pos_z_m(n)
*
*        TLM
*        ---
         Adw_capx1(n) = pos_x(n)
         Adw_capy1(n) = pos_y(n)
         Adw_capz1(n) = pos_z(n)
*
      end do
      end do
      end do
C!$omp end do
*
      call adw_interp2_tl (ruw2,  ruw1,  pos_x,  pos_y,
     %                     ruw2_m,ruw1_m,pos_x_m,pos_y_m,
     %                     .true., .false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
      call adw_interp2_tl (rvw2,  rvw1,  pos_x,  pos_y, 
     %                     rvw2_m,rvw1_m,pos_x_m,pos_y_m,
     %                     .true., .false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
      call adw_interp2_tl (rhsc,  orhsc,  pos_x,  pos_y, 
     %                     rhsc_m,orhsc_m,pos_x_m,pos_y_m,
     %                     .false.,.false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
C!$omp end parallel
*
***********************************************************************
* Prepare for advection on thermodynamic levels
***********************************************************************
*     From upstream position for momentum levels to upstream
*     position for thermodynamic levels
*
      call adw_meanpos_tl (pos_x,  pos_y,  pos_z,  F_u,  F_v,  F_w, 
     %                     pos_x_m,pos_y_m,pos_z_m,F_u_m,F_v_m,F_w_m,
     %                     i0,in,j0,jn)
*
      if (G_lam) 
     %    call adw_cliptraj_tl (pos_x, pos_y, pos_x_m, pos_y_m, i0, in, j0, jn, l_nk+1, 'INT_TH_TL')
*
***********************************************************************
* Perform interpolation for equations on thermodynamic levels
***********************************************************************
      gmmstat = gmm_get(gmmk_rhst_s,rhst,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rhst)'
      gmmstat = gmm_get(gmmk_rhsf_s,rhsf,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rhsf)'
      gmmstat = gmm_get(gmmk_orhst_s,orhst,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(orhst)'
      gmmstat = gmm_get(gmmk_orhsf_s,orhsf,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(orhsf)'
      if (.not. Schm_hydro_L) then
         gmmstat = gmm_get(gmmk_rhsw_s,rhsw,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rhsw)'
         gmmstat = gmm_get(gmmk_orhsw_s,orhsw,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(orhsw)'
      endif
*
*     TRAJECTORY
*     ----------
      gmmstat = gmm_get(gmmk_rhst_m_s,rhst_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rhst_m)'
      gmmstat = gmm_get(gmmk_rhsf_m_s,rhsf_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rhsf_m)'
      gmmstat = gmm_get(gmmk_orhst_m_s,orhst_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(orhst_m)'
      gmmstat = gmm_get(gmmk_orhsf_m_s,orhsf_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(orhsf_m)'
      if (.not. Schm_hydro_L) then
         gmmstat = gmm_get(gmmk_rhsw_m_s,rhsw_m,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(rhsw_m)'
         gmmstat = gmm_get(gmmk_orhsw_m_s,orhsw_m,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_3_int_tl ERROR at gmm_get(orhsw_m)'
      endif
*
*     ----------------------------
*     Keep positions in CAP fields
*     ----------------------------
C!$omp parallel private(n)
C!$omp do
      do k=1,l_nk+1
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
*        TRAJECTORY
*        ----------
         Adw_capx1_m(n) = pos_x_m(n)
         Adw_capy1_m(n) = pos_y_m(n)
         Adw_capz1_m(n) = pos_z_m(n)
*
*        TLM
*        ---
         Adw_capx1(n) = pos_x(n)
         Adw_capy1(n) = pos_y(n)
         Adw_capz1(n) = pos_z(n)
*
      end do
      end do
      end do
C!$omp enddo
*
      call adw_interp2_tl (rhst,  orhst,  pos_x,  pos_y,
     %                     rhst_m,orhst_m,pos_x_m,pos_y_m,
     %                     .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
      call adw_interp2_tl (rhsf,  orhsf,  pos_x,  pos_y,
     %                     rhsf_m,orhsf_m,pos_x_m,pos_y_m,
     %                     .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
      if (.not. Schm_hydro_L) then
          call adw_interp2_tl (rhsw,  orhsw,  pos_x,  pos_y,
     %                         rhsw_m,orhsw_m,pos_x_m,pos_y_m,
     %                         .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
      endif
*
C!$omp end parallel
*
      if ( (Orh_icn .eq. Schm_itcn) .and. (Tr3d_ntr.gt.0) ) then
*
* Tr3d advection
*
         aaa_8 = -1.d0 / Cstv_tau_8
*
         do n=1,Tr3d_ntr
*
            nullify (tr0,tr1)
            gmmstat = gmm_get('TR/'//trim(Tr3d_name_S(n))//':M',tr0,meta3d)
            gmmstat = gmm_get('TR/'//trim(Tr3d_name_S(n))//':P',tr1,meta3d)
*
            nullify (tr0_m,tr1_m)
            gmmstat = gmm_get('TRM/'//trim(Tr3d_name_S(n))//':M',tr0_m,meta3d)
            gmmstat = gmm_get('TRM/'//trim(Tr3d_name_S(n))//':P',tr1_m,meta3d)
*
C!$omp parallel
*
C!$omp do
            do k=1,l_nk+1
            do j=1,l_nj
            do i=1,l_ni
*
*              TRAJECTORY
*              ----------
               tr0_m(i,j,k) = - aaa_8*tr1_m(i,j,k)
*
*              TLM 
*              ---
               tr0(i,j,k) = - aaa_8*tr1(i,j,k)
*
            end do
            end do
            end do
C!$omp enddo
*
C!$omp do
            do k=1,l_nk+1
            do j=l_miny,l_maxy
            do i=l_minx,l_maxx
               work(i,j,k) = tr0(i,j,k)
            enddo
            enddo
            enddo
C!$omp enddo
*
C!$omp end parallel
*
            call adw_interp2_tl ( tr0,  work, pos_x,  pos_y,
     %                            tr0_m,tr0_m,pos_x_m,pos_y_m,
     %                            .false. , Adw_mono_L, LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
C!$omp parallel do
            do k=1,l_nk+1
            do j=1,l_nj
            do i=1,l_ni
*
*              TRAJECTORY
*              ----------
               tr0_m(i,j,k) = Cstv_tau_8*tr0_m(i,j,k)
*
*              TLM
*              ---
               tr0(i,j,k) = Cstv_tau_8*tr0(i,j,k)
*
            end do
            end do
            end do
C!$omp end parallel do
*
         end do
*
      endif
*
***********************************************************************
* Deallocate
***********************************************************************
      call hpdeallc(Adw_capx1_   ,err,1)
      call hpdeallc(Adw_capy1_   ,err,1)
      call hpdeallc(Adw_capz1_   ,err,1)
      call hpdeallc(Adw_n1_      ,err,1)
      call hpdeallc(Adw_xdd1_    ,err,1)
      call hpdeallc(Adw_xgg1_    ,err,1)
      call hpdeallc(Adw_ydd1_    ,err,1)
      call hpdeallc(Adw_ygg1_    ,err,1)
      call hpdeallc(Adw_cz1_     ,err,1)
      call hpdeallc(Adw_c1_      ,err,1)
      call hpdeallc(Adw_wrkb_    ,err,1)
      call hpdeallc(Adw_wrkc_    ,err,1)
*
      call hpdeallc(Adw_capx1_m_ ,err,1)
      call hpdeallc(Adw_capy1_m_ ,err,1)
      call hpdeallc(Adw_capz1_m_ ,err,1)
      call hpdeallc(Adw_n1_m_    ,err,1)
      call hpdeallc(Adw_xdd1_m_  ,err,1)
      call hpdeallc(Adw_xgg1_m_  ,err,1)
      call hpdeallc(Adw_ydd1_m_  ,err,1)
      call hpdeallc(Adw_ygg1_m_  ,err,1)
      call hpdeallc(Adw_cz1_m_   ,err,1)
      call hpdeallc(Adw_c1_m_    ,err,1)
      call hpdeallc(Adw_wrkb_m_  ,err,1)
      call hpdeallc(Adw_wrkc_m_  ,err,1)
*
      deallocate (pos_x,pos_y,pos_z)
      deallocate (pos_x_m,pos_y_m,pos_z_m)

 1000 format(3X,'TLM of ADVECT THE RIGHT-HAND-SIDES: (S/R ADW_MAIN_3_INT_TL)')
*
      return
      end
