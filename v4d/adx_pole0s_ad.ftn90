!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "stop_mpi.h"
#include "msg.h"

subroutine adx_pole0s_ad()
   implicit none
   !---------------------------------------------------------------------
   call stop_mpi(STOP_ERROR,'adx_pole0s_ad','called a stub')
   !---------------------------------------------------------------------
   return
end subroutine adx_pole0s_ad

   !/**
subroutine adx_pole0s2_ad(F_fld_adw, F_fld_model, &
                          F_aminx,F_amaxx,F_aminy,F_amaxy,F_minx,F_maxx,F_miny,F_maxy,F_nk,&
                          F_pol0_L, F_extend_L, F_is_south_L)
   implicit none
#include "adx_dims.cdk"
#include "adx_grid.cdk"
   !@objective ADJ of adx_pole0s 
   !@arguments
   logical :: F_is_south_L !I, .true. if south pole
   logical :: F_extend_L   !I, Extend field beyond poles
   logical :: F_pol0_L     !I, Set values=0 around poles (e.g. 4 winds)
   integer :: F_aminx,F_amaxx,F_aminy,F_amaxy !I, adw local array bounds
   integer :: F_minx,F_maxx,F_miny,F_maxy     !I, model's local array bounds
   integer :: F_nk         !I, number of levels
   real, dimension(F_minx:F_maxx,F_miny:F_maxy,F_nk) :: &
        F_fld_model        !I, fld on model-grid
   real, dimension(F_aminx:F_amaxx,F_aminy:F_amaxy,F_nk) :: &
        F_fld_adw          !O, fld on adw-grid
   !@author monique tanguay
   !@revisions
   ! v4_XX - Tanguay M.        - Adjustments GEM413
   !**/
   integer :: j1, j2, i, k
   real*8  :: ww_8
   real*8, parameter :: ZERO_8 = 0.0
   !---------------------------------------------------------------------
   call msg(MSG_DEBUG,'adx_pole0s_ad')
   !
   !Zero adjoint variables
   !----------------------
   ww_8 = ZERO_8 
   !
   if (F_is_south_L) then
      j1 = 0
      j2 = 1
   else
      j1 = adx_lnj+1
      j2 = adx_lnj
   endif

   if (F_extend_L) then
      !ADJ of
      !extension of a scalar field beyond the poles
      call adx_polx3_ad(F_fld_adw, F_is_south_L, &
           F_aminx,F_amaxx,F_aminy,F_amaxy, &
           adx_lni,adx_lnj, adx_halox,adx_haloy, F_nk)
   endif
   if  (F_pol0_L) then
      !ADJ of
      !set values at the pole = 0.0
      do k = F_nk,1,-1
         do i = F_amaxx,F_aminx,-1
            F_fld_adw(i,j1,k) = 0.0
         enddo
      enddo
   else
      !ADJ of
      !compute weighted average around the pole
      do k = F_nk,1,-1
         do i = F_amaxx,F_aminx,-1
            ww_8              = dble(F_fld_adw(i,j1,k)) + ww_8
            F_fld_adw(i,j1,k) = ZERO_8
         enddo
         do i = adx_lni,1,-1
            F_fld_adw(i,j2,k) = adx_wx_8(i) * ww_8 + F_fld_adw(i,j2,k) 
         enddo
         ww_8 = 0.D0
      enddo
   endif

   call msg(MSG_DEBUG,'adx_pole0s_ad [end]')
   !---------------------------------------------------------------------
   return
   end subroutine adx_pole0s2_ad
