***s/r adw_main_tr -  Equivalent to adw_main for TRAJECTORY 
*
#include "model_macros_f.h"
*
      subroutine adw_main_tr ( F_it )
*
#include "impnone.cdk"
*
      integer F_it
*
*author
*     monique tanguay
*
*revision
* v2_31 - Tanguay M.        - initial MPI version
* v3_00 - Tanguay M.        - adapt to restructured adw_main 
* v3_20 - Tanguay M.        - Option of storing instead of redoing TRAJ 
* v3_21 - Tanguay M.        - Revision Openmp
*
*language
*     fortran 77
*
*object
*     see id section
*
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
* F_it   | total number of iterations for trajectories           |  i  |
*________|_______________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
#include "lun.cdk"
#include "adw.cdk"
#include "orhm.cdk"
#include "rhscm.cdk"
#include "vthm.cdk"
#include "vt1m.cdk"
#include "vt0m.cdk"
#include "tr3d.cdk"
#include "offc.cdk"
#include "cstv.cdk"
#include "orh.cdk"
#include "schm.cdk"
#include "v4dr.cdk"
*
************************************************************************
      integer  vmmlod, vmmget, vmmuld, vmmuln
      external vmmlod, vmmget, vmmuld, vmmuln
*
      integer pnerr, pnlkey1(30), pnlod, key1m(Tr3d_ntr), key0m(Tr3d_ntr), keyorm(Tr3d_ntr),
     $        key1m_, key0m_, keyorm_, err
*
      integer nijkag,n,i,j,k
      real , dimension (Adw_nit*Adw_njt*l_nk) :: um,vm,wm
*
      real wuthm(LDIST_SHAPE,l_nk),wvthm(LDIST_SHAPE,l_nk)
*
      real wxthm (l_ni*l_nj*l_nk),wythm (l_ni*l_nj*l_nk)
      real wzthm (l_ni*l_nj*l_nk)
      real wxcthm(l_ni*l_nj*l_nk),wycthm(l_ni*l_nj*l_nk)
      real wzcthm(l_ni*l_nj*l_nk)
*
      real*8 aaa_8
      real trm,tr0m,orm
      pointer (patrm, trm(LDIST_SHAPE,*)),(patr0m, tr0m(LDIST_SHAPE,*))
      pointer (paorm, orm(LDIST_SHAPE,*))
*
************************************************************************
      if (Lun_debug_L) write (Lun_out,1000)
*
************************************************************************
*
      if( V4dr_redotr_L ) then
*
*     ---------------------
*     Preserve TRAJ (START)
*     ---------------------
      pnlkey1(1)  = VMM_KEY(uthm )
      pnlkey1(2)  = VMM_KEY(vthm )
      pnlkey1(3)  = VMM_KEY(xthm )
      pnlkey1(4)  = VMM_KEY(ythm )
      pnlkey1(5)  = VMM_KEY(zthm )
      pnlkey1(6)  = VMM_KEY(xcthm)
      pnlkey1(7)  = VMM_KEY(ycthm)
      pnlkey1(8)  = VMM_KEY(zcthm)
      pnlod = 8
*
      pnerr = vmmlod(pnlkey1,pnlod)
*
      pnerr = VMM_GET_VAR(uthm )
      pnerr = VMM_GET_VAR(vthm )
      pnerr = VMM_GET_VAR(xthm )
      pnerr = VMM_GET_VAR(ythm )
      pnerr = VMM_GET_VAR(zthm )
      pnerr = VMM_GET_VAR(xcthm)
      pnerr = VMM_GET_VAR(ycthm)
      pnerr = VMM_GET_VAR(zcthm)
*
*     -----------------------
*     Preserve TRAJ uthm vthm
*     -----------------------
!$omp parallel 
*
!$omp do
      do k= 1,l_nk
      do j= l_miny,l_maxy
      do i= l_minx,l_maxx
         wuthm(i,j,k) = uthm(i,j,k)
         wvthm(i,j,k) = vthm(i,j,k)
      enddo
      enddo
      enddo
!$omp enddo
*
*     ----------------------------------------------
*     Preserve TRAJ xthm ythm zthm xcthm ycthm zcthm
*     ----------------------------------------------
!$omp do
      do n= 1,l_ni*l_nj*l_nk
         wxthm (n) = xthm (n)
         wythm (n) = ythm (n)
         wzthm (n) = zthm (n)
         wxcthm(n) = xcthm(n)
         wycthm(n) = ycthm(n)
         wzcthm(n) = zcthm(n)
      enddo
!$omp enddo
*
!$omp end parallel
*
      pnerr = vmmuld(-1,0)
*
*     -------------------
*     Preserve TRAJ (END)
*     -------------------
*
      call adw_main_1_wnd_tr ( um, vm, wm, Adw_nit, Adw_njt, l_nk)
*
      call adw_main_2_pos_tr ( F_it, um, vm, wm )
*
      call adw_main_3_int_tr ( um, vm, wm )
*
      else
*
*     ---------------------------------------------------------------
*     Store in ORTR for ADW_MAIN_3_INT_AD when Orh_icn .eq. Schm_itcn
*     ---------------------------------------------------------------
      if ( Orh_icn .eq. Schm_itcn ) then
*
      aaa_8 = ( Offc_a1_8 / Offc_b0_8 )/ Cstv_dt_8 
*
      key1m_ = VMM_KEY (trt1m)
      key0m_ = VMM_KEY (trt0m)
      keyorm_= VMM_KEY (ortrm)
      do n=1,Tr3d_ntr
         key1m (n) = key1m_  + n
         key0m (n) = key0m_  + n
         keyorm(n) = keyorm_ + n
      end do
      if (Tr3d_ntr.gt.0) then
         err = vmmlod(key1m, Tr3d_ntr)  
         err = vmmlod(key0m, Tr3d_ntr)  
         err = vmmlod(keyorm,Tr3d_ntr)
         do n=1,Tr3d_ntr
            err = vmmget(key1m (n),patrm, trm)
            err = vmmget(key0m (n),patr0m,tr0m)
            err = vmmget(keyorm(n),paorm, orm)
*
!$omp parallel do 
            do k=1,l_nk
*
              do j=1,l_nj
              do i=1,l_ni
                 tr0m(i,j,k) = - aaa_8*trm(i,j,k)
              end do
              end do
*
              do j=1,l_nj
              do i=1,l_ni
                 orm(i,j,k) = tr0m(i,j,k)
              end do
              end do
*
            end do
!$omp end parallel do  
*
         end do
         err = vmmuld(key1m, Tr3d_ntr)
         err = vmmuld(key0m, Tr3d_ntr)
         err = vmmuld(keyorm,Tr3d_ntr)
      endif
*
      endif
*
*     -----------------------------
*     Recover TRAJ RHS interpolated
*     -----------------------------
      call v4d_rwtraj (8)
*
      endif
*
*     ------------------------------
*     Preserve or Reset TRAJ (START)
*     ------------------------------
      pnlkey1(1)  = VMM_KEY(ruw2m )
      pnlkey1(2)  = VMM_KEY(rvw2m )
      pnlkey1(3)  = VMM_KEY(oruw2m)
      pnlkey1(4)  = VMM_KEY(orvw2m)
      pnlod = 4 
*
      if( V4dr_redotr_L ) then
*
      pnlkey1(pnlod+1) = VMM_KEY(uthm  )
      pnlkey1(pnlod+2) = VMM_KEY(vthm  )
      pnlkey1(pnlod+3) = VMM_KEY(xthm  )
      pnlkey1(pnlod+4) = VMM_KEY(ythm  )
      pnlkey1(pnlod+5) = VMM_KEY(zthm  )
      pnlkey1(pnlod+6) = VMM_KEY(xcthm )
      pnlkey1(pnlod+7) = VMM_KEY(ycthm )
      pnlkey1(pnlod+8) = VMM_KEY(zcthm )
      pnlod = pnlod+8 
*
      endif
*
      pnerr = vmmlod(pnlkey1,pnlod)
*
      pnerr = VMM_GET_VAR(ruw2m )
      pnerr = VMM_GET_VAR(rvw2m )
      pnerr = VMM_GET_VAR(oruw2m)
      pnerr = VMM_GET_VAR(orvw2m)
*
      if( V4dr_redotr_L ) then
      pnerr = VMM_GET_VAR(uthm  )
      pnerr = VMM_GET_VAR(vthm  )
      pnerr = VMM_GET_VAR(xthm  )
      pnerr = VMM_GET_VAR(ythm  )
      pnerr = VMM_GET_VAR(zthm  )
      pnerr = VMM_GET_VAR(xcthm )
      pnerr = VMM_GET_VAR(ycthm )
      pnerr = VMM_GET_VAR(zcthm )
      endif
*
*     --------------------------
*     Preserve in ORH for PRE_AD
*     --------------------------
!$omp parallel do  
      do k=1,l_nk
      do j=l_miny,l_maxy
      do i=l_minx,l_maxx
         oruw2m(i,j,k) = ruw2m(i,j,k)
         orvw2m(i,j,k) = rvw2m(i,j,k)
      end do
      end do
      end do
!$omp end parallel do  
*
      if( V4dr_redotr_L ) then
*
!$omp parallel  
*
*     --------------------
*     Reset TRAJ uthm vthm
*     --------------------
!$omp do  
      do k= 1,l_nk
      do j= l_miny,l_maxy
      do i= l_minx,l_maxx
         uthm(i,j,k) = wuthm(i,j,k) 
         vthm(i,j,k) = wvthm(i,j,k)
      enddo
      enddo
      enddo
!$omp enddo  
*
*     -------------------------------------------
*     Reset TRAJ xthm ythm zthm xcthm ycthm zcthm
*     -------------------------------------------
!$omp do  
      do n= 1,l_ni*l_nj*l_nk
         xthm (n) = wxthm (n) 
         ythm (n) = wythm (n) 
         zthm (n) = wzthm (n) 
         xcthm(n) = wxcthm(n)
         ycthm(n) = wycthm(n) 
         zcthm(n) = wzcthm(n) 
      enddo
!$omp enddo  
*
!$omp end parallel  
*
      endif
*
      pnerr = vmmuld(-1,0)
*
***********************************************************************
*
 1000  format(3X,'TRAJ of ADVECT THE RIGHT-HAND-SIDES: (S/R ADW_MAIN_TR)')
*
      return
      end
