!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "msg.h"
#include "stop_mpi.h"

subroutine adx_main_3_intlag5_ad()
   call stop_mpi(STOP_ERROR,'adx_main_3_intlag5_ad','called a stub')
   return
end subroutine adx_main_3_intlag5_ad

!/**
subroutine adx_main_3_intlag6_ad(F_px  ,F_py  ,F_pz  ,F_fields_list  , &
                                 F_px_m,F_py_m,F_pz_m,F_fields_list_m, &
                                 F_fields_type_L, F_nfields, F_is_mom_L, F_doAdwStat_L, F_ni,F_nj,F_nk)

   implicit none
   !@objective ADJ of adx_main_3_intlag6 
   !@arguments
   logical :: F_is_mom_L     !I, momentum level if .true. (thermo if not)
   logical :: F_doAdwStat_L  !I, compute stats if .true.
   integer :: F_ni,F_nj,F_nk !I, pos array dims
   integer :: F_nfields      !I, nb of fields to advect
   logical, dimension(2,F_nfields)         :: F_fields_type_L !I, fields type
   character(len=8), dimension(2,F_nfields):: F_fields_list, & !I, gmm flds lbls
                                              F_fields_list_m  !I, gmm flds lbls TRAJ
   real, dimension(F_ni,F_nj,F_nk) :: F_px  , F_py  , F_pz  , & !I, upstream positions at t1
                                      F_px_m, F_py_m, F_pz_m    !I, upstream positions at t1 TRAJ
   !@author monique tanguay
   !@revisions
   ! v4_XX - Tanguay M.        - Adjustments GEM413
   !**/
#include "adx_nml.cdk"
#include "adx_dims.cdk"
#include "adx_poles.cdk"
#include "adx_interp.cdk"
#include "adx_interp_m.cdk"
   integer, parameter :: FIELD_IN  = 1
   integer, parameter :: FIELD_OUT = 2
   integer, parameter :: IS_MOM    = 1
   integer, parameter :: IS_WIND   = 2

   character(len=1) :: level_type_S

   integer :: n, nijkt,i,j,k
   integer :: i0,j0,in,jn, istat
   real, dimension(F_ni,F_nj,F_nk) :: pos_x  , pos_y  , pos_z  , &
                                      pos_x_m, pos_y_m, pos_z_m
   real, dimension(F_ni,F_nj,F_nk) :: px_1_m, py_1_m
   !---------------------------------------------------------------------
   call msg(MSG_DEBUG, 'adx_main_3_intlag_ad')

   nijkt  = F_ni * F_nj * adx_lnkt !TODO: Check if can use F_nk = nkm or nkt
   allocate( &
        adx_capx1(nijkt), &
        adx_capy1(nijkt), &
        adx_capz1(nijkt), &
        adx_n1(nijkt), &
        adx_xdd1(nijkt), &
        adx_xgg1(nijkt), &
        adx_ydd1(nijkt), &
        adx_ygg1(nijkt), &
        adx_c1(nijkt), &
        !
        !TRAJECTORY
        !----------
        adx_capx1_m(nijkt), &
        adx_capy1_m(nijkt), &
        adx_capz1_m(nijkt), &
        adx_n1_m(nijkt), &
        adx_xdd1_m(nijkt), &
        adx_xgg1_m(nijkt), &
        adx_ydd1_m(nijkt), &
        adx_ygg1_m(nijkt), &
        adx_c1_m(nijkt), &
        ! 
        stat=istat)
   call handle_error_l(istat==0,'adx_main_3_intlag_ad','Problem allocating mem')
   !
   !ZERO adjoint variables
   !----------------------
   adx_capx1 = 0.
   adx_capy1 = 0.
   adx_capz1 = 0. 
!!!adx_n1    = 0  
   adx_xdd1  = 0. 
   adx_xgg1  = 0. 
   adx_ydd1  = 0. 
   adx_ygg1  = 0.
!!!adx_c1    = 0  
   !
   !CAUTION: pos_x  
!!!pos_x = 0.
!!!pos_y = 0.
!!!pos_z = 0.
   !
   call adx_get_ij0n(i0,in,j0,jn)

   level_type_S = 't'
   if (F_is_mom_L) level_type_S = 'm'
   !
   !TRAJECTORY
   !----------
   if (adx_lam_L) then
       px_1_m = F_px_m
       py_1_m = F_py_m
   endif

   do k = 1, F_nk
      do j = j0, jn
         do i = i0, in
            pos_x_m(i,j,k) =  F_px_m(i,j,k)
            pos_y_m(i,j,k) =  F_py_m(i,j,k)
            pos_z_m(i,j,k) =  F_pz_m(i,j,k)
         enddo
      enddo
   enddo

   IF_LAM_TR: if (adx_lam_L) then

      if (F_doAdwStat_L) then
         call adx_cfl_lam2(pos_x_m, pos_y_m, pos_z_m,  &
              i0, in, j0, jn, F_ni,F_nj,F_nk, level_type_S)
      endif
      call adx_cliptraj2(pos_x_m,pos_y_m, i0, in, j0, jn, F_ni,F_nj,F_nk,  &
           'INTERP '//trim(level_type_S))

   else !IF_LAM_TR

   ! NOT DONE

   endif IF_LAM_TR

   !- Keep positions in CAP fields
   do k=1,F_nk
      do j=j0,jn
         do i=i0,in
            n = (k-1)*adx_mlni*adx_mlnj + (j-1)*adx_mlni + i
            adx_capx1_m(n) = pos_x_m(i,j,k)
            adx_capy1_m(n) = pos_y_m(i,j,k)
            adx_capz1_m(n) = pos_z_m(i,j,k)
         end do
      end do
   end do

   do n = F_nfields,1,-1
      if (F_fields_type_L(IS_MOM,n) .neqv. F_is_mom_L) cycle
      call adx_interp_gmm4_ad(F_fields_list  (FIELD_OUT,n),F_fields_list  (FIELD_IN,n),&
                              F_fields_list_m(FIELD_OUT,n),F_fields_list_m(FIELD_IN,n),&
                              F_fields_type_L(IS_WIND,n), F_nk, &
                              i0,in,j0,jn,level_type_S)
   end do


   !Zero adjoint variables
   !----------------------
   pos_x = 0.
   pos_y = 0.
   pos_z = 0.

   !TRAJECTORY
   !----------
   if (adx_lam_L) then
      do k = 1, F_nk
         do j = j0, jn
            do i = i0, in
               pos_x_m(i,j,k) =  F_px_m(i,j,k)
               pos_y_m(i,j,k) =  F_py_m(i,j,k)
            enddo
         enddo
      enddo
   endif
   !
   !- ADJ of
   !- Keep positions in CAP fields
   do k=1,F_nk
      do j=j0,jn
         do i=i0,in
            n = (k-1)*adx_mlni*adx_mlnj + (j-1)*adx_mlni + i

            pos_z(i,j,k) = adx_capz1(n) + pos_z(i,j,k)
            pos_y(i,j,k) = adx_capy1(n) + pos_y(i,j,k)
            pos_x(i,j,k) = adx_capx1(n) + pos_x(i,j,k)
   !
            adx_capz1(n) = 0.
            adx_capy1(n) = 0.
            adx_capx1(n) = 0.

         end do
      end do
   end do

   IF_LAM: if (adx_lam_L) then

      call adx_cliptraj2_ad(pos_x,pos_y,pos_x_m,pos_y_m,i0,in,j0,jn,F_ni,F_nj,F_nk, &
           'INTERP '//trim(level_type_S))


   else !IF_LAM
        !NOT DONE
   endif IF_LAM

   do k = 1, F_nk
      do j = j0, jn
         do i = i0, in

            F_pz(i,j,k) = pos_z(i,j,k) + F_pz(i,j,k)
            F_py(i,j,k) = pos_y(i,j,k) + F_py(i,j,k)
            F_px(i,j,k) = pos_x(i,j,k) + F_px(i,j,k)

            pos_z(i,j,k)= 0.
            pos_y(i,j,k)= 0.
            pos_x(i,j,k)= 0.

         enddo
      enddo
   enddo

   deallocate( &
        adx_capx1  , adx_capy1  , adx_capz1  , adx_n1  , adx_xdd1  , adx_xgg1  , &
        adx_ydd1   , adx_ygg1   , adx_c1     , &
        !
        adx_capx1_m, adx_capy1_m, adx_capz1_m, adx_n1_m, adx_xdd1_m, adx_xgg1_m, &
        adx_ydd1_m , adx_ygg1_m , adx_c1_m   )

   call msg(MSG_DEBUG, 'adx_main_3_intlag_ad [end]')
   !---------------------------------------------------------------------
   return
end subroutine adx_main_3_intlag6_ad
