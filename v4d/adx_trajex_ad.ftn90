!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "constants.h"

subroutine adx_trajex_ad
   call stop_mpi(STOP_ERROR,'adx_trajex_ad','called a stub')
   return
end subroutine adx_trajex_ad

!/**
subroutine adx_trajex2_ad(F_xto   ,F_yto   ,F_xcto  , F_ycto  , &
                          F_zcto  ,F_xctm  ,F_yctm  , F_zctm  , &
                                   F_xctm_m,F_yctm_m, F_zctm_m, &
                          i0,in,j0,jn,F_ni,F_nj,F_nk)
   implicit none
   !@objective ADJ of adx_trajex 
   !@arguments
   integer :: F_ni,F_nj,F_nk !I,
   real, dimension(F_ni,F_nj,F_nk) :: &
        F_xto, F_yto, &          !O, upstream positions at origin
        F_xcto, F_ycto, F_zcto,& !O, upstream cartesian positions at origin
        F_xctm, F_yctm, F_zctm,& !I, upstream cartesian positions at mid-traj
   !
        F_xctm_m, F_yctm_m, F_zctm_m   !I, upstream cartesian positions at mid-traj TRAJ
   integer :: i0,in,j0,jn        !I, scope of operator
   !@author monique tanguay
   !@revisions
   ! v4_XX - Tanguay M.        - Adjustments GEM413
!**/
#include "adx_dims.cdk"
#include "adx_grid.cdk"
   integer :: i,j,k, vnij, trj_i_off
   real*8 :: prx, pry, prz, prdot2
   real*8,dimension(i0:in,j0:jn) :: xasin, yasin, xatan, yatan, zatan
   !TRAJECTORY
   real*8,dimension(i0:in,j0:jn) :: xasin_m, yasin_m, xatan_m, yatan_m, zatan_m
   !TRAJECTORY (EXTRA)
   real*8,dimension(i0:in,j0:jn) :: smin_m,rsmin_m,xy_m,rxy_m 
   real  minmax, minmax_m, prxcto_m, prycto_m, przcto_m
   real*8 :: prdot2_m
   real*8, parameter :: ZERO_8 = 0.0
   !---------------------------------------------------------------------
   vnij = (in-i0+1)*(jn-j0+1)
   trj_i_off = adx_mli0 - adx_li0

   !Zero adjoint variables
   !----------------------
   minmax = ZERO_8
   prdot2 = ZERO_8

   do k=adx_lnkm,1,-1
      do j=j0,jn
         do i=i0,in

            !START REBUILD TRAJECTORY
            !------------------------
            pry = dble(adx_cy_8(j))
            prx = dble(adx_cx_8(trj_i_off + i)) * pry
            pry = dble(adx_sx_8(trj_i_off + i)) * pry
            prz = dble(adx_sy_8(j))

            prdot2_m= 2.D0 * (prx * dble(F_xctm_m(i,j,k)) + &
                              pry * dble(F_yctm_m(i,j,k)) + &
                              prz * dble(F_zctm_m(i,j,k)) )

            prxcto_m = prdot2_m * dble(F_xctm_m(i,j,k)) - prx
            prycto_m = prdot2_m * dble(F_yctm_m(i,j,k)) - pry
            przcto_m = prdot2_m * dble(F_zctm_m(i,j,k)) - prz
 
            !The following min statement is expanded as two IF blocks:
            !minmax_m = max(-1.,min(1.,przcto_m))
            !---------------------------------------------------------
            minmax_m = przcto_m
            !
            !END REBUILD TRAJECTORY
            !----------------------

            !ADJ
            !---
            if (przcto_m.ge.1.) then
                F_yto(i,j,k) = 0.
                minmax       = 0.
            elseif (przcto_m.le.-1.) then
                F_yto(i,j,k) = 0.
                minmax       = 0.
            else
!!!              minmax      = F_yto(i,j,k)/sqrt( 1.0-minmax_m**2 ) + minmax
                 minmax      = F_yto(i,j,k)/sqrt( 1.0-minmax_m**2 )
                 F_yto(i,j,k)= ZERO_8
            endif
            F_zcto(i,j,k) = minmax + F_zcto(i,j,k)
!!!         minmax        = ZERO_8

            F_ycto(i,j,k) = ( F_xto(i,j,k)*prxcto_m  ) &
                            /(prxcto_m*prxcto_m + prycto_m*prycto_m) &
                            + F_ycto(i,j,k)
            F_xcto(i,j,k) = ( - prycto_m*F_xto(i,j,k)) &
                            /(prxcto_m*prxcto_m + prycto_m*prycto_m) &
                            + F_xcto(i,j,k)
            F_xto(i,j,k)  = ZERO_8

            F_zctm(i,j,k) = prdot2_m * dble(F_zcto(i,j,k)) + F_zctm(i,j,k)

            F_yctm(i,j,k) = prdot2_m * dble(F_ycto(i,j,k)) + F_yctm(i,j,k)
 
            F_xctm(i,j,k) = prdot2_m * dble(F_xcto(i,j,k)) + F_xctm(i,j,k)
 
            prdot2 = dble(F_xcto(i,j,k)) * dble(F_xctm_m(i,j,k)) + &
                     dble(F_ycto(i,j,k)) * dble(F_yctm_m(i,j,k)) + &
                     dble(F_zcto(i,j,k)) * dble(F_zctm_m(i,j,k))
 
            F_zcto(i,j,k) = ZERO_8
            F_ycto(i,j,k) = ZERO_8
            F_xcto(i,j,k) = ZERO_8

            F_xctm(i,j,k) = 2.0 * ( prx * prdot2 ) + F_xctm(i,j,k)
            F_yctm(i,j,k) = 2.0 * ( pry * prdot2 ) + F_yctm(i,j,k)
            F_zctm(i,j,k) = 2.0 * ( prz * prdot2 ) + F_zctm(i,j,k)

         enddo
      enddo

   enddo
   !---------------------------------------------------------------------
   return
end subroutine adx_trajex2_ad
