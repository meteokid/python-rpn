!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "constants.h"
#include "msg.h"
#include "stop_mpi.h"

subroutine adx_main_2_pos_tl()
   call stop_mpi(STOP_ERROR,'adx_main_2_pos_tl','called a stub')
   return
end subroutine adx_main_2_pos_tl

subroutine adx_main_2_pos2_tl()
   call stop_mpi(STOP_ERROR,'adx_main_2_pos2_tl','called a stub')
   return
end subroutine adx_main_2_pos2_tl

!/**
subroutine adx_main_2_pos3_tl( &
     F_nb_iter  ,F_l_S, &
!
     F_px  ,F_py  ,F_pz  , &
     F_u   ,F_v   ,F_w   , &
     F_xth ,F_yth ,F_zth , &
     F_xcth,F_ycth,F_zcth, &
     F_xct1,F_yct1,F_zct1, &
!
     F_px_m  ,F_py_m  ,F_pz_m  , &
     F_u_m   ,F_v_m   ,F_w_m   , &
     F_xth_m ,F_yth_m ,F_zth_m , &
     F_xcth_m,F_ycth_m,F_zcth_m, &
     F_xct1_m,F_yct1_m,F_zct1_m, &
!
     F_aminx, F_amaxx, F_aminy, F_amaxy, &
     F_ni, F_nj, F_nk, F_nk_super)
!
   implicit none
   !@objective TLM of adx_main_2_pos3
   !@arguments
   integer :: F_nb_iter          !I, total number of iterations for traj
   character(len=1) :: F_l_S     !I, m/t for momentum or thermo level
   integer :: F_aminx, F_amaxx, F_aminy, F_amaxy !I, wind fields array bounds
   integer :: F_ni, F_nj         !I, dims of position fields
   integer :: F_nk, F_nk_super   !I, nb levels
   real, dimension(F_ni,F_nj,F_nk) :: &
        F_px  , F_py  , F_pz,&   !O, upstream positions valid at t1
        F_px_m, F_py_m, F_pz_m   !O, upstream positions valid at t1 TRAJ
   real,dimension(F_aminx:F_amaxx,F_aminy:F_amaxy,F_nk_super),target::&
        F_u   ,F_v   ,F_w,&      !I, real destag winds, super-set (mom+thermo)
        F_u_m ,F_v_m ,F_w_m      !I, real destag winds, super-set (mom+thermo) TRAJ
   real, dimension(F_ni,F_nj,F_nk) :: &
        F_xth   , F_yth   , F_zth,&    !I/O, upwind longitudes at central time 
        F_xcth  , F_ycth  , F_zcth,&   !O, upwind cartesian positions at central time
        F_xct1  , F_yct1  , F_zct1,&   !O, upstream cartesian positions at t1
        F_xth_m , F_yth_m , F_zth_m,&  !I/O, upwind longitudes at central time TRAJ 
        F_xcth_m, F_ycth_m, F_zcth_m,& !O, upwind cartesian positions at central time TRAJ
        F_xct1_m, F_yct1_m, F_zct1_m   !O, upstream cartesian positions at t1 TRAJ
   !@author monique tanguay
   !@revisions
   ! v4_XX - Tanguay M.        - Adjustments GEM413
   !**/
#include "adx_nml.cdk"
#include "adx_dims.cdk"
#include "adx_grid.cdk"
#include "adx_dyn.cdk"
#include "adx_poles.cdk"

   real*8, parameter :: PDP_8 = 1.D0 + 1.D-6
   real*8, parameter :: PDM_8 = 1.D0 - 1.D-6
   logical,parameter :: CLIP_TRAJ = .true.
   logical,parameter :: DO_W      = .false.
   logical,parameter :: DO_UV     = .true.
   real, parameter   :: DTH_1     = 1.

   integer :: i, j, k, iter, ioff
   integer :: i0,in,j0,jn
   real    :: dth
   real, dimension(F_ni,F_nj,F_nk) :: wrkx1,wrky1
   real, dimension(F_ni,F_nj,F_nk) :: xgrid,ygrid,zgrid
   !
   real, dimension(F_ni,F_nj,F_nk) :: wrkx1_m,wrky1_m
   real, dimension(F_ni,F_nj,F_nk) :: xgrid_m,ygrid_m,zgrid_m

   real, dimension(:,:,:), pointer :: dummy3d
   real*8, dimension(:), pointer :: p_z
   !---------------------------------------------------------------------
   call msg(MSG_DEBUG,'adx_main_2_pos_tl ('//trim(F_l_S)//')')

   if (adx_zdotMid_L) call handle_error(-1,'adx_main_2_pos_tl','adx_zdotMid_L not done')

   dummy3d => F_w

   dth  = adx_dt_8/2.

   p_z => adx_verZ_8%t
   if (F_l_S == 'm') p_z => adx_verZ_8%m

   call adx_get_ij0n(i0,in,j0,jn)


   DO_ITER: do iter = 1, F_nb_iter

      !- 3d interpol of u and v winds and new upstream pos along x and y

      ygrid  (:,:,:) = F_yth  (:,:,:)
      ygrid_m(:,:,:) = F_yth_m(:,:,:)
      if (adx_lam_L) then
         call adx_pos_lam3_tl(wrkx1  ,wrky1  ,F_u  ,F_v  ,F_xth  ,ygrid  ,F_zth  , &
                              wrkx1_m,wrky1_m,F_u_m,F_v_m,F_xth_m,ygrid_m,F_zth_m, &
                              DTH_1, CLIP_TRAJ, DO_UV, i0,in,j0,jn, &
                              F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,F_nk,F_nk_super)
      else
         call adx_pos_glb3_tl(wrkx1  ,wrky1  ,F_u  ,F_v  ,F_xth  ,ygrid  ,F_zth  , &
                              wrkx1_m,wrky1_m,F_u_m,F_v_m,F_xth_m,ygrid_m,F_zth_m, &
                              DTH_1, DO_UV, i0,in,j0,jn, &
                              F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,F_nk,F_nk_super)
      endif

      call adx_trajsp2_tl(F_xth  ,F_yth  ,F_xcth  ,F_ycth  ,F_zcth  ,wrkx1  ,wrky1  , &
                          F_xth_m,F_yth_m,F_xcth_m,F_ycth_m,F_zcth_m,wrkx1_m,wrky1_m,dth,&
                          i0,in,j0,jn,F_ni,F_nj,F_nk)

      !- 3D interpol of zeta dot and new upstream pos along zeta

      IF_ZDOTMID: if (adx_zdotMid_L) then

      !- NOT DONE

      else  !IF_ZDOTMID

         ygrid  (:,:,:) = F_yth  (:,:,:)
         ygrid_m(:,:,:) = F_yth_m(:,:,:)

         if (adx_lam_L) then
            call adx_pos_lam3_tl(wrkx1  ,wrky1  ,F_w  ,dummy3d,F_xth  ,ygrid  ,F_zth  , &
                                 wrkx1_m,wrky1_m,F_w_m,dummy3d,F_xth_m,ygrid_m,F_zth_m, &
                                 -dth, CLIP_TRAJ, DO_W, i0,in,j0,jn, &
                                 F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,F_nk,F_nk_super)
         else
            call adx_pos_glb3_tl(wrkx1  ,wrky1  ,F_w  ,dummy3d,F_xth  ,ygrid  ,F_zth  , &
                                 wrkx1_m,wrky1_m,F_w_m,dummy3d,F_xth_m,ygrid_m,F_zth_m, &
                                 -dth, DO_W, i0,in,j0,jn, &
                                 F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,F_nk,F_nk_super)
         endif

      endif IF_ZDOTMID

      do k = 2,F_nk-1
         do j = j0,jn
            do i = i0,in
               ! 
               !TRAJECTORY
               !----------
               F_zth_m(i,j,k) = p_z(k) + 2.D0*wrkx1_m(i,j,k)
               ! 
               !TLM
               !---
               F_zth(i,j,k) = 2.D0*wrkx1(i,j,k)
               ! 
               !Make sure F_zth is below p_z(1) and above p_z(F_nk)
               !---------------------------------------------------
!!!            F_zth_m(i,j,k) = min(PDM_8*p_z(F_nk),  &
!!!                             max(1.0d0*F_zth_m(i,j,k), PDP_8*p_z(1)) )
               if (1.0d0*F_zth_m(i,j,k).lt.PDP_8*p_z(1)) then
                   F_zth_m(i,j,k) = PDP_8*p_z(1)
                   F_zth  (i,j,k) = 0.0
               elseif (1.0d0*F_zth_m(i,j,k).gt.PDM_8*p_z(F_nk)) then
                   F_zth_m(i,j,k) = pdm_8*p_z(F_nk)
                   F_zth  (i,j,k) = 0.0
               endif
               ! 
               !TRAJECTORY
               !----------
               F_zth_m(i,j,k) = 0.5D0*(F_zth_m(i,j,k) + p_z(k))
               ! 
               !TLM
               !---
               F_zth(i,j,k) = 0.5D0*(F_zth(i,j,k))
               ! 
            enddo
         enddo
      enddo

   enddo DO_ITER

   call adx_trajex2_tl(F_px  ,F_py  ,F_xct1  ,F_yct1  ,F_zct1  ,F_xcth  ,F_ycth  ,F_zcth  ,&
                       F_px_m,F_py_m,F_xct1_m,F_yct1_m,F_zct1_m,F_xcth_m,F_ycth_m,F_zcth_m,&
                       i0,in,j0,jn,F_ni,F_nj,F_nk)

   do j = j0,jn
      do i = i0,in
         !
         !TRAJECTORY
         !----------
         F_pz_m(i,j,1)    = p_z(1)
         F_pz_m(i,j,F_nk) = p_z(F_nk)
         !
         !TLM
         !---
         F_pz(i,j,1)    = 0. 
         F_pz(i,j,F_nk) = 0. 
         !
      enddo
   enddo

   do k = 2,F_nk-1
      do j = j0,jn
         do i = i0,in
            !
            !TRAJECTORY
            !----------
            F_pz_m(i,j,k) = F_zth_m(i,j,k) - p_z(k)
            F_pz_m(i,j,k) = p_z(k) + 2.0 * F_pz_m(i,j,k)
            !
            !TLM
            !---
            F_pz(i,j,k) = F_zth(i,j,k) 
            F_pz(i,j,k) = 2.0 * F_pz(i,j,k)
            !
         enddo
      enddo
   enddo

   call msg(MSG_DEBUG,'adx_main_2_pos_tl ('//trim(F_l_S)//') [end]')
   !---------------------------------------------------------------------
   return
end subroutine adx_main_2_pos3_tl
