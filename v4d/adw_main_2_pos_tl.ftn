!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/r adw_main_2_pos_tl - TLM of adw_main_2_pos when Adw_nosetint_L=.TRUE. 
*
#include "model_macros_f.h"
#include "constants.h"
#include "msg.h"
*
      subroutine adw_main_2_pos_tl(
     $                             F_it  ,F_l_S ,F_nk  ,
*
     $                             F_px  ,F_py  ,F_pz  ,
     $                             F_u   ,F_v   ,F_w   ,
     $                             F_xth ,F_yth ,F_zth ,
     $                             F_xcth,F_ycth,F_zcth,
     $                             F_xct1,F_yct1,F_zct1,
     $                             F_pxc ,F_pyc , 
*
     $                             F_px_m  ,F_py_m  ,F_pz_m  ,
     $                             F_u_m   ,F_v_m   ,F_w_m   ,
     $                             F_xth_m ,F_yth_m ,F_zth_m ,
     $                             F_xcth_m,F_ycth_m,F_zcth_m,
     $                             F_xct1_m,F_yct1_m,F_zct1_m,
     $                             F_pxc_m ,F_pyc_m)
*
      implicit none
*
      integer F_it,F_nk
      character(len=1) :: F_l_S
      real F_px(*)  ,F_py(*)  ,F_pz(*),
     $     F_u(*)   ,F_v(*)   ,F_w(*),
     $     F_xth(*) ,F_yth(*) ,F_zth(*),
     $     F_xcth(*),F_ycth(*),F_zcth(*),
     $     F_xct1(*),F_yct1(*),F_zct1(*),
     $     F_pxc(*) ,F_pyc(*)
*
      real F_px_m(*)  ,F_py_m(*)  ,F_pz_m(*),
     $     F_u_m(*)   ,F_v_m(*)   ,F_w_m(*),
     $     F_xth_m(*) ,F_yth_m(*) ,F_zth_m(*),
     $     F_xcth_m(*),F_ycth_m(*),F_zcth_m(*),
     $     F_xct1_m(*),F_yct1_m(*),F_zct1_m(*),
     $     F_pxc_m(*) ,F_pyc_m(*)
*
*author
*     monique tanguay
*
*revision
* v2_31 - Tanguay M.        - initial MPI version
* v3_00 - Tanguay M.        - adapt to restructured adw_main 
* v3_11 - Tanguay M.        - AIXport+Opti+OpenMP for TLM-ADJ
* v3_20 - Tanguay M.        - Optimized SETINT/TRILIN
*                           - TLM of Change test a lower and upper boundaries
* v3_21 - Tanguay M.        - Call adw_main_2_pos_noset_tl based on Adw_nosetint_L
* v3_30 - Tanguay M.        - correct calculation for LAM when Glb_pil gt 7 
*                           - correct parameters adw_trilin_turbo_tl
* v4_04 - Tanguay M.        - Staggered version TL/AD 
* v4_10 - Tanguay M.        - VMM replacement with GMM for (TL/AD)
* v4_12 - Tanguay M.        - TL/AD Thermo upstream positions
*
*language
*     fortran 77
*
*object
*     see id section
*
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
* F_it   | total number of iterations for trajectory             |  i  |
*        |                                                       |     |
* F_u,F_v| input:  3 components of wind on advection grid        |  io |
* F_w    | output: 3 upstream positions valid at t1              |     |
*________|_______________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
!      logical G_lam
!      integer G_nk
!      logical l_north, l_south, l_east, l_west
!      integer l_ni, l_nj, l_nk, l_niu, l_njv
!      integer l_minx, l_maxx, l_miny, l_maxy
!      integer pil_n,pil_s,pil_w,pil_e
#include "adw.cdk"
#include "cstv.cdk"
!      real*8    Cstv_dt_8
#include "ver.cdk"
!      #include "type.cdk"
!      type (vertical_8) Ver_z_8  
#include "schm.cdk"
!      logical schm_zdotmid_l
#include "lun.cdk"
*
************************************************************************
      integer i, j, k, n, nm, ij, ijk, nij, nijk, it
      integer i1,j1,k1,ier,i0,in,j0,jn
*
      integer, dimension(l_ni*l_nj*F_nk) :: n1_m,loci,locj,lock
      real,    dimension(l_ni*l_nj*F_nk) :: capx1,capy1,capz1
      real,    dimension(l_ni*l_nj*F_nk) :: wrkx1,wrky1,wrk_yth
*
      real,    dimension(l_ni*l_nj*F_nk) :: capx1_m,capy1_m,capz1_m
      real,    dimension(l_ni*l_nj*F_nk) :: wrkx1_m,wrky1_m,wrk_yth_m
*
      real dummy, dth
      real*8 r2pi_8,TWO_8,HALF_8,pdp_8,pdm_8
      parameter (TWO_8=2.0,HALF_8=0.5)
*
      real*8 ,dimension(:), pointer :: p_z_8
*
************************************************************************
*TEMPORAIRE
*     Zero adjoint variables
*     ----------------------
      wrkx1 = 0.
      wrky1 = 0.
      wrk_yth = 0.
      capx1   = 0.
      capy1   = 0.
      capz1   = 0.
*
      if (Schm_zdotMid_L) call handle_error(-1,'adw_main_2_pos_tl','Schm_zdotMid_L not DONE')
*
      if (Lun_debug_L) write (Lun_out,1000)
*
      nij    = l_ni   *l_nj
      nijk   = l_ni   *l_nj   *F_nk
*
      r2pi_8 = TWO_8 * CONST_PI_8 
      dth    = Cstv_dt_8/2.
      pdp_8  = 1.d0 + 1.d-6
      pdm_8  = 1.d0 - 1.d-6
*
      if(F_l_S.eq.'m')then
         p_z_8 =>Ver_z_8%m
         call msg(MSG_DEBUG,'TLM of CALC UPSTREAM MOMENTUM POSITIONS: (S/R ADW_MAIN_2_POS_TL)')
      else if(F_l_S.eq.'t')then
         p_z_8 =>Ver_z_8%t
         call msg(MSG_DEBUG,'TLM of CALC UPSTREAM THERMO   POSITIONS: (S/R ADW_MAIN_2_POS_TL)')
      else
         call handle_error(-1,'adw_main_2_pos_tl','wrong level descriptor')
      endif
*
************************************************************************
*
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west)  i0=pil_w
          if (l_east)  in=l_niu - pil_e + 2
          if (l_south) j0=pil_s
          if (l_north) jn=l_njv - pil_n + 2
      endif
*
************************************************************************
      do it=1,F_it ! begin iterations loop
************************************************************************
*
*        ==================================================================
*        3d interpolation of u and v winds
*        ==================================================================
*
         do n = 1,nijk
*
*           TRAJECTORY
*           ----------
            wrk_yth_m(n) = F_yth_m(n)
*
*           TLM 
*           ---
            wrk_yth(n) = F_yth(n)
*
         enddo
*
         if (G_lam) then
            call adw_cliptraj_tl (F_xth,wrk_yth,F_xth_m,wrk_yth_m,i0,in,j0,jn,F_nk,'POS1_TL')
         else
*           NOT DONE YET
         endif
*
         if( .not. Adw_nosetint_L ) then
*
         call adw_setint_tl (       capx1  , dummy, dummy  , capy1    , dummy  , 
     %                       dummy, capz1  , dummy, F_xth  , wrk_yth  , F_zth  , 
     %                        n1_m, capx1_m, dummy, dummy  , capy1_m  , dummy  , 
     %                       dummy, capz1_m, dummy, F_xth_m, wrk_yth_m, F_zth_m, 
     %                       .true., .true., .true.,nijk,i0,in,j0,jn,F_nk)
*
         call adw_trilin_tl(wrkx1  ,F_u  ,         capx1  ,capy1  ,capz1  ,
     %                      wrkx1_m,F_u_m,1.0,n1_m,capx1_m,capy1_m,capz1_m,
     %                      nijk,i0,in,j0,jn,F_nk)
         call adw_trilin_tl(wrky1  ,F_v  ,         capx1  ,capy1  ,capz1  ,
     %                      wrky1_m,F_v_m,1.0,n1_m,capx1_m,capy1_m,capz1_m,
     %                      nijk,i0,in,j0,jn,F_nk)
*
         else
*
         call adw_trilin_turbo_tl (wrkx1,  F_u,  1.0,F_xth,  wrk_yth,  F_zth,  
     %                             wrkx1_m,F_u_m,    F_xth_m,wrk_yth_m,F_zth_m,
     %                             capx1_m,capy1_m,capz1_m,
     %                             loci,locj,lock,nijk,i0,in,j0,jn,F_nk,.true.,.true.)
*
         call adw_trilin_turbo_tl (wrky1,  F_v,  1.0,F_xth,  wrk_yth,  F_zth,  
     %                             wrky1_m,F_v_m,    F_xth_m,wrk_yth_m,F_zth_m,
     %                             capx1_m,capy1_m,capz1_m,
     %                             loci,locj,lock,nijk,i0,in,j0,jn,F_nk,.false.,.false.)
*
         endif
*
*        ==================================================================
*        Compute new upstream positions along x and y
*        ==================================================================
*
************************************************************************
         call adw_trajsp_tl ( F_xth,  F_yth,  F_xcth,  F_ycth,  F_zcth,  wrkx1,  wrky1, 
     %                        F_xth_m,F_yth_m,F_xcth_m,F_ycth_m,F_zcth_m,wrkx1_m,wrky1_m,dth,
     %                        i0,in,j0,jn)
************************************************************************
*
*        ==================================================================
*        3D interpolation of zeta dot
*        ==================================================================
*
         do n = 1,nijk
*
*           TRAJECTORY
*           ----------
            wrk_yth_m(n) = F_yth_m(n)
*
*           TLM
*           ---
            wrk_yth(n) = F_yth(n)
*
         enddo
*
         if (G_lam) then
             if (.not.Schm_zdotMid_L)
     %       call adw_cliptraj_tl (F_xth, wrk_yth, F_xth_m, wrk_yth_m, i0, in, j0, jn, F_nk, 'POS2_TL')
         else
*            NOT DONE YET
         endif
*
         if( .not. Adw_nosetint_L ) then
*
             call adw_setint_tl (        capx1  , dummy, dummy  , capy1    , dummy  ,  
     %                            dummy, capz1  , dummy, F_xth  , wrk_yth  , F_zth  ,  
     %                            n1_m , capx1_m, dummy, dummy  , capy1_m  , dummy  ,  
     %                            dummy, capz1_m, dummy, F_xth_m, wrk_yth_m, F_zth_m,  
     %                            .true., .true., .true., nijk,i0,in,j0,jn,F_nk)
*
             call adw_trilin_tl (wrkx1  ,F_w  ,          capx1  ,capy1  ,capz1  ,
     %                           wrkx1_m,F_w_m,-dth,n1_m,capx1_m,capy1_m,capz1_m,
     %                           nijk,i0,in,j0,jn,F_nk)
*
         else
*
         call adw_trilin_turbo_tl (wrkx1,  F_w,  -dth,F_xth,  wrk_yth,  F_zth,  
     %                             wrkx1_m,F_w_m,     F_xth_m,wrk_yth_m,F_zth_m,
     %                             capx1_m,capy1_m,capz1_m,
     %                             loci,locj,lock,nijk,i0,in,j0,jn,F_nk,.true.,.true.)
*
         endif
*
************************************************************************
*
*        ==================================================================
*        Compute new upstream position along zeta
*        ==================================================================
*
         do k = 2,F_nk-1
            do j = j0,jn
            do i = i0,in
*
               n = (k-1)*nij + ((j-1)*l_ni) + i
*
*              TRAJECTORY
*              ----------
               F_zth_m(n) = p_z_8(k) + TWO_8*wrkx1_m(n)
*
*              TLM
*              ---
               F_zth(n) = TWO_8*wrkx1(n)
*
*              TRAJECTORY and TLM
*              ------------------
*              Make sure F_zth is below p_z_8(1) and above p_z_8(F_nk)
               F_zth_m(n) = min( pdm_8*p_z_8(F_nk),
     %              max( 1.0d0*F_zth_m(n), pdp_8*p_z_8(1) ) )
               if (1.0d0*F_zth_m(n).lt.pdp_8*p_z_8(1)) then
                   F_zth_m(n) = pdp_8*p_z_8(1) 
                   F_zth  (n) = 0.0 
               elseif (1.0d0*F_zth_m(n).gt.pdm_8*p_z_8(F_nk)) then
                   F_zth_m(n) = pdm_8*p_z_8(F_nk)
                   F_zth  (n) = 0.0 
               endif
*
*              TRAJECTORY and TLM
*              ------------------
               F_zth_m(n) = HALF_8*(F_zth_m(n) + p_z_8(k))
               F_zth  (n) = HALF_8*(F_zth  (n)           )
*
            enddo
            enddo
         enddo
*
************************************************************************
      enddo ! end of iterations loop
************************************************************************
*
      call adw_trajex_tl (F_px,  F_py,  F_xct1,  F_yct1,  F_zct1,  F_xcth,  F_ycth,  F_zcth,
     %                    F_px_m,F_py_m,F_xct1_m,F_yct1_m,F_zct1_m,F_xcth_m,F_ycth_m,F_zcth_m,
     %                    i0,in,j0,jn)
*
      do j = j0,jn
      do i = i0,in
         n = ((j-1)*l_ni) + i   !for k=1
*
*        TRAJECTORY
*        ----------
         F_pz_m(n) = p_z_8(1)
*
*        TLM
*        ---
         F_pz(n) = 0. 
*
         n = (F_nk-1)*nij+((j-1)*l_ni) + i !for k=F_nk
*
*        TRAJECTORY
*        ----------
         F_pz_m(n) = p_z_8(F_nk)
*
*        TLM
*        ---
         F_pz(n) = 0. 
*
      enddo
      enddo
*
      do k = 2,F_nk-1
         do j = j0,jn
         do i = i0,in
            n=(k-1)*nij+((j-1)*l_ni) + i
* 
*           TRAJECTORY
*           ----------
            F_pz_m(n) = F_zth_m(n) - p_z_8(k)
            F_pz_m(n) = p_z_8(k) + 2.0 * F_pz_m(n)
*
*           TLM
*           ---
            F_pz(n) = F_zth(n) 
            F_pz(n) = 2.0 * F_pz(n)
*
         enddo
         enddo
      enddo
*
      if(F_l_S.eq.'t')then
*
         do j = j0,jn
         do i = i0,in
            n = ((j-1)*l_ni) + i !for k=1
*
*           TRAJECTORY
*           ----------
            F_px_m(n) = F_pxc_m(n)
            F_py_m(n) = F_pyc_m(n)
*
*           TLM
*           ---
            F_px(n) = F_pxc(n)
            F_py(n) = F_pyc(n)
*
            n  = l_nk*nij+((j-1)*l_ni) + i !for k=l_nk+1
            nm = (l_nk-1)*nij+((j-1)*l_ni) + i !for k=l_nk
*
*           TRAJECTORY
*           ----------
            F_px_m(n) = F_pxc_m(nm)
            F_py_m(n) = F_pyc_m(nm)
*
*           TLM
*           ---
            F_px(n) = F_pxc(nm)
            F_py(n) = F_pyc(nm)
*
         enddo
         enddo
*
      endif
*
 1000 format(3X,'TLM of CALC UPSTREAM POSITIONS: (S/R ADW_MAIN_2_POS_TL)')
*
      return
      end
