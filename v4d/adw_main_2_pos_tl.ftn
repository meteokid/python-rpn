! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r adw_main_2_pos_tl - TLM of adw_main_2_pos when Adw_nosetint_L=.TRUE. 
*
#include "model_macros_f.h"
*
      subroutine adw_main_2_pos_tl ( F_it, F_u, F_v, F_w, F_u_m, F_v_m, F_w_m )
*
      implicit none
*
      integer F_it
      real F_u  (*),F_v  (*),F_w  (*)
      real F_u_m(*),F_v_m(*),F_w_m(*)
*
*author
*     monique tanguay
*
*revision
* v2_31 - Tanguay M.        - initial MPI version
* v3_00 - Tanguay M.        - adapt to restructured adw_main 
* v3_11 - Tanguay M.        - AIXport+Opti+OpenMP for TLM-ADJ
* v3_20 - Tanguay M.        - Optimized SETINT/TRILIN
*                           - TLM of Change test a lower and upper boundaries
* v3_21 - Tanguay M.        - Call adw_main_2_pos_noset_tl based on Adw_nosetint_L
* v3_30 - Tanguay M.        - correct calculation for LAM when Glb_pil gt 7 
*                           - correct parameters adw_trilin_turbo_tl
* v4_04 - Tanguay M.        - Staggered version TL/AD 
*
*language
*     fortran 77
*
*object
*     see id section
*
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
* F_it   | total number of iterations for trajectory             |  i  |
*        |                                                       |     |
* F_u,F_v| input:  3 components of wind on advection grid        |  io |
* F_w    | output: 3 upstream positions valid at t1              |     |
*________|_______________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "lun.cdk"
#include "type.cdk"
#include "adw.cdk"
#include "dcst.cdk"
#include "cstv.cdk"
#include "vth.cdk"
#include "vt1.cdk"
#include "v4dg.cdk"
#include "lctl.cdk"
#include "ver.cdk"
#include "geomg.cdk"
#include "vth_m.cdk"
#include "vt1_m.cdk"
#include "schm.cdk"
*
*modules
      integer  vmmlod, vmmget, vmmuld
      external vmmlod, vmmget, vmmuld
************************************************************************
      integer pnerr, pnlkey1(30), pnlod
*
      integer i, j, k, n, ij, ijk, nij, nijk, it, kmin, kmax
      integer i1,j1,k1,nn
*
      integer, dimension(l_ni*l_nj*l_nk) :: n1
      real,    dimension(l_ni*l_nj*l_nk) :: capx1,capy1,capz1
      real,    dimension(l_ni*l_nj*l_nk) :: wrkx1,wrky1,wrkz1,wrkc1,wrk_yth
*
      integer, dimension(l_ni*l_nj*l_nk) :: n1_m
      real,    dimension(l_ni*l_nj*l_nk) :: capx1_m,capy1_m,capz1_m
      real,    dimension(l_ni*l_nj*l_nk) :: wrkx1_m,wrky1_m,wrkz1_m,wrkc1_m,wrk_yth_m
*
      real dummy, dth
      real*8 r2pi_8,TWO_8,HALF_8,pdp_8,pdm_8
      parameter (TWO_8 = 2.0,HALF_8=0.5)

      integer i0,in,j0,jn
************************************************************************
*
      if (Schm_zdotMid_L) call gem_stop('adw_main_2_pos_noset_TL : Schm_zdotMid_L not DONE    ',-1)
*
      if (Lun_debug_L) write (Lun_out,1000)
*
      nij    = l_ni   *l_nj
      nijk   = l_ni   *l_nj   *l_nk
*
      r2pi_8 = TWO_8 * Dcst_pi_8
      dth    = Cstv_dt_8/2.
      pdp_8  = 1.d0 + 1.d-6
      pdm_8  = 1.d0 - 1.d-6
*
      kmin=2
      kmax=l_nk-1
************************************************************************
*
      pnlkey1(1) = VMM_KEY(xth)
      pnlkey1(2) = VMM_KEY(yth)
      pnlkey1(3) = VMM_KEY(zth)
      pnlkey1(4) = VMM_KEY(xcth)
      pnlkey1(5) = VMM_KEY(ycth)
      pnlkey1(6) = VMM_KEY(zcth)
      pnlkey1(7) = VMM_KEY(xct1)
      pnlkey1(8) = VMM_KEY(yct1)
      pnlkey1(9) = VMM_KEY(zct1)
      pnlod = 9
*
*     TRAJECTORY
*     ----------
      pnlkey1(1+pnlod) = VMM_KEY(xth_m)
      pnlkey1(2+pnlod) = VMM_KEY(yth_m)
      pnlkey1(3+pnlod) = VMM_KEY(zth_m)
      pnlkey1(4+pnlod) = VMM_KEY(xcth_m)
      pnlkey1(5+pnlod) = VMM_KEY(ycth_m)
      pnlkey1(6+pnlod) = VMM_KEY(zcth_m)
      pnlkey1(7+pnlod) = VMM_KEY(xct1_m)
      pnlkey1(8+pnlod) = VMM_KEY(yct1_m)
      pnlkey1(9+pnlod) = VMM_KEY(zct1_m)
      pnlod = 9+pnlod
*
      pnerr = vmmlod(pnlkey1,pnlod)
*
      pnerr = VMM_GET_VAR(xth)
      pnerr = VMM_GET_VAR(yth)
      pnerr = VMM_GET_VAR(zth)
      pnerr = VMM_GET_VAR(xcth)
      pnerr = VMM_GET_VAR(ycth)
      pnerr = VMM_GET_VAR(zcth)
      pnerr = VMM_GET_VAR(xct1)
      pnerr = VMM_GET_VAR(yct1)
      pnerr = VMM_GET_VAR(zct1)
*
*     TRAJECTORY
*     ----------
      pnerr = VMM_GET_VAR(xth_m)
      pnerr = VMM_GET_VAR(yth_m)
      pnerr = VMM_GET_VAR(zth_m)
      pnerr = VMM_GET_VAR(xcth_m)
      pnerr = VMM_GET_VAR(ycth_m)
      pnerr = VMM_GET_VAR(zcth_m)
      pnerr = VMM_GET_VAR(xct1_m)
      pnerr = VMM_GET_VAR(yct1_m)
      pnerr = VMM_GET_VAR(zct1_m)
*
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west)  i0=pil_w
          if (l_east)  in=l_niu - pil_e + 2
          if (l_south) j0=pil_s
          if (l_north) jn=l_njv - pil_n + 2
      endif
*
************************************************************************
      do it=1,F_it
************************************************************************
*
*     ==================================================================
*     3d interpolation of u and v winds
*     ==================================================================
*
      do n = 1,nijk
*
*     TRAJECTORY
*     ----------
      wrk_yth_m(n) = yth_m(n)
*
*     TLM 
*     ---
      wrk_yth(n) = yth(n)
*
      enddo
*
      if (G_lam) then
          call adw_cliptraj_tl (xth, wrk_yth, xth_m, wrk_yth_m, i0, in, j0, jn, G_nk, 'POS1_TL')
      else
*     NOT DONE YET
      endif
*
      Adw_hor_L = .true. 
      Adw_ver_L = .true.
*
      call adw_trilin_turbo_tl (wrkx1,  F_u,  1.0,xth,  wrk_yth,  zth,
     %                          wrkx1_m,F_u_m,    xth_m,wrk_yth_m,zth_m,
     %                          capx1_m,capy1_m,capz1_m,Adw_Fn_I,
     %                          nijk,i0,in,j0,jn,l_nk,'m')
*
      call adw_trilin_turbo_tl (wrky1,  F_v,  1.0,xth,  wrk_yth,  zth,
     %                          wrky1_m,F_v_m,    xth_m,wrk_yth_m,zth_m,
     %                          capx1_m,capy1_m,capz1_m,Adw_Fn_I,
     %                          nijk,i0,in,j0,jn,l_nk,'m')
*
*     ==================================================================
*     Compute new upstream postions along x and y
*     ==================================================================
*
************************************************************************
      call adw_trajsp_tl ( xth,  yth,  xcth,  ycth,  zcth,  wrkx1,  wrky1, 
     %                     xth_m,yth_m,xcth_m,ycth_m,zcth_m,wrkx1_m,wrky1_m,dth,
     %                     i0,in,j0,jn)
************************************************************************
*
*     ==================================================================
*     3D interpolation of zeta dot
*     ==================================================================
*
      do n = 1,nijk
*
*     TRAJECTORY
*     ----------
      wrk_yth_m(n) = yth_m(n)
*
*     TLM
*     ---
      wrk_yth(n) = yth(n)
*
      enddo
*
      if (G_lam) then
          if (.not.Schm_zdotMid_L)
     %    call adw_cliptraj_tl (xth, wrk_yth, xth_m, wrk_yth_m, i0, in, j0, jn, G_nk, 'POS2_TL')
      else
*     NOT DONE YET
      endif
*
      Adw_hor_L = .true.
      Adw_ver_L = .true.
      call adw_trilin_turbo_tl (wrkx1,  F_w,  -dth,xth,  wrk_yth,  zth, 
     %                          wrkx1_m,F_w_m,     xth_m,wrk_yth_m,zth_m,
     %                          capx1_m,capy1_m,capz1_m,Adw_Fn_I,
     %                          nijk,i0,in,j0,jn,l_nk,'t')
*
************************************************************************
*
*     ==================================================================
*     Compute new upstream position along zeta
*     ==================================================================
*
C!$omp parallel private(n)
C!$omp do
      do k = kmin,kmax
      do j = j0,jn
      do i = i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
*        TRAJECTORY
*        ----------
         zth_m(n) = Ver_z_8%m(k) + TWO_8*wrkx1_m(n)
*
*        TLM
*        ---
         zth(n) = TWO_8*wrkx1(n)
*
*        TRAJECTORY and TLM
*        ------------------
*        The following min statement is expanded as two IF blocks:
*        zth_m(n) = min( pdm_8*Ver_z_8%m(l_nk), max( 1.0d0*zth_m(n), pdp_8*Ver_z_8%m(1) ) 
*
         if (1.0d0*zth_m(n).lt.pdp_8*Ver_z_8%m(1)) then
             zth_m(n) = pdp_8*Ver_z_8%m(1)
             zth  (n) = 0.
         elseif (1.0d0*zth_m(n).gt.pdm_8*Ver_z_8%m(l_nk)) then
             zth_m(n) = pdm_8*Ver_z_8%m(l_nk)
             zth  (n) = 0.
         endif
*
*        TRAJECTORY and TLM
*        ------------------
         zth_m(n) = HALF_8*(zth_m(n) + Ver_z_8%m(k)) 
         zth  (n) = HALF_8*(zth  (n)               ) 
*
      enddo
      enddo
      enddo
C!$omp enddo
C!$omp end parallel
*
************************************************************************
      enddo ! end of iterations loop
************************************************************************
*
      call adw_trajex_tl (F_u,  F_v,  xct1,  yct1,  zct1,  xcth,  ycth,  zcth,
     %                    F_u_m,F_v_m,xct1_m,yct1_m,zct1_m,xcth_m,ycth_m,zcth_m,
     %                    i0,in,j0,jn)
*
C!$omp parallel private(n)
C!$omp do
      do j = j0,jn
      do i = i0,in
         n = ((j-1)*l_ni) + i   !for k=1
*
*        TRAJECTORY
*        ----------
         F_w_m(n) = Ver_z_8%m(1) 
*
*        TLM 
*        ---
         F_w(n) = 0. 
*
         n = (l_nk-1)*nij+((j-1)*l_ni) + i !for k=l_nk
*
*        TRAJECTORY
*        ----------
         F_w_m(n) = Ver_z_8%m(l_nk) 
*
*        TLM 
*        ---
         F_w(n) = 0. 
*
      enddo
      enddo
C!$omp enddo
*
C!$omp do
      do k = kmin,kmax
         do j = j0,jn
         do i = i0,in
            n=(k-1)*nij+((j-1)*l_ni) + i
*
*           TRAJECTORY
*           ----------
            F_w_m(n) = zth_m(n) - Ver_z_8%m(k)
            F_w_m(n) = Ver_z_8%m(k) + 2.0 * F_w_m(n)
*
*           TLM
*           ---
            F_w(n) = zth(n) 
            F_w(n) = 2.0 * F_w(n)
*
         enddo
         enddo
      enddo
C!$omp enddo
*
C!$omp end parallel
*
      pnerr = vmmuld(-1,0)
*
 1000  format(3X,'TLM of CALC UPSTREAM POSITIONS: (S/R ADW_MAIN_2_POS_NOSET_TL)')
      return
      end
