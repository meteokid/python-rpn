! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r adw_main_2_pos_ad - ADJ of adw_main_2_pos_tl when Adw_nosetint_L=.TRUE. 
*
#include "model_macros_f.h"
*
      subroutine adw_main_2_pos_ad ( F_it, F_u, F_v, F_w, F_u_m, F_v_m, F_w_m )
*
      implicit none
*
      integer F_it
      real F_u  (*),F_v  (*),F_w  (*)
      real F_u_m(*),F_v_m(*),F_w_m(*)
*
*author
*     monique tanguay
*
*revision
* v2_31 - Tanguay M.        - initial MPI version
* v3_00 - Tanguay M.        - adapt to restructured adw_main 
* v3_00 - Tanguay M.        - restore vectorization in adjoint of semi-Lag.
* v3_03 - Tanguay M.        - Adjoint Lam configuration 
* v3_11 - Tanguay M.        - Remove restoration of vectorization in adjoint of semi-Lag
*                           - AIXport+Opti+OpenMP for TLM-ADJ
* v3_20 - Tanguay M.        - Optimized SETINT/TRILIN
*                           - ADJ of Change test a lower and upper boundaries
* v3_21 - Tanguay M.        - Call adw_main_2_pos_noset_ad based on Adw_nosetint_L
* v3_30 - Tanguay M.        - correct calculation for LAM when Glb_pil gt 7 
* v4_04 - Tanguay M.        - Staggered version TL/AD 
* v4_10 - Tanguay M.        - VMM replacement with GMM for (TL/AD)
*
*language
*     fortran 77
*
*object
*     see id section
*
*ADJ of
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
* F_it   | total number of iterations for trajectory             |  i  |
*        |                                                       |     |
* F_u,F_v| input:  3 components of wind on advection grid        |  io |
* F_w    | output: 3 upstream positions valid at t1              |     |
*________|_______________________________________________________|_____|
*
*implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "lun.cdk"
#include "type.cdk"
#include "adw.cdk"
#include "dcst.cdk"
#include "cstv.cdk"
#include "vth.cdk"
#include "vt1.cdk"
#include "v4dg.cdk"
#include "lctl.cdk"
#include "ver.cdk"
#include "geomg.cdk"
#include "vth_m.cdk"
#include "vt1_m.cdk"
#include "schm.cdk"
#include "step.cdk"
*
*modules
************************************************************************
      integer i, j, k, n, ij, ijk, nij, nijk, it, kmin, kmax
*
      real,    dimension(l_ni*l_nj*l_nk) :: wrkx1,wrky1,wrkz1,wrkc1,wrk_yth
*
      real,    dimension(l_ni*l_nj*l_nk) :: wrkx1_m,wrky1_m,wrkz1_m,wrkc1_m,wrk_yth_m
*
      real dth
      real*8 ZERO_8,TWO_8,HALF_8,pdp_8,pdm_8
      parameter (ZERO_8 = 0.0,TWO_8 = 2.0,HALF_8=0.5)
*
*     -----------------------
*     Define extra space TRAJ
*     -----------------------
      integer ind(F_it)
*
      integer i0,in,j0,jn
*
      integer Fn_I_1(l_ni*l_nj*l_nk*F_it),
     %        Fn_I_2(l_ni*l_nj*l_nk*F_it)
*
      real capx1_1_m(l_ni*l_nj*l_nk*F_it),
     %     capy1_1_m(l_ni*l_nj*l_nk*F_it),
     %     capz1_1_m(l_ni*l_nj*l_nk*F_it),
*
     %     capx1_2_m(l_ni*l_nj*l_nk*F_it),
     %     capy1_2_m(l_ni*l_nj*l_nk*F_it),
     %     capz1_2_m(l_ni*l_nj*l_nk*F_it),
*
     %     yth_3_m  (l_ni*l_nj*l_nk*F_it),
     %     xcth_3_m (l_ni*l_nj*l_nk*F_it),
     %     ycth_3_m (l_ni*l_nj*l_nk*F_it),
     %     zcth_3_m (l_ni*l_nj*l_nk*F_it),
     %     wrkx1_3_m(l_ni*l_nj*l_nk*F_it),
     %     wrky1_3_m(l_ni*l_nj*l_nk*F_it),
*
     %     zth_5_m (l_ni*l_nj*l_nk*F_it)
*
      real xth_m_ref1(l_ni*l_nj*l_nk,F_it),wrk_yth_m_ref1(l_ni*l_nj*l_nk,F_it)
      real xth_m_ref2(l_ni*l_nj*l_nk,F_it),wrk_yth_m_ref2(l_ni*l_nj*l_nk,F_it)
*
************************************************************************
*
      if (Schm_zdotMid_L) call gem_stop('adw_main_2_pos_noset_AD : Schm_zdotMid_L not DONE    ',-1)
*
      if (Lun_debug_L) write (Lun_out,1000)
*
*     ---------------
*     Initializations 
*     ---------------
      nij    = l_ni   *l_nj
      nijk   = l_ni   *l_nj   *l_nk
*
      dth    = Cstv_dt_8/2.
      pdp_8  = 1.d0 + 1.d-6
      pdm_8  = 1.d0 - 1.d-6
*
      kmin=2
      kmax=l_nk-1
*
*     Set positions in extra space TRAJ
*     ---------------------------------
      do it = 1,F_it
         ind(it) = nijk*(it-1) + 1
      enddo
************************************************************************
*
C!$omp parallel do private (n)
      do n = 1,nijk
*
*        Set localization indices to 0 at it=1 
*        -------------------------------------
         Fn_I_1 (n) = transfer(-1,1.0)
*
*        Zero adjoint variables 
*        ----------------------
         wrkx1(n)   = ZERO_8
         wrky1(n)   = ZERO_8
         wrkz1(n)   = ZERO_8
         wrkc1(n)   = ZERO_8
*
         wrk_yth(n) = ZERO_8
*
      enddo
C!$omp end parallel do 
*
*     -----------------
*     Do VMM allocation 
*     -----------------
      gmmstat = gmm_get(gmmk_xth_s,xth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(xth)'
      gmmstat = gmm_get(gmmk_yth_s,yth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(yth)'
      gmmstat = gmm_get(gmmk_zth_s,zth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(zth)'

      gmmstat = gmm_get(gmmk_xcth_s,xcth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(xcth)'
      gmmstat = gmm_get(gmmk_ycth_s,ycth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(ycth)'
      gmmstat = gmm_get(gmmk_zcth_s,zcth,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(zcth)'

      gmmstat = gmm_get(gmmk_xct1_s,xct1,tmp_meta1d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(xct1)'
      gmmstat = gmm_get(gmmk_yct1_s,yct1,tmp_meta1d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(yct1)'
      gmmstat = gmm_get(gmmk_zct1_s,zct1,tmp_meta1d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(zct1)'

*     TRAJECTORY
*     ----------
      gmmstat = gmm_get(gmmk_xth_m_s,xth_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(xth_m)'
      gmmstat = gmm_get(gmmk_yth_m_s,yth_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(yth_m)'
      gmmstat = gmm_get(gmmk_zth_m_s,zth_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(zth_m)'

      gmmstat = gmm_get(gmmk_xcth_m_s,xcth_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(xcth_m)'
      gmmstat = gmm_get(gmmk_ycth_m_s,ycth_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(ycth_m)'
      gmmstat = gmm_get(gmmk_zcth_m_s,zcth_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(zcth_m)'

      gmmstat = gmm_get(gmmk_xct1_m_s,xct1_m,tmp_meta1d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(xct1_m)'
      gmmstat = gmm_get(gmmk_yct1_m_s,yct1_m,tmp_meta1d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(yct1_m)'
      gmmstat = gmm_get(gmmk_zct1_m_s,zct1_m,tmp_meta1d)
      if (GMM_IS_ERROR(gmmstat)) print *,'adw_main_2_pos_ad ERROR at gmm_get(zct1_m)'
*
*     ------------------
*     TRAJECTORY (START)
*     ------------------
*
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west)  i0=pil_w
          if (l_east)  in=l_niu - pil_e + 2
          if (l_south) j0=pil_s
          if (l_north) jn=l_njv - pil_n + 2
      endif
*
************************************************************************
      do it=1,F_it
************************************************************************
*
*     ==================================================================
*     3d interpolation of u and v winds
*     ==================================================================
*
      do n = 1,nijk
*
*     TRAJECTORY
*     ----------
      wrk_yth_m(n) = yth_m(n)
*
      enddo
*
      if (G_lam) then
*
          if (Step_cliptraj_L) then
          do n=1,l_ni*l_nj*l_nk
                 xth_m_ref1(n,it) =     xth_m(n)
             wrk_yth_m_ref1(n,it) = wrk_yth_m(n)
          enddo
          endif
          call adw_cliptraj (xth_m, wrk_yth_m, i0, in, j0, jn, G_nk, 'POS1_TR')
*
      else
*     NOT DONE YET
      endif
*
      Adw_hor_L = .true.  
      Adw_ver_L = .true.
*     --------------------------------------------------
*     Preserve Fn_Im capx1m capy1m capz1m for ADJOINT #1
*     --------------------------------------------------
*
      call adw_trilin_turbo_tr (wrkx1_m,F_u_m,1.0,xth_m,wrk_yth_m,zth_m,
     %                          capx1_1_m(ind(it)),capy1_1_m(ind(it)),capz1_1_m(ind(it)),
     %                          Fn_I_1(ind(it)),nijk,i0,in,j0,jn,l_nk,'m')
*
      call adw_trilin_turbo (wrky1_m,F_v_m,1.0,xth_m,wrk_yth_m,zth_m,
     %                       capz1_1_m(ind(it)),
     %                       Fn_I_1(ind(it)),nijk,i0,in,j0,jn,l_nk,'m')
*
C!$omp parallel do private(ijk)
      do ijk=1,nijk
*
*        ------------------------------------------------------------
*        Preserve ythm xcthm ycthm zcthm wrkx1m wrky1m for ADJOINT #3
*        ------------------------------------------------------------
         yth_3_m  (ind(it)+ijk-1) = yth_m(ijk)
         xcth_3_m (ind(it)+ijk-1) = xcth_m (ijk)
         ycth_3_m (ind(it)+ijk-1) = ycth_m (ijk)
         zcth_3_m (ind(it)+ijk-1) = zcth_m (ijk)
         wrkx1_3_m(ind(it)+ijk-1) = wrkx1_m(ijk)
         wrky1_3_m(ind(it)+ijk-1) = wrky1_m(ijk)
*
*        ------------------------------------------------
*        Set Fn_I_2 = Fn_I_1 
*        NOTE: Fn_I_2 will be changed by adw_trilin_turbo
*        ------------------------------------------------
         Fn_I_2  (ind(it)+ijk-1) = Fn_I_1(ind(it)+ijk-1)
*
      enddo
C!$omp end parallel do  
*
************************************************************************
      call adw_trajsp ( xth_m, yth_m, xcth_m, ycth_m, zcth_m, wrkx1_m, wrky1_m, dth,
     %                  i0,in,j0,jn)
************************************************************************
*
*     ==================================================================
*     3D interpolation of zeta dot
*     ==================================================================
*
      do n = 1,nijk
*
*     TRAJECTORY
*     ----------
      wrk_yth_m(n) = yth_m(n)
*
      enddo
*
      if (G_lam) then
*
          if (.not.Schm_zdotMid_L) then
*
          if (Step_cliptraj_L) then
          do n=1,l_ni*l_nj*l_nk
                 xth_m_ref2(n,it) =     xth_m(n)
             wrk_yth_m_ref2(n,it) = wrk_yth_m(n)
          enddo
          endif
          call adw_cliptraj (xth_m, wrk_yth_m, i0, in, j0, jn, G_nk, 'POS2_TR')
*
          endif
*
      else
*     NOT DONE YET
      endif
*
      Adw_hor_L = .true.
      Adw_ver_L = .true.
*
*     -------------------------------------------------
*     Preserve capx1m capy1m capz1m Fn_I for ADJOINT #2
*     -------------------------------------------------
      call adw_trilin_turbo_tr (wrkx1_m,F_w_m,-dth,xth_m,wrk_yth_m,zth_m,
     %                          capx1_2_m(ind(it)),capy1_2_m(ind(it)),capz1_2_m(ind(it)),
     %                          Fn_I_2(ind(it)),nijk,i0,in,j0,jn,l_nk,'t')
*
************************************************************************
C!$omp parallel private(n,ijk)
*
      if(it.ne.F_it) then
*
*     -------------------------------
*     Reset Fn_I_1 for next iteration
*     -------------------------------
C!$omp do
      do ijk=1,nijk
         Fn_I_1(ind(it+1)+ijk-1) = Fn_I_2(ind(it)+ijk-1)
      enddo
C!$omp enddo
*
      endif
*
C!$omp do
      do k = kmin,kmax
      do j = j0,jn
      do i = i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
         zth_m(n) = Ver_z_8%m(k) + TWO_8*wrkx1_m(n)
*
*        -----------------------------
*        Preserve zthm for ADJOINT #5
*        -----------------------------
         zth_5_m (ind(it)+n)  = zth_m(n)
*
         zth_m(n) = min( pdm_8*Ver_z_8%m(l_nk), max( 1.0d0*zth_m(n), pdp_8*Ver_z_8%m(1) ) )
*
         zth_m(n) = HALF_8 * (zth_m(n) + Ver_z_8%m(k))
*
      enddo
      enddo
      enddo
C!$omp enddo
*
C!$omp end parallel
************************************************************************
      enddo ! end of iterations loop
************************************************************************
*
*     ----------------
*     TRAJECTORY (END)
*     ----------------
*
C!$omp parallel private(n)
*
*     ADJOINT CALCULATIONS
*     --------------------
C!$omp do
      do k = kmax,kmin,-1
         do j = j0,jn
         do i = i0,in
            n=(k-1)*nij+((j-1)*l_ni) + i
*
            F_w(n) = 2.0 * F_w(n)
            zth(n) = F_w(n) + zth(n)
            F_w(n) = ZERO_8
*
         enddo
         enddo
      enddo
C!$omp enddo
*
C!$omp do
      do j = j0,jn
      do i = i0,in
*
         n = ((j-1)*l_ni) + i   !for k=1
*
         F_w(n) = 0.
*
         n = (l_nk-1)*nij+((j-1)*l_ni) + i !for k=l_nk
*
         F_w(n) = 0.
*
      enddo
      enddo
C!$omp enddo
*
C!$omp end parallel
*
      call adw_trajex_ad (F_u, F_v, xct1, yct1, zct1, xcth,  ycth,  zcth,
     %                                                xcth_m,ycth_m,zcth_m,
     %                    i0,in,j0,jn)
*
************************************************************************
      do it=F_it,1,-1
************************************************************************
*
C!$omp parallel private(n)
C!$omp do
      do k = kmax,kmin,-1
      do j = j0,jn
      do i = i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
         zth (n) = HALF_8 * (zth (n))
*
*        --------------------------
*        Reset zthm for ADJOINT #5
*        --------------------------
         if (1.0d0*zth_5_m(ind(it)+n).lt.pdp_8*Ver_z_8%m(1)) then
             zth (n) = 0.
         elseif (1.0d0*zth_5_m(ind(it)+n).gt.pdm_8*Ver_z_8%m(l_nk)) then
             zth (n) = 0.
         endif
*
         wrkx1(n) = TWO_8*zth(n) + wrkx1(n)
         zth  (n) = ZERO_8
*
      enddo
      enddo
      enddo
C!$omp enddo
C!$omp end parallel
*
*     -----------------------
*     NOTE:Wthm never changed
*     -----------------------
*
*     ----------------------------------------------
*     Reset capx1m capy1m capz1m Fn_I for ADJOINT #2 
*     ----------------------------------------------
      call adw_trilin_turbo_ad (wrkx1, F_w, -dth, xth, wrk_yth, zth, 
     %                                 F_w_m,  
     %                          capx1_2_m(ind(it)),capy1_2_m(ind(it)),capz1_2_m(ind(it)),
     %                          Fn_I_2(ind(it)),nijk,i0,in,j0,jn,l_nk,'t')
*
      if (G_lam) then
          if (.not.Schm_zdotMid_L)
     %    call adw_cliptraj_ad (xth, wrk_yth, xth_m_ref2(1,it), wrk_yth_m_ref2(1,it), i0, in, j0, jn, G_nk, 'POS2_AD')
      else
*     NOT DONE YET
      endif
*
*     ADJ
*     ---
      do n = 1,nijk
         yth    (n) = wrk_yth(n) + yth(n)
         wrk_yth(n) = ZERO_8
      enddo
*
************************************************************************
*     ---------------------------------------------------------
*     Reset ythm xcthm ycthm zcthm wrkx1m wrky1m for ADJOINT #3
*     ---------------------------------------------------------
      call adw_trajsp_ad ( xth,  yth,  xcth,  ycth,  zcth,  wrkx1,  wrky1,
     %                           yth_3_m(ind(it)),xcth_3_m (ind(it)),
     %                                            ycth_3_m (ind(it)),
     %                                            zcth_3_m (ind(it)), 
     %                                            wrkx1_3_m(ind(it)),wrky1_3_m(ind(it)),
     %                     dth,i0,in,j0,jn)
*
************************************************************************
*
*     ----------------------------
*     NOTE:Uthm Vthm never changed
*     ----------------------------
*
*     -----------------------------------------------
*     Reset Fn_Im capx1m capy1m capz1m for ADJOINT #1
*     -----------------------------------------------
*
      call adw_trilin_turbo_ad (wrky1, F_v, 1.0, xth, wrk_yth, zth, 
     %                                 F_v_m, 
     %                          capx1_1_m(ind(it)),capy1_1_m(ind(it)),capz1_1_m(ind(it)),  
     %                          Fn_I_1(ind(it)),nijk,i0,in,j0,jn,l_nk,'m')
*
      call adw_trilin_turbo_ad (wrkx1, F_u, 1.0, xth, wrk_yth, zth, 
     %                                 F_u_m, 
     %                          capx1_1_m(ind(it)),capy1_1_m(ind(it)),capz1_1_m(ind(it)),  
     %                          Fn_I_1(ind(it)),nijk,i0,in,j0,jn,l_nk,'m')
*
      if (G_lam) then
          call adw_cliptraj_ad (xth, wrk_yth, xth_m_ref1(1,it), wrk_yth_m_ref1(1,it),i0, in, j0, jn, G_nk, 'POS1_AD')
      else
*     NOT DONE YET
      endif
*
*     ADJ
*     ---
      do n = 1,nijk
         yth    (n) = wrk_yth(n) + yth(n)
         wrk_yth(n) = ZERO_8
      enddo
*
************************************************************************
      enddo ! end of iterations loop
************************************************************************
*
 1000 format(3X,'ADJ of CALC UPSTREAM POSITIONS: (S/R ADW_MAIN_2_POS_AD)')
*
      return
      end
