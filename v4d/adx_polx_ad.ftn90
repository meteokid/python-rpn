
!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "stop_mpi.h"

subroutine adx_polx_ad()
   implicit none
   !---------------------------------------------------------------------
   call stop_mpi(STOP_ERROR,'adx_polx_ad','called a stub')
   !---------------------------------------------------------------------
   return
end subroutine adx_polx_ad

subroutine adx_polx2_ad()
   implicit none
   !---------------------------------------------------------------------
   call stop_mpi(STOP_ERROR,'adx_polx2_ad','called a stub')
   !---------------------------------------------------------------------
   return
end subroutine adx_polx2_ad

!/**
subroutine adx_polx3_ad(F_field, F_sud, F_aminx,F_amaxx,F_aminy,F_amaxy, &
                        F_lni,F_lnj, F_halox,F_haloy, F_nk )
   implicit none
   !@objective ADJ of adx_polx3 
   !@arguments
   integer :: F_lni, F_lnj, F_nk !I, Field computational area dims
   integer :: F_halox, F_haloy   !I, Field halo dims
   integer :: F_aminx,F_amaxx,F_aminy,F_amaxy !I, adw local array bounds
   logical :: F_sud              !I, .T.=S-Pole ; .F.=N-Pole
   real,dimension(F_aminx:F_amaxx,F_aminy:F_amaxy, F_nk):: &
        F_field                  !I/O, field to treat
   !@author monique tanguay
   !@revisions
   ! v4_XX - Tanguay M.        - Adjustments GEM413
!**/
#include "adx_grid.cdk"
#include "adx_poles.cdk"

   integer :: ns, nd, i, i2, k
   real :: e(0:F_lni+49) !TODO: why 49?

   ! Basic statement functions for cubic int. on a non-uniform mesh
   real triprd, delta, poly
   real*8 y_8, y1_8, y2_8, y3_8, y4_8
   real v1, v2, v3, v4
   triprd(y1_8, y2_8, y3_8, y4_8) = (y1_8 - y2_8) * (y1_8 - y3_8) * (y1_8 - y4_8)

   ! triprd is fully symmetric in y2, y3, y4.
   ! and hence delta is symmetric in y2, y3, y4.
   delta(y_8, y1_8, y2_8, y3_8, y4_8) = triprd(y_8, y2_8, y3_8, y4_8) / triprd(y1_8, y2_8, y3_8, y4_8)

   ! delta is a cubic in y which asumes the value 1.0 at y = y1,
   ! and the value 0.0 for y = y2, y3, y4.
   ! consequently a cubic which takes the values v1, v2, v3, v4 at
   ! y = y1, y2, y3, y4, is
   poly(v1, v2, v3, v4, y_8, y1_8, y2_8, y3_8, y4_8) = &
        v1 * delta(y_8, y1_8, y2_8, y3_8, y4_8) + &
        v2 * delta(y_8, y2_8, y1_8, y3_8, y4_8) + &
        v3 * delta(y_8, y3_8, y1_8, y2_8, y4_8) + &
        v4 * delta(y_8, y4_8, y1_8, y2_8, y3_8)
   real*8, parameter :: ZERO_8 = 0.0
   !---------------------------------------------------------------------
   ns = F_lnj
   if (F_sud) ns = 1
   nd = F_lnj+2
   if (F_sud) nd = -1
!
!  Zero adjoint variables
!  ----------------------
   do i = 1,(F_lni+50)
      e(i-1)  = 0.0
   enddo
!
   do k = F_nk,1,-1
!
      do i = F_halox,1,-1
         F_field(F_lni+1-i,nd,k) = F_field(    1-i,nd,k) + F_field(F_lni+1-i,nd,k)
         F_field(      1-i,nd,k) = ZERO_8
         F_field(        i,nd,k) = F_field(F_lni+i,nd,k) + F_field(        i,nd,k)
         F_field(F_lni+  i,nd,k) = ZERO_8
      enddo
!    
!     ADJ of
!     ----------------------------------------------------------------
!     do i = 1, F_lni
!        i2 = adx_iln(i)
!        F_field(i,nd,k) = poly(e(i2-1),e(i2),e(i2+1),e(i2+2),adx_lnr_8(i), &
!             adx_xg_8(i2-1),adx_xg_8(i2),adx_xg_8(i2+1),adx_xg_8(i2+2))
!     enddo
!     ----------------------------------------------------------------
!
      do i=F_lni,1,-1
         i2 = adx_iln(i)
!
         y_8  = adx_lnr_8(i)
         y1_8 = adx_xg_8(i2-1) 
         y2_8 = adx_xg_8(i2) 
         y3_8 = adx_xg_8(i2+1) 
         y4_8 = adx_xg_8(i2+2) 
!
         e(i2+2)    = F_field(i,nd,k) * delta( y_8, y4_8, y1_8, y2_8, y3_8 ) + e(i2+2)
         e(i2+1)    = F_field(i,nd,k) * delta( y_8, y3_8, y1_8, y2_8, y4_8 ) + e(i2+1)
         e(i2)      = F_field(i,nd,k) * delta( y_8, y2_8, y1_8, y3_8, y4_8 ) + e(i2)
         e(i2-1)    = F_field(i,nd,k) * delta( y_8, y1_8, y2_8, y3_8, y4_8 ) + e(i2-1)
         F_field(i,nd,k) = ZERO_8
!
      enddo
!
      do i=F_lni,1,-1
         F_field(i,ns,k) = e(i) + F_field(i,ns,k)
               e(i)      = ZERO_8
      enddo
!
      F_field(2,    ns,k) = e(F_lni+2) + F_field(2,    ns,k)
      e(F_lni+2)          = ZERO_8
      F_field(1,    ns,k) = e(F_lni+1) + F_field(1,    ns,k)
      e(F_lni+1)          = ZERO_8
      F_field(F_lni,ns,k) = e(0)       + F_field(F_lni,ns,k)
      e(0)                = ZERO_8
!
   enddo
   !---------------------------------------------------------------------
   return
end subroutine adx_polx3_ad

