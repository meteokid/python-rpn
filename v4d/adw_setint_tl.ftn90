!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r adw_setint_tl - TLM of adw_setint 
!
#include "model_macros_f.h"
!
      subroutine adw_setint_tl ( &
                                 F_capx  , F_xgg  , F_xdd  , &
                                 F_capy  , F_ygg  , F_ydd  , &
                                 F_capz  , F_cz   ,          &
                                 F_x     , F_y    , F_z    , &
                                 F_n_m   , &
                                 F_capx_m, F_xgg_m, F_xdd_m, &
                                 F_capy_m, F_ygg_m, F_ydd_m, &
                                 F_capz_m, F_cz_m ,          &
                                 F_x_m   , F_y_m  , F_z_m  , &
                                 F_h_L,  F_z_L, F_lin_L,  &
                                 F_num, i0,in,j0,jn,kn)
!
      implicit none
!
      integer F_num, F_n_m(F_num),i0,in,j0,jn,kn
!
      real    F_capx(F_num), F_xgg(F_num), F_xdd(F_num)
      real    F_capy(F_num), F_ygg(F_num), F_ydd(F_num)
      real    F_capz(F_num), F_cz (F_num)
      real    F_x   (F_num), F_y  (F_num), F_z  (F_num)
!
      real    F_capx_m(F_num), F_xgg_m(F_num), F_xdd_m(F_num)
      real    F_capy_m(F_num), F_ygg_m(F_num), F_ydd_m(F_num)
      real    F_capz_m(F_num), F_cz_m (F_num)
      real    F_x_m   (F_num), F_y_m  (F_num), F_z_m  (F_num)
!
      logical F_h_L, F_z_L, F_lin_L
!
!     @author monique tanguay
!     @revisions
!     v4_XX - Tanguay M.        - Adjustments GEM413
!
!object
!     see id section
!
!
!arguments
!______________________________________________________________________
!              |                                                 |     |
! NAME         | DESCRIPTION                                     | I/O |
!--------------|-------------------------------------------------|-----|
!              |                                                 |     |
! F_n          | positions in the 3D volume of interpolation     |  o  |
!              | boxes                                           |     |
!              |                                                 |     |
! F_capx       | \                                               |  o  |
! F_xgg        |   precomputed displacements and interpolation   |  o  |
! F_xdd        | / terms along the x-direction                   |  o  |
!              |                                                 |     |
! F_capy       | \                                               |  o  |
! F_ygg        |   precomputed displacements and interpolation   |  o  |
! F_ydd        | / terms along the y-direction                   |  o  |
!              |                                                 |     |
! F_capz       | \ precomputed displacements and interpolation   |  o  |
! F_cz         | / terms along the z-direction                   |  o  |
!              |                                                 |     |
! F_x          | x coordinate of upstream position               |  i  |
! F_y          | y coordinate of upstream position               |  i  |
! F_z          | z coordinate of upstream position               |  i  |
!              |                                                 |     |
! F_h_L        | switch: .true. :compute horizontal parameters   |  i  |
! F_z_L        | switch: .true. :compute vertical parameters     |  i  |
! F_lin_L      | switch: .true. :compute interpolation parameters|  i  |
!              |                 only for linear interpolation   |     |
!              |                                                 |     |
! F_num        | number of points to treat                       |  i  |
!______________|_________________________________________________|_____|
!
!Notes on computations of positions in the 3D volume of interpolation 
!                   boxes for adw_trilin or adw_tricub
!
!  The same algorithm applies to finding the positions in the interpolation
!  box for each X,Y,Z upstream position.
!  For example, say a given F_x(i), we try to find "ii" on advection
!  axis X (Adw_xg_8) where F_x(i) is closest to the gridpoint Adw_xg_8(ii) 
!  and Adw_xg_8(ii) must be less than or equal to F_x(i).
!  The 3-D positions (ii,jj,kk) are stored in F_n, a folded 3-D array.
! 
!implicits
#include "glb_ld.cdk"
!      integer G_ni, G_nj
!      integer l_ni, l_nj
#include "adw.cdk"
#include "ver.cdk"
!      #include "type.cdk"
!      type (vertical_8) Ver_z_8  
!***********************************************************************
      integer n, ii, jj, kk, ij, nijag, nij,i, j, k, istat
      real*8  prd, prdt, p_z00_8, prd_m, prdt_m
!
      p_z00_8 = Ver_z_8%t(1)
!
      nij   = l_ni * l_nj
      nijag = Adw_nit * Adw_njt
!***********************************************************************
      if ( F_h_L .and. F_z_L ) then
!***********************************************************************
         if ( F_lin_L ) then
!
            do k=1,kn
            do j=j0,jn
            do i=i0,in
            n = (k-1)*nij + ((j-1)*l_ni) + i
!
            prd_m = dble(F_x_m(n))
            prd   = dble(F_x  (n))
!
            ii = ( prd_m - Adw_x00_8 ) * Adw_ovdx_8
            ii = Adw_lcx( ii+1 ) + 1
!
            ii = max(2,ii)
            ii = min(ii,G_ni+2*Adw_halox-2)
!
            prdt_m = prd_m - Adw_bsx_8(ii)
            prdt   = prd
            if ( prdt_m .lt. 0.0 ) then
               ii = max(2,ii - 1)
               prdt_m = prd_m - Adw_bsx_8(ii)
            endif
            F_capx_m(n) = prdt_m * Adw_dix_8(ii)
            F_capx  (n) = prdt   * Adw_dix_8(ii)

            prd_m = dble(F_y_m(n))
            prd   = dble(F_y  (n))
            jj = ( prd_m - Adw_y00_8 ) * Adw_ovdy_8
            jj = Adw_lcy( jj+1 ) + 1
!
            jj = max(Adw_haloy,jj)
            jj = min(jj,G_nj+Adw_haloy)
!
            prdt_m = prd_m - Adw_bsy_8(jj)
            prdt   = prd 
            if ( prdt_m .lt. 0.0 ) then
               jj = max(Adw_haloy,jj - 1)
               prdt_m = prd_m - Adw_bsy_8(jj)
            endif
            F_capy_m(n) = prdt_m * Adw_diy_8(jj)
            F_capy  (n) = prdt   * Adw_diy_8(jj)

            prd_m = dble(F_z_m(n))
            prd   = dble(F_z  (n))
            kk = ( prd_m - p_z00_8 ) * Adw_ovdz_8
            kk = Adw_lcz%s( kk+1 )
            prd_m = prd_m - Adw_bsz_8%s(kk)
            if ( prd_m .lt. 0.0 ) kk = kk - 1
            F_capz_m(n) = prd_m * Adw_diz_8(kk)
            F_capz  (n) = prd   * Adw_diz_8(kk)
            if ( prd_m .lt. 0.0 ) F_capz_m(n) = 1.0 + F_capz_m(n)
            ij = (jj-Adw_int_j_off-1)*Adw_nit + (ii-Adw_int_i_off)
            F_n_m(n) = kk*nijag + ij
            enddo
            enddo
            enddo
!
         else
            call handle_error(istat,'adw_setint_tl','KO1 not done')
         endif
!***********************************************************************
      elseif (F_h_L) then
!***********************************************************************
         if ( F_lin_L ) then
            call handle_error(istat,'adw_setint_tl','KO2 not done')
         else
            call handle_error(istat,'adw_setint_tl','KO3 not done')
         endif
!***********************************************************************
      elseif (F_z_L) then
!***********************************************************************
         if ( F_lin_L ) then
            call handle_error(istat,'adw_setint_tl','KO4 not done')
         else
            call handle_error(istat,'adw_setint_tl','KO5 not done')
         endif
!***********************************************************************
      endif
!***********************************************************************
      return
      end
