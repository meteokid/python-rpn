!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/p adw_trilin_turbo_ad - ADJ of adw_trilin_turbo_tl
*
#include "model_macros_f.h"
*
      subroutine adw_trilin_turbo_ad( F_out,  F_in,  F_dt,F_x,  F_y,  F_z,   
     %                                        F_in_m,
     %                                F_capx_m,F_capy_m,F_capz_m,
     %                                F_ii, F_jj, F_kk, 
     %                                F_num, i0, in, j0, jn, kn,
     %                                F_hor_L,F_ver_L)
*
      implicit none
*
      integer F_num, i0, in, j0, jn, kn,F_ii(F_num),F_jj(F_num),F_kk(F_num) 
*
      real F_dt, F_in(*), F_in_m(*)
*
      real F_out(F_num), F_x(F_num), F_y(F_num), F_z(F_num)
*
      real F_capx_m(F_num),F_capy_m(F_num),F_capz_m(F_num)
*
      logical F_hor_L,F_ver_L
*
*authors
*     Monique Tanguay
*
*     (Based on adw_trilin_ad v_3.1.1)
*
*revision
* v3_20 - Tanguay M. -  initial version
* v3_21 - Tanguay M. -  OPENMP based on min-max vertical CFL
* v4_04 - Tanguay M. -  Staggered version TL/AD
* v4_12 - Tanguay M. - TL/AD Thermo upstream positions
*
*object
*     see id section
*
*ADJ of
*arguments
*______________________________________________________________________
*              |                                                 |     |
* NAME         | DESCRIPTION                                     | I/O |
*--------------|-------------------------------------------------|-----|
* F_out        | F_dt * result of interpolation                  |  o  |
* F_in         | field to interpolate                            |  i  |
*              |                                                 |     |
* F_dt         | multiplicative constant (1.0 or timestep lenght)|  i  |
*              |                                                 |     |
* F_x          | \                                               |  i  |
* F_y          |   x,y,z positions                               |  i  |
* F_z          | /                                               |  i  |
*              |                                                 |     |
* F_capx       | \                                               |  i  |
* F_capy       |   precomputed displacements                     |  i  |
* F_capz       | / along the x,y,z directions                    |  i  |
*              |                                                 |     |
* F_ii (jj,kk) | localisation indices                            |  i  |
*              |                                                 |     |
* F_num        | number of points to interpolate                 |  i  |
*______________|_________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
!      integer G_ni,G_nj
!      integer l_ni,l_nj,l_nk
#include "adw.cdk"
!      #include "type.cdk"
!      logical Adw_hor_L,Adw_ver_L
!      integer            Adw_halox, Adw_haloy
!      integer            Adw_nit, Adw_njt
!      integer            Adw_int_i_off, Adw_int_j_off
!      real*8             Adw_x00_8,  Adw_y00_8
!      real*8             Adw_ovdx_8, Adw_ovdy_8, Adw_ovdz_8
!      type (vertical_i)  Adw_lcz
!      type (vertical_8)  Adw_bsz_8
!      type (vertical_8)  Adw_diz_8
!      DCL_DYNVAR(Adw,    lcx,    integer, (*))
!      DCL_DYNVAR(Adw,    lcy,    integer, (*))
!      DCL_DYNVAR(Adw,  bsx_8,    real*8 , (*))
!      DCL_DYNVAR(Adw,  bsy_8,    real*8 , (*))
!      DCL_DYNVAR(Adw,  xbc_8,    real*8 , (*))
!      DCL_DYNVAR(Adw,  ybc_8,    real*8 , (*))
#include "ver.cdk"
!      #include "type.cdk"
!      type (vertical_8) Ver_z_8  
*
************************************************************************
*
      integer n, n0, nijag, nij, o1, o2, i, j, k,
     %        ii,jj,kk
*
      real capx, capy, capz
*
      real*8 rri_8, rrj_8, rrk_8, prf1_8, prf2_8, prf3_8, prf4_8, p_z00_8,
     %       prf1_y_8, prf2_y_8
*
      real capx_m, capy_m, capz_m
*
      real*8 prf1_m_8, prf2_m_8, prf3_m_8, prf4_m_8, prf1_y_m_8, prf2_y_m_8
*
      real*8, parameter :: ZERO_8 = 0.0
*
************************************************************************
*
      p_z00_8 = Ver_z_8%t(1)
*
*     ----------------------------------------------------------------
*
      nijag = Adw_nit * Adw_njt
      nij = l_ni*l_nj
*
C!$omp parallel do private(n,n0,ii,jj,kk,rri_8,rrj_8,rrk_8,
C!$omp&     capx,capy,capz,o1,o2,prf1_8,prf2_8,prf3_8,prf4_8,
C!$omp&     prf1_y_8,prf2_y_8,prf1_y_m_8,prf2_y_m_8, 
C!$omp&     capx_m,capy_m,capz_m,prf1_m_8,prf2_m_8,prf3_m_8,prf4_m_8)
      do 100 k=kn,1,-1
      do  90 j=jn,j0,-1
      n0 = (k-1)*nij + ((j-1)*l_ni)
      do  80 i=in,i0,-1
        n = n0 + i
*
*       ------------------
*       TRAJECTORY (START)
*       ------------------
*
        ii = F_ii(n)
        jj = F_jj(n)
        kk = F_kk(n)
*
        o1 = (kk)*nijag + (jj-Adw_int_j_off-1)*Adw_nit + (ii-Adw_int_i_off)
        o2 = o1 + Adw_nit
*
************************************************************************
*       x interpolation
************************************************************************
*
        capx_m = F_capx_m(n)
*
        prf1_m_8 = (1.0 - capx_m) * F_in_m(o1) + capx_m * F_in_m(o1+1)
        prf2_m_8 = (1.0 - capx_m) * F_in_m(o2) + capx_m * F_in_m(o2+1)
*
        o1 = o1 + nijag
        o2 = o2 + nijag
*
        prf3_m_8 = (1.0 - capx_m) * F_in_m(o1) + capx_m * F_in_m(o1+1)
        prf4_m_8 = (1.0 - capx_m) * F_in_m(o2) + capx_m * F_in_m(o2+1)
*
************************************************************************
*       y interpolation
************************************************************************
*
        capy_m = F_capy_m(n)
*
        prf1_y_m_8 = (1.0 - capy_m) * prf1_m_8 + capy_m  * prf2_m_8
        prf2_y_m_8 = (1.0 - capy_m) * prf3_m_8 + capy_m  * prf4_m_8
*
************************************************************************
*       z interpolation
************************************************************************
*
        capz_m = F_capz_m(n)
*
*       ----------------
*       TRAJECTORY (END)
*       ----------------
*
************************************************************************
*       ADJ of
*       z interpolation
************************************************************************
        prf2_y_8  =      capz_m  * F_out(n)  * F_dt
        prf1_y_8  = (1.0-capz_m) * F_out(n)  * F_dt
        capz      = (prf2_y_m_8 - prf1_y_m_8) * F_out(n) * F_dt
        F_out (n) = ZERO_8
*
        rrk_8 = capz * Adw_diz_8(kk)
*
************************************************************************
*       ADJ of
*       y interpolation
************************************************************************
        prf4_8 =      capy_m  * prf2_y_8
        prf3_8 = (1.0-capy_m) * prf2_y_8
*
        prf2_8 =      capy_m  * prf1_y_8
        prf1_8 = (1.0-capy_m) * prf1_y_8
*
        capy   =  (prf4_m_8 - prf3_m_8) * prf2_y_8
     %          + (prf2_m_8 - prf1_m_8) * prf1_y_8
*
        rrj_8 = capy *Adw_ybc_8(jj)
*
************************************************************************
*       ADJ of
*       x interpolation
************************************************************************
        F_in(o2+1) = F_in(o2+1) +      capx_m  * prf4_8
        F_in(o2  ) = F_in(o2  ) + (1.0-capx_m) * prf4_8
*
        F_in(o1+1) = F_in(o1+1) +      capx_m  * prf3_8
        F_in(o1  ) = F_in(o1  ) + (1.0-capx_m) * prf3_8
*
        capx    =   (F_in_m(o2+1) - F_in_m(o2)) * prf4_8
     %            + (F_in_m(o1+1) - F_in_m(o1)) * prf3_8
*
        o1 = o1 - nijag
        o2 = o2 - nijag
*
        F_in(o2+1) = F_in(o2+1) +      capx_m  * prf2_8
        F_in(o2  ) = F_in(o2  ) + (1.0-capx_m) * prf2_8
*
        F_in(o1+1) = F_in(o1+1) +      capx_m  * prf1_8
        F_in(o1  ) = F_in(o1  ) + (1.0-capx_m) * prf1_8
*
        capx    =   (F_in_m(o2+1) - F_in_m(o2)) * prf2_8
     %            + (F_in_m(o1+1) - F_in_m(o1)) * prf1_8 + capx
*
        rri_8 = capx *Adw_xbc_8(ii)
*
        F_x(n) = rri_8 + F_x(n)
        F_y(n) = rrj_8 + F_y(n)
        F_z(n) = rrk_8 + F_z(n)
*
   80 continue
   90 continue
  100 continue
C!$omp end parallel do
*
      return
      end
