! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/p adw_trilin_turbo_ad - ADJ of adw_trilin_turbo_tl
*
#include "model_macros_f.h"
*
      subroutine adw_trilin_turbo_ad ( F_out,  F_in,  F_dt, F_x, F_y, F_z, 
     %                                         F_in_m,       
     %                                 F_capx_m,F_capy_m,F_capz_m,
     %                                 Fn_I,F_num,i0,in,j0,jn,kn,
     %                                 F_lev_S)
*
      implicit none
*
      character*1 F_lev_S
*
      integer F_num, i0, in, j0, jn, kn, Fn_I(F_num)
*
      real F_dt, F_in(*), F_in_m(*)
*
      real F_out (F_num),F_x (F_num),F_y (F_num),F_z (F_num)
*
      real F_capx_m(F_num),F_capy_m(F_num),F_capz_m(F_num)
*
*authors
*     Monique Tanguay
*
*     (Based on adw_trilin_ad v_3.1.1)
*
*revision
* v3_20 - Tanguay M. -  initial version
* v3_21 - Tanguay M. -  OPENMP based on min-max vertical CFL 
* v4_04 - Tanguay M. -  Staggered version TL/AD 
*
*object
*     see id section
*
*ADJ of
*arguments
*______________________________________________________________________
*              |                                                 |     |
* NAME         | DESCRIPTION                                     | I/O |
*--------------|-------------------------------------------------|-----|
*              |                                                 |     |
* F_out        | F_dt * result of interpolation                  |  o  |
* F_in         | field to interpolate                            |  i  |
*              |                                                 |     |
* F_dt         | multiplicative constant (1.0 or timestep lenght)|  i  |
*              |                                                 |     |
* F_n          | positions in the 3D volume of interpolation     |  i  |
*              | boxes                                           |     |
*              |                                                 |     |
* F_capx       | \                                               |  i  |
* F_capy       |   precomputed displacements                     |  i  |
* F_capz       | / along the x,y,z directions                    |  i  |
*              |                                                 |     |
* F_num        | number of points to interpolate                 |  i  |
*______________|_________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
#include "type.cdk"
#include "adw.cdk"
#include "ver.cdk"
#include "v4dcfl.cdk"
#include "ptopo.cdk"
#include "lun.cdk"
************************************************************************
      integer n,nn,n0,nijag,o1,o2,i,j,k,nij,shift,
     %        ii,jj,kk
*
      real capx, capy, capz, capx_m, capy_m, capz_m
*
      real*8 rri_8, rrj_8, rrk_8, p_z00_8
*
      real*8 prf1_8, prf2_8, prf3_8, prf4_8, prf1_y_8, prf2_y_8
      real*8 prf1_m_8,prf2_m_8,prf3_m_8,prf4_m_8,prf1_y_m_8,prf2_y_m_8
*
      real*8, parameter :: ZERO_8 = 0.0
*
      integer,dimension(:),pointer :: p_lcz
      real*8, dimension(:),pointer :: p_bsz_8, p_diz_8
*
      logical done_L
      data done_L /.false./
      save done_L
      integer cflp(Ptopo_numproc),cfln(Ptopo_numproc),iproc,err
*
************************************************************************
*
      if ( F_lev_S .eq. 'm') then
         p_z00_8 = Ver_z_8%m(1)
         p_lcz =>Adw_lcz%m
         p_bsz_8 =>Adw_bsz_8%m
         p_diz_8 =>Adw_diz_8%m
      else
         p_z00_8 = Ver_z_8%t(1)
         p_lcz =>Adw_lcz%t
         p_bsz_8 =>Adw_bsz_8%t
         p_diz_8 =>Adw_diz_8%t
      endif
*
      if(.not.done_L) then
*
*        Evaluate min-max vertical CFL
*        -----------------------------
         V4dcfl_p0 = V4dcfl_p(1)
         V4dcfl_n0 = V4dcfl_n(1)
         do k=2,l_nk
            if (V4dcfl_p(k).gt.V4dcfl_p0) then
                V4dcfl_p0 = V4dcfl_p(k)
            endif
            if (V4dcfl_n(k).lt.V4dcfl_n0) then
                V4dcfl_n0 = V4dcfl_n(k)
            endif
         enddo
*
         call RPN_COMM_gather (V4dcfl_p0,1,"MPI_INTEGER",cflp,1,
     $                         "MPI_INTEGER",0,"GRID", err)
         call RPN_COMM_gather (V4dcfl_n0,1,"MPI_INTEGER",cfln,1,
     $                         "MPI_INTEGER",0,"GRID", err)
*
         if (Ptopo_myproc.eq.0) then
*
            V4dcfl_p0 = cflp(1)
            V4dcfl_n0 = cfln(1)
            do iproc = 2, Ptopo_numproc
               if (cflp(iproc).gt.V4dcfl_p0) 
     %             V4dcfl_p0 = cflp(iproc) 
               if (cfln(iproc).lt.V4dcfl_n0) 
     %             V4dcfl_n0 = cfln(iproc) 
            end do
*
         endif
*
         call RPN_COMM_bcast(V4dcfl_p0,1,"MPI_INTEGER",0,"grid",err )
         call RPN_COMM_bcast(V4dcfl_n0,1,"MPI_INTEGER",0,"grid",err )
*
*        Evaluate admissible distance between threads
*        --------------------------------------------
         V4dcfl_dist =  max((kn+Ptopo_npeOpenMP-1)/Ptopo_npeOpenMP,
     %                      2 + V4dcfl_p0 - V4dcfl_n0) 
*
         if (Ptopo_myproc.eq.0.and.Lun_out.gt.0) then
             write(Lun_out,*) 'ADW_TRILIN_AD: max vertical CFL         =',V4dcfl_p0
             write(Lun_out,*) 'ADW_TRILIN_AD: min vertical CFL         =',V4dcfl_n0
             write(Lun_out,*) 'ADW_TRILIN_AD: Distance between threads =',V4dcfl_dist
         endif
*
         done_L = .true.
      endif
*
*     Initializations 
*     ---------------
      nij   = l_ni*l_nj
      nijag = Adw_nit * Adw_njt
*
*     Distribute levels respecting admissible distance between threads 
*     ----------------------------------------------------------------
      do shift=1,V4dcfl_dist
*
C!$omp parallel do private(n,n0,ii,jj,kk,rri_8,rrj_8,rrk_8,
C!$omp&         capx,capy,capz,o1,o2,prf1_8,prf2_8,prf3_8,prf4_8,
C!$omp&         capx_m,capy_m,capz_m,prf1_y_8,prf2_y_8,
C!$omp&         prf1_m_8,prf2_m_8,prf3_m_8,prf4_m_8,
C!$omp&         prf1_y_m_8,prf2_y_m_8,i,j,k)
C!$omp&         shared(shift)
*
      do k=shift,kn,V4dcfl_dist
*
      do j=j0,jn
*
      n0 = (k-1)*nij + ((j-1)*l_ni)
*
      do i=i0,in
*
      n = n0 + i
*
*     ------------------
*     TRAJECTORY (START)
*     ------------------
      ii = and( Fn_I(n) , 4095 )
      jj = and( ishft( Fn_I(n) , -12 ) , 4095 )
      kk = ishft(Fn_I(n) , -24)
*
      o1 = (kk)*nijag + (jj-Adw_int_j_off-1)*Adw_nit + (ii-Adw_int_i_off)
      o2 = o1 + Adw_nit
*
************************************************************************
*     x interpolation
************************************************************************
      capx_m = F_capx_m(n) 
*
      prf1_m_8 = (1.0 - capx_m) * F_in_m(o1) + capx_m * F_in_m(o1+1)
      prf2_m_8 = (1.0 - capx_m) * F_in_m(o2) + capx_m * F_in_m(o2+1)
*
      o1 = o1 + nijag
      o2 = o2 + nijag
*
      prf3_m_8 = (1.0 - capx_m) * F_in_m(o1) + capx_m * F_in_m(o1+1)
      prf4_m_8 = (1.0 - capx_m) * F_in_m(o2) + capx_m * F_in_m(o2+1)
************************************************************************
*     y interpolation
************************************************************************
      capy_m = F_capy_m(n) 
*
      prf1_y_m_8= (1.0 - capy_m) * prf1_m_8 + capy_m  * prf2_m_8
      prf2_y_m_8= (1.0 - capy_m) * prf3_m_8 + capy_m  * prf4_m_8
*
************************************************************************
*     z interpolation
************************************************************************
      capz_m = F_capz_m(n) 
*
*     ----------------
*     TRAJECTORY (END)
*     ----------------
*
************************************************************************
*     ADJ of
*     z interpolation
************************************************************************
      prf2_y_8  =      capz_m  * F_out(n)  * F_dt
      prf1_y_8  = (1.0-capz_m) * F_out(n)  * F_dt
      capz      = (prf2_y_m_8 - prf1_y_m_8) * F_out(n) * F_dt
      F_out (n) = ZERO_8
*
      rrk_8 = capz * p_diz_8(kk)
*
************************************************************************
*     ADJ of
*     y interpolation
************************************************************************
      prf4_8 =      capy_m  * prf2_y_8 
      prf3_8 = (1.0-capy_m) * prf2_y_8 
*
      prf2_8 =      capy_m  * prf1_y_8 
      prf1_8 = (1.0-capy_m) * prf1_y_8 
*
      capy   =  (prf4_m_8 - prf3_m_8) * prf2_y_8
     %        + (prf2_m_8 - prf1_m_8) * prf1_y_8 
*
      rrj_8 = capy *Adw_ybc_8(jj)
*
************************************************************************
*     x interpolation
************************************************************************
      F_in(o2+1) = F_in(o2+1) +      capx_m  * prf4_8
      F_in(o2  ) = F_in(o2  ) + (1.0-capx_m) * prf4_8
*
      F_in(o1+1) = F_in(o1+1) +      capx_m  * prf3_8
      F_in(o1  ) = F_in(o1  ) + (1.0-capx_m) * prf3_8
*
      capx    =   (F_in_m(o2+1) - F_in_m(o2)) * prf4_8
     %          + (F_in_m(o1+1) - F_in_m(o1)) * prf3_8
*
      o1 = o1 - nijag
      o2 = o2 - nijag
*
      F_in(o2+1) = F_in(o2+1) +      capx_m  * prf2_8
      F_in(o2  ) = F_in(o2  ) + (1.0-capx_m) * prf2_8
*
      F_in(o1+1) = F_in(o1+1) +      capx_m  * prf1_8
      F_in(o1  ) = F_in(o1  ) + (1.0-capx_m) * prf1_8
*
      capx    =   (F_in_m(o2+1) - F_in_m(o2)) * prf2_8
     %          + (F_in_m(o1+1) - F_in_m(o1)) * prf1_8 + capx
*
      rri_8 = capx *Adw_xbc_8(ii)
*
      F_x(n) = rri_8 + F_x(n) 
      F_y(n) = rrj_8 + F_y(n) 
      F_z(n) = rrk_8 + F_z(n) 
*
      enddo
      enddo
      enddo
C!$omp end parallel do
*
      enddo
*
      return
      end
