! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r itf_phy_vmmprep_ad - adjoint of load all fields required by the physics
*
#include "model_macros_f.h"
*
      subroutine itf_phy_vmmprep_ad(F_pvptr,NPTR, F_trp, F_trm, 
     $                           F_tp, F_vtm, DIST_DIM,nkphy)
*
      implicit none
*
*
*
      integer,   INTENT(IN) :: NPTR, DIST_DIM, nkphy
      integer*8, INTENT(OUT):: F_pvptr(NPTR)
      real, INTENT(OUT),dimension(DIST_SHAPE,nkphy,*) :: F_trp, F_trm
      real, INTENT(OUT),dimension(DIST_SHAPE,nkphy)   :: F_tp,  F_vtm
*
*author
*     Stephane Laroche - January 2002
*
*revision
* v3_00 - Laroche S.        - initial MPI version
* v3_20 - Laroche S.        - cleanup pil_#
* v3_21 - Tanguay M.        - Revision Openmp 
* v3_30 - Tanguay M.        - adapt TL/AD to itf
*                           - Validation for LAM version
* v4_03 - Spacek L.         - Staggered version
*
*object
*
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_up     
*----------------------------------------------------------------
*
*implicits
#include "glb_ld.cdk"
#include "geomg.cdk"
#include "cstv.cdk"
#include "lun.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "itf_phy_config.cdk"
#include "itf_phy_buses.cdk"
#include "inuvl.cdk"
#include "vt1.cdk"
#include "vt0.cdk"
#include "vtx.cdk"
#include "itf_phy_busind.cdk"
#include "p_geof.cdk"
#include "itf_phy_vmm.cdk"
#include "ver.cdk"
#include "itf_vmm.cdk"
#include "tr3d.cdk"
#include "v4dg.cdk"
**
*
      integer err, key(14), i, j, k, n, i0, j0, in, jn, nksurf,
     $        keyd(17), keyp(phyt_ntr), keym(phyt_ntr), keyp_, keym_
      integer pnlod, nik, nikp, km1, iadd
      real dt, dzsedi, dzmin, dzmin_, sigsfc, trp, trm, con(l_nj)
      real xtmp(l_ni,nkphy)
      real wtmp(l_ni,nkphy-1),wtmp2(l_ni,nkphy-1),ztmp(l_ni,l_nj)
      real*8 r0, ZERO_8
      parameter (ZERO_8=0.0)
      real, dimension(LDIST_SHAPE,nkphy) :: vmm, tpm, tmm
      real, dimension(LDIST_SHAPE,nkphy,1) :: trpm, trmm
      real, dimension(LDIST_SHAPE) :: st1m
      pointer (patrp, trp(LDIST_SHAPE,*)),(patrm, trm(LDIST_SHAPE,*))
      pointer (pavmm, vmm)
*
*     ________________________________________________________________
*
      key( 1) = VMM_KEY(ut0)
      key( 2) = VMM_KEY(vt0)
      key( 3) = VMM_KEY(tt0)
      key( 4) = VMM_KEY(st0)
      key( 5) = VMM_KEY(ut1)
      key( 6) = VMM_KEY(vt1)
      key( 7) = VMM_KEY(tt1)
      key( 8) = VMM_KEY(st1)
      key( 9) = VMM_KEY(fiptx)
      key(10) = VMM_KEY(topo)
      key(11) = VMM_KEY(piup)
      pnlod = 11
      if (.not. Schm_hydro_L ) then
        key(12) = VMM_KEY(qt1)
        pnlod = 12
      endif

      err = vmmlod(key,pnlod)
      err = VMM_GET_VAR(ut0)
      err = VMM_GET_VAR(vt0)
      err = VMM_GET_VAR(tt0)
      err = VMM_GET_VAR(st0)   !ln (pi_s/z_s)
      err = VMM_GET_VAR(ut1)
      err = VMM_GET_VAR(vt1)
      err = VMM_GET_VAR(tt1)
      err = VMM_GET_VAR(st1)   !ln (pi_s/z_s)
      err = VMM_GET_VAR(fiptx) !phi
      err = VMM_GET_VAR(topo)  !Phi at the surface (xfis) with halos on it
      err = VMM_GET_VAR(piup)  !Upstream hydrostatic pressure at t-dt for omega
      if (.not. Schm_hydro_L ) then
         err = VMM_GET_VAR(qt1) !q''
      endif
*
      keyd(1) = VMM_KEY(p_uplus)
      keyd(2) = VMM_KEY(p_vplus)
      keyd(3) = VMM_KEY(p_tplus)
      keyd(4) = VMM_KEY(p_umoins)
      keyd(5) = VMM_KEY(p_vmoins)
      keyd(6) = VMM_KEY(p_tmoins)
      keyd(7) = VMM_KEY(p_gzplus)
      keyd(8) = VMM_KEY(p_omegap)
      keyd(9) = VMM_KEY(p_sigm_m)
      keyd(10) = VMM_KEY(p_sigm_t)
      keyd(11) = VMM_KEY(p_phis)
      keyd(12) = VMM_KEY(p_pplus)
      keyd(13) = VMM_KEY(p_pmoins)
      keyd(14) = VMM_KEY(p_dxdy)
      keyd(15) = VMM_KEY(p_eponmod)
      keyd(16) = VMM_KEY(p_fcpf)
      keyd(17) = VMM_KEY(p_fcpw)
      err = vmmlod(keyd,17)
      err = VMM_GET_VAR(p_uplus)
      err = VMM_GET_VAR(p_vplus)
      err = VMM_GET_VAR(p_tplus)
      err = VMM_GET_VAR(p_umoins)
      err = VMM_GET_VAR(p_vmoins)
      err = VMM_GET_VAR(p_tmoins)
      err = VMM_GET_VAR(p_gzplus)
      err = VMM_GET_VAR(p_omegap)
      err = VMM_GET_VAR(p_sigm_m)
      err = VMM_GET_VAR(p_sigm_t)
      err = VMM_GET_VAR(p_phis)
      err = VMM_GET_VAR(p_pplus)
      err = VMM_GET_VAR(p_pmoins)
      err = VMM_GET_VAR(p_dxdy)
      err = VMM_GET_VAR(p_eponmod)
      err = VMM_GET_VAR(p_fcpf)
      err = VMM_GET_VAR(p_fcpw)

      nik  = l_ni*(nkphy-1)
      nikp = l_ni*(nkphy)
**
*     Trajectory
*
      call v4d_rwtraj(25,tmm,trmm,tpm,trpm)

      call itf_phy_padbuf(tpm,  l_minx,l_maxx,l_miny,l_maxy,nkphy)
      call itf_phy_padbuf(trpm, l_minx,l_maxx,l_miny,l_maxy,nkphy)
      call itf_phy_padbuf(tmm,  l_minx,l_maxx,l_miny,l_maxy,nkphy)
      call itf_phy_padbuf(trmm,l_minx,l_maxx,l_miny,l_maxy,nkphy)
*     ________________________________________________________________
*
*
*     Compute temperature from virtual temperature
*     --------------------------------------------
*
         call mfottv_ad ( p_tplus ,F_tp,
     $            F_trp(l_minx,l_miny,1,hucond),
     $            tpm, trpm(l_minx,l_miny,1,1),
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1),nkphy,
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1) )

         call mfottv_ad ( p_tmoins,F_vtm,
     $            F_trm(l_minx,l_miny,1,hucond),
     $            tmm, trmm(l_minx,l_miny,1,1),
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1),nkphy,
     $            (l_maxx-l_minx+1)*(l_maxy-l_miny+1) )
*
      call itf_phy_padbuf_ad(F_tp,l_minx,l_maxx,l_miny,l_maxy,nkphy)
      call itf_phy_padbuf_ad(F_trp,l_minx,l_maxx,l_miny,l_maxy,nkphy)
      call itf_phy_padbuf_ad(F_trm,l_minx,l_maxx,l_miny,l_maxy,nkphy)
      call itf_phy_padbuf_ad(F_vtm,l_minx,l_maxx,l_miny,l_maxy,nkphy)
*
*
*     Real winds
*     --------------------------------------------
*
      do j=1,l_nj
         con(j) = ( 1.0/cos(geomg_y_8(j))) * Dcst_rayt_8
      enddo
!$omp parallel
!$omp do
      do k=1,nkphy
      do j= 1, l_nj
      do i= 1, l_ni 
         p_uplus(i,j,k) = p_uplus(i,j,k)*con(j)
         p_umoins(i,j,k) = p_umoins(i,j,k)*con(j)
         p_vplus(i,j,k) = p_vplus(i,j,k)*con(j)
         p_vmoins(i,j,k) = p_vmoins(i,j,k)*con(j)
      enddo
      enddo
      enddo
!$omp end do
!$omp end parallel
*
*C    interpolate wind images at time t1 and t2
*     -----------------------------------------
*
      call itf_phy_uvgridscal_ad (p_uplus ,p_vplus ,LDIST_DIM,nkphy,.true.)
      call itf_phy_uvgridscal_ad (p_umoins,p_vmoins,LDIST_DIM,nkphy,.true.)
*
*    
*     Tracers
*     -----------------------------------------
*
!$omp parallel private(km1) shared(keyp_,keym_,phyt_ntr,err)
      keyp_ = VMM_KEY (trt1)
      keym_ = VMM_KEY (trt0)
      if (phyt_ntr.gt.0) then
         do n=1,phyt_ntr
            keyp(n) = keyp_ + n
            keym(n) = keym_ + n
         end do
         err = vmmlod(keyp,phyt_ntr)  
         err = vmmlod(keym,phyt_ntr)  
*No Clipping for tracers, it will be done in the PHYSICS
         do n=1,phyt_ntr
            err = vmmget(keyp(n),patrp,trp)
            err = vmmget(keym(n),patrm,trm)
*For HU, take NK+2 level for diagnostics, for others,copy NK+1 to Nk+2
*Note that hucond not equal to 1 always, use hucond for HU reference in F_trt1
            if (n.ne.hucond) then
            do j= 1, l_nj
            do i= 1, l_ni
               trp(i,j,l_nk+1) = trp(i,j,l_nk+1) + F_trp(i,j,l_nk+2,n)
               trm(i,j,l_nk+1) = trm(i,j,l_nk+1) + F_trm(i,j,l_nk+2,n)
               F_trp(i,j,l_nk+2,n) = ZERO_8
               F_trm(i,j,l_nk+2,n) = ZERO_8
            end do
            end do
            endif
!$omp do
            do k=l_nk+2,1,-1
            do j= 1, l_nj
            do i= 1, l_ni
               trp(i,j,k) = trp(i,j,k) + F_trp(i,j,k,n)
               trm(i,j,k) = trm(i,j,k) + F_trm(i,j,k,n)
               F_trp(i,j,k,n) = ZERO_8
               F_trm(i,j,k,n) = ZERO_8
            end do
            end do
            enddo
!$omp end do
         enddo
         err = vmmuln(keyp,phyt_ntr)
         err = vmmuln(keym,phyt_ntr)
      endif
**
*
*
* Surface pressure
*
      call v4d_rwtraj (26, st1m)

      do j=1,l_nj
         do i=1,l_ni 
         st1(i,j) = st1(i,j) +Ver_b_8%m(nkphy)*exp( Ver_a_8%m(nkphy) 
     $                     + Ver_b_8%m(nkphy)*st1m(i,j) )*p_pplus(i,j)

         p_pplus(i,j) = ZERO_8
         end do
      end do
*
!$omp do 
      do k=l_nk+2,1,-1
      km1=max(k-1,1)
      do j= 1, l_nj
      do i= 1, l_ni 
         ut0 (i,j,km1) = ut0 (i,j,km1) + p_umoins (i,j,k)
         vt0 (i,j,km1) = vt0 (i,j,km1) + p_vmoins (i,j,k)
         tt0 (i,j,k)   = tt0 (i,j,k)   + F_vtm    (i,j,k)
         ut1 (i,j,km1) = ut1 (i,j,km1) + p_uplus  (i,j,k)
         vt1 (i,j,km1) = vt1 (i,j,km1) + p_vplus  (i,j,k)
         tt1 (i,j,k)   = tt1 (i,j,k)   + F_tp     (i,j,k)
         p_umoins  (i,j,k) = ZERO_8
         p_vmoins  (i,j,k) = ZERO_8
         F_vtm     (i,j,k) = ZERO_8
         p_uplus   (i,j,k) = ZERO_8
         p_vplus   (i,j,k) = ZERO_8
         F_tp      (i,j,k) = ZERO_8
      end do
      end do
      end do
!$omp end do 
!$omp end parallel
*
*
      return
      end

