! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r adw_main_3_int_ad - ADJ of adw_main_3_int_tl when Adw_lag3d_L=.TRUE. 
*
#include "model_macros_f.h"
*
      subroutine adw_main_3_int_ad ( F_u, F_v, F_w, F_u_m, F_v_m, F_w_m )
*
      implicit none
      real F_u  (*),F_v  (*),F_w  (*)
      real F_u_m(*),F_v_m(*),F_w_m(*)
*
*author
*     monique tanguay
*
*revision
* v2_31 - Tanguay M.        - initial MPI version
* v3_00 - Tanguay M.        - adapt to restructured adw_main 
* v3_02 - Tanguay M.        - restore tracers monotone if V4dg_conf.ne.0
* v3_03 - Tanguay M.        - Adjoint NoHyd configuration 
* v3_11 - Tanguay M.        - introduce key Adw_mono_L
* v3_20 - Tanguay M.        - Lagrange 3D
* v3_21 - Tanguay M.        - Call adw_main_3_intlag_tl based on Adw_lag3d_L
* v3_30 - Tanguay M.        - correct calculation for LAM when Glb_pil gt 7 
* v4_04 - Tanguay M.        - Staggered version TL/AD 
*
*language
*     fortran 77
*
*object
*     see id section
*
*     CAUTION: WUP-ZZ1-ZDUP not done
*
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
*        |                                                       |     |
*        |                                                       |     |
* F_u,F_v| 3 components of upstream positions at t1 at input     |  iw |
* F_w    | used as work field afterward                          |     |
*________|_______________________________________________________|_____|
*
*implicits
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "ptopo.cdk"
#include "geomg.cdk"
#include "orh.cdk"
#include "lctl.cdk"
#include "step.cdk"
#include "lun.cdk"
#include "schm.cdk"
#include "offc.cdk"
#include "cstv.cdk"
#include "rhsc.cdk"
#include "v4dg.cdk"
#include "type.cdk"
#include "adw.cdk"
#include "tr3d.cdk"
#include "vt1.cdk"
#include "vt0.cdk"
#include "ver.cdk"
#include "orh_m.cdk"
#include "rhsc_m.cdk"
#include "adw_m.cdk"
#include "vt1_m.cdk"
#include "vt0_m.cdk"
*
*modules
      integer  vmmlod, vmmget, vmmuld
      external vmmlod, vmmget, vmmuld
************************************************************************
      integer i0,in,j0,jn
      integer pnerr, pnlkey1(30), pnlkey2(30), key1(Tr3d_ntr), key0(Tr3d_ntr), 
     $        key1_, key0_, pnlod, err
      integer key1_m(Tr3d_ntr), key0_m(Tr3d_ntr), key1_m_, key0_m_ 
*
      integer n, nij, nijkt, nijkm, nijkad, cnt, unf
      integer i,j,k
*
      integer*8 pnt_trt1  (Tr3d_ntr),pnt_trt0  (Tr3d_ntr)
      integer*8 pnt_trt1_m(Tr3d_ntr),pnt_trt0_m(Tr3d_ntr)
*
      integer DIST_DIM
*
      real*8 aaa_8
*
      real tr,tr0,tr_m,tr0_m
      pointer (patr,   tr  (LDIST_SHAPE,*)),(patr0,   tr0  (LDIST_SHAPE,*))
      pointer (patr_m, tr_m(LDIST_SHAPE,*)),(patr0_m, tr0_m(LDIST_SHAPE,*))
      real, allocatable, dimension(:) :: pos_x, pos_y, pos_z
      real, allocatable, dimension(:) :: pos_x_m, pos_y_m, pos_z_m
      real, allocatable, dimension(:) :: pos_x_1_m, pos_y_1_m, pos_z_1_m
      real, allocatable, dimension(:) :: pos_x_2_m, pos_y_2_m, pos_z_2_m
*
      real work(LDIST_SHAPE,l_nk+1)
*
      real pos_x_1_ref_m(l_ni*l_nj* l_nk   ),pos_y_1_ref_m(l_ni*l_nj* l_nk   )
      real pos_x_2_ref_m(l_ni*l_nj*(l_nk+1)),pos_y_2_ref_m(l_ni*l_nj*(l_nk+1))
*
************************************************************************
*
      if (Schm_zdotMid_L) call gem_stop('adw_main_3_intlag_TL : Schm_zdotMid_L not DONE',-1)
      if (Schm_zdotlag_L) call gem_stop('adw_main_3_intlag_TL : Schm_zdotlag_L not DONE',-1)
*
      if (Lun_debug_L) write (Lun_out,1000)
*
      nij    = l_ni   *l_nj
      nijkt  = l_ni   *l_nj   *(l_nk+1)
      nijkm  = l_ni   *l_nj   * l_nk
      nijkad = Adw_nit*Adw_njt*(l_nk+1)
      call hpalloc(Adw_capx1_   ,nijkt,      err,1)
      call hpalloc(Adw_capy1_   ,nijkt,      err,1)
      call hpalloc(Adw_capz1_   ,nijkt,      err,1)
      call hpalloc(Adw_n1_      ,nijkt,      err,1)
      call hpalloc(Adw_xdd1_    ,nijkt,      err,1)
      call hpalloc(Adw_xgg1_    ,nijkt,      err,1)
      call hpalloc(Adw_ydd1_    ,nijkt,      err,1)
      call hpalloc(Adw_ygg1_    ,nijkt,      err,1)
      call hpalloc(Adw_cz1_     ,nijkt,      err,1)
      call hpalloc(Adw_c1_      ,nijkt,      err,1)
      call hpalloc(Adw_wrkb_    ,nijkt,      err,1)
      call hpalloc(Adw_wrkc_    ,nijkt,      err,1)
*
      allocate ( pos_x(nijkad) )
      allocate ( pos_y(nijkad) )
      allocate ( pos_z(nijkad) )
*
*     TRAJECTORY
*     ----------
      call hpalloc(Adw_capx1_m_ ,nijkt,      err,1)
      call hpalloc(Adw_capy1_m_ ,nijkt,      err,1)
      call hpalloc(Adw_capz1_m_ ,nijkt,      err,1)
      call hpalloc(Adw_n1_m_    ,nijkt,      err,1)
      call hpalloc(Adw_xdd1_m_  ,nijkt,      err,1)
      call hpalloc(Adw_xgg1_m_  ,nijkt,      err,1)
      call hpalloc(Adw_ydd1_m_  ,nijkt,      err,1)
      call hpalloc(Adw_ygg1_m_  ,nijkt,      err,1)
      call hpalloc(Adw_cz1_m_   ,nijkt,      err,1)
      call hpalloc(Adw_c1_m_    ,nijkt,      err,1)
      call hpalloc(Adw_wrkb_m_  ,nijkt,      err,1)
      call hpalloc(Adw_wrkc_m_  ,nijkt,      err,1)
*
      allocate ( pos_x_m(nijkad) )
      allocate ( pos_y_m(nijkad) )
      allocate ( pos_z_m(nijkad) )
*
      allocate ( pos_x_1_m(nijkad) )
      allocate ( pos_y_1_m(nijkad) )
      allocate ( pos_z_1_m(nijkad) )
*
      allocate ( pos_x_2_m(nijkad) )
      allocate ( pos_y_2_m(nijkad) )
      allocate ( pos_z_2_m(nijkad) )
*
      pos_x_m = 0.
      pos_y_m = 0.
      pos_z_m = 0.
*
      pos_x_1_m = 0.
      pos_y_1_m = 0.
      pos_z_1_m = 0.
*
      pos_x_2_m = 0.
      pos_y_2_m = 0.
      pos_z_2_m = 0.
*
*     ZERO adjoint variables 
*     ----------------------
      do n=1,nijkt
      Adw_capx1(n) = 0.
      Adw_capy1(n) = 0. 
      Adw_capz1(n) = 0. 
      Adw_n1   (n) = 0. 
      Adw_xdd1 (n) = 0.
      Adw_xgg1 (n) = 0. 
      Adw_ydd1 (n) = 0. 
      Adw_ygg1 (n) = 0. 
      Adw_cz1  (n) = 0. 
      Adw_c1   (n) = 0. 
      Adw_wrkb (n) = 0. 
      Adw_wrkc (n) = 0. 
      enddo
*
      pos_x = 0.
      pos_y = 0.
      pos_z = 0.
*
      work  = 0. 
*
************************************************************************
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
          if (l_west)  i0=pil_w
          if (l_east)  in=l_niu - pil_e + 2
          if (l_south) j0=pil_s
          if (l_north) jn=l_njv - pil_n + 2
      endif
*
***********************************************************************
      pnlkey1(1) = VMM_KEY(ruw1)
      pnlkey1(2) = VMM_KEY(rvw1)
      pnlkey1(3) = VMM_KEY(ruw2)
      pnlkey1(4) = VMM_KEY(rvw2)
      pnlkey1(5) = VMM_KEY(rhsc)
      pnlkey1(6) = VMM_KEY(orhsc)
      pnlod = 6
*
*     TRAJECTORY
*     ----------
      pnlkey1(pnlod+1) = VMM_KEY(ruw1_m)
      pnlkey1(pnlod+2) = VMM_KEY(rvw1_m)
      pnlkey1(pnlod+3) = VMM_KEY(ruw2_m)
      pnlkey1(pnlod+4) = VMM_KEY(rvw2_m)
      pnlkey1(pnlod+5) = VMM_KEY(rhsc_m)
      pnlkey1(pnlod+6) = VMM_KEY(orhsc_m)
      pnlod = pnlod+6
*
      pnerr = vmmlod(pnlkey1,pnlod)
*
      pnerr = VMM_GET_VAR(ruw1)
      pnerr = VMM_GET_VAR(rvw1)
      pnerr = VMM_GET_VAR(ruw2)
      pnerr = VMM_GET_VAR(rvw2)
      pnerr = VMM_GET_VAR(rhsc)
      pnerr = VMM_GET_VAR(orhsc)
*
*     TRAJECTORY
*     ----------
      pnerr = VMM_GET_VAR(ruw1_m)
      pnerr = VMM_GET_VAR(rvw1_m)
      pnerr = VMM_GET_VAR(ruw2_m)
      pnerr = VMM_GET_VAR(rvw2_m)
      pnerr = VMM_GET_VAR(rhsc_m)
      pnerr = VMM_GET_VAR(orhsc_m)
*
***********************************************************************
      pnlkey2(1) = VMM_KEY(rhst)
      pnlkey2(2) = VMM_KEY(orhst)
      pnlkey2(3) = VMM_KEY(rhsf)
      pnlkey2(4) = VMM_KEY(orhsf)
      pnlod = 4 
*
      if (.not. Schm_hydro_L) then
         pnlkey2(5) = VMM_KEY(rhsw)
         pnlkey2(6) = VMM_KEY(orhsw)
         pnlod = 6
      endif
*
*     TRAJECTORY
*     ----------
      pnlkey2(pnlod+1) = VMM_KEY(rhst_m)
      pnlkey2(pnlod+2) = VMM_KEY(orhst_m)
      pnlkey2(pnlod+3) = VMM_KEY(rhsf_m)
      pnlkey2(pnlod+4) = VMM_KEY(orhsf_m)
      pnlod = pnlod+4
*
      if (.not. Schm_hydro_L) then
         pnlkey2(pnlod+1) = VMM_KEY(rhsw_m)
         pnlkey2(pnlod+2) = VMM_KEY(orhsw_m)
         pnlod = pnlod+2
      endif
*
      pnerr = vmmlod(pnlkey2,pnlod)
*
      pnerr = VMM_GET_VAR(rhst)
      pnerr = VMM_GET_VAR(orhst)
      pnerr = VMM_GET_VAR(rhsf)
      pnerr = VMM_GET_VAR(orhsf)
*
      if (.not. Schm_hydro_L) then
         pnerr = VMM_GET_VAR(rhsw)
         pnerr = VMM_GET_VAR(orhsw)
      endif
*
*     TRAJECTORY
*     ----------
      pnerr = VMM_GET_VAR(rhst_m)
      pnerr = VMM_GET_VAR(orhst_m)
      pnerr = VMM_GET_VAR(rhsf_m)
      pnerr = VMM_GET_VAR(orhsf_m)
*
      if (.not. Schm_hydro_L) then
         pnerr = VMM_GET_VAR(rhsw_m)
         pnerr = VMM_GET_VAR(orhsw_m)
      endif
*
***********************************************************************
* Prepare for advection on momentum levels
***********************************************************************
*     TRAJECTORY
*     ----------
C!$omp parallel do private(n)
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
         pos_x_m(n) =  F_u_m(n)
         pos_y_m(n) =  F_v_m(n)
         pos_z_m(n) =  F_w_m(n)
*
      enddo
      enddo
      enddo
C!$omp end parallel do
*
      if (G_lam) then
          do i = 1,l_ni*l_nj*l_nk
             pos_x_1_ref_m(i) = pos_x_m(i)
             pos_y_1_ref_m(i) = pos_y_m(i)
          enddo
*
          call adw_cliptraj (pos_x_m, pos_y_m, i0, in, j0, jn, l_nk, 'INT_MT_TR')
      endif
*
*     ----------------------------
*     Keep positions in CAP fields
*     ----------------------------
C!$omp parallel private(n)
C!$omp do
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
c        Adw_capx1_m(n) = pos_x_m(n)
c        Adw_capy1_m(n) = pos_y_m(n)
c        Adw_capz1_m(n) = pos_z_m(n)
         pos_x_1_m  (n) = pos_x_m(n)
         pos_y_1_m  (n) = pos_y_m(n)
         pos_z_1_m  (n) = pos_z_m(n)
*
      end do
      end do
      end do
C!$omp end do
C!$omp end parallel
*
***********************************************************************
* Prepare for advection on thermodynamic levels
***********************************************************************
*     From upstream position for momentum levels to upstream
*     position for thermodynamic levels
*
      call adw_meanpos (pos_x_m, pos_y_m, pos_z_m, F_u_m, F_v_m, F_w_m, i0,in,j0,jn)
*
      if (G_lam) then
          do i = 1,l_ni*l_nj*(l_nk+1)
             pos_x_2_ref_m(i) = pos_x_m(i)
             pos_y_2_ref_m(i) = pos_y_m(i)
          enddo
*
          call adw_cliptraj (pos_x_m, pos_y_m, i0, in, j0, jn, l_nk+1, 'INT_TH_TR')
      endif
*
*     ----------------------------
*     Keep positions in CAP fields
*     ----------------------------
C!$omp parallel private(n)
C!$omp do
      do k=1,l_nk+1
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
         Adw_capx1_m(n) = pos_x_m(n)
         Adw_capy1_m(n) = pos_y_m(n)
         Adw_capz1_m(n) = pos_z_m(n)
*
c        pos_x_2_m  (n) = pos_x_m(n)
c        pos_y_2_m  (n) = pos_y_m(n)
c        pos_z_2_m  (n) = pos_z_m(n)
*
      end do
      end do
      end do
C!$omp enddo
C!$omp end parallel 
*
      if ( (Orh_icn .eq. Schm_itcn) .and. (Tr3d_ntr.gt.0) ) then
*
* ADJ of
* Tr3d advection
*
         key1_   = VMM_KEY (trt1)
         key0_   = VMM_KEY (trt0)
         key1_m_ = VMM_KEY (trt1_m)
         key0_m_ = VMM_KEY (trt0_m)
         do n=1,Tr3d_ntr
            key1  (n) = key1_   + n
            key0  (n) = key0_   + n
            key1_m(n) = key1_m_ + n
            key0_m(n) = key0_m_ + n
         end do
         err = vmmlod(key1,  Tr3d_ntr)
         err = vmmlod(key0,  Tr3d_ntr)
         err = vmmlod(key1_m,Tr3d_ntr)
         err = vmmlod(key0_m,Tr3d_ntr)
         do n=1,Tr3d_ntr
*
            err = vmmget(key1(n),patr,tr)
            pnt_trt1(n) = patr
            err = vmmget(key0(n),patr0,tr0)
            pnt_trt0(n) = patr0
*
            err = vmmget(key1_m(n),patr_m,tr_m)
            pnt_trt1_m(n) = patr_m
            err = vmmget(key0_m(n),patr0_m,tr0_m)
            pnt_trt0_m(n) = patr0_m
*
         end do
*
         aaa_8 = -1.d0 / Cstv_tau_8
*
C!$omp parallel
         do n=1,Tr3d_ntr
*
            patr = pnt_trt1(n)
            patr0= pnt_trt0(n)
*
C!$omp do
            do k=1,l_nk+1
            do j=1,l_nj
            do i=1,l_ni
*
*              TRAJECTORY
*              ----------
CCC            tr0_m(i,j,k) = - aaa_8*tr_m(i,j,k)
*
            end do
            end do
            end do
C!$omp enddo
*
C!$omp do
            do k=1,l_nk+1
            do j=1,l_nj
            do i=1,l_ni
*
               tr0(i,j,k) = Cstv_tau_8*tr0(i,j,k)
*
            end do
            end do
            end do
C!$omp enddo
*
            call adw_interp2_ad ( tr0,  work, pos_x,  pos_y,
     %                                  tr0_m,pos_x_m,pos_y_m,
     %                            .false. , Adw_mono_L, LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
            do k=1,l_nk+1
            do j=l_miny,l_maxy
            do i=l_minx,l_maxx
               tr0 (i,j,k) = work(i,j,k) + tr0(i,j,k)
               work(i,j,k) = 0.
            enddo
            enddo
            enddo
C!$omp do
            do k=1,l_nk+1
            do j=1,l_nj
            do i=1,l_ni
*
               tr (i,j,k) = - aaa_8*tr0(i,j,k) + tr(i,j,k)
               tr0(i,j,k) = 0.0
*
            end do
            end do
            end do
C!$omp enddo
*
         end do
*
C!$omp end parallel
*
      endif
*
***********************************************************************
* ADJ of
* Perform interpolation for equations on thermodynamic levels
***********************************************************************
*
      if (.not. Schm_hydro_L) then
*
*
          call adw_interp2_ad (rhsw,  orhsw,  pos_x,  pos_y,
     %                                orhsw_m,pos_x_m,pos_y_m,
     %                         .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
      endif
*
      call adw_interp2_ad (rhsf,  orhsf,  pos_x,  pos_y,
     %                            orhsf_m,pos_x_m,pos_y_m,
     %                     .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
      call adw_interp2_ad (rhst,  orhst,  pos_x,  pos_y,
     %                            orhst_m,pos_x_m,pos_y_m,
     %                     .false., .false., LDIST_DIM, l_nk+1,i0,in,j0,jn,'t')
*
*     ----------------------------
*     ADJ of
*     Keep positions in CAP fields
*     ----------------------------
C!$omp parallel private(n)
C!$omp do
      do k=l_nk+1,1,-1
      do j=jn,j0,-1
      do i=in,i0,-1
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
         pos_z(n) = Adw_capz1(n) + pos_z(n)
         pos_y(n) = Adw_capy1(n) + pos_y(n)
         pos_x(n) = Adw_capx1(n) + pos_x(n)
*
         Adw_capz1(n) = 0.
         Adw_capy1(n) = 0.
         Adw_capx1(n) = 0.
      end do
      end do
      end do
C!$omp enddo
C!$omp end parallel
*
***********************************************************************
* ADJ of
* Prepare for advection on thermodynamic levels
***********************************************************************
*     From upstream position for momentum levels to upstream
*     position for thermodynamic levels
*
      if (G_lam)
     %    call adw_cliptraj_ad (pos_x, pos_y, pos_x_2_ref_m, pos_y_2_ref_m, i0, in, j0, jn, l_nk+1, 'INT_TH_AD')
*
      call adw_meanpos_ad (pos_x,  pos_y,  pos_z,  F_u,  F_v,  F_w,
     %                                             F_u_m,F_v_m,F_w_m,
     %                     i0,in,j0,jn)
*
*     ----------------------------
*     RECALL
*     Keep positions in CAP fields
*     ----------------------------
C!$omp parallel private(n)
C!$omp do
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
         Adw_capx1_m(n) = pos_x_1_m(n)
         Adw_capy1_m(n) = pos_y_1_m(n)
         Adw_capz1_m(n) = pos_z_1_m(n)
*
      end do
      end do
      end do
C!$omp end do
C!$omp end parallel
*
***********************************************************************
* ADJ of
* Perform interpolation on momentum levels
***********************************************************************
*
      call adw_interp2_ad (rhsc,  orhsc,  pos_x,  pos_y,
     %                            orhsc_m,pos_x_m,pos_y_m,
     %                     .false.,.false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
      call adw_interp2_ad (rvw2,  rvw1,  pos_x,  pos_y,
     %                            rvw1_m,pos_x_m,pos_y_m,
     %                     .true., .false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
      call adw_interp2_ad (ruw2,  ruw1,  pos_x,  pos_y,
     %                            ruw1_m,pos_x_m,pos_y_m,
     %                     .true., .false., LDIST_DIM, l_nk,i0,in,j0,jn,'m')
*
*     ----------------------------
*     ADJ of
*     Keep positions in CAP fields
*     ----------------------------
C!$omp parallel private(n)
C!$omp do
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
         pos_z(n) = Adw_capz1(n) + pos_z(n)
         pos_y(n) = Adw_capy1(n) + pos_y(n)
         pos_x(n) = Adw_capx1(n) + pos_x(n)
*
         Adw_capz1(n) = 0.
         Adw_capy1(n) = 0.
         Adw_capx1(n) = 0.
*
      end do
      end do
      end do
C!$omp end do
C!$omp end parallel
*
      if (G_lam) 
     %    call adw_cliptraj_ad (pos_x, pos_y, pos_x_1_ref_m, pos_y_1_ref_m, i0, in, j0, jn, l_nk, 'INT_MT_AD')
*
***********************************************************************
* ADJ of
* Prepare for advection on momentum levels
***********************************************************************
!
C!$omp parallel do private(n)
      do k=1,l_nk
      do j=j0,jn
      do i=i0,in
         n = (k-1)*nij + ((j-1)*l_ni) + i
*
         F_w(n) = pos_z(n) + F_w(n)
         F_v(n) = pos_y(n) + F_v(n)
         F_u(n) = pos_x(n) + F_u(n)
*
         pos_x(n) =  0. 
         pos_y(n) =  0. 
         pos_z(n) =  0.
*
      enddo
      enddo
      enddo
C!$omp end parallel do
*
***********************************************************************
* Deallocate
***********************************************************************
      call hpdeallc(Adw_capx1_   ,err,1)
      call hpdeallc(Adw_capy1_   ,err,1)
      call hpdeallc(Adw_capz1_   ,err,1)
      call hpdeallc(Adw_n1_      ,err,1)
      call hpdeallc(Adw_xdd1_    ,err,1)
      call hpdeallc(Adw_xgg1_    ,err,1)
      call hpdeallc(Adw_ydd1_    ,err,1)
      call hpdeallc(Adw_ygg1_    ,err,1)
      call hpdeallc(Adw_cz1_     ,err,1)
      call hpdeallc(Adw_c1_      ,err,1)
      call hpdeallc(Adw_wrkb_    ,err,1)
      call hpdeallc(Adw_wrkc_    ,err,1)
*
      call hpdeallc(Adw_capx1_m_ ,err,1)
      call hpdeallc(Adw_capy1_m_ ,err,1)
      call hpdeallc(Adw_capz1_m_ ,err,1)
      call hpdeallc(Adw_n1_m_    ,err,1)
      call hpdeallc(Adw_xdd1_m_  ,err,1)
      call hpdeallc(Adw_xgg1_m_  ,err,1)
      call hpdeallc(Adw_ydd1_m_  ,err,1)
      call hpdeallc(Adw_ygg1_m_  ,err,1)
      call hpdeallc(Adw_cz1_m_   ,err,1)
      call hpdeallc(Adw_c1_m_    ,err,1)
      call hpdeallc(Adw_wrkb_m_  ,err,1)
      call hpdeallc(Adw_wrkc_m_  ,err,1)
*
      deallocate (pos_x,pos_y,pos_z)
      deallocate (pos_x_m,pos_y_m,pos_z_m)
      deallocate (pos_x_1_m,pos_y_1_m,pos_z_1_m)
      deallocate (pos_x_2_m,pos_y_2_m,pos_z_2_m)
*
      pnerr = vmmuld(-1,0)
*
 1000  format(3X,'ADJ of ADVECT THE RIGHT-HAND-SIDES: (S/R ADW_MAIN_3_INTLAG_AD)')
*
      return
      end
