!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r itf_phy_apply - apply tendencies to dynamical variables
!
#include "model_macros_f.h"
!
      subroutine itf_phy_apply_ad ( F_apply_L )
      use nest_blending_ad, only: nest_blend_ad
      implicit none
!
      logical,intent(IN) :: F_apply_L
!
!author
!     Stephane Laroche        Janvier 2001
!
!revision
! v3_00 - Laroche S.        - initial MPI version
! v3_20 - Laroche S.        - slight modification to rpn_comm_xch_halo call
! v3_21 - Tanguay M.        - Revision Openmp 
! v3_30 - Tanguay M.        - adapt TL/AD to itf/new tendencies
!                           - Validation for LAM version
! v4_03 - Spacek L.         - Staggered version
! v4_06 - Spacek L.         - GMM version
!
!object
!       TLM of apply consistency of the tendencies on physics variables
!       with related dynamical variables. Interpolate wind
!       tendancies toward theirs respective grids.
!
!arguments
!
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "cstv.cdk"
#include "nest.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "geomg.cdk"
#include "lam.cdk"
#include "vt0_m.cdk"
#include "vt1.cdk"
#include "vt1_m.cdk"
#include "vtx.cdk"
#include "vtx_m.cdk"
#include "p_geof.cdk"
#include "pw.cdk"
#include "itf_phy_buses.cdk"
!
      logical nest_it, flag_u, flag_v, nest_tr
      integer i, j, k, n, err, cnt, HU_indx, UU_indx, VV_indx, km1
      real wk2(LDIST_SHAPE,p_nk),con(YDIST_SHAPE),con2,                    &
           tdu(LDIST_SHAPE,p_nk),tdv(LDIST_SHAPE,p_nk)

      real, pointer, dimension(:,:,:) :: tr,hu
!     __________________________________________________________________
!
      flag_u  = .true. ; flag_v = .true.
      wk2     = 0.; tdu=0.0 ; tdv=0.0
!
      nest_it = ( Lam_0ptend_L .and. G_lam .and.                           &
                ((Lam_blend_Hx.gt.0).or.(Lam_blend_Hy.gt.0)) )
!
      con(:)  = cos(geomg_y_8(:)) / Dcst_rayt_8
!
      if (Schm_pheat_L) then
         nullify(fiptx,st1,tt1,st0_m,tt0_m)
         gmmstat = gmm_get(gmmk_fiptx_s  ,fiptx,meta3d)
         gmmstat = gmm_get(gmmk_st1_s    ,st1  ,meta2d)
         gmmstat = gmm_get(gmmk_tt1_s    ,tt1  ,meta3d)
         gmmstat = gmm_get(gmmk_st0_m_s  ,st0_m,meta2d)
         gmmstat = gmm_get(gmmk_tt0_m_s  ,tt0_m,meta3d)
      call diag_fip_ad (fiptx, st1,   tt1, st0_m, tt0_m,                   &
                        1+pil_w,l_ni-pil_e,1+pil_s,l_nj-pil_n,l_nk)
!
      endif
!

      cnt = 0
      UU_indx = 0
      VV_indx = 0
      HU_indx = 0

      do n=1,p_bvol_top
         if (volnm(n)(1:5) .eq. 'PHYTD') then
            cnt = cnt + 1
            if  (volnm(n)(7:).eq.'UU') UU_indx=cnt
            if  (volnm(n)(7:).eq.'VV') VV_indx=cnt
            if  (volnm(n)(7:).eq.'HU') HU_indx=cnt
            if ((volnm(n)(7:).eq.'UU').or.(volnm(n)(7:).eq.'VV')           &
                                      .or.(volnm(n)(7:).eq.'HU')) cycle
            if (volnm(n)(7:)  .eq. 'TT'   ) then
               nullify(pw_tplus,tt1)
               gmmstat = gmm_get('PW_TT:P',pw_tplus,meta3d)
               gmmstat = gmm_get(gmmk_tt1_s,tt1     ,meta3d)
!
               call tt2virt_ad (tt1 , .true. ,'P')

               do k= 1, p_nk
               do j= 1+pil_s, l_nj-pil_n
               do i= 1+pil_w, l_ni-pil_e
                  phy_tend(i,j,k,cnt) = phy_tend(i,j,k,cnt) + Cstv_dt_8*pw_tplus(i,j,k)
               end do
               end do
               end do
            endif
! Tracers
            nullify(tr)
            gmmstat = gmm_get('TR/'//trim(volnm(n)(7:))//':P',tr,meta3d)
	    if (gmmstat.eq.0) then
               do k=1,p_nk
               do j= 1+pil_s, l_nj-pil_n
               do i= 1+pil_w, l_ni-pil_e
                  phy_tend(i,j,k,cnt) = phy_tend(i,j,k,cnt) + Cstv_dt_8*tr(i,j,k)
               end do
               end do
               end do
            endif

            if ( nest_it ) call nest_blend_ad (phy_tend(:,:,:,cnt),wk2,     &
                                          LDIST_DIM,1,p_nk,'M')


         endif
      end do
!
      if ((UU_indx.gt.0) .and. (VV_indx.gt.0)) then
         nullify(ut1,vt1,pw_uplus,pw_vplus)
         gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
         gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
         gmmstat = gmm_get('PW_UU:P',pw_uplus,meta3d)
         gmmstat = gmm_get('PW_VV:P',pw_vplus,meta3d)

         do k=1,l_nk+1
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_niu-pil_e
               tdu(i,j,k+1) = tdu(i,j,k+1) + Cstv_dt_8*ut1(i,j,k)
             end do
            end do
            do j= 1+pil_s, l_njv-pil_n
            do i= 1+pil_w, l_ni-pil_e
               tdv(i,j,k+1) = tdv(i,j,k+1) + Cstv_dt_8*vt1(i,j,k)
            end do
            end do
         end do

         if ( nest_it ) then
            call nest_blend_ad (tdu,wk2,LDIST_DIM,1,p_nk,'U')
            call nest_blend_ad (tdv,wk2,LDIST_DIM,1,p_nk,'V')
         endif

         call itf_phy_uvgridscal_ad (tdu, tdv, LDIST_DIM, p_nk, .false.)

         do k= 1, p_nk
         do j= 1, l_nj
         do i= 1, l_ni
            phy_tend(i,j,k,UU_indx) = tdu(i,j,k)*con(j)
            phy_tend(i,j,k,VV_indx) = tdv(i,j,k)*con(j)
         end do
         end do
         end do
!
      endif
! Humidity at the end
      if (HU_indx.gt.0) then
         nullify(tr)
         gmmstat = gmm_get('TR/HU:P',tr,meta3d)
         if (gmmstat.eq.0) then
            do k=1,p_nk
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_ni-pil_e
               phy_tend(i,j,k,HU_indx) = phy_tend(i,j,k,HU_indx) + Cstv_dt_8*tr(i,j,k)
            end do
            end do
            end do
         endif
         if ( nest_it ) call nest_blend_ad (phy_tend(:,:,:,HU_indx),wk2,   &
                                       LDIST_DIM,1,p_nk,'M')
      endif
!     
!     __________________________________________________________________

      return
      end
