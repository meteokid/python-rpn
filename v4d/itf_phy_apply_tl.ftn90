!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r itf_phy_apply - apply tendencies to dynamical variables
!
#include "model_macros_f.h"
!
      subroutine itf_phy_apply_tl ( F_apply_L )
      use nest_blending, only: nest_blend
      implicit none
!
      logical,intent(IN) :: F_apply_L
!
!author
!     Stephane Laroche        Janvier 2001
!
!revision
! v3_00 - Laroche S.        - initial MPI version
! v3_20 - Laroche S.        - slight modification to rpn_comm_xch_halo call
! v3_21 - Tanguay M.        - Revision Openmp 
! v3_30 - Tanguay M.        - adapt TL/AD to itf/new tendencies
!                           - Validation for LAM version
! v4_03 - Spacek L.         - Staggered version
! v4_06 - Spacek L.         - GMM version
!
!object
!       TLM of apply consistency of the tendencies on physics variables
!       with related dynamical variables. Interpolate wind
!       tendancies toward theirs respective grids.
!
!arguments
!
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "cstv.cdk"
#include "nest.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "geomg.cdk"
#include "lam.cdk"
#include "vt0_m.cdk"
#include "vt1.cdk"
#include "vt1_m.cdk"
#include "vtx.cdk"
#include "vtx_m.cdk"
#include "p_geof.cdk"
#include "pw.cdk"
#include "itf_phy_buses.cdk"
!
      logical nest_it, flag_u, flag_v
      integer i, j, k, n, err, cnt, UU_indx, VV_indx, km1
      real wk2(LDIST_SHAPE,p_nk),con(YDIST_SHAPE),con2,                    &
           tdu(LDIST_SHAPE,p_nk),tdv(LDIST_SHAPE,p_nk)
      real, pointer, dimension(:,:,:) :: tr, hu
!     __________________________________________________________________
!
      flag_u  = .false. ; flag_v = .false.
      wk2     = 0.; tdu=0.0 ; tdv=0.0
!
      nest_it = ( Lam_0ptend_L .and. G_lam .and.                           &
                ((Lam_blend_Hx.gt.0).or.(Lam_blend_Hy.gt.0)) )
!
      con(:)  = cos(geomg_y_8(:)) / Dcst_rayt_8
!
      cnt = 0
      UU_indx = 0
      VV_indx = 0

      do n=1,p_bvol_top

         if (volnm(n)(1:5) .eq. 'PHYTD') then
            cnt = cnt + 1
            if  (volnm(n)(7:)  .eq. 'UU') UU_indx=cnt
            if  (volnm(n)(7:)  .eq. 'VV') VV_indx=cnt
            if ((volnm(n)(7:)  .eq. 'UU') .or. (volnm(n)(7:)  .eq. 'VV') ) cycle

            if ( nest_it ) call nest_blend (phy_tend(:,:,:,cnt),wk2,       &
                                       LDIST_DIM,1,p_nk,'M')

! Tracers
            nullify(tr)
            gmmstat = gmm_get('TR/'//trim(volnm(n)(7:))//':P',tr,meta3d)
	    if (gmmstat.eq.0) then
!
               do k=1,p_nk
               do j= 1+pil_s, l_nj-pil_n
               do i= 1+pil_w, l_ni-pil_e
                  tr(i,j,k) = tr(i,j,k) + Cstv_dt_8*phy_tend(i,j,k,cnt)
               end do
               end do
               end do
!
            endif

            if (volnm(n)(7:)  .eq. 'TT'   ) then
               nullify(pw_tplus,tt1)
               gmmstat = gmm_get('PW_TT:P',pw_tplus,meta3d)
               gmmstat = gmm_get(gmmk_tt1_s,tt1     ,meta3d)
!
               do k= 1, p_nk
               do j= 1+pil_s, l_nj-pil_n
               do i= 1+pil_w, l_ni-pil_e
                  pw_tplus(i,j,k) = pw_tplus(i,j,k) + Cstv_dt_8*phy_tend(i,j,k,cnt)
               end do
               end do
               end do

               call tt2virt_tl (tt1 , .true., 'P')

            endif

         endif

      end do
!
      if ((UU_indx.gt.0) .and. (VV_indx.gt.0)) then
         nullify(ut1,vt1,pw_uplus,pw_vplus)
         gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
         gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
         gmmstat = gmm_get('PW_UU:P',pw_uplus,meta3d)
         gmmstat = gmm_get('PW_VV:P',pw_vplus,meta3d)
!

         do k= 1, p_nk
         do j= 1, l_nj
         do i= 1, l_ni
            tdu(i,j,k) = phy_tend(i,j,k,UU_indx)*con(j)
            tdv(i,j,k) = phy_tend(i,j,k,VV_indx)*con(j)
         end do
         end do
         end do

         call itf_phy_uvgridscal (tdu, tdv, LDIST_DIM, p_nk, .false. )

         if ( nest_it ) then
            call nest_blend (tdu,wk2,LDIST_DIM,1,p_nk,'U')
            call nest_blend (tdv,wk2,LDIST_DIM,1,p_nk,'V')
         endif
!
         do k=1,l_nk+1
            do j= 1+pil_s, l_nj-pil_n
            do i= 1+pil_w, l_niu-pil_e
               ut1 (i,j,k) =  ut1(i,j,k) + Cstv_dt_8*tdu(i,j,k+1)
            end do
            end do
            do j= 1+pil_s, l_njv-pil_n
            do i= 1+pil_w, l_ni-pil_e
               vt1 (i,j,k) =  vt1(i,j,k) + Cstv_dt_8*tdv(i,j,k+1)
            end do
            end do
         end do
!
      endif
!
      if (Schm_pheat_L) then
         nullify(fiptx,st1,tt1,fiptx_m,st0_m,tt0_m,topo)
         gmmstat = gmm_get(gmmk_fiptx_s  ,fiptx  ,meta3d)
         gmmstat = gmm_get(gmmk_st1_s    ,st1    ,meta2d)
         gmmstat = gmm_get(gmmk_tt1_s    ,tt1    ,meta3d)
         gmmstat = gmm_get(gmmk_st0_m_s  ,st0_m  ,meta2d)
         gmmstat = gmm_get(gmmk_fiptx_m_s,fiptx_m,meta3d)
         gmmstat = gmm_get(gmmk_tt0_m_s  ,tt0_m  ,meta3d)
         gmmstat = gmm_get(gmmk_topo_s   ,topo   ,meta2d)

         call diag_fip_tl ( fiptx,  st1,  tt1,                             &
                         fiptx_m,st0_m,tt0_m,topo,                         &
                         1+pil_w,l_ni-pil_e,1+pil_s,l_nj-pil_n,l_nk)
      endif
!
!     __________________________________________________________________
!
      return
      end
