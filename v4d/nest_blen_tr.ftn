! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r nest_blen_tr - Equivalent to nest_blen for TRAJECTORY 
*
#include "model_macros_f.h"
*
      subroutine nest_blen_tr ()
*
      implicit none
*
*author M.Tanguay 
*
*revision
* v3_30 - Tanguay M.        - initial MPI version
* v4_04 - Tanguay M.        - Staggered version TL/AD 
* v4_10 - Tanguay M.        - Open top TL/AD
* v4_10 - Tanguay M.        - VMM replacement with GMM for (TL/AD)
*
*object
*
*implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "vt1_m.cdk"
#include "nest_m.cdk"
#include "tr3d.cdk"
#include "schm.cdk"
#include "hblen.cdk"
#include "vtopo.cdk"
#include "lun.cdk"
*
      character*16 tr_name
      integer err,i,j,k,n
      real, pointer, dimension(:,:,:) :: trn_m,tr1_m
*----------------------------------------------------------------------
*
      if ( (north+south+west+east.lt.1) .or.
     $    ((Hblen_x.le.0).and.(Hblen_y.le.0)) ) return
*
      if (Lun_debug_L) write(Lun_out,1001)
*
      gmmstat = gmm_get(gmmk_nest_u_m_s ,nest_u_m ,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(nest_u_m)'
      gmmstat = gmm_get(gmmk_nest_v_m_s ,nest_v_m ,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(nest_v_m)'
      gmmstat = gmm_get(gmmk_nest_w_m_s ,nest_w_m ,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(nest_w_m)'
      gmmstat = gmm_get(gmmk_nest_t_m_s ,nest_t_m ,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(nest_t_m)'
      gmmstat = gmm_get(gmmk_nest_zd_m_s,nest_zd_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(nest_zd_m)'
      gmmstat = gmm_get(gmmk_nest_s_m_s ,nest_s_m ,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(nest_s_m)'
*
      gmmstat = gmm_get(gmmk_ut1_m_s,ut1_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(ut1_m)'
      gmmstat = gmm_get(gmmk_vt1_m_s,vt1_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(vt1_m)'
      gmmstat = gmm_get(gmmk_wt1_m_s,wt1_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(wt1_m)'
      gmmstat = gmm_get(gmmk_tt1_m_s,tt1_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(tt1_m)'
      gmmstat = gmm_get(gmmk_zdt1_m_s,zdt1_m,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(zdt1_m)'
      gmmstat = gmm_get(gmmk_st1_m_s,st1_m,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(st1_m)'
      if (.not.Schm_hydro_L) then
         gmmstat = gmm_get(gmmk_nest_q_m_s,nest_q_m,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(nest_q_m)'
         gmmstat = gmm_get(gmmk_qt1_m_s,qt1_m,meta3d)
         if (GMM_IS_ERROR(gmmstat)) print *,'nest_blen_tr ERROR at gmm_get(qt1_m)'
      endif
*
* Update the nesting values in the blending zone before blending
* if the orography is growing
      if (Vtopo_L.and.(.not.Schm_theoc_L)) then
         call vtopo_bnd_update(nest_t_m,nest_s_m,
     $        LDIST_DIM,G_nk,Hblen_x,Hblen_y)
      endif
*
* Set up blending zones
      call nesajr (ut1_m  ,nest_u_m  ,LDIST_DIM,G_nk  ,1,0,Hblen_x,Hblen_y,Hblen_z)
      call nesajr (vt1_m  ,nest_v_m  ,LDIST_DIM,G_nk  ,0,1,Hblen_x,Hblen_y,Hblen_z)
      call nesajr (wt1_m  ,nest_w_m  ,LDIST_DIM,G_nk+1,0,0,Hblen_x,Hblen_y,Hblen_z)
      call nesajr (zdt1_m ,nest_zd_m ,LDIST_DIM,G_nk+1,0,0,Hblen_x,Hblen_y,Hblen_z)
      call nesajr (tt1_m  ,nest_t_m  ,LDIST_DIM,G_nk+1,0,0,Hblen_x,Hblen_y,Hblen_z)
      call nesajr (st1_m  ,nest_s_m  ,LDIST_DIM,1     ,0,0,Hblen_x,Hblen_y,Hblen_z)
*
      if (.not. Schm_hydro_L) then
      call nesajr (qt1_m  ,nest_q_m  ,LDIST_DIM,G_nk+2,0,0,Hblen_x,Hblen_y,Hblen_z)
      endif
*
      do n=1,Tr3d_ntr
         tr_name = 'TRM/'//trim(Tr3d_name_S(n))//':N'
         gmmstat = gmm_get(tr_name,trn_m,meta3d)
         tr_name = 'TRM/'//trim(Tr3d_name_S(n))//':P'
         gmmstat = gmm_get(tr_name,tr1_m,meta3d)
         call nesajr (tr1_m, trn_m, LDIST_DIM,G_nk+1,0,0,Hblen_x,Hblen_y,Hblen_z)
      enddo
*
 1001 format(/,'BLENDING TO PILOT AREA(S/R NEST_BLEN_TR):',/,60('='))
*----------------------------------------------------------------------
      return
      end
