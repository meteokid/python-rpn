
subroutine adx_trilin_opt_ad()
   call stop_mpi(STOP_ERROR,'adx_trilin_opt_ad','called a stub')
   return
end subroutine adx_trilin_opt_ad

subroutine adx_trilin_opt2_ad()
   call stop_mpi(STOP_ERROR,'adx_trilin_opt2_ad','called a stub')
   return
end subroutine adx_trilin_opt2_ad

   !/**
subroutine adx_trilin_opt3_ad(F_xo  ,F_yo  ,F_u1  ,F_u2  ,F_xth  ,F_yth  ,F_zth  , &
                                            F_u1_m,F_u2_m,F_xth_m,F_yth_m,F_zth_m, &
                              F_dth,F_has_u2_L, F_i0,F_in,F_j0,F_jn, &
                              F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,F_nk, F_nk_super)

   implicit none
   !@objective ADJ of adx_trilin_opt 
   !@arguments
   logical :: F_has_u2_L           !I, .T. if F_u2 needs to be treated
   real    :: F_dth                !I, multiplicative constant (1. or timestep)
   integer :: F_nk, F_nk_super     !I, number of vertical levels
   integer :: F_aminx, F_amaxx, F_aminy, F_amaxy !I, wind fields array bounds
   integer :: F_ni, F_nj           !I, dims of position fields
   integer :: F_i0,F_in,F_j0,F_jn  !I, operator scope
   real,dimension(F_ni,F_nj,F_nk) :: F_xth  ,F_yth  ,F_zth,  & !I, x,y,z positions
                                     F_xth_m,F_yth_m,F_zth_m   !I, x,y,z positions TRAJ
   real,dimension(F_aminx:F_amaxx,F_aminy:F_amaxy,F_nk_super) :: &
        F_u1  , F_u2  , &  !I, field to interpol
        F_u1_m, F_u2_m     !I, field to interpol TRAJ
   real,dimension(F_ni,F_nj,F_nk) :: F_xo  ,F_yo !O, F_dt * result of interp
   !@author monique tanguay
   !@revisions
   ! v4_XX - Tanguay M.        - Adjustments GEM413
   !**/
#include "adx_nml.cdk"
#include "adx_dims.cdk"
   integer :: num
   logical,parameter :: DO_HORIZ_L = .true.
   logical,parameter :: DO_VERTI_L = .true.
   real,    dimension(F_ni,F_nj,F_nk) :: capx1,capy1,capz1
   !
   integer, dimension(F_ni,F_nj,F_nk) :: n1_m
   real,    dimension(F_ni,F_nj,F_nk) :: capx1_m,capy1_m,capz1_m
   !---------------------------------------------------------------------
   num = F_ni*F_nj*F_nk
   !
   !Zero adjoint variables
   !---------------------- 
   capx1 = 0. 
   capy1 = 0. 
   capz1 = 0. 
   !
   if (adw_nosetint_L) call handle_error(-1,'adx_trilin_opt_ad','adw_nosetint_L NOT DONE')
   !
   if (.not.adw_nosetint_L) then

      !TRAJECTORY
      !----------
!!!   call adx_setint_lin_hor_ver2(n1_m,capx1_m,capy1_m,capz1_m,F_xth_m,F_yth_m,F_zth_m,&
!!!                                F_i0,F_in,F_j0,F_jn, F_ni,F_nj,F_nk)
      call adx_setint_lin_hor_ver1(n1_m,capx1_m,capy1_m,capz1_m,F_xth_m,F_yth_m,F_zth_m,&
                                   F_i0,F_in,F_j0,F_jn, F_nk,num)


      if (F_has_u2_L) then
         call adx_trilin3_ad(F_yo  ,F_u2             ,capx1  ,capy1  ,capz1  , &
                                    F_u2_m,F_dth,n1_m,capx1_m,capy1_m,capz1_m, &
                             F_i0,F_in,F_j0,F_jn, &
                             F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,F_nk, F_nk_super)
      endif

      call adx_trilin3_ad(F_xo  ,F_u1  ,           capx1  ,capy1  ,capz1  , &
                                 F_u1_m,F_dth,n1_m,capx1_m,capy1_m,capz1_m, &
                          F_i0,F_in,F_j0,F_jn, &
                          F_ni,F_nj,F_aminx, F_amaxx, F_aminy, F_amaxy,F_nk, F_nk_super)

      call adx_setint_lin_hor_ver2_ad(      capx1  ,capy1  ,capz1  ,F_xth  ,F_yth  ,F_zth  ,&
                                                                    F_xth_m,F_yth_m,F_zth_m,&
                                      F_i0,F_in,F_j0,F_jn, F_ni,F_nj,F_nk)

   else
   ! NOT DONE
   endif
   !---------------------------------------------------------------------
   return
   end subroutine adx_trilin_opt3_ad
