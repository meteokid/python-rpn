!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/r adw_main_1_wnd2_ad - ADJ of adw_main_1_wnd2 
*
#include "model_macros_f.h"
#include "msg.h"
*
      subroutine adw_main_1_wnd2_ad (F_su,F_sv,F_sw,um,vm,wm,ut,vt,wt,F_nit,F_njt,F_nk)
*
      implicit none
*
      integer F_nit, F_njt, F_nk
*
      real F_su(*),
     %     F_sv(*),
     %     F_sw(*)
      real um(F_nit,F_njt,F_nk),
     %     vm(F_nit,F_njt,F_nk),
     %     wm(F_nit,F_njt,F_nk),
     %     ut(F_nit,F_njt,F_nk+1),
     %     vt(F_nit,F_njt,F_nk+1),
     %     wt(F_nit,F_njt,F_nk+1)
*
*author
*     monique tanguay
*
*revision
* v2_31 - Tanguay M.        - initial MPI version
* v3_00 - Tanguay M.        - adapt to restructured adw_main 
* v3_11 - Tanguay M.        - AIXport+Opti+OpenMP for TLM-ADJ
* v3_21 - Tanguay M.        - Revision Openmp
* v3_30 - Tanguay M.        - Validation for LAM version 
* v4_04 - Tanguay M.        - Staggered version TL/AD 
* v4_10 - Tanguay M.        - VMM replacement with GMM for (TL/AD)
* v4_12 - Tanguay M.        - TL/AD Thermo upstream positions
*
*language
*     fortran 77
*
*object
*     see id section
*
*ADJ of
*arguments
*______________________________________________________________________
*              |                                                 |     |
* NAME         | DESCRIPTION                                     | I/O |
*--------------|-------------------------------------------------|-----|
* F_nk         | number of levels                                |  i  |
*______________|_________________________________________________|_____|
*
*implicits
#include "gmm.hf"
#include "var_gmm.cdk"
!      type(gmm_metadata) :: meta3d
!      integer :: gmmstat
#include "glb_ld.cdk"
!      logical G_lam, G_periodx, G_periody
!      integer G_ni
!      integer G_halox, G_haloy
!      logical l_north, l_south, l_east, l_west
!      integer l_ni, l_nj, l_niu, l_njv
!      integer l_minx, l_maxx, l_miny, l_maxy
#include "ver.cdk"
#include "adw.cdk"
!      integer adw_nic,adw_njc, adw_halox, adw_haloy
!      real*8 adw_cy_8(),adw_cx_8(),adw_sx_8(),adw_wx_8(),adw_sy_8()
#include "inuvl.cdk"
!      real*8 inuvl_wxux3_8(XDIST_SHAPE,4)
!      real*8 inuvl_wyvy3_8(YDIST_SHAPE,4)
#include "vth.cdk"
!      real, pointer, dimension (:,:,:) :: uth,vth,zdth
!      character(len=8) :: gmmk_uth_s, gmmk_vth_s, gmmk_zdth_s
#include "geomg.cdk"
*
************************************************************************
      type(gmm_metadata) :: dummy_gmm_meta
*
      integer i, j, k, i0, in, j0, jn, n, dest_ni,istat
      real*8 sc_8, lag3_8, xx_8, x1_8, x2_8, x3_8, x4_8, w1_8, w2_8, w3_8, w4_8, den_8
      real*8, parameter ::  ONE_8 = 1.0
      real*8, parameter :: ZERO_8 = 0.0
#define lag3_8(xx_8, x1_8, x2_8, x3_8, x4_8)  ((( xx_8 - x2_8 ) * ( xx_8 - x3_8 ) * ( xx_8 - x4_8 ))/( ( x1_8 - x2_8 ) * ( x1_8 - x3_8 ) * ( x1_8 - x4_8 )))
      real, dimension(LDIST_SHAPE,F_nk  ) :: workm
      real, dimension(LDIST_SHAPE,F_nk+1) :: wut,wvt
* 
      real, dimension(:,:,:)  ,allocatable :: in0_1,in0_2,in0_3,inw_1,inw_2,inw_3
*
************************************************************************
*
      call msg(MSG_DEBUG,'ADJ of PREPARE WINDS: (S/R ADW_MAIN_1_WND_AD)')
*
      if (G_lam) allocate ( in0_1(LDIST_SHAPE,F_nk)   )
      if (G_lam) allocate ( in0_2(LDIST_SHAPE,F_nk)   )
      if (G_lam) allocate ( in0_3(LDIST_SHAPE,F_nk+1) )
      if (G_lam) allocate ( inw_1(LDIST_SHAPE,F_nk+1) )
      if (G_lam) allocate ( inw_2(LDIST_SHAPE,F_nk+1) )
      if (G_lam) allocate ( inw_3(LDIST_SHAPE,F_nk)   )
*
*     ZERO adjoint variables
*     ----------------------
      workm = 0.
      wut   = 0.
      wvt   = 0.
      if (G_lam) then
      in0_1 = 0. 
      in0_2 = 0. 
      in0_3 = 0. 
      inw_1 = 0. 
      inw_2 = 0. 
      inw_3 = 0. 
      endif
*
      istat = gmm_get(gmmk_uth_s,uth,dummy_gmm_meta)
      istat = min(istat,gmm_get(gmmk_vth_s,vth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zdth_s,zdth,dummy_gmm_meta))
      call handle_error(istat,'adw_main_1_wnd2_ad','gmm_get')
*
      call adw_load_super_winds_ad (um,vm,wt,ut,vt,wm,F_su,F_sv,F_sw)
*
C!$omp parallel private(k,i0,in,j0,jn,sc_8,
C!$omp& xx_8, x1_8, x2_8, x3_8, x4_8, w1_8, w2_8, w3_8, w4_8, den_8)
*
***********************************************************************
* ADJ of
* Adjust wind fields to advection grid
***********************************************************************
      if (.not.G_lam) then
*
         if ( l_north ) then
*
            call adw_pols_ad (wm,Adw_wx_8,Adw_njc+1,Adw_nic,Adw_halox,
     %        Adw_njc,Adw_haloy,F_nk)
*
            call adw_pols_ad (wt,Adw_wx_8,Adw_njc+1,Adw_nic,Adw_halox,
     %        Adw_njc,Adw_haloy,F_nk+1)
*
            call adw_polw_ad (ut,vt,Adw_cx_8,Adw_sx_8,Adw_wx_8,
     %        Adw_sy_8,Adw_njc+1,Adw_nic,Adw_halox,Adw_njc,Adw_haloy,F_nk+1)
*
            call adw_polw_ad (um,vm,Adw_cx_8,Adw_sx_8,Adw_wx_8,
     %        Adw_sy_8,Adw_njc+1,Adw_nic,Adw_halox,Adw_njc,Adw_haloy,F_nk)
*
         endif
*
         if ( l_south ) then
*
            call adw_pols_ad (wm,Adw_wx_8,0,Adw_nic,Adw_halox,Adw_njc,
     %        Adw_haloy,F_nk)
*
            call adw_pols_ad (wt,Adw_wx_8,0,Adw_nic,Adw_halox,Adw_njc,
     %        Adw_haloy,F_nk+1)
*
            call adw_polw_ad (ut,vt,Adw_cx_8,Adw_sx_8,Adw_wx_8,
     %        Adw_sy_8,0,Adw_nic,Adw_halox,Adw_njc,Adw_haloy,F_nk+1)
*
            call adw_polw_ad (um,vm,Adw_cx_8,Adw_sx_8,Adw_wx_8,
     %        Adw_sy_8,0,Adw_nic,Adw_halox,Adw_njc,Adw_haloy,F_nk)
*
         endif
*
      endif
*
      if (G_lam) then
          n=0
          dest_ni=l_ni
      else
          n=999
          dest_ni=G_ni
      endif
*
      if (G_lam) then
*
          in0_1 = uth
          in0_2 = vth
          in0_3 = zdth
*
          inw_1 = wut 
          inw_2 = wvt 
          inw_3 = workm 
*
      endif
*
C!$omp single
      call rpn_comm_adj_halox ( workm, LDIST_DIM, l_ni, l_nj, F_nk,
     %  Adw_halox, Adw_haloy, G_periodx, G_periody, wm, 1-Adw_halox,
     %  Adw_nic+Adw_halox, 1-Adw_haloy, Adw_njc+Adw_haloy, dest_ni, n)
      call rpn_comm_adj_halox ( zdth, LDIST_DIM, l_ni, l_nj, F_nk+1,
     %  Adw_halox, Adw_haloy, G_periodx, G_periody, wt, 1-Adw_halox,
     %  Adw_nic+Adw_halox, 1-Adw_haloy, Adw_njc+Adw_haloy, dest_ni, n)
*
      call rpn_comm_adj_halox ( wvt, LDIST_DIM, l_ni, l_nj, F_nk+1,
     %  Adw_halox, Adw_haloy, G_periodx, G_periody, vt, 1-Adw_halox,
     %  Adw_nic+Adw_halox, 1-Adw_haloy, Adw_njc+Adw_haloy, dest_ni, n)
      call rpn_comm_adj_halox ( vth, LDIST_DIM, l_ni, l_nj, F_nk,
     %  Adw_halox, Adw_haloy, G_periodx, G_periody, vm, 1-Adw_halox,
     %  Adw_nic+Adw_halox, 1-Adw_haloy, Adw_njc+Adw_haloy, dest_ni, n)
*
      call rpn_comm_adj_halox ( wut, LDIST_DIM, l_ni, l_nj, F_nk+1,
     %  Adw_halox, Adw_haloy, G_periodx, G_periody, ut, 1-Adw_halox,
     %  Adw_nic+Adw_halox, 1-Adw_haloy, Adw_njc+Adw_haloy, dest_ni, n)
      call rpn_comm_adj_halox ( uth, LDIST_DIM, l_ni, l_nj, F_nk,
     %  Adw_halox, Adw_haloy, G_periodx, G_periody, um, 1-Adw_halox,
     %  Adw_nic+Adw_halox, 1-Adw_haloy, Adw_njc+Adw_haloy, dest_ni, n)
C!$omp end single
*
       if (G_lam) then
C!$omp do
           do k=1,F_nk+1
           do j=l_miny,l_maxy
           do i=l_minx,l_maxx
              zdth (i,j,k) = in0_3(i,j,k) + zdth(i,j,k)
C             in0_3(i,j,k) = ZERO_8
           end do
           end do
           end do
C!$omp end do
*
C!$omp do
           do k=1,F_nk
           do j=l_miny,l_maxy
           do i=l_minx,l_maxx
              vth  (i,j,k) = in0_2(i,j,k) + vth(i,j,k)
              uth  (i,j,k) = in0_1(i,j,k) + uth(i,j,k)
C             in0_2(i,j,k) = ZERO_8
C             in0_1(i,j,k) = ZERO_8
           end do
           end do
           end do
C!$omp end do
*
C!$omp do
           do k=1,F_nk
           do j=l_miny,l_maxy
           do i=l_minx,l_maxx
              workm(i,j,k) = inw_3(i,j,k) + workm(i,j,k)
C             inw_3(i,j,k) = ZERO_8
           end do
           end do
           end do
C!$omp end do
*
C!$omp do
           do k=1,F_nk+1
           do j=l_miny,l_maxy
           do i=l_minx,l_maxx
              wvt  (i,j,k) = inw_2(i,j,k) + wvt(i,j,k)
              wut  (i,j,k) = inw_1(i,j,k) + wut(i,j,k)
C             inw_2(i,j,k) = ZERO_8
C             inw_1(i,j,k) = ZERO_8
           end do
           end do
           end do
C!$omp end do
         endif
*
*     Zero adjoint variables
*     ----------------------
      um = 0. 
      vm = 0. 
      wt = 0. 
      ut = 0. 
      vt = 0. 
      wm = 0. 
*
***********************************************************************
* ADJ of
* Interpolate u and v on thermo levels
***********************************************************************
*
*     TRAJECTORY
*     ----------
      i0 = 1
      in = l_ni
      j0 = 1
      jn = l_nj
      if (G_lam) then
         if (l_west)  i0 = 3
         if (l_east)  in = l_ni - 1
         if (l_south) j0 = 3
         if (l_north) jn = l_nj - 1
      endif
*
* ADJ of
* Downward Extrapolation
      den_8=1.d0/(Ver_z_8%m(F_nk-1)-Ver_z_8%m(F_nk))
      k=F_nk+1
      w1_8=(Ver_z_8%t(k)     -Ver_z_8%m(F_nk))*den_8
      w2_8=(Ver_z_8%m(F_nk-1)-Ver_z_8%t(k)   )*den_8
C!$omp do
      do j = j0, jn
      do i = i0, in
         vth(i,j,F_nk-1) = w1_8*wvt(i,j,k) + vth(i,j,F_nk-1)
         vth(i,j,F_nk)   = w2_8*wvt(i,j,k) + vth(i,j,F_nk)
         wvt(i,j,k)      = ZERO_8
*
         uth(i,j,F_nk-1) = w1_8*wut(i,j,k) + uth(i,j,F_nk-1)
         uth(i,j,F_nk)   = w2_8*wut(i,j,k) + uth(i,j,F_nk)
         wut(i,j,k)      = ZERO_8
      enddo
      enddo
C!$omp enddo
*
      k=F_nk
      w1_8=(Ver_z_8%t(k)     -Ver_z_8%m(F_nk))*den_8
      w2_8=(Ver_z_8%m(F_nk-1)-Ver_z_8%t(k)   )*den_8
C!$omp do
      do j = j0, jn
      do i = i0, in
         vth(i,j,F_nk-1) = w1_8*wvt(i,j,k) + vth(i,j,F_nk-1)
         vth(i,j,F_nk)   = w2_8*wvt(i,j,k) + vth(i,j,F_nk)
         wvt(i,j,k)      = ZERO_8
*
         uth(i,j,F_nk-1) = w1_8*wut(i,j,k) + uth(i,j,F_nk-1)
         uth(i,j,F_nk)   = w2_8*wut(i,j,k) + uth(i,j,F_nk)
         wut(i,j,k)      = ZERO_8
      enddo
      enddo
C!$omp enddo
*
* ADJ of
* Updward Extrapolation
      den_8=1.d0/(Ver_z_8%m(1)-Ver_z_8%m(2))
      k=1
      w1_8=(Ver_z_8%t(k)-Ver_z_8%m(2))*den_8
      w2_8=(Ver_z_8%m(1)-Ver_z_8%t(k))*den_8
C!$omp do
      do j = j0, jn
      do i = i0, in
         vth(i,j,1) = w1_8*wvt(i,j,k) + vth(i,j,1)
         vth(i,j,2) = w2_8*wvt(i,j,k) + vth(i,j,2)
         wvt(i,j,k) = ZERO_8
*
         uth(i,j,1) = w1_8*wut(i,j,k) + uth(i,j,1)
         uth(i,j,2) = w2_8*wut(i,j,k) + uth(i,j,2) 
         wut(i,j,k) = ZERO_8
      enddo
      enddo
C!$omp enddo
*
      k=2
      w1_8=(Ver_z_8%t(k)-Ver_z_8%m(2))*den_8
      w2_8=(Ver_z_8%m(1)-Ver_z_8%t(k))*den_8
C!$omp do
      do j = j0, jn
      do i = i0, in
         vth(i,j,1) = w1_8*wvt(i,j,k) + vth(i,j,1)
         vth(i,j,2) = w2_8*wvt(i,j,k) + vth(i,j,2)
         wvt(i,j,k) = ZERO_8
*
         uth(i,j,1) = w1_8*wut(i,j,k) + uth(i,j,1)
         uth(i,j,2) = w2_8*wut(i,j,k) + uth(i,j,2)
         wut(i,j,k) = ZERO_8
      enddo
      enddo
C!$omp enddo
*
C!$omp do
      do k=3,F_nk-1
         xx_8 = Ver_z_8%t(k)
         x1_8 = Ver_z_8%m(k-2)
         x2_8 = Ver_z_8%m(k-1)
         x3_8 = Ver_z_8%m(k  )
         x4_8 = Ver_z_8%m(k+1)
         w1_8 = lag3_8( xx_8, x1_8, x2_8, x3_8, x4_8 )
         w2_8 = lag3_8( xx_8, x2_8, x1_8, x3_8, x4_8 )
         w3_8 = lag3_8( xx_8, x3_8, x1_8, x2_8, x4_8 )
         w4_8 = lag3_8( xx_8, x4_8, x1_8, x2_8, x3_8 )

         do j = j0, jn
         do i = i0, in
*
            vth(i,j,k-2) = w1_8*wvt(i,j,k) + vth(i,j,k-2)
            vth(i,j,k-1) = w2_8*wvt(i,j,k) + vth(i,j,k-1)
            vth(i,j,k  ) = w3_8*wvt(i,j,k) + vth(i,j,k  )
            vth(i,j,k+1) = w4_8*wvt(i,j,k) + vth(i,j,k+1)
            wvt(i,j,k)   = ZERO_8
*
            uth(i,j,k-2) = w1_8*wut(i,j,k) + uth(i,j,k-2)
            uth(i,j,k-1) = w2_8*wut(i,j,k) + uth(i,j,k-1)
            uth(i,j,k  ) = w3_8*wut(i,j,k) + uth(i,j,k  )
            uth(i,j,k+1) = w4_8*wut(i,j,k) + uth(i,j,k+1)
            wut(i,j,k)   = ZERO_8
*
         enddo
         enddo
      enddo
C!$omp enddo
*
***********************************************************************
* ADJ of
* Interpolate w on momentum levels
***********************************************************************
*     Note  zdth(i,j,F_nk+1)=0
      k=F_nk
      w1_8=(Ver_z_8%m(k)-Ver_z_8%t(k+1))/
     $     (Ver_z_8%t(k)-Ver_z_8%t(k+1))
c     w2_8=(Ver_z_8%t(k)-Ver_z_8%m(k))/
c    $     (Ver_z_8%t(k)-Ver_z_8%t(k+1))
C!$omp do
      do j = j0, jn
      do i = i0, in
         zdth (i,j,k) = w1_8*workm(i,j,k) + zdth(i,j,k) 
         workm(i,j,k) = ZERO_8
      enddo
      enddo
C!$omp enddo
*
*     Note  zdth(i,j,1)=0
      k=1
c     w1_8=(Ver_z_8%m(k)-Ver_z_8%t(k+1))/
c    $     (Ver_z_8%t(k)-Ver_z_8%t(k+1))
      w2_8=(Ver_z_8%t(k)-Ver_z_8%m(k))/
     $     (Ver_z_8%t(k)-Ver_z_8%t(k+1))
C!$omp do
      do j = j0, jn
      do i = i0, in
         zdth (i,j,k+1) = w2_8*workm(i,j,k) + zdth(i,j,k+1)
         workm(i,j,k)   = ZERO_8
      enddo
      enddo
C!$omp enddo
*
C!$omp do
      do k=2,F_nk-1
         xx_8 = Ver_z_8%m(k)
         x1_8 = Ver_z_8%t(k-1)
         x2_8 = Ver_z_8%t(k)
         x3_8 = Ver_z_8%t(k+1)
         x4_8 = Ver_z_8%t(k+2)
         w1_8 = lag3_8( xx_8, x1_8, x2_8, x3_8, x4_8 )
         w2_8 = lag3_8( xx_8, x2_8, x1_8, x3_8, x4_8 )
         w3_8 = lag3_8( xx_8, x3_8, x1_8, x2_8, x4_8 )
         w4_8 = lag3_8( xx_8, x4_8, x1_8, x2_8, x3_8 )
         do j = j0, jn
         do i = i0, in
            zdth (i,j,k-1) = w1_8*workm(i,j,k) + zdth(i,j,k-1)
            zdth (i,j,k)   = w2_8*workm(i,j,k) + zdth(i,j,k)
            zdth (i,j,k+1) = w3_8*workm(i,j,k) + zdth(i,j,k+1)
            zdth (i,j,k+2) = w4_8*workm(i,j,k) + zdth(i,j,k+2)
            workm(i,j,k)   = ZERO_8 
         enddo
         enddo
      enddo
C!$omp enddo
*
***********************************************************************
* ADJ of
* Image to component
***********************************************************************
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
             if (l_west) i0 = 3
             if (l_east) in = l_niu - 1
      endif
*
C!$omp do
      do k = 1,F_nk
      do j = j0,jn
*
      sc_8 = ONE_8/Adw_cy_8(j)
*
      do i = i0,in
*
      um (i,j,k) = sc_8 * uth(i,j,k) + um(i,j,k)
      uth(i,j,k) = ZERO_8
*
      enddo
      enddo
      enddo
C!$omp enddo
*
      i0=1
      in=l_ni
      j0=1
      jn=l_nj
      if (G_lam) then
             if (l_south) j0 = 3
             if (l_north) jn = l_njv - 1
      endif
*
C!$omp do
      do k = 1,F_nk
      do j = j0,jn
*
      sc_8 = ONE_8/Adw_cy_8(j)
*
      do i = i0,in
*
      vm (i,j,k) = sc_8 * vth(i,j,k) + vm(i,j,k)
      vth(i,j,k) = ZERO_8
*
      enddo
      enddo
      enddo
C!$omp enddo
*
***********************************************************************
* ADJ of
* Interpolate advection winds to geopotential grid
* F_u and F_v are used as work space
***********************************************************************
C!$omp do
      do k=1,F_nk
*
         i0 = 1
         in = l_ni
         j0 = 1
         jn = l_njv
         if (l_south) j0 = 3
         if (l_north) jn = l_njv - 1
*
         if (.not.G_lam) then
*
         if (l_north) then
            do i = i0, in
         vth(i,jn+1,k) = inuvl_wyvy3_8(jn+1,3) * vm(i,jn+1,k) + vth(i,jn+1,k)
         vth(i,jn  ,k) = inuvl_wyvy3_8(jn+1,2) * vm(i,jn+1,k) + vth(i,jn  ,k)
         vth(i,jn-1,k) = inuvl_wyvy3_8(jn+1,1) * vm(i,jn+1,k) + vth(i,jn-1,k)
         vm (i,jn+1,k) = ZERO_8
*
         vth(i,jn+1,k) = inuvl_wyvy3_8(jn+2,2) * vm(i,jn+2,k) + vth(i,jn+1,k)
         vth(i,jn  ,k) = inuvl_wyvy3_8(jn+2,1) * vm(i,jn+2,k) + vth(i,jn  ,k)
         vm (i,jn+2,k) = ZERO_8
            end do
         endif
         if (l_south) then
            do i = i0, in
         vth(i,j0,  k) = inuvl_wyvy3_8(j0-1,4) * vm(i,j0-1,k) + vth(i,j0,  k)
         vth(i,j0-1,k) = inuvl_wyvy3_8(j0-1,3) * vm(i,j0-1,k) + vth(i,j0-1,k)
         vth(i,j0-2,k) = inuvl_wyvy3_8(j0-1,2) * vm(i,j0-1,k) + vth(i,j0-2,k)
         vm (i,j0-1,k) = ZERO_8
*
         vth(i,j0-1,k) = inuvl_wyvy3_8(j0-2,4) * vm(i,j0-2,k) + vth(i,j0-1,k)
         vth(i,j0-2,k) = inuvl_wyvy3_8(j0-2,3) * vm(i,j0-2,k) + vth(i,j0-2,k)
         vm (i,j0-2,k) = ZERO_8
            end do
         endif
*
         endif
*
         do j = jn, j0, -1
         do i = in, i0, -1
         vth(i,j+1,k) = inuvl_wyvy3_8(j,4) * vm(i,j,k) + vth(i,j+1,k)
         vth(i,j  ,k) = inuvl_wyvy3_8(j,3) * vm(i,j,k) + vth(i,j  ,k)
         vth(i,j-1,k) = inuvl_wyvy3_8(j,2) * vm(i,j,k) + vth(i,j-1,k)
         vth(i,j-2,k) = inuvl_wyvy3_8(j,1) * vm(i,j,k) + vth(i,j-2,k)
         vm (i,j,  k) = ZERO_8
         end do
         end do
*
         i0 = 1
         in = l_niu
         j0 = 1
         jn = l_nj
         if (G_lam) then
             if (l_west) i0 = 3
             if (l_east) in = l_niu - 1
         endif
*
         do j = jn,j0,-1
         do i = in,i0,-1
         uth(i+1,j,k) = inuvl_wxux3_8(i,4) * um(i,j,k) + uth(i+1,j,k)
         uth(i  ,j,k) = inuvl_wxux3_8(i,3) * um(i,j,k) + uth(i  ,j,k)
         uth(i-1,j,k) = inuvl_wxux3_8(i,2) * um(i,j,k) + uth(i-1,j,k)
         uth(i-2,j,k) = inuvl_wxux3_8(i,1) * um(i,j,k) + uth(i-2,j,k)
         um (i,  j,k) = ZERO_8
         end do
         end do
*
      end do
C!$omp enddo
*
C!$omp single 
      call rpn_comm_adj_halo (vth,LDIST_DIM,l_ni,l_njv,F_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
C!$omp end single 
*   
*     Zero vth halo
*     -------------
C!$omp do
      do k=1,F_nk
         do j=l_miny,0
         do i=l_minx,l_maxx
            vth(i,j,k) = ZERO_8
         end do
         end do
         do j=l_njv+1,l_maxy
         do i=l_minx ,l_maxx
            vth(i,j,k) = ZERO_8
         end do
         end do
         do i=l_minx,0
         do j=l_miny,l_maxy
            vth(i,j,k) = ZERO_8
         end do
         end do
         do i=l_ni+1,l_maxx
         do j=l_miny,l_maxy
            vth(i,j,k) = ZERO_8
         end do
         end do
      end do
C!$omp enddo
*
C!$omp single 
      call rpn_comm_adj_halo (uth,LDIST_DIM,l_niu,l_nj, F_nk,
     %             G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
C!$omp end single 
*
*     Zero uth halo
*     -------------
C!$omp do
      do k=1,F_nk
         do j=l_miny,0
         do i=l_minx,l_maxx
            uth(i,j,k) = ZERO_8
         end do
         end do
         do j=l_nj+1,l_maxy
         do i=l_minx,l_maxx
            uth(i,j,k) = ZERO_8
         end do
         end do
         do i=l_minx,0
         do j=l_miny,l_maxy
            uth(i,j,k) = ZERO_8
         end do
         end do
         do i=l_niu+1,l_maxx
         do j=l_miny ,l_maxy
            uth(i,j,k) = ZERO_8
         end do
         end do
      end do
C!$omp enddo
*
C!$omp end parallel
*
      if (G_lam) deallocate ( in0_1  )
      if (G_lam) deallocate ( in0_2  )
      if (G_lam) deallocate ( in0_3  )
      if (G_lam) deallocate ( inw_1  )
      if (G_lam) deallocate ( inw_2  )
      if (G_lam) deallocate ( inw_3  )
*
      return
      end
