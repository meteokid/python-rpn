!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/r adw_main_tl - TLM of adw_main
*
#include "model_macros_f.h"
#include "msg.h"
*
      subroutine adw_main_tl (F_it,F_isStatStep_L)
*
      implicit none
*
      integer F_it
      logical F_isStatStep_L
*
*author
*     monique tanguay
*
*revision
* v2_31 - Tanguay M.        - initial MPI version
* v3_00 - Tanguay M.        - adapt to restructured adw_main 
* v4_04 - Tanguay M.        - Staggered version TL/AD 
* v4_12 - Tanguay M.        - TL/AD Thermo upstream positions
*
*language
*     fortran 77
*
*object
*     see id section
*
*arguments
*______________________________________________________________________
*        |                                                       |     |
* NAME   | DESCRIPTION                                           | I/O |
*--------|-------------------------------------------------------|-----|
* F_it   | total number of iterations for trajectories           |  i  |
*________|_______________________________________________________|_____|
*
*implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
!      integer G_nk
!      integer l_ni,l_nj
#include "adw.cdk"
!      integer adw_nit,adw_njt
!      integer            Adw_trunc(4)
#include "v4dg.cdk"
!      integer V4dg_conf
!      logical V4dg_oktr_L
#include "vth.cdk"
#include "vt1.cdk"
#include "vth_m.cdk"
#include "vt1_m.cdk"
*
*modules
************************************************************************
      type(gmm_metadata) :: dummy_gmm_meta
      integer :: i,istat
      real, dimension(Adw_nit*Adw_njt,  G_nk  ) :: pxm,pym,pzm,um,vm,wm
      real, dimension(Adw_nit*Adw_njt,  G_nk+1) :: pxt,pyt,pzt,ut,vt,wt
      real, dimension(Adw_nit*Adw_njt,2*G_nk+1) :: su,sv,sw
      real, dimension(l_ni*l_nj*(l_nk+1)) :: l_xct1,l_yct1,l_zct1
*
      real, dimension(Adw_nit*Adw_njt,  G_nk  ) :: pxm_m,pym_m,pzm_m,um_m,vm_m,wm_m
      real, dimension(Adw_nit*Adw_njt,  G_nk+1) :: pxt_m,pyt_m,pzt_m,ut_m,vt_m,wt_m
      real, dimension(Adw_nit*Adw_njt,2*G_nk+1) :: su_m,sv_m,sw_m
      real, dimension(l_ni*l_nj*(l_nk+1)) :: l_xct1_m,l_yct1_m,l_zct1_m
*
      real dummy
*
************************************************************************
      call msg(MSG_DEBUG,'TLM of ADVECT THE RIGHT-HAND-SIDES: (S/R ADW_MAIN_TL)')
************************************************************************
*
*     TRAJECTORY
*     ----------
      call adw_main_1_wnd2_tr (su_m,sv_m,sw_m,um_m,vm_m,wm_m,ut_m,vt_m,wt_m,Adw_nit,Adw_njt,G_nk)
*
*     TLM
*     ---
      call adw_main_1_wnd2 (su,sv,sw,um,vm,wm,ut,vt,wt,Adw_nit,Adw_njt,G_nk)
*
*     TRAJECTORY
*     ---------- 
      istat = gmm_get(gmmk_xth_m_s,xth_m,dummy_gmm_meta)
      istat = min(istat,gmm_get(gmmk_yth_m_s,yth_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zth_m_s,zth_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xcth_m_s,xcth_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_ycth_m_s,ycth_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zcth_m_s,zcth_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xct1_m_s,xct1_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_yct1_m_s,yct1_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zct1_m_s,zct1_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xth_thermo_m_s,xth_thermo_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_yth_thermo_m_s,yth_thermo_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zth_thermo_m_s,zth_thermo_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xcth_thermo_m_s,xcth_thermo_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_ycth_thermo_m_s,ycth_thermo_m,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zcth_thermo_m_s,zcth_thermo_m,dummy_gmm_meta))
      call handle_error(istat,'adw_main_tl TRAJ','gmm_get')
*
*     TLM
*     ---
      istat = gmm_get(gmmk_xth_s,xth,dummy_gmm_meta)
      istat = min(istat,gmm_get(gmmk_yth_s,yth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zth_s,zth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xcth_s,xcth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_ycth_s,ycth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zcth_s,zcth,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xct1_s,xct1,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_yct1_s,yct1,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zct1_s,zct1,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xth_thermo_s,xth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_yth_thermo_s,yth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zth_thermo_s,zth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_xcth_thermo_s,xcth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_ycth_thermo_s,ycth_thermo,dummy_gmm_meta))
      istat = min(istat,gmm_get(gmmk_zcth_thermo_s,zcth_thermo,dummy_gmm_meta))
      call handle_error(istat,'adw_main_tl TLM ','gmm_get')
*
*     TLM and TRAJECTORY
*     ------------------
      call adw_main_2_pos_tl (
     $     F_it,'m',l_nk,
*
     $     pxm ,pym ,pzm ,
     $     su  ,sv  ,sw  ,
     $     xth ,yth ,zth ,
     $     xcth,ycth,zcth,
     $     xct1,yct1,zct1,
     $     dummy,dummy,
*
     $     pxm_m ,pym_m ,pzm_m ,
     $     su_m  ,sv_m  ,sw_m  ,
     $     xth_m ,yth_m ,zth_m ,
     $     xcth_m,ycth_m,zcth_m,
     $     xct1_m,yct1_m,zct1_m,
     $     dummy,dummy)
*
      call adw_main_2_pos_tl (
     $     F_it         ,'t'          ,l_nk+1,
*
     $     pxt          ,pyt          ,pzt,
     $     su           ,sv           ,sw,
     $     xth_thermo   ,yth_thermo   ,zth_thermo,
     $     xcth_thermo  ,ycth_thermo  ,zcth_thermo,
     $     l_xct1       ,l_yct1       ,l_zct1,
     $     pxm          ,pym          ,
*
     $     pxt_m        ,pyt_m        ,pzt_m,
     $     su_m         ,sv_m         ,sw_m,
     $     xth_thermo_m ,yth_thermo_m ,zth_thermo_m,
     $     xcth_thermo_m,ycth_thermo_m,zcth_thermo_m,
     $     l_xct1_m     ,l_yct1_m     ,l_zct1_m,
     $     pxm_m        ,pym_m)
*
*     Recover TRAJ upstream positions
*     -------------------------------
      call v4d_rwtraj(5,pxm_m,pym_m,pzm_m,pxt_m,pyt_m,pzt_m,l_ni,l_nj,G_nk,G_nk+1)
*
*     Recover TRAJ RHS before interpolation
*     -------------------------------------
      call v4d_rwtraj (11)
*
*     TLM and TRAJECTORY
*     ------------------
      call adw_main_3_intlag_tl (pxm,  pym,  pzm,  pxt,  pyt,  pzt,
     %                           pxm_m,pym_m,pzm_m,pxt_m,pyt_m,pzt_m,F_isStatStep_L)
*
***********************************************************************
*
      return
      end
