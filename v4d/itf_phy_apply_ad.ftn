! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
***s/r itf_phy_apply_ad - adjoint of apply consistency with related dynamical variables
*
#include "model_macros_f.h"
*
      subroutine itf_phy_apply_ad ( F_tdu,F_tdv,F_tdt,F_trp,F_trm,
     $                        F_tp,DIST_DIM, nkphy,F_apply_L)
*
      implicit none
*
      logical,intent(IN) :: F_apply_L
      integer,intent(IN) :: DIST_DIM,nkphy
      real,dimension(DIST_SHAPE,nkphy),intent(INOUT) :: F_tdu, F_tdv, F_tdt, F_tp
      real,dimension(DIST_SHAPE,nkphy,*),intent(INOUT) :: F_trp, F_trm
*
*author 
*     Stephane Laroche        Janvier 2002
*
*revision
* v3_00 - Laroche S.        - initial MPI version
* v3_03 - Tanguay M.        - use v4d_zerohalo 
* v3_20 - Laroche S.        - slight modification to rpn_comm_xch_halo call
* v3_21 - Tanguay M.        - Revision Openmp 
* v3_30 - Tanguay M.        - adapt TL/AD to itf/new tendencies
*                           - Validation for LAM version  
* v4_03 - Spacek L.         - Staggered version
*
*object
*       TLM of apply consistency of the tendencies on physics variables
*       with related dynamical variables. Interpolate wind
*       tendancies toward theirs respective grids.
*
*arguments
*arguments
*  Name        I/O                 Description
*----------------------------------------------------------------
* F_tcond       I    -
*	
*implicits
#include "glb_ld.cdk"
#include "cstv.cdk"
#include "lun.cdk"
#include "hblen.cdk"
#include "dcst.cdk"
#include "schm.cdk"
#include "geomg.cdk"
#include "lam.cdk"
#include "intuv.cdk"
#include "inuvl.cdk"
#include "vt0.cdk"
#include "vt1.cdk"
#include "vtx.cdk"
#include "vt1_m.cdk"
#include "vt0_m.cdk"
#include "p_geof.cdk"
#include "itf_phy_busind.cdk"
#include "v4dg.cdk"
#include "lctl.cdk"
*
*modules
      integer  vmmlod,vmmget,vmmuld
      external vmmlod,vmmget,vmmuld
*
      integer*8 pnt_trp(phyt_ntr)
      integer i, j, k, n, i0, in, j0, jn, err, key1(11), ng,
     $        inu, jnv,
     $     keyp(phyt_ntr), keyp_
      real trajexp
      real*8, parameter :: ZERO_8 = 0.0
      real  wk1(LDIST_SHAPE,nkphy) ,  wk2(LDIST_SHAPE,nkphy),
     $   F_tdtm(LDIST_SHAPE,nkphy), F_trmm(LDIST_SHAPE,nkphy)
      real,dimension(LDIST_SHAPE,nkphy) :: F_trpm, F_tpm
      real trp
      pointer (patrp, trp(LDIST_SHAPE,*))
*     __________________________________________________________________
*
      keyp_ = VMM_KEY (trt1)
      if (phyt_ntr.gt.0) then
         do n=1,phyt_ntr
            keyp(n) = keyp_ + n
         end do
         err = vmmlod(keyp,phyt_ntr)
         do n=1,phyt_ntr
            err = vmmget(keyp(n),patrp,trp)
            pnt_trp(n) = patrp
         end do
      endif
*
      key1(1) = VMM_KEY(tt0_m)
      key1(2) = VMM_KEY(st0_m)
      key1(3) = VMM_KEY(fiptx)
      key1(4) = VMM_KEY(tt0)
      key1(5) = VMM_KEY(st0)
      key1(6) = VMM_KEY(ut1)
      key1(7) = VMM_KEY(vt1)
      key1(8) = VMM_KEY(tt1)
      key1(9) = VMM_KEY(st1)
      err = vmmlod(key1,9)
      err = VMM_GET_VAR(tt0_m)
      err = VMM_GET_VAR(st0_m)
      err = VMM_GET_VAR(fiptx)
      err = VMM_GET_VAR(tt0)
      err = VMM_GET_VAR(st0)
      err = VMM_GET_VAR(tt1)
      err = VMM_GET_VAR(vt1)
      err = VMM_GET_VAR(ut1)
      err = VMM_GET_VAR(st1)
!!!
      key1(1) = VMM_KEY(ut0)
      err = vmmlod(key1,1)
      err = VMM_GET_VAR(ut0)
!!!
*
*
!$omp parallel
* 
******START TRAJECTORY **********************************************
*
*     Read TRAJ for the simplified physics
*     -------------------------------------
      call v4d_rwtraj(20,F_tdtm,F_trmm)
      call v4d_rwtraj(24,F_tpm,F_trpm)

*     Zero adjoint WORK variables
*     ---------------------------

!$omp do 
      do k=1,nkphy
       wk1(:,:,k)  = ZERO_8
       wk2(:,:,k)  = ZERO_8
      end do
!$omp end do 
*
*
      do n=1,phyt_ntr
         if (phyt_ind(3,n).gt.0) then
            patrp = pnt_trp(n) 
            if (n.ne.hucond) then
               do j= 1+pil_s, l_nj-pil_n
               do i= 1+pil_w, l_ni-pil_e
                  trp(i,j,l_nk+1) = trp(i,j,l_nk+1) + trp(i,j,l_nk+2)
                  trp(i,j,l_nk+2) = ZERO_8
               end do
               end do
            endif
!$omp do 
            do k=1,l_nk+2
            do j= 1+pil_s, l_nj-pil_n 
            do i= 1+pil_w, l_ni-pil_e
               F_trm(i,j,k,n) = F_trm(i,j,k,n) + Cstv_dt_8*trp(i,j,k)
            end do
            end do
            end do
!$omp end do 

!$omp single
            if ( Lam_0ptend_L .and. G_lam .and.
     $         ((Hblen_x.gt.0).or.(Hblen_y.gt.0)) ) then
               call nesajr_ad (F_trp(minx,miny,1,n), wk2, LDIST_DIM,nkphy,
     $                                          0,0,Hblen_x,Hblen_y)
               call nesajr_ad (F_trm(minx,miny,1,n), wk2, LDIST_DIM,nkphy,
     $                                          0,0,Hblen_x,Hblen_y)
            endif
!$omp end single
         endif
      end do
!$omp end parallel
*
*
      call diag_fip_ad (fiptx, st0,   tt0, st0_m, tt0_m,   
     $                  1+pil_w,l_ni-pil_e,1+pil_s,l_nj-pil_n,l_nk)
*

*
*   4. apply tendencies to primary variables
*      -------------------------------------
*
!$omp parallel
*
!$omp do 
      do k=1,l_nk+1
         do j= 1+pil_s, l_njv-pil_n 
         do i= 1+pil_w, l_ni-pil_e 
            F_tdv(i,j,k) = F_tdv(i,j,k) + Cstv_dt_8*vt1(i,j,k)
         end do
         end do
         do j= 1+pil_s, l_nj-pil_n 
         do i= 1+pil_w, l_niu-pil_e 
            F_tdu(i,j,k) = F_tdu(i,j,k) + Cstv_dt_8*ut1(i,j,k)
         end do
         end do
      end do
!$omp end do 
!$omp do 
      do k=1,l_nk+2
         do j= 1+pil_s, l_nj-pil_n 
         do i= 1+pil_w, l_ni-pil_e 
            wk1  (i,j,k) = wk1  (i,j,k) + Cstv_dt_8*tt1(i,j,k)
         end do
         end do
      end do
!$omp end do
*
!$omp end parallel
*
*     3. de-stagger wind tendancies in the vertical
*     ------------------------------------------
*
!$omp do
      do j= 1+pil_s, l_nj-pil_n
         do k=l_nk+1,1,-1
         do i= 1+pil_w, l_niu-pil_e
         F_tdu(i,j,k+1) = F_tdu(i,j,k+1) + F_tdu(i,j,k)
         F_tdu(i,j,k) = ZERO_8
         end do
         end do
      end do
!$omp enddo
!$omp do
      do j= 1+pil_s, l_njv-pil_n
         do k=l_nk+1,1,-1
         do i= 1+pil_w, l_ni-pil_e
         F_tdv(i,j,k+1) = F_tdv(i,j,k+1) + F_tdv(i,j,k)
         F_tdv(i,j,k)   = ZERO_8
         end do
         end do
      end do
!$omp enddo

      if ( Lam_0ptend_L .and. G_lam .and.
     $   ((Hblen_x.gt.0).or.(Hblen_y.gt.0)) ) then
         call nesajr_ad (F_tdv, wk2, LDIST_DIM,nkphy,0,1,Hblen_x,Hblen_y)
         call nesajr_ad (F_tdu, wk2, LDIST_DIM,nkphy,1,0,Hblen_x,Hblen_y)
         call nesajr_ad (wk1,wk2,LDIST_DIM,nkphy,0,0,Hblen_x,Hblen_y)
      endif
*
*
*   2.   Compute VIRTUAL temperature tendency from:  temperature tendency,
*        specific humidity, virtual temperature & specific humidity tendency
*        -------------------------------------------------------------------
*
      patrp = pnt_trp(hucond)

!$omp parallel
*
!$omp do  
      do k=1,l_nk+2
      do j= 1+pil_s, l_nj-pil_n 
      do i= 1+pil_w, l_ni-pil_e 
!*
!*       TRAJECTORY
!*       ----------
!        F_tdtm(i,j,k) = (F_tdtm(i,j,k)
!     $                -  Dcst_delta_8*F_tpm(i,j,k)*F_trmm(i,j,k))
!     $                /  (1. + Dcst_delta_8*F_trpm(i,j,k))
*
*       ADJ
*       ---
        F_tdt(i,j,k) = wk1(i,j,k) + F_tdt(i,j,k)
        wk1(i,j,k) = ZERO_8
*
        trp(i,j,k)          = trp(i,j,k)          
     $                      + F_tdt(i,j,k) * Dcst_delta_8 * F_tdtm(i,j,k)
        F_tp(i,j,k)         = F_tp(i,j,k)         
     $                      + F_tdt(i,j,k) * Dcst_delta_8 * F_trmm(i,j,k)
        F_trm(i,j,k,hucond) = F_trm(i,j,k,hucond) 
     $                      + F_tdt(i,j,k) * Dcst_delta_8 * F_tpm(i,j,k)
        F_tdt(i,j,k)        = F_tdt(i,j,k) * (1. + Dcst_delta_8*F_trpm(i,j,k))

      end do
      end do
      end do
!$omp end do
*
*
!$omp end parallel 
      call glbstat ( F_tp, 'APTP',LDIST_DIM,G_nk+2,1,G_ni    ,1,G_nj  ,1,G_nk+2)
*
*  1. Interpolation of the wind associated tendencies
*     -----------------------------------------------
*
      call itf_phy_uvgridscal_ad ( F_tdu, F_tdv, LDIST_DIM, nkphy, .false. )
*

      return
      end
