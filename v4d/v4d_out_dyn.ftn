!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/r v4d_out_dyn - perform dynamic output for 4D-Var
*
#include "model_macros_f.h"
*
      subroutine v4d_out_dyn (reg_out,casc_out)
*
      implicit none
*
      logical reg_out
      integer casc_out
*
*author M.Tanguay
*
*revision
* v4_04 - Tanguay M.        - Initial MPI version 
* v4_04 - Tanguay M.        - Staggered version TL/AD 
* v4_10 - Tanguay M.        - VMM replacement with GMM for (TL/AD)
*
*object
*     see id section
*
*     BASED ON OUT_DYN_AD (GEM330)
*
*implicits
#include "gmm.hf"
#include "var_gmm.cdk"
#include "glb_ld.cdk"
#include "lun.cdk"
#include "geomg.cdk"
#include "dcst.cdk"
#include "p_geof.cdk"
#include "vt1.cdk"
#include "vtx.cdk"
#include "v4dc.cdk"
#include "dimout.cdk"
#include "tr3d.cdk"
#include "v4dg.cdk"
#include "schm.cdk"
*     ---------------------------------------------------------------------
*
      integer dostep(MAXSET), dostep_max
*
      integer  doout
      external doout
*
      integer i,j,k,m,n 
      real, pointer    , dimension(:,:,:) :: tr
      real z
*
      logical imguv_L
*
      real*8 pdsc1_8
*
      real w_u (LDIST_SHAPE,l_nk+1),  w_v (LDIST_SHAPE,l_nk+1)
      real w_t (LDIST_SHAPE,l_nk+2),  w_s (LDIST_SHAPE)
      real w_f (LDIST_SHAPE,0:l_nk+1),w_tr(LDIST_SHAPE,l_nk+2,Tr3d_ntr)
*
*     ---------------------------------------------------------------------
*
      if (V4dg_di_L) call out_dyn (reg_out,casc_out) 
      if (V4dg_tl_L) call out_dyn (reg_out,casc_out) 
*
      if (.NOT.V4dg_ad_L) return 
*
*     ---------------------------------------------------------------------
*     NOTE: OUT_DYN may need to fill the halos.
*     It is why OUT_DYN when V4dg_ad_L  keeps track of the original fields
*     ---------------------------------------------------------------------
*
*     Check if output is required
*     ---------------------------
      dostep_max = doout(dostep,1)
*
      if (dostep_max .le. 0) goto 999
*
      if(Lun_out.gt.0) write (Lun_out,1000)
*
*     Get fields in memory
*     --------------------
      gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(ut1)'
      gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(vt1)'
      gmmstat = gmm_get(gmmk_tt1_s,tt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(tt1)'
      gmmstat = gmm_get(gmmk_fiptx_s,fiptx,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(fiptx)'
      gmmstat = gmm_get(gmmk_st1_s,st1,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(st1)'
*
*     Keep original fields (PART1)
*     ----------------------------
      w_u = ut1 
      w_v = vt1 
      w_t = tt1
      w_s = st1
      w_f = fiptx 
*
      imguv_L = V4dg_imguv_L
*
      if (.not.V4dg_imguv_L) then
*
         V4dg_imguv_L = .true.
*
*        Inverse the action of uv2img_ad
*        -------------------------------
         do j= 1, l_njv
            pdsc1_8 = Dcst_rayt_8 / Geomg_cyv_8(j)
            do k=1,G_nk+1
               do i= 1, l_ni
                  vt1(i,j,k) = pdsc1_8 * vt1(i,j,k)
               end do
            end do
         end do
*
         do j= 1, l_nj
            pdsc1_8 = Dcst_rayt_8 / Geomg_cy_8(j)
            do k=1,G_nk+1
               do i= 1, l_niu
                  ut1(i,j,k) = pdsc1_8 * ut1(i,j,k)
               end do
            end do
         end do
*
      endif
*
      if(.not.(V4dg_4dvar_L.or.V4dg_sgvc_L)) then
*
*     SIMULATE V4D_CAIN_AD (PART1)
*     ----------------------------
      m = 0  
      do k=1,l_nk+1
      do j=1,l_nj
      do i=1,l_niu
         m = m+1
         if(V4dc_scalp(m).eq.0.) then
            z = 0.
         else
            z = 1./V4dc_scalp(m)
         endif
         ut1(i,j,k) = ut1(i,j,k)*z
      end do
      end do
      end do
*
      do k=1,l_nk+1
      do j=1,l_njv
      do i=1,l_ni
         m = m+1
         if(V4dc_scalp(m).eq.0.) then
            z = 0.
         else
            z = 1./V4dc_scalp(m)
         endif
         vt1(i,j,k) = vt1(i,j,k)*z
      end do
      end do
      end do
*
      do k=1,l_nk+2
      do j=1,l_nj
      do i=1,l_ni
         m = m+1
         if(V4dc_scalp(m).eq.0.) then
            z = 0.
         else
            z = 1./V4dc_scalp(m)
         endif
         tt1(i,j,k) = tt1(i,j,k)*z
      end do
      end do
      end do
*
      do j=1,l_nj
      do i=1,l_ni
         m = m+1
         if(V4dc_scalp(m).eq.0.) then
            z = 0.
         else
            z = 1./V4dc_scalp(m)
         endif
         st1(i,j) = st1(i,j)*z
      end do
      end do
*
      endif
*
      do n=1,Tr3d_ntr
         nullify (tr)
         gmmstat = gmm_get('TR/'//trim(Tr3d_name_S(n))//':P',tr,meta3d)
*
*           Keep original fields (PART2)
*           ----------------------------
            do k=1,l_nk+2
            do j=l_miny,l_maxy
            do i=l_minx,l_maxx
               w_tr(i,j,k,n) = tr(i,j,k)
            end do
            end do
            end do
*
            if(.not.(V4dg_4dvar_L.or.V4dg_sgvc_L)) then
*
*           SIMULATE V4D_CAIN_AD (PART2)
*           ----------------------------
            do k=1,l_nk+2
            do j=1,l_nj
            do i=1,l_ni
               m = m+1
               if(V4dc_scalp(m).eq.0.) then
                  z = 0.
               else
                  z = 1./V4dc_scalp(m)
               endif
               tr(i,j,k) = tr(i,j,k)*z
            end do
            end do
            end do
*
            endif
*
      end do
*
*     ______________________________________________________
*
      if(m.ne.V4dc_ncv.and..not.(V4dg_4dvar_L.or.V4dg_sgvc_L)) call handle_error(-1,'v4d_out_dyn','m.ne.V4dc_ncv')
*     ______________________________________________________
*
*     Perform output if required
*     --------------------------
      call out_dyn (.true.,-1) 
*
*     Reset original fields 
*     ---------------------
      gmmstat = gmm_get(gmmk_ut1_s,ut1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(ut1)'
      gmmstat = gmm_get(gmmk_vt1_s,vt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(vt1)'
      gmmstat = gmm_get(gmmk_tt1_s,tt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(tt1)'
      gmmstat = gmm_get(gmmk_fiptx_s,fiptx,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(fiptx)'
      gmmstat = gmm_get(gmmk_zdt1_s,zdt1,meta3d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(zdt1)'
      gmmstat = gmm_get(gmmk_st1_s,st1,meta2d)
      if (GMM_IS_ERROR(gmmstat)) print *,'v4d_out_dyn ERROR at gmm_get(st1)'
*
      ut1  = w_u 
      vt1  = w_v
      tt1  = w_t
      st1  = w_s
      fiptx= w_f
*
      do n=1,Tr3d_ntr
         nullify (tr)
         gmmstat = gmm_get('TR/'//trim(Tr3d_name_S(n))//':P',tr,meta3d)
*
            do k=1,l_nk+2
            do j=l_miny,l_maxy
            do i=l_minx,l_maxx
               tr(i,j,k) = w_tr(i,j,k,n)
            end do
            end do
            end do
*
      end do
*
      if(.not.imguv_L) V4dg_imguv_L = .false. 
*
      return
*
*     __________________________________________________________________

  999 continue
*
      if(Lun_out.gt.0) write (Lun_out,1001)
*
1000  format(' OUT_DYN_AD - PERFORMING REQUIRED ADJOINT OUTPUT')
1001  format(' OUT_DYN_AD - NO ADJOINT OUTPUT REQUIRED')
*
      return
      end

