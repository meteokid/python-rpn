! ------------------------------------------------------------------------------------------------------------------------------
! EC-RPN COMM Group License/Disclaimer, version 2, Last Modified: Jan 08th, 2008 , Environment Canada
! 
! This is free software, you can use/redistribute/modify it under the terms of the EC-RPN COMM Group License/Disclaimer version 2 
! or (at your option) any later version that should be found at http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
! 
! This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the EC-RPN COMM Group License/Disclaimer for more details.
! 
! You should have received a copy of the EC-RPN COMM Group License/Disclaimer along with this software; if not, write to the
! EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), CANADA, H9P 1J3 ; or send e-mail to service.rpn@ec.gc.ca
! ------------------------------------------------------------------------------------------------------------------------------
!**s/r itf_phy_fillbus_tl - TLM of Fill the slice workspace variable for the physics
!
#include "model_macros_f.h"
!
      subroutine itf_phy_fillbus_tr(F_busdyn,F_busper,F_jdo,F_step,nk)
      implicit none
!
      integer F_step, F_jdo, nk
      real F_busdyn(*),F_busper(*)
!
!author 
!     Stephane Laroche - January 2002
!
!revision
! v3_00 - Laroche S.            - initial MPI version
! v3_02 - Tanguay M./Laroche S. - do not assume TRAJ HU positive
!                               - contribution of surface pressure
! v3_30 - Tanguay M.            - adapt TL/AD to itf
!                               - Validation for LAM version
! v4_03 - Spacek L.             - Staggered version
! v4_12 - Spacek L.             - GMM version
!
!object
!	Fill the slice trajectory for the physics.
!
      include "v4dg.inc"
#include "glb_ld.cdk"
#include "itf_phy_buses.cdk"
!
!notes
!
      integer i, k, n
      integer pid,soit,lght,stepm1,stepone
      integer index, numtr
      integer kmm,ktm,bmm,btm
      integer utrajm,vtrajm,ttrajm,hutrajm
      integer utrajp,vtrajp,ttrajp,hutrajp,ptrajp
      integer sigm,sigt
!
!     ---------------------------------------------------------------
!
      stepm1=F_step-1;stepone=1
      kmm=-1;ktm=-1;bmm=-1;btm=-1
      utrajm=-1;vtrajm=-1;ttrajm=-1;hutrajm=-1;
      utrajp=-1;vtrajp=-1;ttrajp=-1;hutrajp=-1;ptrajp=-1
      sigm=-1;sigt=-1
!
!     Find indexes in busper
!
      do n=1,p_bper_top
         if (pernm(n)(1:3).eq.'KMM')call getindx(pernm(n),'P',kmm,lght,soit)
         if (pernm(n)(1:3).eq.'KTM')call getindx(pernm(n),'P',ktm,lght,soit)
         if (pernm(n)(1:3).eq.'BMM')call getindx(pernm(n),'P',bmm,lght,soit)
         if (pernm(n)(1:3).eq.'BTM')call getindx(pernm(n),'P',btm,lght,soit)
      end do
!
!     Find indexes in busdyn
!
      call getindx ('PW_PM:P',  'D', pid, lght, soit)

      do n=1,p_bdyn_top
         if (dynnm(n)(1:6).eq.'UTRAJM')                                     &
                            call getindx(dynnm(n),'D',utrajm ,lght,soit)
         if (dynnm(n)(1:6).eq.'VTRAJM')                                     &
                            call getindx(dynnm(n),'D',vtrajm ,lght,soit)
         if (dynnm(n)(1:6).eq.'TTRAJM')                                     &
                            call getindx(dynnm(n),'D',ttrajm ,lght,soit)
         if (dynnm(n)(1:7).eq.'HUTRAJM')                                    &
                            call getindx(dynnm(n),'D',hutrajm,lght,soit)
         if (dynnm(n)(1:6).eq.'UTRAJP')                                     &
                            call getindx(dynnm(n),'D',utrajp ,lght,soit)
         if (dynnm(n)(1:6).eq.'VTRAJP')                                     &
                            call getindx(dynnm(n),'D',vtrajp ,lght,soit)
         if (dynnm(n)(1:6).eq.'TTRAJP')                                     &
                            call getindx(dynnm(n),'D',ttrajp ,lght,soit)
         if (dynnm(n)(1:7).eq.'HUTRAJP')                                    &
                            call getindx(dynnm(n),'D',hutrajp,lght,soit)
         if (dynnm(n)(1:6).eq.'PTRAJP')                                     &
                            call getindx(dynnm(n),'D',ptrajp ,lght,soit)
         if (dynnm(n)(1:7).eq.'PW_PM:P')                                    &
                            call getindx(dynnm(n),'D',sigm   ,lght,soit)
         if (dynnm(n)(1:7).eq.'PW_PT:P')                                    &
                            call getindx(dynnm(n),'D',sigt   ,lght,soit)
      end do
!
!   Trajectory for vertical diffusion
!
      if( V4dg_phy_pbl.eq.2) then
         numtr=22
         index=0;        call v4d_rtrnch                                    &
        (F_busper,kmm,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=nk;       call v4d_rtrnch                                    &
        (F_busper,ktm,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=nk+1;     call v4d_rtrnch                                    &
        (F_busper,bmm,numtr,F_step,index,F_jdo,p_offi,p_ni,1)
         index=nk+2;     call v4d_rtrnch                                    &
        (F_busper,btm,numtr,F_step,index,F_jdo,p_offi,p_ni,1)
      endif
!
!    Trajectory t-
! 
         numtr=21
         index=0;        call v4d_rtrnch                                    &
        (F_busdyn,utrajm ,numtr,stepm1,index,F_jdo,p_offi,p_ni,nk)
         index=nk;       call v4d_rtrnch                                    &
        (F_busdyn,vtrajm ,numtr,stepm1,index,F_jdo,p_offi,p_ni,nk)
         index=2*nk;     call v4d_rtrnch                                    &
        (F_busdyn,ttrajm ,numtr,stepm1,index,F_jdo,p_offi,p_ni,nk)
         index=3*nk;     call v4d_rtrnch                                    &
        (F_busdyn,hutrajm,numtr,stepm1,index,F_jdo,p_offi,p_ni,nk)
!
!   Trajectory t+
!
         index=0;        call v4d_rtrnch                                    &
        (F_busdyn,utrajp ,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=nk;       call v4d_rtrnch                                    &
        (F_busdyn,vtrajp ,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=2*nk;     call v4d_rtrnch                                    &
        (F_busdyn,ttrajp ,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=3*nk;     call v4d_rtrnch                                    &
        (F_busdyn,hutrajp,numtr,F_step,index,F_jdo,p_offi,p_ni,nk)
         index=4*nk;     call v4d_rtrnch                                    &
        (F_busdyn,ptrajp ,numtr,F_step,index,F_jdo,p_offi,p_ni,1)
!
!   Sigmas
!
         numtr=20
         index=0;        call v4d_rtrnch                                    &
        (F_busdyn,sigm ,numtr,stepone,index,F_jdo,p_offi,p_ni,nk-1)
         index=nk;       call v4d_rtrnch                                    &
        (F_busdyn,sigt ,numtr,stepone,index,F_jdo,p_offi,p_ni,nk)
!
!     ---------------------------------------------------------------
!
      return
      end
