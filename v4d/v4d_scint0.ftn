***s/r v4d_scint0 - Preparation for polar correction and interpolation of
*                   scalar field FLDSC at positions px,py 
*
#include <model_macros_f.h>
*
      subroutine v4d_scint0 (fldscint,px,py,npts,fldsc,ax,ay,cx,cy,wx_8,
     %                       i1,i2,j1,j2,nk,grtypi,degree,var)
*
      use v4d_interzone
*
#include "impnone.cdk"
*
      integer npts,i1,i2,j1,j2,nk,degree
*
      real,   pointer, dimension(:,:) :: fldscint
      real,   pointer, dimension(:)   :: px,py
*
      real fldsc(i1:i2,j1:j2,nk),ax(i1:i2),ay(j1:j2),cx(i1:i2,6),cy(j1:j2,6)
*
      character*2 var
*
      character*1 grtypi
*
      real*8 wx_8(*)
*
*author Tanguay M.
*
*revision
* v3_00 - Tanguay M.        - initial MPI version
*
*object
*     see id section 
*
*arguments
* Name         I/O        Description
*----------------------------------------------------------------
* fldscint      O         Interpolated scalar field at positions px,py 
* px            I         Position x in INPUT grid 
* py            I         Position y in INPUT grid 
* npts          I         Number of positions in fldscint 
* fldsc         I         Scalar field on INPUT grid 
* ax            I         X axe of INPUT grid 
* ay            I         Y axe of INPUT grid 
* cx            I         AX difference on INPUT grid 
* cy            I         AY difference on INPUT grid 
* wx            I         Weights on INPUT grid x axe 
* i1-i2         I         Dimension x in INPUT grid 
* j1-j2         I         Dimension y in INPUT grid 
* nk            I         Dimension z in INPUT grid 
* grtypi        I         Type of INPUT grid 
* degree        I         Degree of interpolation 
* var           I         Name of fldsc 
*----------------------------------------------------------------
*
*implicits
#include "glb_ld.cdk"
*
      integer gni,jmin,jmax,ni
*
*     Recall ni = Period if grid='G', Heart if grid='Z'
*     -------------------------------------------------
      if(grtypi.eq.'Z') ni = l_ni
      if(grtypi.eq.'G') ni = i2-i1+1 
*
*     Recall dimension of a latitude circle in INPUT grid 
*     ---------------------------------------------------
      if(grtypi.eq.'Z') gni = G_ni
      if(grtypi.eq.'G') gni = ni 
*
*     Recall j limit  
*     --------------
      jmin=j1
      jmax=j2
      if(grtypi.eq.'Z'.and.l_north) jmax=l_nj 
      if(grtypi.eq.'Z'.and.l_south) jmin=1 
*
*     Fill halo for interpolation between processors if INPUT grid='Z"  
*     ----------------------------------------------------------------
      if(grtypi.eq.'Z') 
     %   call rpn_comm_xch_halo (fldsc, LDIST_DIM,l_ni,l_nj,nk,
     %                           G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
*
*     Preparation for polar correction if scalar interpolation
*     --------------------------------------------------------
      if(l_north.or.l_south) call v4d_zonesca (px,py,npts,fldsc,wx_8,i1,i2,j1,j2,
     %                                         nk,jmin,jmax,ni,G_lnimax,gni,grtypi,degree,
     %                                         var,l_north,l_south,1)
*
*     Scalar interpolation at px,py positions using EZSCINT  
*     -----------------------------------------------------
      if(npts.ne.0) call v4d_ezscint (fldscint,px,py,npts,fldsc,ax,ay,cx,cy, 
     %                                i1,i2,j1,j2,nk,jmin,jmax,ni,grtypi,degree)
*
*     Closing if scalar interpolation in polar zones
*     ----------------------------------------------
      if(l_north.or.l_south) call v4d_zonesca (px,py,npts,fldsc,wx_8,i1,i2,j1,j2,
     %                                         nk,jmin,jmax,ni,G_lnimax,gni,grtypi,degree,
     %                                         var,l_north,l_south,2)
*
      return
      end
