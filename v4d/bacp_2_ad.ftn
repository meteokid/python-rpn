!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
***s/r  bacp_2_ad - ADJ of bacp_2_tl 
*
#include "model_macros_f.h"
*
      subroutine bacp_2_ad (
     $                    F_itr, F_itnlh, F_p , F_fis,
     $                    F_u  , F_v    , F_w , F_t  ,
     $                    F_s  , F_zd   , F_q , F_fip, F_nest_q,
     $                    F_ru , F_rv   , F_rt, F_rw , F_rf    , F_rb,
     $                    F_nu , F_nv   , F_nt, F_nw , F_nf    , F_nb,
*
     $                    F_t_m,F_s_m,F_fip_m, 
*
     $                    DIST_DIM, Nk )
*
      implicit none
*
      integer  F_itr, F_itnlh, DIST_DIM, Nk
*
      real     F_p     (DIST_SHAPE,0:Nk+1) ,  F_fis(DIST_SHAPE)       ,
     %         F_u     (DIST_SHAPE,  Nk)   ,  F_v  (DIST_SHAPE,  Nk)  ,
     %         F_w     (DIST_SHAPE,  Nk+1) ,  F_t  (DIST_SHAPE,  Nk+1),
     %         F_s     (DIST_SHAPE)        ,  F_zd (DIST_SHAPE,  Nk+1),
     %         F_q     (DIST_SHAPE,0:Nk+1) ,  F_fip(DIST_SHAPE,0:Nk+1),
     %         F_nest_q(DIST_SHAPE,0:Nk+1) ,
     %         F_ru    (DIST_SHAPE,  Nk)   ,  F_rv (DIST_SHAPE,  Nk)  ,
     %         F_rt    (DIST_SHAPE,  Nk+1) ,  F_rw (DIST_SHAPE,  Nk+1),
     %         F_rf    (DIST_SHAPE,  Nk+1) ,  F_rb (DIST_SHAPE)       ,
     %         F_nu    (DIST_SHAPE,  Nk)   ,  F_nv (DIST_SHAPE,  Nk)  ,
     %         F_nt    (DIST_SHAPE,  Nk+1) ,  F_nw (DIST_SHAPE,  Nk+1),
     %         F_nf    (DIST_SHAPE,  Nk+1) ,  F_nb (DIST_SHAPE)
*
      real     F_t_m  (DIST_SHAPE,  Nk+1)  ,  F_s_m  (DIST_SHAPE)     , 
     %         F_fip_m(DIST_SHAPE,0:Nk+1)
*
*author
*     M.Tanguay
*
*revision
* v2_10 - Tanguay M.        - initial MPI version
* v2_30 - Edouard S.        - remove pi' at the top (F_pptt0)
* v2_31 - Tanguay M.        - adapt for vertical hybrid coordinate and LAM version 
*                           - adapt for tracers in tr3d  
* v3_00 - Tanguay M.        - adapt to restructured bacp_2 
* v3_03 - Tanguay M.        - Adjoint Lam and NoHyd configuration 
* v3_11 - Tanguay M.        - AIXport+Opti+OpenMP for TLM-ADJ
* v3_21 - Tanguay M.        - Revision Openmp
* v3_30 - Tanguay M.        - Enforce similarities between NL and TRAJ TL  
* v4_04 - Tanguay M.        - Staggered version TL/AD 
* v4_12 - Tanguay M.        - OPENMP TL/AD
* v4_12 - Tanguay M.        - TL/AD Open top
*
*object
*     see id section 
*
*arguments
*     see documentation of appropriate comdecks 
*
*implicits
#include "glb_ld.cdk"
#include "lam.cdk"
*
      integer i0, j0, in, jn, k0
*
      i0 = 1+pil_w
      in = l_ni-pil_e
      j0 = 1+pil_s
      jn = l_nj-pil_n
      k0 = 1+Lam_gbpil_T
*
      call  bacp_2_2_ad (
     $                 F_itr, F_itnlh, F_p , F_fis,
     $                 F_u  , F_v    , F_w , F_t  ,
     $                 F_s  , F_zd   , F_q , F_fip, F_nest_q,
     $                 F_ru , F_rv   , F_rt, F_rw , F_rf    , F_rb,
     $                 F_nu , F_nv   , F_nt, F_nw , F_nf    , F_nb,
*
     $                 F_t_m,F_s_m,F_fip_m, 
*
     $                 DIST_DIM, Nk, i0, j0, k0, in, jn )
*
      return
      end
*
      subroutine bacp_2_2_ad (
     $                      F_itr, F_itnlh, F_p , F_fis,
     $                      F_u  , F_v    , F_w , F_t  ,
     $                      F_s  , F_zd   , F_q , F_fip, F_nest_q,
     $                      F_ru , F_rv   , F_rt, F_rw , F_rf    , F_rb,
     $                      F_nu , F_nv   , F_nt, F_nw , F_nf    , F_nb,
*
     $                      F_t_m,F_s_m,F_fip_m, 
*
     $                      DIST_DIM, Nk, i0, j0, k0, in, jn )
*
      implicit none
*
      integer  F_itr, F_itnlh, DIST_DIM, Nk , i0, j0, k0, in, jn
      real     F_p     (DIST_SHAPE,0:Nk+1) ,  F_fis(DIST_SHAPE)       ,
     %         F_u     (DIST_SHAPE,  Nk)   ,  F_v  (DIST_SHAPE,  Nk)  ,
     %         F_w     (DIST_SHAPE,  Nk+1) ,  F_t  (DIST_SHAPE,  Nk+1),
     %         F_s     (DIST_SHAPE)        ,  F_zd (DIST_SHAPE,  Nk+1),
     %         F_q     (DIST_SHAPE,0:Nk+1) ,  F_fip(DIST_SHAPE,0:Nk+1),
     %         F_nest_q(DIST_SHAPE,0:Nk+1) ,
     %         F_ru    (DIST_SHAPE,  Nk)   ,  F_rv (DIST_SHAPE,  Nk)  ,
     %         F_rt    (DIST_SHAPE,  Nk+1) ,  F_rw (DIST_SHAPE,  Nk+1),
     %         F_rf    (DIST_SHAPE,  Nk+1) ,  F_rb (DIST_SHAPE)       ,
     %         F_nu    (DIST_SHAPE,  Nk)   ,  F_nv (DIST_SHAPE,  Nk)  ,
     %         F_nt    (DIST_SHAPE,  Nk+1) ,  F_nw (DIST_SHAPE,  Nk+1),
     %         F_nf    (DIST_SHAPE,  Nk+1) ,  F_nb (DIST_SHAPE)
*
      real     F_t_m  (DIST_SHAPE,  Nk+1)  , F_s_m  (DIST_SHAPE)      , 
     %         F_fip_m(DIST_SHAPE,0:Nk+1)
*
*implicits
#include "glb_pil.cdk"
#include "glb_ld.cdk"
#include "orh.cdk"
#include "cori.cdk"
#include "cstv.cdk"
#include "dcst.cdk"
#include "geomg.cdk"
#include "lun.cdk"
#include "type.cdk"
#include "ver.cdk"
#include "schm.cdk"
#include "ptopo.cdk"
*
      integer i, j, k, nij, kminzd
      real*8  xxx_8, yyy_8, zzz_8, p1_8, p2_8, p3_8, p4_8, p5_8, xxx_m_8
*
      real*8  ONE_8, HALF_8, ZERO_8
      parameter(ONE_8=1.d0, HALF_8=.5d0, ZERO_8=0.0)
*
      real*8, dimension(i0:in,j0:jn):: xtmp_8, ytmp_8
*
      real*8, dimension(i0:in,j0:jn):: xtmp_m_8,ytmp_m_8
*
      real*8 Pbar_8(DIST_SHAPE,Nk+1)
*
      logical finbac_L
*
      if (.not.Cori_cornl_L) call handle_error(-1,'bacp_2_ad','.not.Cori_cornl_L not done')
      if (Schm_opentop_L)    call handle_error(-1,'bacp_2_ad','Schm_opentop_L    not done')
*
*     __________________________________________________________________
      finbac_L=.false.
      if ( .not. (F_itr .lt. F_itnlh) )finbac_L=.true.
*     ______________________________________________________
*
      nij = (in - i0 + 1)*(jn - j0 + 1)
*
*     ZERO adjoint work fields  
*     ------------------------
      xtmp_8 = 0.
      ytmp_8 = 0.
      Pbar_8 = 0.
*
      xxx_8  = 0.
*
      p1_8 = Cstv_tau_8*Cstv_RTstr_8/Dcst_grav_8
      p2_8 = ONE_8/Cstv_RTstr_8
      p3_8 = ONE_8/Dcst_grav_8
      p4_8 = ONE_8/Dcst_rayt_8**2
      p5_8 = ONE_8/Cstv_tau_8
*
*     ADJ of
*     Compute T
*     ~~~~~~~~~
*
      if(.not.Schm_autobar_L) then            ! safer for autobar
*
      if(Schm_opentop_L) then
         do j=j0,jn
            do k= 1,k0-1
            yyy_8=Cstv_RTstr_8*Ver_dz_8%t(k)/Cstv_Tstr_8
            do i=i0,in
*
*              TRAJECTORY
*              ----------
               xxx_m_8=ONE_8+Ver_dbdz_8%t(k)*F_s_m(i,j)
*
               xxx_8         = yyy_8*(F_t_m(i,j,k)*F_fip(i,j,k-1))     
               F_t  (i,j,k)  = yyy_8*(             F_fip(i,j,k-1)*xxx_m_8) + F_t(i,j,k) 
               F_fip(i,j,k)  =                     F_fip(i,j,k-1)          + F_fip(i,j,k)
               F_fip(i,j,k-1)= ZERO_8
*
               F_s(i,j) = Ver_dbdz_8%t(k)*xxx_8 + F_s(i,j)
*
            end do
            end do
         end do
      endif
*
*     ADJ 
*     ---
      do k=l_nk+1,k0,-1
*
         xxx_8=p2_8*Ver_idz_8%t(k)
*
*        TRAJECTORY
*        ----------
         do j= j0, jn
         do i= i0, in
*
            xtmp_m_8(i,j)=ONE_8+Ver_dbdz_8%t(k)*F_s_m(i,j)
*
         enddo
         enddo
*
         call vrec ( ytmp_m_8, xtmp_m_8, nij )
*
         do j= j0, jn
         do i= i0, in
*
            ytmp_8(i,j)    = Cstv_Tstr_8*F_t(i,j,k)
     $           *(ONE_8-xxx_8*(F_fip_m(i,j,k)-F_fip_m(i,j,k-1))) 
            F_fip (i,j,k)  = Cstv_Tstr_8*ytmp_m_8(i,j)
     $           *(     -xxx_8*( F_t(i,j,k)) )                    + F_fip (i,j,k)
            F_fip (i,j,k-1)= Cstv_Tstr_8*ytmp_m_8(i,j)
     $           *(     -xxx_8*(-F_t(i,j,k)) )                    + F_fip (i,j,k-1)
            F_t   (i,j,k)  = ZERO_8  
*
            xtmp_8(i,j) = -ytmp_8(i,j)/xtmp_m_8(i,j)**2 
            ytmp_8(i,j) = ZERO_8
*
            F_s   (i,j) = Ver_dbdz_8%t(k)*xtmp_8(i,j) + F_s(i,j)
            xtmp_8(i,j) = ZERO_8
*
         enddo
         enddo
*
      enddo
*
      endif
*
*     ADJ of
*     Compute FI'
*     ~~~~~~~~~~~
      do j= j0, jn
      do i= i0, in
*
         F_fip(i,j,l_nk+1)=0.0
*
      enddo
      enddo
*
      if (.not. Schm_hydro_L) then
         do k=l_nk,k0-1,-1
            do j= j0, jn
            do i= i0, in
*
               F_q(i,j,k) = -Cstv_RTstr_8*F_fip(i,j,k) + F_q(i,j,k)
*
            enddo
            enddo
         enddo
      endif
*
      do k=l_nk+1,k0-1,-1
*
         if(k.eq.0) then
            xxx_8=0.d0
         else
            xxx_8=Cstv_RTstr_8*Ver_b_8%m(k)
         endif
*
         do j= j0, jn
         do i= i0, in
*
            F_p  (i,j,k) =        F_fip(i,j,k) + F_p(i,j,k)
            F_s  (i,j)   = -xxx_8*F_fip(i,j,k) + F_s(i,j)
            F_fip(i,j,k) = ZERO_8
*
         enddo
         enddo
*
      enddo
*
*     ADJ of
*     Compute zd
*     ~~~~~~~~~~
*
      if(.not.Schm_autobar_L) then  ! safer for autobar
*
*        ADJ of
*        N.B.  Top Boundary condition:
*                 Closed Top:  F_zd(i,j,1) = 0
*                   Open Top:  F_zd(i,j,k0) is computed
*
         kminzd=2
         if(Schm_opentop_L) kminzd=k0
*
         if (.not. Schm_hydro_L) then
            do k=l_nk,kminzd,-1
*
               do j= j0, jn
               do i= i0, in
                  F_q(i,j,k)  = -p5_8*(Ver_wp_8%t(k)*F_zd(i,j,k)) + F_q(i,j,k)
                  F_q(i,j,k-1)= -p5_8*(Ver_wm_8%t(k)*F_zd(i,j,k)) + F_q(i,j,k-1)
               enddo
               enddo
*
            enddo
         endif
*
         do k=l_nk,kminzd,-1
*
            xxx_8=Ver_gokt2RT_8*Ver_idz_8%t(k)
            yyy_8=Ver_gokt2RT_8*Ver_epsilon_8
            zzz_8=Ver_b_8%t(k)*p5_8
            if(Schm_autobar_L) zzz_8=0.d0
*
            do j= j0, jn
            do i= i0, in
*
               F_rt  (i,j,k)  =-Cstv_tau_8*(          F_zd(i,j,k) ) + F_rt  (i,j,k)
               F_nt  (i,j,k)  =-Cstv_tau_8*(         -F_zd(i,j,k) ) + F_nt  (i,j,k) 
               F_p   (i,j,k)  =-Cstv_tau_8*(  xxx_8*( F_zd(i,j,k))) + F_p   (i,j,k)
               F_p   (i,j,k-1)=-Cstv_tau_8*(  xxx_8*(-F_zd(i,j,k))) + F_p   (i,j,k-1)
               Pbar_8(i,j,k)  =-Cstv_tau_8*(- yyy_8*  F_zd(i,j,k) ) + Pbar_8(i,j,k)
               F_s   (i,j)    =             - zzz_8*  F_zd(i,j,k)   + F_s   (i,j)
               F_zd  (i,j,k)  =ZERO_8               
*
            enddo
            enddo
*
         enddo
*
      endif
*
*     ADJ of
*     Compute s
*     ~~~~~~~~~
*
      if (.not. Schm_hydro_L) then
*
         do j= j0, jn
         do i= i0, in
            F_q(i,j,l_nk+1) = - Ver_wp_8%t(l_nk+1)*F_s(i,j) + F_q(i,j,l_nk+1)
            F_q(i,j,l_nk)   = - Ver_wm_8%t(l_nk+1)*F_s(i,j) + F_q(i,j,l_nk)  
         end do
         end do
*
      endif
*
      do j= j0, jn
      do i= i0, in
*
         F_p(i,j,l_nk+1) = p2_8*(Ver_wp_8%t(l_nk+1)*F_s(i,j)) + F_p(i,j,l_nk+1)
         F_p(i,j,l_nk)   = p2_8*(Ver_wm_8%t(l_nk+1)*F_s(i,j)) + F_p(i,j,l_nk) 
         F_s(i,j)        = ZERO_8
*
      end do
      end do
*
*     ADJ of
*     Compute q & w
*     ~~~~~~~~~~~~~
*
      if(.not.Schm_hydro_L) then
*
*        ADJ of
*        Compute q
*        ~~~~~~~~~
*
*        N.B.  Top Boundary condition:
*                 Closed Top:  F_q(i,j,0) = 0
*                   Open Top:  F_q(i,j,k0-1) is externally specified
*
*        Note : we cannot use omp on loop k
*               due to vertical dependance F_q(i,j,k-1)
*
         do k=l_nk+1,k0,-1
*
            xxx_8 = p3_8*Ver_dz_8%t(k)
*
            do j= j0, jn
            do i= i0, in
*
               F_q (i,j,k-1) =                     F_q(i,j,k)   + F_q (i,j,k-1)
               F_rw(i,j,k)   = - xxx_8 *(          F_q(i,j,k) ) + F_rw(i,j,k)
               F_nw(i,j,k)   = - xxx_8 *(        - F_q(i,j,k) ) + F_nw(i,j,k) 
               F_w (i,j,k)   = - xxx_8 *( - p5_8 * F_q(i,j,k) ) + F_w (i,j,k)
               F_q (i,j,k)   = ZERO_8
*
            end do
            end do
*
         end do
*
         if (Schm_opentop_L) then
            do j= j0, jn
            do i= i0, in
*
               F_nest_q(i,j,k0-1) = F_q(i,j,k0-1) + F_nest_q(i,j,k0-1)
               F_q     (i,j,k0-1) = ZERO_8
*
            end do
            end do
         endif
*
       endif
*
*     ADJ of
*     Compute w
*     ~~~~~~~~~
*
         do k=l_nk+1,k0,-1
         do j= j0, jn
         do i= i0, in
*
           F_rf  (i,j,k)   = p1_8 * (   F_w(i,j,k) )                                        +  F_rf  (i,j,k)
           F_nf  (i,j,k)   = p1_8 * ( - F_w(i,j,k) )                                        +  F_nf  (i,j,k) 
           F_p   (i,j,k)   = p1_8 * ( Ver_gokt2RT_8 * ( (   F_w(i,j,k) )*Ver_idz_8%t(k) ) ) +  F_p   (i,j,k) 
           F_p   (i,j,k-1) = p1_8 * ( Ver_gokt2RT_8 * ( ( - F_w(i,j,k) )*Ver_idz_8%t(k) ) ) +  F_p   (i,j,k-1)
           Pbar_8(i,j,k)   = p1_8 * ( Ver_gokt2RT_8 * (   Dcst_cappa_8  *F_w(i,j,k)     ) ) +  Pbar_8(i,j,k)
           F_w   (i,j,k)   = ZERO_8
*
           F_p   (i,j,k)   = Ver_wp_8%t(k)*Pbar_8(i,j,k) + F_p(i,j,k)
           F_p   (i,j,k-1) = Ver_wm_8%t(k)*Pbar_8(i,j,k) + F_p(i,j,k-1)
           Pbar_8(i,j,k)   = ZERO_8
*
         end do
         end do
         end do
*
*     ADJ of
*     Compute U & V
*     ~~~~~~~~~~~~~
*
      if (Cori_cornl_L .or. (finbac_L.and..not.Cori_cornl_L)) then
*
         do k=l_nk,k0,-1
*
            do j= l_njv-pil_n,j0,-1
            do i= i0,in
*
               F_rv (i,j,  k) = Cstv_tau_8*(          F_v(i,j,k) ) + F_rv(i,j,  k)
               F_nv (i,j,  k) = Cstv_tau_8*(        - F_v(i,j,k) ) + F_nv(i,j,  k) 
               F_p  (i,j+1,k) = Cstv_tau_8*(-p4_8*(   F_v(i,j,k) ) * Geomg_invDYv_8(j) ) + F_p (i,j+1,k) 
               F_p  (i,j,  k) = Cstv_tau_8*(-p4_8*( - F_v(i,j,k) ) * Geomg_invDYv_8(j) ) + F_p (i,j,  k)
               F_v  (i,j,  k) = ZERO_8
*
            end do
            end do
*
            do j= j0,jn
            do i= l_niu-pil_e,i0,-1
*
               F_ru (i,  j,k) = Cstv_tau_8*(          F_u(i,j,k) ) + F_ru(i,j,k) 
               F_nu (i,  j,k) = Cstv_tau_8*(        - F_u(i,j,k) ) + F_nu(i,j,k)
               F_p  (i+1,j,k) = Cstv_tau_8*(-p4_8*(   F_u(i,j,k) ) * Geomg_invDXu_8(i) ) + F_p(i+1,j,k)
               F_p  (i,  j,k) = Cstv_tau_8*(-p4_8*( - F_u(i,j,k) ) * Geomg_invDXu_8(i) ) + F_p(i,  j,k) 
               F_u  (i,  j,k) = ZERO_8
*
            end do
            end do
*
         enddo
*
      endif
*
      call rpn_comm_adj_halo(F_p,LDIST_DIM,l_ni,l_nj,G_nk+2,
     $     G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
*
*     Zero F_p halo
*     --------------
      call v4d_zerohalo ( F_p,l_ni,l_nj,LDIST_DIM, G_nk+2)
*
*     ADJ of
*     Compute P at top and bottom
*     ~~~~~~~~~~~~~~~~~~~~~~~~~~~
*
      do j= j0, jn
         do i= i0, in
*
            F_p (i,j,l_nk)   =   Ver_alfas_8 *   F_p(i,j,l_nk+1)  + F_p (i,j,l_nk) 
            F_rt(i,j,l_nk+1) = - Ver_css_8   *(  F_p(i,j,l_nk+1)) + F_rt(i,j,l_nk+1)
            F_nt(i,j,l_nk+1) = - Ver_css_8   *(- F_p(i,j,l_nk+1)) + F_nt(i,j,l_nk+1)
            F_p (i,j,l_nk+1) = ZERO_8
*
            F_p (i,j,k0)    = Ver_alfat_8 *  F_p(i,j,k0-1)  + F_p (i,j,k0) 
            F_rb(i,j)       = Ver_cst_8   *( F_p(i,j,k0-1)) + F_rb(i,j)
            F_nb(i,j)       = Ver_cst_8   *(-F_p(i,j,k0-1)) + F_nb(i,j)
            F_p (i,j,k0-1) = ZERO_8
*
         end do
      end do
*
      if ( (Cori_cornl_L) .or. (F_itr .lt. F_itnlh) ) then
*
         call rpn_comm_adj_halo( F_p  , LDIST_DIM,l_ni,l_nj,G_nk+2,
     $                 G_halox,G_haloy,G_periodx,G_periody,l_ni,0)
*
*        Zero F_p halo
*        --------------
         call v4d_zerohalo ( F_p,l_ni,l_nj,LDIST_DIM, G_nk+2)
*
      endif
*
*     __________________________________________________________________
*
      return
      end
