!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------
#include "stop_mpi.h"

subroutine adx_interp3_ad()
   implicit none
   !---------------------------------------------------------------------
   call stop_mpi(STOP_ERROR,'adx_interp3_ad','called a stub')
   !---------------------------------------------------------------------
   return
end subroutine adx_interp3_ad

!/**
subroutine adx_interp4_ad(F_out,F_in  , &
                                F_in_m, &
                          Minx,Maxx,Miny,Maxy,F_nk, &
                          F_wind_L,F_mono_L,i0,in,j0,jn,F_lev_S)
   implicit none  
   !@objective ADJ of adx_interp4 
   !@arguments
   character (len=*) :: F_lev_S !I, m/t : Momemtum/thermo level
   integer :: Minx,Maxx,Miny,Maxy
   integer :: i0,in,j0,jn       !I, scope of operator
   integer :: F_nk              !I, number of vertical levels
   logical :: F_mono_L          !I, .true. monotonic interpolation
   logical :: F_wind_L          !I, .true. if field is wind like
   real, dimension(Minx:Maxx,Miny:Maxy,F_nk) :: F_in,F_out,F_in_m
   !
   !@author monique tanguay
   !@revisions
   ! v4_XX - Tanguay M.        - Adjustments GEM413
   !**/
#include "adx_dims.cdk"
#include "adx_poles.cdk"
#include "adx_interp.cdk"
#include "adx_interp_m.cdk"
   logical, parameter :: EXTEND_L = .true.
   integer :: i, j, k, istat
   real    :: dummy
   real    :: fld_adw  (adx_lminx:adx_lmaxx,adx_lminy:adx_lmaxy,F_nk)
   real    :: fld_adw_m(adx_lminx:adx_lmaxx,adx_lminy:adx_lmaxy,F_nk)
   real, dimension(adx_mlni,adx_mlnj,F_nk) :: wrkb  , wrkc
   real, dimension(adx_mlni,adx_mlnj,F_nk) :: wrkb_m, wrkc_m
   real*8, parameter :: ZERO_8 = 0.0
   !---------------------------------------------------------------------
   !
   !Zero adjoint variables
   !----------------------  
   wrkb    = 0.
   wrkc    = 0.
   fld_adw = 0.

   if (.not.adx_lam_L) then
   ! NOT DONE
   endif
   do k = 1, F_nk
      do j = j0,jn
         do i = i0,in
            !
            wrkc (i,j,k) = F_out(i,j,k) + wrkc(i,j,k)
            F_out(i,j,k) = ZERO_8
            !
         enddo
      enddo
   enddo
   !
   !TRAJECTORY
   !----------
   call adx_model2adx_grid_scalar2(fld_adw_m, F_in_m, adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy,Minx,Maxx,Miny,Maxy,F_nk,F_wind_L,EXTEND_L)

   call adx_tricub_lag3d3_ad(wrkc, fld_adw  , adx_capx1  , adx_capy1  , adx_capz1  , &
                                   fld_adw_m, adx_capx1_m, adx_capy1_m, adx_capz1_m, &
                             F_mono_L, i0,in,j0,jn, & 
                             adx_mlni,adx_mlnj, adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy,&
                             F_nk, F_nk, F_lev_S)
   !
   call adx_model2adx_grid_scalar2_ad(fld_adw,F_in,adx_lminx,adx_lmaxx,adx_lminy,adx_lmaxy,Minx,Maxx,Miny,Maxy,F_nk,F_wind_L,EXTEND_L)


   !---------------------------------------------------------------------
   return
end subroutine adx_interp4_ad
